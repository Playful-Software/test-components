var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, {get: all3[name2], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports2, module2) => {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  "use strict";
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from3;
    var to = toObject(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from3 = Object(arguments[s2]);
      for (var key in from3) {
        if (hasOwnProperty2.call(from3, key)) {
          to[key] = from3[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from3);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from3, symbols[i])) {
            to[symbols[i]] = from3[symbols[i]];
          }
        }
      }
    }
    return to;
  };
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS((exports2) => {
  /** @license React v0.20.1
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var f;
  var g;
  var h2;
  var k;
  if (typeof performance === "object" && typeof performance.now === "function") {
    l = performance;
    exports2.unstable_now = function() {
      return l.now();
    };
  } else {
    p = Date, q = p.now();
    exports2.unstable_now = function() {
      return p.now() - q;
    };
  }
  var l;
  var p;
  var q;
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    t = null, u = null, w3 = function() {
      if (t !== null)
        try {
          var a2 = exports2.unstable_now();
          t(true, a2);
          t = null;
        } catch (b) {
          throw setTimeout(w3, 0), b;
        }
    };
    f = function(a2) {
      t !== null ? setTimeout(f, 0, a2) : (t = a2, setTimeout(w3, 0));
    };
    g = function(a2, b) {
      u = setTimeout(a2, b);
    };
    h2 = function() {
      clearTimeout(u);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    x = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    A2 = false, B = null, C = -1, D2 = 5, E2 = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E2;
    };
    k = function() {
    };
    exports2.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    F = new MessageChannel(), G2 = F.port2;
    F.port1.onmessage = function() {
      if (B !== null) {
        var a2 = exports2.unstable_now();
        E2 = a2 + D2;
        try {
          B(true, a2) ? G2.postMessage(null) : (A2 = false, B = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f = function(a2) {
      B = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g = function(a2, b) {
      C = x(function() {
        a2(exports2.unstable_now());
      }, b);
    };
    h2 = function() {
      y2(C);
      C = -1;
    };
  }
  var t;
  var u;
  var w3;
  var x;
  var y2;
  var z2;
  var A2;
  var B;
  var C;
  var D2;
  var E2;
  var F;
  var G2;
  function H2(a2, b) {
    var c = a2.length;
    a2.push(b);
    a:
      for (; ; ) {
        var d2 = c - 1 >>> 1, e2 = a2[d2];
        if (e2 !== void 0 && 0 < I(e2, b))
          a2[d2] = b, a2[c] = e2, c = d2;
        else
          break a;
      }
  }
  function J(a2) {
    a2 = a2[0];
    return a2 === void 0 ? null : a2;
  }
  function K(a2) {
    var b = a2[0];
    if (b !== void 0) {
      var c = a2.pop();
      if (c !== b) {
        a2[0] = c;
        a:
          for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n = a2[m2], v = m2 + 1, r = a2[v];
            if (n !== void 0 && 0 > I(n, c))
              r !== void 0 && 0 > I(r, n) ? (a2[d2] = r, a2[v] = c, d2 = v) : (a2[d2] = n, a2[m2] = c, d2 = m2);
            else if (r !== void 0 && 0 > I(r, c))
              a2[d2] = r, a2[v] = c, d2 = v;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I(a2, b) {
    var c = a2.sortIndex - b.sortIndex;
    return c !== 0 ? c : a2.id - b.id;
  }
  var L = [];
  var M2 = [];
  var N = 1;
  var O = null;
  var P = 3;
  var Q2 = false;
  var R = false;
  var S = false;
  function T(a2) {
    for (var b = J(M2); b !== null; ) {
      if (b.callback === null)
        K(M2);
      else if (b.startTime <= a2)
        K(M2), b.sortIndex = b.expirationTime, H2(L, b);
      else
        break;
      b = J(M2);
    }
  }
  function U(a2) {
    S = false;
    T(a2);
    if (!R)
      if (J(L) !== null)
        R = true, f(V);
      else {
        var b = J(M2);
        b !== null && g(U, b.startTime - a2);
      }
  }
  function V(a2, b) {
    R = false;
    S && (S = false, h2());
    Q2 = true;
    var c = P;
    try {
      T(b);
      for (O = J(L); O !== null && (!(O.expirationTime > b) || a2 && !exports2.unstable_shouldYield()); ) {
        var d2 = O.callback;
        if (typeof d2 === "function") {
          O.callback = null;
          P = O.priorityLevel;
          var e2 = d2(O.expirationTime <= b);
          b = exports2.unstable_now();
          typeof e2 === "function" ? O.callback = e2 : O === J(L) && K(L);
          T(b);
        } else
          K(L);
        O = J(L);
      }
      if (O !== null)
        var m2 = true;
      else {
        var n = J(M2);
        n !== null && g(U, n.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O = null, P = c, Q2 = false;
    }
  }
  var W = k;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R || Q2 || (R = true, f(V));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J(L);
  };
  exports2.unstable_next = function(a2) {
    switch (P) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P;
    }
    var c = P;
    P = b;
    try {
      return a2();
    } finally {
      P = c;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W;
  exports2.unstable_runWithPriority = function(a2, b) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c = P;
    P = a2;
    try {
      return b();
    } finally {
      P = c;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b, c) {
    var d2 = exports2.unstable_now();
    typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d2 + c : d2) : c = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a2 = {id: N++, callback: b, priorityLevel: a2, startTime: c, expirationTime: e2, sortIndex: -1};
    c > d2 ? (a2.sortIndex = c, H2(M2, a2), J(L) === null && a2 === J(M2) && (S ? h2() : S = true, g(U, c - d2))) : (a2.sortIndex = e2, H2(L, a2), R || Q2 || (R = true, f(V)));
    return a2;
  };
  exports2.unstable_wrapCallback = function(a2) {
    var b = P;
    return function() {
      var c = P;
      P = b;
      try {
        return a2.apply(this, arguments);
      } finally {
        P = c;
      }
    };
  };
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_scheduler_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/react-reconciler/cjs/react-reconciler.production.min.js
var require_react_reconciler_production_min = __commonJS((exports2, module2) => {
  /** @license React v0.26.1
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  module2.exports = function $$$reconciler($$$hostConfig) {
    var exports3 = {};
    "use strict";
    var aa2 = require_object_assign(), ba = require("react"), m2 = require_scheduler();
    function q(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var ca = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, da = 60103, ea = 60106, fa = 60107, ha = 60108, ia = 60114, ja = 60109, ka = 60110, la = 60112, ma = 60113, na = 60120, oa = 60115, pa = 60116, qa = 60121, ra = 60129, sa = 60130, ta = 60131;
    if (typeof Symbol === "function" && Symbol.for) {
      var r = Symbol.for;
      da = r("react.element");
      ea = r("react.portal");
      fa = r("react.fragment");
      ha = r("react.strict_mode");
      ia = r("react.profiler");
      ja = r("react.provider");
      ka = r("react.context");
      la = r("react.forward_ref");
      ma = r("react.suspense");
      na = r("react.suspense_list");
      oa = r("react.memo");
      pa = r("react.lazy");
      qa = r("react.block");
      r("react.scope");
      ra = r("react.debug_trace_mode");
      sa = r("react.offscreen");
      ta = r("react.legacy_hidden");
    }
    var ua = typeof Symbol === "function" && Symbol.iterator;
    function va(a2) {
      if (a2 === null || typeof a2 !== "object")
        return null;
      a2 = ua && a2[ua] || a2["@@iterator"];
      return typeof a2 === "function" ? a2 : null;
    }
    function wa(a2) {
      if (a2 == null)
        return null;
      if (typeof a2 === "function")
        return a2.displayName || a2.name || null;
      if (typeof a2 === "string")
        return a2;
      switch (a2) {
        case fa:
          return "Fragment";
        case ea:
          return "Portal";
        case ia:
          return "Profiler";
        case ha:
          return "StrictMode";
        case ma:
          return "Suspense";
        case na:
          return "SuspenseList";
      }
      if (typeof a2 === "object")
        switch (a2.$$typeof) {
          case ka:
            return (a2.displayName || "Context") + ".Consumer";
          case ja:
            return (a2._context.displayName || "Context") + ".Provider";
          case la:
            var b = a2.render;
            b = b.displayName || b.name || "";
            return a2.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
          case oa:
            return wa(a2.type);
          case qa:
            return wa(a2._render);
          case pa:
            b = a2._payload;
            a2 = a2._init;
            try {
              return wa(a2(b));
            } catch (c) {
            }
        }
      return null;
    }
    function xa(a2) {
      var b = a2, c = a2;
      if (a2.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a2 = b;
        do
          b = a2, (b.flags & 1026) !== 0 && (c = b.return), a2 = b.return;
        while (a2);
      }
      return b.tag === 3 ? c : null;
    }
    function ya(a2) {
      if (xa(a2) !== a2)
        throw Error(q(188));
    }
    function za(a2) {
      var b = a2.alternate;
      if (!b) {
        b = xa(a2);
        if (b === null)
          throw Error(q(188));
        return b !== a2 ? null : a2;
      }
      for (var c = a2, d2 = b; ; ) {
        var e2 = c.return;
        if (e2 === null)
          break;
        var f = e2.alternate;
        if (f === null) {
          d2 = e2.return;
          if (d2 !== null) {
            c = d2;
            continue;
          }
          break;
        }
        if (e2.child === f.child) {
          for (f = e2.child; f; ) {
            if (f === c)
              return ya(e2), a2;
            if (f === d2)
              return ya(e2), b;
            f = f.sibling;
          }
          throw Error(q(188));
        }
        if (c.return !== d2.return)
          c = e2, d2 = f;
        else {
          for (var g = false, h2 = e2.child; h2; ) {
            if (h2 === c) {
              g = true;
              c = e2;
              d2 = f;
              break;
            }
            if (h2 === d2) {
              g = true;
              d2 = e2;
              c = f;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g) {
            for (h2 = f.child; h2; ) {
              if (h2 === c) {
                g = true;
                c = f;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g = true;
                d2 = f;
                c = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g)
              throw Error(q(189));
          }
        }
        if (c.alternate !== d2)
          throw Error(q(190));
      }
      if (c.tag !== 3)
        throw Error(q(188));
      return c.stateNode.current === c ? a2 : b;
    }
    function Aa(a2) {
      a2 = za(a2);
      if (!a2)
        return null;
      for (var b = a2; ; ) {
        if (b.tag === 5 || b.tag === 6)
          return b;
        if (b.child)
          b.child.return = b, b = b.child;
        else {
          if (b === a2)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function Ba(a2) {
      a2 = za(a2);
      if (!a2)
        return null;
      for (var b = a2; ; ) {
        if (b.tag === 5 || b.tag === 6)
          return b;
        if (b.child && b.tag !== 4)
          b.child.return = b, b = b.child;
        else {
          if (b === a2)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function Ca(a2, b) {
      for (var c = a2.alternate; b !== null; ) {
        if (b === a2 || b === c)
          return true;
        b = b.return;
      }
      return false;
    }
    var Da = $$$hostConfig.getPublicInstance, Ea = $$$hostConfig.getRootHostContext, Fa = $$$hostConfig.getChildHostContext, Ga = $$$hostConfig.prepareForCommit, Ha = $$$hostConfig.resetAfterCommit, Ia = $$$hostConfig.createInstance, Ja = $$$hostConfig.appendInitialChild, Ka = $$$hostConfig.finalizeInitialChildren, La = $$$hostConfig.prepareUpdate, Ma = $$$hostConfig.shouldSetTextContent, Na = $$$hostConfig.createTextInstance, Pa = $$$hostConfig.scheduleTimeout, Qa = $$$hostConfig.cancelTimeout, Ra = $$$hostConfig.noTimeout, Sa = $$$hostConfig.isPrimaryRenderer, Ta = $$$hostConfig.supportsMutation, Ua = $$$hostConfig.supportsPersistence, Va = $$$hostConfig.supportsHydration, Wa = $$$hostConfig.getInstanceFromNode, Xa = $$$hostConfig.makeOpaqueHydratingObject, Ya = $$$hostConfig.makeClientId, Za = $$$hostConfig.beforeActiveInstanceBlur, $a = $$$hostConfig.afterActiveInstanceBlur, ab = $$$hostConfig.preparePortalMount, bb = $$$hostConfig.supportsTestSelectors, cb = $$$hostConfig.findFiberRoot, db = $$$hostConfig.getBoundingRect, eb = $$$hostConfig.getTextContent, fb = $$$hostConfig.isHiddenSubtree, gb = $$$hostConfig.matchAccessibilityRole, hb = $$$hostConfig.setFocusIfFocusable, ib = $$$hostConfig.setupIntersectionObserver, jb = $$$hostConfig.appendChild, kb = $$$hostConfig.appendChildToContainer, lb = $$$hostConfig.commitTextUpdate, mb = $$$hostConfig.commitMount, nb = $$$hostConfig.commitUpdate, ob = $$$hostConfig.insertBefore, pb = $$$hostConfig.insertInContainerBefore, qb = $$$hostConfig.removeChild, rb = $$$hostConfig.removeChildFromContainer, sb = $$$hostConfig.resetTextContent, tb = $$$hostConfig.hideInstance, ub = $$$hostConfig.hideTextInstance, vb = $$$hostConfig.unhideInstance, wb = $$$hostConfig.unhideTextInstance, xb = $$$hostConfig.clearContainer, yb = $$$hostConfig.cloneInstance, zb = $$$hostConfig.createContainerChildSet, Ab = $$$hostConfig.appendChildToContainerChildSet, Bb = $$$hostConfig.finalizeContainerChildren, Cb = $$$hostConfig.replaceContainerChildren, Db = $$$hostConfig.cloneHiddenInstance, Eb = $$$hostConfig.cloneHiddenTextInstance, Fb = $$$hostConfig.canHydrateInstance, Gb = $$$hostConfig.canHydrateTextInstance, Hb = $$$hostConfig.isSuspenseInstancePending, Ib = $$$hostConfig.isSuspenseInstanceFallback, Jb = $$$hostConfig.getNextHydratableSibling, Kb = $$$hostConfig.getFirstHydratableChild, Lb = $$$hostConfig.hydrateInstance, Mb = $$$hostConfig.hydrateTextInstance, Nb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, Ob = $$$hostConfig.commitHydratedContainer, Pb = $$$hostConfig.commitHydratedSuspenseInstance, Qb;
    function Rb(a2) {
      if (Qb === void 0)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          Qb = b && b[1] || "";
        }
      return "\n" + Qb + a2;
    }
    var Sb = false;
    function Tb(a2, b) {
      if (!a2 || Sb)
        return "";
      Sb = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", {set: function() {
            throw Error();
          }}), typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (k) {
              var d2 = k;
            }
            Reflect.construct(a2, [], b);
          } else {
            try {
              b.call();
            } catch (k) {
              d2 = k;
            }
            a2.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k) {
            d2 = k;
          }
          a2();
        }
      } catch (k) {
        if (k && d2 && typeof k.stack === "string") {
          for (var e2 = k.stack.split("\n"), f = d2.stack.split("\n"), g = e2.length - 1, h2 = f.length - 1; 1 <= g && 0 <= h2 && e2[g] !== f[h2]; )
            h2--;
          for (; 1 <= g && 0 <= h2; g--, h2--)
            if (e2[g] !== f[h2]) {
              if (g !== 1 || h2 !== 1) {
                do
                  if (g--, h2--, 0 > h2 || e2[g] !== f[h2])
                    return "\n" + e2[g].replace(" at new ", " at ");
                while (1 <= g && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Sb = false, Error.prepareStackTrace = c;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Rb(a2) : "";
    }
    var Ub = [], Vb = -1;
    function Wb(a2) {
      return {current: a2};
    }
    function z2(a2) {
      0 > Vb || (a2.current = Ub[Vb], Ub[Vb] = null, Vb--);
    }
    function A2(a2, b) {
      Vb++;
      Ub[Vb] = a2.current;
      a2.current = b;
    }
    var Xb = {}, B = Wb(Xb), D2 = Wb(false), Yb = Xb;
    function Zb(a2, b) {
      var c = a2.type.contextTypes;
      if (!c)
        return Xb;
      var d2 = a2.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f;
      for (f in c)
        e2[f] = b[f];
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function E2(a2) {
      a2 = a2.childContextTypes;
      return a2 !== null && a2 !== void 0;
    }
    function $b() {
      z2(D2);
      z2(B);
    }
    function ac(a2, b, c) {
      if (B.current !== Xb)
        throw Error(q(168));
      A2(B, b);
      A2(D2, c);
    }
    function bc(a2, b, c) {
      var d2 = a2.stateNode;
      a2 = b.childContextTypes;
      if (typeof d2.getChildContext !== "function")
        return c;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in a2))
          throw Error(q(108, wa(b) || "Unknown", e2));
      return aa2({}, c, d2);
    }
    function cc(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Xb;
      Yb = B.current;
      A2(B, a2);
      A2(D2, D2.current);
      return true;
    }
    function dc(a2, b, c) {
      var d2 = a2.stateNode;
      if (!d2)
        throw Error(q(169));
      c ? (a2 = bc(a2, b, Yb), d2.__reactInternalMemoizedMergedChildContext = a2, z2(D2), z2(B), A2(B, a2)) : z2(D2);
      A2(D2, c);
    }
    var ec = null, fc = null, gc = m2.unstable_now;
    gc();
    var hc = 0, F = 8;
    function ic(a2) {
      if ((1 & a2) !== 0)
        return F = 15, 1;
      if ((2 & a2) !== 0)
        return F = 14, 2;
      if ((4 & a2) !== 0)
        return F = 13, 4;
      var b = 24 & a2;
      if (b !== 0)
        return F = 12, b;
      if ((a2 & 32) !== 0)
        return F = 11, 32;
      b = 192 & a2;
      if (b !== 0)
        return F = 10, b;
      if ((a2 & 256) !== 0)
        return F = 9, 256;
      b = 3584 & a2;
      if (b !== 0)
        return F = 8, b;
      if ((a2 & 4096) !== 0)
        return F = 7, 4096;
      b = 4186112 & a2;
      if (b !== 0)
        return F = 6, b;
      b = 62914560 & a2;
      if (b !== 0)
        return F = 5, b;
      if (a2 & 67108864)
        return F = 4, 67108864;
      if ((a2 & 134217728) !== 0)
        return F = 3, 134217728;
      b = 805306368 & a2;
      if (b !== 0)
        return F = 2, b;
      if ((1073741824 & a2) !== 0)
        return F = 1, 1073741824;
      F = 8;
      return a2;
    }
    function jc(a2) {
      switch (a2) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function kc(a2) {
      switch (a2) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(q(358, a2));
      }
    }
    function lc(a2, b) {
      var c = a2.pendingLanes;
      if (c === 0)
        return F = 0;
      var d2 = 0, e2 = 0, f = a2.expiredLanes, g = a2.suspendedLanes, h2 = a2.pingedLanes;
      if (f !== 0)
        d2 = f, e2 = F = 15;
      else if (f = c & 134217727, f !== 0) {
        var k = f & ~g;
        k !== 0 ? (d2 = ic(k), e2 = F) : (h2 &= f, h2 !== 0 && (d2 = ic(h2), e2 = F));
      } else
        f = c & ~g, f !== 0 ? (d2 = ic(f), e2 = F) : h2 !== 0 && (d2 = ic(h2), e2 = F);
      if (d2 === 0)
        return 0;
      d2 = 31 - mc(d2);
      d2 = c & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
      if (b !== 0 && b !== d2 && (b & g) === 0) {
        ic(b);
        if (e2 <= F)
          return b;
        F = e2;
      }
      b = a2.entangledLanes;
      if (b !== 0)
        for (a2 = a2.entanglements, b &= d2; 0 < b; )
          c = 31 - mc(b), e2 = 1 << c, d2 |= a2[c], b &= ~e2;
      return d2;
    }
    function nc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function oc(a2, b) {
      switch (a2) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a2 = pc(24 & ~b), a2 === 0 ? oc(10, b) : a2;
        case 10:
          return a2 = pc(192 & ~b), a2 === 0 ? oc(8, b) : a2;
        case 8:
          return a2 = pc(3584 & ~b), a2 === 0 && (a2 = pc(4186112 & ~b), a2 === 0 && (a2 = 512)), a2;
        case 2:
          return b = pc(805306368 & ~b), b === 0 && (b = 268435456), b;
      }
      throw Error(q(358, a2));
    }
    function pc(a2) {
      return a2 & -a2;
    }
    function qc(a2) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a2);
      return b;
    }
    function rc(a2, b, c) {
      a2.pendingLanes |= b;
      var d2 = b - 1;
      a2.suspendedLanes &= d2;
      a2.pingedLanes &= d2;
      a2 = a2.eventTimes;
      b = 31 - mc(b);
      a2[b] = c;
    }
    var mc = Math.clz32 ? Math.clz32 : sc, tc = Math.log, uc = Math.LN2;
    function sc(a2) {
      return a2 === 0 ? 32 : 31 - (tc(a2) / uc | 0) | 0;
    }
    var vc = m2.unstable_runWithPriority, wc = m2.unstable_scheduleCallback, xc = m2.unstable_cancelCallback, yc = m2.unstable_shouldYield, zc = m2.unstable_requestPaint, Ac = m2.unstable_now, Bc = m2.unstable_getCurrentPriorityLevel, Cc = m2.unstable_ImmediatePriority, Dc = m2.unstable_UserBlockingPriority, Ec = m2.unstable_NormalPriority, Fc = m2.unstable_LowPriority, Gc = m2.unstable_IdlePriority, Hc = {}, Ic = zc !== void 0 ? zc : function() {
    }, Jc = null, Kc = null, Lc = false, Mc = Ac(), G2 = 1e4 > Mc ? Ac : function() {
      return Ac() - Mc;
    };
    function Nc() {
      switch (Bc()) {
        case Cc:
          return 99;
        case Dc:
          return 98;
        case Ec:
          return 97;
        case Fc:
          return 96;
        case Gc:
          return 95;
        default:
          throw Error(q(332));
      }
    }
    function Oc(a2) {
      switch (a2) {
        case 99:
          return Cc;
        case 98:
          return Dc;
        case 97:
          return Ec;
        case 96:
          return Fc;
        case 95:
          return Gc;
        default:
          throw Error(q(332));
      }
    }
    function Pc(a2, b) {
      a2 = Oc(a2);
      return vc(a2, b);
    }
    function Qc(a2, b, c) {
      a2 = Oc(a2);
      return wc(a2, b, c);
    }
    function H2() {
      if (Kc !== null) {
        var a2 = Kc;
        Kc = null;
        xc(a2);
      }
      Rc();
    }
    function Rc() {
      if (!Lc && Jc !== null) {
        Lc = true;
        var a2 = 0;
        try {
          var b = Jc;
          Pc(99, function() {
            for (; a2 < b.length; a2++) {
              var c = b[a2];
              do
                c = c(true);
              while (c !== null);
            }
          });
          Jc = null;
        } catch (c) {
          throw Jc !== null && (Jc = Jc.slice(a2 + 1)), wc(Cc, H2), c;
        } finally {
          Lc = false;
        }
      }
    }
    var Sc = ca.ReactCurrentBatchConfig;
    function Tc(a2, b) {
      return a2 === b && (a2 !== 0 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var I = typeof Object.is === "function" ? Object.is : Tc, Uc = Object.prototype.hasOwnProperty;
    function Vc(a2, b) {
      if (I(a2, b))
        return true;
      if (typeof a2 !== "object" || a2 === null || typeof b !== "object" || b === null)
        return false;
      var c = Object.keys(a2), d2 = Object.keys(b);
      if (c.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c.length; d2++)
        if (!Uc.call(b, c[d2]) || !I(a2[c[d2]], b[c[d2]]))
          return false;
      return true;
    }
    function Wc(a2) {
      switch (a2.tag) {
        case 5:
          return Rb(a2.type);
        case 16:
          return Rb("Lazy");
        case 13:
          return Rb("Suspense");
        case 19:
          return Rb("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Tb(a2.type, false), a2;
        case 11:
          return a2 = Tb(a2.type.render, false), a2;
        case 22:
          return a2 = Tb(a2.type._render, false), a2;
        case 1:
          return a2 = Tb(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Xc(a2, b) {
      if (a2 && a2.defaultProps) {
        b = aa2({}, b);
        a2 = a2.defaultProps;
        for (var c in a2)
          b[c] === void 0 && (b[c] = a2[c]);
        return b;
      }
      return b;
    }
    var Yc = Wb(null), Zc = null, $c = null, ad = null;
    function bd() {
      ad = $c = Zc = null;
    }
    function cd(a2, b) {
      a2 = a2.type._context;
      Sa ? (A2(Yc, a2._currentValue), a2._currentValue = b) : (A2(Yc, a2._currentValue2), a2._currentValue2 = b);
    }
    function dd2(a2) {
      var b = Yc.current;
      z2(Yc);
      a2 = a2.type._context;
      Sa ? a2._currentValue = b : a2._currentValue2 = b;
    }
    function ed(a2, b) {
      for (; a2 !== null; ) {
        var c = a2.alternate;
        if ((a2.childLanes & b) === b)
          if (c === null || (c.childLanes & b) === b)
            break;
          else
            c.childLanes |= b;
        else
          a2.childLanes |= b, c !== null && (c.childLanes |= b);
        a2 = a2.return;
      }
    }
    function fd(a2, b) {
      Zc = a2;
      ad = $c = null;
      a2 = a2.dependencies;
      a2 !== null && a2.firstContext !== null && ((a2.lanes & b) !== 0 && (gd = true), a2.firstContext = null);
    }
    function J(a2, b) {
      if (ad !== a2 && b !== false && b !== 0) {
        if (typeof b !== "number" || b === 1073741823)
          ad = a2, b = 1073741823;
        b = {context: a2, observedBits: b, next: null};
        if ($c === null) {
          if (Zc === null)
            throw Error(q(308));
          $c = b;
          Zc.dependencies = {lanes: 0, firstContext: b, responders: null};
        } else
          $c = $c.next = b;
      }
      return Sa ? a2._currentValue : a2._currentValue2;
    }
    var hd = false;
    function id(a2) {
      a2.updateQueue = {baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: {pending: null}, effects: null};
    }
    function jd(a2, b) {
      a2 = a2.updateQueue;
      b.updateQueue === a2 && (b.updateQueue = {baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects});
    }
    function kd(a2, b) {
      return {eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null};
    }
    function md(a2, b) {
      a2 = a2.updateQueue;
      if (a2 !== null) {
        a2 = a2.shared;
        var c = a2.pending;
        c === null ? b.next = b : (b.next = c.next, c.next = b);
        a2.pending = b;
      }
    }
    function nd(a2, b) {
      var c = a2.updateQueue, d2 = a2.alternate;
      if (d2 !== null && (d2 = d2.updateQueue, c === d2)) {
        var e2 = null, f = null;
        c = c.firstBaseUpdate;
        if (c !== null) {
          do {
            var g = {eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null};
            f === null ? e2 = f = g : f = f.next = g;
            c = c.next;
          } while (c !== null);
          f === null ? e2 = f = b : f = f.next = b;
        } else
          e2 = f = b;
        c = {baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f, shared: d2.shared, effects: d2.effects};
        a2.updateQueue = c;
        return;
      }
      a2 = c.lastBaseUpdate;
      a2 === null ? c.firstBaseUpdate = b : a2.next = b;
      c.lastBaseUpdate = b;
    }
    function od(a2, b, c, d2) {
      var e2 = a2.updateQueue;
      hd = false;
      var f = e2.firstBaseUpdate, g = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (h2 !== null) {
        e2.shared.pending = null;
        var k = h2, l = k.next;
        k.next = null;
        g === null ? f = l : g.next = l;
        g = k;
        var n = a2.alternate;
        if (n !== null) {
          n = n.updateQueue;
          var t = n.lastBaseUpdate;
          t !== g && (t === null ? n.firstBaseUpdate = l : t.next = l, n.lastBaseUpdate = k);
        }
      }
      if (f !== null) {
        t = e2.baseState;
        g = 0;
        n = l = k = null;
        do {
          h2 = f.lane;
          var p = f.eventTime;
          if ((d2 & h2) === h2) {
            n !== null && (n = n.next = {
              eventTime: p,
              lane: 0,
              tag: f.tag,
              payload: f.payload,
              callback: f.callback,
              next: null
            });
            a: {
              var y2 = a2, x = f;
              h2 = b;
              p = c;
              switch (x.tag) {
                case 1:
                  y2 = x.payload;
                  if (typeof y2 === "function") {
                    t = y2.call(p, t, h2);
                    break a;
                  }
                  t = y2;
                  break a;
                case 3:
                  y2.flags = y2.flags & -4097 | 64;
                case 0:
                  y2 = x.payload;
                  h2 = typeof y2 === "function" ? y2.call(p, t, h2) : y2;
                  if (h2 === null || h2 === void 0)
                    break a;
                  t = aa2({}, t, h2);
                  break a;
                case 2:
                  hd = true;
              }
            }
            f.callback !== null && (a2.flags |= 32, h2 = e2.effects, h2 === null ? e2.effects = [f] : h2.push(f));
          } else
            p = {eventTime: p, lane: h2, tag: f.tag, payload: f.payload, callback: f.callback, next: null}, n === null ? (l = n = p, k = t) : n = n.next = p, g |= h2;
          f = f.next;
          if (f === null)
            if (h2 = e2.shared.pending, h2 === null)
              break;
            else
              f = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
        } while (1);
        n === null && (k = t);
        e2.baseState = k;
        e2.firstBaseUpdate = l;
        e2.lastBaseUpdate = n;
        pd |= g;
        a2.lanes = g;
        a2.memoizedState = t;
      }
    }
    function qd(a2, b, c) {
      a2 = b.effects;
      b.effects = null;
      if (a2 !== null)
        for (b = 0; b < a2.length; b++) {
          var d2 = a2[b], e2 = d2.callback;
          if (e2 !== null) {
            d2.callback = null;
            d2 = c;
            if (typeof e2 !== "function")
              throw Error(q(191, e2));
            e2.call(d2);
          }
        }
    }
    var rd = new ba.Component().refs;
    function sd(a2, b, c, d2) {
      b = a2.memoizedState;
      c = c(d2, b);
      c = c === null || c === void 0 ? b : aa2({}, b, c);
      a2.memoizedState = c;
      a2.lanes === 0 && (a2.updateQueue.baseState = c);
    }
    var vd = {isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? xa(a2) === a2 : false;
    }, enqueueSetState: function(a2, b, c) {
      a2 = a2._reactInternals;
      var d2 = K(), e2 = td(a2), f = kd(d2, e2);
      f.payload = b;
      c !== void 0 && c !== null && (f.callback = c);
      md(a2, f);
      ud(a2, e2, d2);
    }, enqueueReplaceState: function(a2, b, c) {
      a2 = a2._reactInternals;
      var d2 = K(), e2 = td(a2), f = kd(d2, e2);
      f.tag = 1;
      f.payload = b;
      c !== void 0 && c !== null && (f.callback = c);
      md(a2, f);
      ud(a2, e2, d2);
    }, enqueueForceUpdate: function(a2, b) {
      a2 = a2._reactInternals;
      var c = K(), d2 = td(a2), e2 = kd(c, d2);
      e2.tag = 2;
      b !== void 0 && b !== null && (e2.callback = b);
      md(a2, e2);
      ud(a2, d2, c);
    }};
    function wd(a2, b, c, d2, e2, f, g) {
      a2 = a2.stateNode;
      return typeof a2.shouldComponentUpdate === "function" ? a2.shouldComponentUpdate(d2, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Vc(c, d2) || !Vc(e2, f) : true;
    }
    function xd(a2, b, c) {
      var d2 = false, e2 = Xb;
      var f = b.contextType;
      typeof f === "object" && f !== null ? f = J(f) : (e2 = E2(b) ? Yb : B.current, d2 = b.contextTypes, f = (d2 = d2 !== null && d2 !== void 0) ? Zb(a2, e2) : Xb);
      b = new b(c, f);
      a2.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;
      b.updater = vd;
      a2.stateNode = b;
      b._reactInternals = a2;
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function yd(a2, b, c, d2) {
      a2 = b.state;
      typeof b.componentWillReceiveProps === "function" && b.componentWillReceiveProps(c, d2);
      typeof b.UNSAFE_componentWillReceiveProps === "function" && b.UNSAFE_componentWillReceiveProps(c, d2);
      b.state !== a2 && vd.enqueueReplaceState(b, b.state, null);
    }
    function zd(a2, b, c, d2) {
      var e2 = a2.stateNode;
      e2.props = c;
      e2.state = a2.memoizedState;
      e2.refs = rd;
      id(a2);
      var f = b.contextType;
      typeof f === "object" && f !== null ? e2.context = J(f) : (f = E2(b) ? Yb : B.current, e2.context = Zb(a2, f));
      od(a2, c, e2, d2);
      e2.state = a2.memoizedState;
      f = b.getDerivedStateFromProps;
      typeof f === "function" && (sd(a2, b, f, c), e2.state = a2.memoizedState);
      typeof b.getDerivedStateFromProps === "function" || typeof e2.getSnapshotBeforeUpdate === "function" || typeof e2.UNSAFE_componentWillMount !== "function" && typeof e2.componentWillMount !== "function" || (b = e2.state, typeof e2.componentWillMount === "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount === "function" && e2.UNSAFE_componentWillMount(), b !== e2.state && vd.enqueueReplaceState(e2, e2.state, null), od(a2, c, e2, d2), e2.state = a2.memoizedState);
      typeof e2.componentDidMount === "function" && (a2.flags |= 4);
    }
    var Ad = Array.isArray;
    function Bd(a2, b, c) {
      a2 = c.ref;
      if (a2 !== null && typeof a2 !== "function" && typeof a2 !== "object") {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (c.tag !== 1)
              throw Error(q(309));
            var d2 = c.stateNode;
          }
          if (!d2)
            throw Error(q(147, a2));
          var e2 = "" + a2;
          if (b !== null && b.ref !== null && typeof b.ref === "function" && b.ref._stringRef === e2)
            return b.ref;
          b = function(a3) {
            var b2 = d2.refs;
            b2 === rd && (b2 = d2.refs = {});
            a3 === null ? delete b2[e2] : b2[e2] = a3;
          };
          b._stringRef = e2;
          return b;
        }
        if (typeof a2 !== "string")
          throw Error(q(284));
        if (!c._owner)
          throw Error(q(290, a2));
      }
      return a2;
    }
    function Cd(a2, b) {
      if (a2.type !== "textarea")
        throw Error(q(31, Object.prototype.toString.call(b) === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
    }
    function Dd(a2) {
      function b(b2, c2) {
        if (a2) {
          var d3 = b2.lastEffect;
          d3 !== null ? (d3.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
          c2.nextEffect = null;
          c2.flags = 8;
        }
      }
      function c(c2, d3) {
        if (!a2)
          return null;
        for (; d3 !== null; )
          b(c2, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a3, b2) {
        for (a3 = new Map(); b2 !== null; )
          b2.key !== null ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
        return a3;
      }
      function e2(a3, b2) {
        a3 = Ed(a3, b2);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f(b2, c2, d3) {
        b2.index = d3;
        if (!a2)
          return c2;
        d3 = b2.alternate;
        if (d3 !== null)
          return d3 = d3.index, d3 < c2 ? (b2.flags = 2, c2) : d3;
        b2.flags = 2;
        return c2;
      }
      function g(b2) {
        a2 && b2.alternate === null && (b2.flags = 2);
        return b2;
      }
      function h2(a3, b2, c2, d3) {
        if (b2 === null || b2.tag !== 6)
          return b2 = Fd(c2, a3.mode, d3), b2.return = a3, b2;
        b2 = e2(b2, c2);
        b2.return = a3;
        return b2;
      }
      function k(a3, b2, c2, d3) {
        if (b2 !== null && b2.elementType === c2.type)
          return d3 = e2(b2, c2.props), d3.ref = Bd(a3, b2, c2), d3.return = a3, d3;
        d3 = Gd(c2.type, c2.key, c2.props, null, a3.mode, d3);
        d3.ref = Bd(a3, b2, c2);
        d3.return = a3;
        return d3;
      }
      function l(a3, b2, c2, d3) {
        if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
          return b2 = Hd(c2, a3.mode, d3), b2.return = a3, b2;
        b2 = e2(b2, c2.children || []);
        b2.return = a3;
        return b2;
      }
      function n(a3, b2, c2, d3, f2) {
        if (b2 === null || b2.tag !== 7)
          return b2 = Id(c2, a3.mode, d3, f2), b2.return = a3, b2;
        b2 = e2(b2, c2);
        b2.return = a3;
        return b2;
      }
      function t(a3, b2, c2) {
        if (typeof b2 === "string" || typeof b2 === "number")
          return b2 = Fd("" + b2, a3.mode, c2), b2.return = a3, b2;
        if (typeof b2 === "object" && b2 !== null) {
          switch (b2.$$typeof) {
            case da:
              return c2 = Gd(b2.type, b2.key, b2.props, null, a3.mode, c2), c2.ref = Bd(a3, null, b2), c2.return = a3, c2;
            case ea:
              return b2 = Hd(b2, a3.mode, c2), b2.return = a3, b2;
          }
          if (Ad(b2) || va(b2))
            return b2 = Id(b2, a3.mode, c2, null), b2.return = a3, b2;
          Cd(a3, b2);
        }
        return null;
      }
      function p(a3, b2, c2, d3) {
        var e3 = b2 !== null ? b2.key : null;
        if (typeof c2 === "string" || typeof c2 === "number")
          return e3 !== null ? null : h2(a3, b2, "" + c2, d3);
        if (typeof c2 === "object" && c2 !== null) {
          switch (c2.$$typeof) {
            case da:
              return c2.key === e3 ? c2.type === fa ? n(a3, b2, c2.props.children, d3, e3) : k(a3, b2, c2, d3) : null;
            case ea:
              return c2.key === e3 ? l(a3, b2, c2, d3) : null;
          }
          if (Ad(c2) || va(c2))
            return e3 !== null ? null : n(a3, b2, c2, d3, null);
          Cd(a3, c2);
        }
        return null;
      }
      function y2(a3, b2, c2, d3, e3) {
        if (typeof d3 === "string" || typeof d3 === "number")
          return a3 = a3.get(c2) || null, h2(b2, a3, "" + d3, e3);
        if (typeof d3 === "object" && d3 !== null) {
          switch (d3.$$typeof) {
            case da:
              return a3 = a3.get(d3.key === null ? c2 : d3.key) || null, d3.type === fa ? n(b2, a3, d3.props.children, e3, d3.key) : k(b2, a3, d3, e3);
            case ea:
              return a3 = a3.get(d3.key === null ? c2 : d3.key) || null, l(b2, a3, d3, e3);
          }
          if (Ad(d3) || va(d3))
            return a3 = a3.get(c2) || null, n(b2, a3, d3, e3, null);
          Cd(b2, d3);
        }
        return null;
      }
      function x(e3, g2, h3, k2) {
        for (var l2 = null, v = null, u = g2, C = g2 = 0, n2 = null; u !== null && C < h3.length; C++) {
          u.index > C ? (n2 = u, u = null) : n2 = u.sibling;
          var w3 = p(e3, u, h3[C], k2);
          if (w3 === null) {
            u === null && (u = n2);
            break;
          }
          a2 && u && w3.alternate === null && b(e3, u);
          g2 = f(w3, g2, C);
          v === null ? l2 = w3 : v.sibling = w3;
          v = w3;
          u = n2;
        }
        if (C === h3.length)
          return c(e3, u), l2;
        if (u === null) {
          for (; C < h3.length; C++)
            u = t(e3, h3[C], k2), u !== null && (g2 = f(u, g2, C), v === null ? l2 = u : v.sibling = u, v = u);
          return l2;
        }
        for (u = d2(e3, u); C < h3.length; C++)
          n2 = y2(u, e3, C, h3[C], k2), n2 !== null && (a2 && n2.alternate !== null && u.delete(n2.key === null ? C : n2.key), g2 = f(n2, g2, C), v === null ? l2 = n2 : v.sibling = n2, v = n2);
        a2 && u.forEach(function(a3) {
          return b(e3, a3);
        });
        return l2;
      }
      function Y(e3, g2, h3, k2) {
        var l2 = va(h3);
        if (typeof l2 !== "function")
          throw Error(q(150));
        h3 = l2.call(h3);
        if (h3 == null)
          throw Error(q(151));
        for (var u = l2 = null, v = g2, n2 = g2 = 0, C = null, w3 = h3.next(); v !== null && !w3.done; n2++, w3 = h3.next()) {
          v.index > n2 ? (C = v, v = null) : C = v.sibling;
          var x2 = p(e3, v, w3.value, k2);
          if (x2 === null) {
            v === null && (v = C);
            break;
          }
          a2 && v && x2.alternate === null && b(e3, v);
          g2 = f(x2, g2, n2);
          u === null ? l2 = x2 : u.sibling = x2;
          u = x2;
          v = C;
        }
        if (w3.done)
          return c(e3, v), l2;
        if (v === null) {
          for (; !w3.done; n2++, w3 = h3.next())
            w3 = t(e3, w3.value, k2), w3 !== null && (g2 = f(w3, g2, n2), u === null ? l2 = w3 : u.sibling = w3, u = w3);
          return l2;
        }
        for (v = d2(e3, v); !w3.done; n2++, w3 = h3.next())
          w3 = y2(v, e3, n2, w3.value, k2), w3 !== null && (a2 && w3.alternate !== null && v.delete(w3.key === null ? n2 : w3.key), g2 = f(w3, g2, n2), u === null ? l2 = w3 : u.sibling = w3, u = w3);
        a2 && v.forEach(function(a3) {
          return b(e3, a3);
        });
        return l2;
      }
      return function(a3, d3, f2, h3) {
        var k2 = typeof f2 === "object" && f2 !== null && f2.type === fa && f2.key === null;
        k2 && (f2 = f2.props.children);
        var l2 = typeof f2 === "object" && f2 !== null;
        if (l2)
          switch (f2.$$typeof) {
            case da:
              a: {
                l2 = f2.key;
                for (k2 = d3; k2 !== null; ) {
                  if (k2.key === l2) {
                    switch (k2.tag) {
                      case 7:
                        if (f2.type === fa) {
                          c(a3, k2.sibling);
                          d3 = e2(k2, f2.props.children);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                        break;
                      default:
                        if (k2.elementType === f2.type) {
                          c(a3, k2.sibling);
                          d3 = e2(k2, f2.props);
                          d3.ref = Bd(a3, k2, f2);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                    }
                    c(a3, k2);
                    break;
                  } else
                    b(a3, k2);
                  k2 = k2.sibling;
                }
                f2.type === fa ? (d3 = Id(f2.props.children, a3.mode, h3, f2.key), d3.return = a3, a3 = d3) : (h3 = Gd(f2.type, f2.key, f2.props, null, a3.mode, h3), h3.ref = Bd(a3, d3, f2), h3.return = a3, a3 = h3);
              }
              return g(a3);
            case ea:
              a: {
                for (k2 = f2.key; d3 !== null; ) {
                  if (d3.key === k2)
                    if (d3.tag === 4 && d3.stateNode.containerInfo === f2.containerInfo && d3.stateNode.implementation === f2.implementation) {
                      c(a3, d3.sibling);
                      d3 = e2(d3, f2.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c(a3, d3);
                      break;
                    }
                  else
                    b(a3, d3);
                  d3 = d3.sibling;
                }
                d3 = Hd(f2, a3.mode, h3);
                d3.return = a3;
                a3 = d3;
              }
              return g(a3);
          }
        if (typeof f2 === "string" || typeof f2 === "number")
          return f2 = "" + f2, d3 !== null && d3.tag === 6 ? (c(a3, d3.sibling), d3 = e2(d3, f2), d3.return = a3, a3 = d3) : (c(a3, d3), d3 = Fd(f2, a3.mode, h3), d3.return = a3, a3 = d3), g(a3);
        if (Ad(f2))
          return x(a3, d3, f2, h3);
        if (va(f2))
          return Y(a3, d3, f2, h3);
        l2 && Cd(a3, f2);
        if (typeof f2 === "undefined" && !k2)
          switch (a3.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(q(152, wa(a3.type) || "Component"));
          }
        return c(a3, d3);
      };
    }
    var Jd = Dd(true), Kd = Dd(false), Ld = {}, L = Wb(Ld), Md = Wb(Ld), Nd = Wb(Ld);
    function Od(a2) {
      if (a2 === Ld)
        throw Error(q(174));
      return a2;
    }
    function Pd(a2, b) {
      A2(Nd, b);
      A2(Md, a2);
      A2(L, Ld);
      a2 = Ea(b);
      z2(L);
      A2(L, a2);
    }
    function Qd() {
      z2(L);
      z2(Md);
      z2(Nd);
    }
    function Rd(a2) {
      var b = Od(Nd.current), c = Od(L.current);
      b = Fa(c, a2.type, b);
      c !== b && (A2(Md, a2), A2(L, b));
    }
    function Sd(a2) {
      Md.current === a2 && (z2(L), z2(Md));
    }
    var M2 = Wb(0);
    function Td(a2) {
      for (var b = a2; b !== null; ) {
        if (b.tag === 13) {
          var c = b.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || Hb(c) || Ib(c)))
            return b;
        } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
          if ((b.flags & 64) !== 0)
            return b;
        } else if (b.child !== null) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2)
          break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a2)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Ud = null, Vd = null, Wd = false;
    function Xd(a2, b) {
      var c = Yd(5, null, null, 0);
      c.elementType = "DELETED";
      c.type = "DELETED";
      c.stateNode = b;
      c.return = a2;
      c.flags = 8;
      a2.lastEffect !== null ? (a2.lastEffect.nextEffect = c, a2.lastEffect = c) : a2.firstEffect = a2.lastEffect = c;
    }
    function Zd(a2, b) {
      switch (a2.tag) {
        case 5:
          return b = Fb(b, a2.type, a2.pendingProps), b !== null ? (a2.stateNode = b, true) : false;
        case 6:
          return b = Gb(b, a2.pendingProps), b !== null ? (a2.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function $d(a2) {
      if (Wd) {
        var b = Vd;
        if (b) {
          var c = b;
          if (!Zd(a2, b)) {
            b = Jb(c);
            if (!b || !Zd(a2, b)) {
              a2.flags = a2.flags & -1025 | 2;
              Wd = false;
              Ud = a2;
              return;
            }
            Xd(Ud, c);
          }
          Ud = a2;
          Vd = Kb(b);
        } else
          a2.flags = a2.flags & -1025 | 2, Wd = false, Ud = a2;
      }
    }
    function ae(a2) {
      for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
        a2 = a2.return;
      Ud = a2;
    }
    function be(a2) {
      if (!Va || a2 !== Ud)
        return false;
      if (!Wd)
        return ae(a2), Wd = true, false;
      var b = a2.type;
      if (a2.tag !== 5 || b !== "head" && b !== "body" && !Ma(b, a2.memoizedProps))
        for (b = Vd; b; )
          Xd(a2, b), b = Jb(b);
      ae(a2);
      if (a2.tag === 13) {
        if (!Va)
          throw Error(q(316));
        a2 = a2.memoizedState;
        a2 = a2 !== null ? a2.dehydrated : null;
        if (!a2)
          throw Error(q(317));
        Vd = Nb(a2);
      } else
        Vd = Ud ? Jb(a2.stateNode) : null;
      return true;
    }
    function ce() {
      Va && (Vd = Ud = null, Wd = false);
    }
    var de = [];
    function ee2() {
      for (var a2 = 0; a2 < de.length; a2++) {
        var b = de[a2];
        Sa ? b._workInProgressVersionPrimary = null : b._workInProgressVersionSecondary = null;
      }
      de.length = 0;
    }
    var fe = ca.ReactCurrentDispatcher, ge = ca.ReactCurrentBatchConfig, he = 0, N = null, O = null, P = null, ie = false, je = false;
    function Q2() {
      throw Error(q(321));
    }
    function ke(a2, b) {
      if (b === null)
        return false;
      for (var c = 0; c < b.length && c < a2.length; c++)
        if (!I(a2[c], b[c]))
          return false;
      return true;
    }
    function le(a2, b, c, d2, e2, f) {
      he = f;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      fe.current = a2 === null || a2.memoizedState === null ? me : ne;
      a2 = c(d2, e2);
      if (je) {
        f = 0;
        do {
          je = false;
          if (!(25 > f))
            throw Error(q(301));
          f += 1;
          P = O = null;
          b.updateQueue = null;
          fe.current = oe;
          a2 = c(d2, e2);
        } while (je);
      }
      fe.current = pe;
      b = O !== null && O.next !== null;
      he = 0;
      P = O = N = null;
      ie = false;
      if (b)
        throw Error(q(300));
      return a2;
    }
    function qe() {
      var a2 = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
      P === null ? N.memoizedState = P = a2 : P = P.next = a2;
      return P;
    }
    function re() {
      if (O === null) {
        var a2 = N.alternate;
        a2 = a2 !== null ? a2.memoizedState : null;
      } else
        a2 = O.next;
      var b = P === null ? N.memoizedState : P.next;
      if (b !== null)
        P = b, O = a2;
      else {
        if (a2 === null)
          throw Error(q(310));
        O = a2;
        a2 = {memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null};
        P === null ? N.memoizedState = P = a2 : P = P.next = a2;
      }
      return P;
    }
    function se(a2, b) {
      return typeof b === "function" ? b(a2) : b;
    }
    function te(a2) {
      var b = re(), c = b.queue;
      if (c === null)
        throw Error(q(311));
      c.lastRenderedReducer = a2;
      var d2 = O, e2 = d2.baseQueue, f = c.pending;
      if (f !== null) {
        if (e2 !== null) {
          var g = e2.next;
          e2.next = f.next;
          f.next = g;
        }
        d2.baseQueue = e2 = f;
        c.pending = null;
      }
      if (e2 !== null) {
        e2 = e2.next;
        d2 = d2.baseState;
        var h2 = g = f = null, k = e2;
        do {
          var l = k.lane;
          if ((he & l) === l)
            h2 !== null && (h2 = h2.next = {lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null}), d2 = k.eagerReducer === a2 ? k.eagerState : a2(d2, k.action);
          else {
            var n = {
              lane: l,
              action: k.action,
              eagerReducer: k.eagerReducer,
              eagerState: k.eagerState,
              next: null
            };
            h2 === null ? (g = h2 = n, f = d2) : h2 = h2.next = n;
            N.lanes |= l;
            pd |= l;
          }
          k = k.next;
        } while (k !== null && k !== e2);
        h2 === null ? f = d2 : h2.next = g;
        I(d2, b.memoizedState) || (gd = true);
        b.memoizedState = d2;
        b.baseState = f;
        b.baseQueue = h2;
        c.lastRenderedState = d2;
      }
      return [b.memoizedState, c.dispatch];
    }
    function ue(a2) {
      var b = re(), c = b.queue;
      if (c === null)
        throw Error(q(311));
      c.lastRenderedReducer = a2;
      var d2 = c.dispatch, e2 = c.pending, f = b.memoizedState;
      if (e2 !== null) {
        c.pending = null;
        var g = e2 = e2.next;
        do
          f = a2(f, g.action), g = g.next;
        while (g !== e2);
        I(f, b.memoizedState) || (gd = true);
        b.memoizedState = f;
        b.baseQueue === null && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d2];
    }
    function ve(a2, b, c) {
      var d2 = b._getVersion;
      d2 = d2(b._source);
      var e2 = Sa ? b._workInProgressVersionPrimary : b._workInProgressVersionSecondary;
      if (e2 !== null)
        a2 = e2 === d2;
      else if (a2 = a2.mutableReadLanes, a2 = (he & a2) === a2)
        Sa ? b._workInProgressVersionPrimary = d2 : b._workInProgressVersionSecondary = d2, de.push(b);
      if (a2)
        return c(b._source);
      de.push(b);
      throw Error(q(350));
    }
    function we(a2, b, c, d2) {
      var e2 = R;
      if (e2 === null)
        throw Error(q(349));
      var f = b._getVersion, g = f(b._source), h2 = fe.current, k = h2.useState(function() {
        return ve(e2, b, c);
      }), l = k[1], n = k[0];
      k = P;
      var t = a2.memoizedState, p = t.refs, y2 = p.getSnapshot, x = t.source;
      t = t.subscribe;
      var Y = N;
      a2.memoizedState = {refs: p, source: b, subscribe: d2};
      h2.useEffect(function() {
        p.getSnapshot = c;
        p.setSnapshot = l;
        var a3 = f(b._source);
        if (!I(g, a3)) {
          a3 = c(b._source);
          I(n, a3) || (l(a3), a3 = td(Y), e2.mutableReadLanes |= a3 & e2.pendingLanes);
          a3 = e2.mutableReadLanes;
          e2.entangledLanes |= a3;
          for (var d3 = e2.entanglements, h3 = a3; 0 < h3; ) {
            var k2 = 31 - mc(h3), t2 = 1 << k2;
            d3[k2] |= a3;
            h3 &= ~t2;
          }
        }
      }, [c, b, d2]);
      h2.useEffect(function() {
        return d2(b._source, function() {
          var a3 = p.getSnapshot, c2 = p.setSnapshot;
          try {
            c2(a3(b._source));
            var d3 = td(Y);
            e2.mutableReadLanes |= d3 & e2.pendingLanes;
          } catch (Oa) {
            c2(function() {
              throw Oa;
            });
          }
        });
      }, [b, d2]);
      I(y2, c) && I(x, b) && I(t, d2) || (a2 = {pending: null, dispatch: null, lastRenderedReducer: se, lastRenderedState: n}, a2.dispatch = l = xe.bind(null, N, a2), k.queue = a2, k.baseQueue = null, n = ve(e2, b, c), k.memoizedState = k.baseState = n);
      return n;
    }
    function ye(a2, b, c) {
      var d2 = re();
      return we(d2, a2, b, c);
    }
    function ze(a2) {
      var b = qe();
      typeof a2 === "function" && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = b.queue = {pending: null, dispatch: null, lastRenderedReducer: se, lastRenderedState: a2};
      a2 = a2.dispatch = xe.bind(null, N, a2);
      return [b.memoizedState, a2];
    }
    function Ae(a2, b, c, d2) {
      a2 = {tag: a2, create: b, destroy: c, deps: d2, next: null};
      b = N.updateQueue;
      b === null ? (b = {lastEffect: null}, N.updateQueue = b, b.lastEffect = a2.next = a2) : (c = b.lastEffect, c === null ? b.lastEffect = a2.next = a2 : (d2 = c.next, c.next = a2, a2.next = d2, b.lastEffect = a2));
      return a2;
    }
    function Be(a2) {
      var b = qe();
      a2 = {current: a2};
      return b.memoizedState = a2;
    }
    function Ce() {
      return re().memoizedState;
    }
    function De(a2, b, c, d2) {
      var e2 = qe();
      N.flags |= a2;
      e2.memoizedState = Ae(1 | b, c, void 0, d2 === void 0 ? null : d2);
    }
    function Ee(a2, b, c, d2) {
      var e2 = re();
      d2 = d2 === void 0 ? null : d2;
      var f = void 0;
      if (O !== null) {
        var g = O.memoizedState;
        f = g.destroy;
        if (d2 !== null && ke(d2, g.deps)) {
          Ae(b, c, f, d2);
          return;
        }
      }
      N.flags |= a2;
      e2.memoizedState = Ae(1 | b, c, f, d2);
    }
    function Fe(a2, b) {
      return De(516, 4, a2, b);
    }
    function Ge(a2, b) {
      return Ee(516, 4, a2, b);
    }
    function He(a2, b) {
      return Ee(4, 2, a2, b);
    }
    function Ie(a2, b) {
      if (typeof b === "function")
        return a2 = a2(), b(a2), function() {
          b(null);
        };
      if (b !== null && b !== void 0)
        return a2 = a2(), b.current = a2, function() {
          b.current = null;
        };
    }
    function Je(a2, b, c) {
      c = c !== null && c !== void 0 ? c.concat([a2]) : null;
      return Ee(4, 2, Ie.bind(null, b, a2), c);
    }
    function Ke() {
    }
    function Le(a2, b) {
      var c = re();
      b = b === void 0 ? null : b;
      var d2 = c.memoizedState;
      if (d2 !== null && b !== null && ke(b, d2[1]))
        return d2[0];
      c.memoizedState = [a2, b];
      return a2;
    }
    function Me(a2, b) {
      var c = re();
      b = b === void 0 ? null : b;
      var d2 = c.memoizedState;
      if (d2 !== null && b !== null && ke(b, d2[1]))
        return d2[0];
      a2 = a2();
      c.memoizedState = [a2, b];
      return a2;
    }
    function Ne(a2, b) {
      var c = Nc();
      Pc(98 > c ? 98 : c, function() {
        a2(true);
      });
      Pc(97 < c ? 97 : c, function() {
        var c2 = ge.transition;
        ge.transition = 1;
        try {
          a2(false), b();
        } finally {
          ge.transition = c2;
        }
      });
    }
    function xe(a2, b, c) {
      var d2 = K(), e2 = td(a2), f = {lane: e2, action: c, eagerReducer: null, eagerState: null, next: null}, g = b.pending;
      g === null ? f.next = f : (f.next = g.next, g.next = f);
      b.pending = f;
      g = a2.alternate;
      if (a2 === N || g !== null && g === N)
        je = ie = true;
      else {
        if (a2.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))
          try {
            var h2 = b.lastRenderedState, k = g(h2, c);
            f.eagerReducer = g;
            f.eagerState = k;
            if (I(k, h2))
              return;
          } catch (l) {
          } finally {
          }
        ud(a2, e2, d2);
      }
    }
    var pe = {readContext: J, useCallback: Q2, useContext: Q2, useEffect: Q2, useImperativeHandle: Q2, useLayoutEffect: Q2, useMemo: Q2, useReducer: Q2, useRef: Q2, useState: Q2, useDebugValue: Q2, useDeferredValue: Q2, useTransition: Q2, useMutableSource: Q2, useOpaqueIdentifier: Q2, unstable_isNewReconciler: false}, me = {readContext: J, useCallback: function(a2, b) {
      qe().memoizedState = [a2, b === void 0 ? null : b];
      return a2;
    }, useContext: J, useEffect: Fe, useImperativeHandle: function(a2, b, c) {
      c = c !== null && c !== void 0 ? c.concat([a2]) : null;
      return De(4, 2, Ie.bind(null, b, a2), c);
    }, useLayoutEffect: function(a2, b) {
      return De(4, 2, a2, b);
    }, useMemo: function(a2, b) {
      var c = qe();
      b = b === void 0 ? null : b;
      a2 = a2();
      c.memoizedState = [a2, b];
      return a2;
    }, useReducer: function(a2, b, c) {
      var d2 = qe();
      b = c !== void 0 ? c(b) : b;
      d2.memoizedState = d2.baseState = b;
      a2 = d2.queue = {pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b};
      a2 = a2.dispatch = xe.bind(null, N, a2);
      return [d2.memoizedState, a2];
    }, useRef: Be, useState: ze, useDebugValue: Ke, useDeferredValue: function(a2) {
      var b = ze(a2), c = b[0], d2 = b[1];
      Fe(function() {
        var b2 = ge.transition;
        ge.transition = 1;
        try {
          d2(a2);
        } finally {
          ge.transition = b2;
        }
      }, [a2]);
      return c;
    }, useTransition: function() {
      var a2 = ze(false), b = a2[0];
      a2 = Ne.bind(null, a2[1]);
      Be(a2);
      return [a2, b];
    }, useMutableSource: function(a2, b, c) {
      var d2 = qe();
      d2.memoizedState = {refs: {getSnapshot: b, setSnapshot: null}, source: a2, subscribe: c};
      return we(d2, a2, b, c);
    }, useOpaqueIdentifier: function() {
      if (Wd) {
        var a2 = false, b = Xa(function() {
          a2 || (a2 = true, c(Ya()));
          throw Error(q(355));
        }), c = ze(b)[1];
        (N.mode & 2) === 0 && (N.flags |= 516, Ae(5, function() {
          c(Ya());
        }, void 0, null));
        return b;
      }
      b = Ya();
      ze(b);
      return b;
    }, unstable_isNewReconciler: false}, ne = {
      readContext: J,
      useCallback: Le,
      useContext: J,
      useEffect: Ge,
      useImperativeHandle: Je,
      useLayoutEffect: He,
      useMemo: Me,
      useReducer: te,
      useRef: Ce,
      useState: function() {
        return te(se);
      },
      useDebugValue: Ke,
      useDeferredValue: function(a2) {
        var b = te(se), c = b[0], d2 = b[1];
        Ge(function() {
          var b2 = ge.transition;
          ge.transition = 1;
          try {
            d2(a2);
          } finally {
            ge.transition = b2;
          }
        }, [a2]);
        return c;
      },
      useTransition: function() {
        var a2 = te(se)[0];
        return [Ce().current, a2];
      },
      useMutableSource: ye,
      useOpaqueIdentifier: function() {
        return te(se)[0];
      },
      unstable_isNewReconciler: false
    }, oe = {
      readContext: J,
      useCallback: Le,
      useContext: J,
      useEffect: Ge,
      useImperativeHandle: Je,
      useLayoutEffect: He,
      useMemo: Me,
      useReducer: ue,
      useRef: Ce,
      useState: function() {
        return ue(se);
      },
      useDebugValue: Ke,
      useDeferredValue: function(a2) {
        var b = ue(se), c = b[0], d2 = b[1];
        Ge(function() {
          var b2 = ge.transition;
          ge.transition = 1;
          try {
            d2(a2);
          } finally {
            ge.transition = b2;
          }
        }, [a2]);
        return c;
      },
      useTransition: function() {
        var a2 = ue(se)[0];
        return [Ce().current, a2];
      },
      useMutableSource: ye,
      useOpaqueIdentifier: function() {
        return ue(se)[0];
      },
      unstable_isNewReconciler: false
    }, Oe = ca.ReactCurrentOwner, gd = false;
    function S(a2, b, c, d2) {
      b.child = a2 === null ? Kd(b, null, c, d2) : Jd(b, a2.child, c, d2);
    }
    function Pe(a2, b, c, d2, e2) {
      c = c.render;
      var f = b.ref;
      fd(b, e2);
      d2 = le(a2, b, c, d2, f, e2);
      if (a2 !== null && !gd)
        return b.updateQueue = a2.updateQueue, b.flags &= -517, a2.lanes &= ~e2, Re(a2, b, e2);
      b.flags |= 1;
      S(a2, b, d2, e2);
      return b.child;
    }
    function Se(a2, b, c, d2, e2, f) {
      if (a2 === null) {
        var g = c.type;
        if (typeof g === "function" && !Te(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
          return b.tag = 15, b.type = g, Ue(a2, b, g, d2, e2, f);
        a2 = Gd(c.type, null, d2, b, b.mode, f);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      g = a2.child;
      if ((e2 & f) === 0 && (e2 = g.memoizedProps, c = c.compare, c = c !== null ? c : Vc, c(e2, d2) && a2.ref === b.ref))
        return Re(a2, b, f);
      b.flags |= 1;
      a2 = Ed(g, d2);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function Ue(a2, b, c, d2, e2, f) {
      if (a2 !== null && Vc(a2.memoizedProps, d2) && a2.ref === b.ref)
        if (gd = false, (f & e2) !== 0)
          (a2.flags & 16384) !== 0 && (gd = true);
        else
          return b.lanes = a2.lanes, Re(a2, b, f);
      return Ve(a2, b, c, d2, f);
    }
    function We(a2, b, c) {
      var d2 = b.pendingProps, e2 = d2.children, f = a2 !== null ? a2.memoizedState : null;
      if (d2.mode === "hidden" || d2.mode === "unstable-defer-without-hiding")
        if ((b.mode & 4) === 0)
          b.memoizedState = {baseLanes: 0}, Xe(b, c);
        else if ((c & 1073741824) !== 0)
          b.memoizedState = {baseLanes: 0}, Xe(b, f !== null ? f.baseLanes : c);
        else
          return a2 = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {baseLanes: a2}, Xe(b, a2), null;
      else
        f !== null ? (d2 = f.baseLanes | c, b.memoizedState = null) : d2 = c, Xe(b, d2);
      S(a2, b, e2, c);
      return b.child;
    }
    function Ye(a2, b) {
      var c = b.ref;
      if (a2 === null && c !== null || a2 !== null && a2.ref !== c)
        b.flags |= 128;
    }
    function Ve(a2, b, c, d2, e2) {
      var f = E2(c) ? Yb : B.current;
      f = Zb(b, f);
      fd(b, e2);
      c = le(a2, b, c, d2, f, e2);
      if (a2 !== null && !gd)
        return b.updateQueue = a2.updateQueue, b.flags &= -517, a2.lanes &= ~e2, Re(a2, b, e2);
      b.flags |= 1;
      S(a2, b, c, e2);
      return b.child;
    }
    function Ze(a2, b, c, d2, e2) {
      if (E2(c)) {
        var f = true;
        cc(b);
      } else
        f = false;
      fd(b, e2);
      if (b.stateNode === null)
        a2 !== null && (a2.alternate = null, b.alternate = null, b.flags |= 2), xd(b, c, d2), zd(b, c, d2, e2), d2 = true;
      else if (a2 === null) {
        var g = b.stateNode, h2 = b.memoizedProps;
        g.props = h2;
        var k = g.context, l = c.contextType;
        typeof l === "object" && l !== null ? l = J(l) : (l = E2(c) ? Yb : B.current, l = Zb(b, l));
        var n = c.getDerivedStateFromProps, t = typeof n === "function" || typeof g.getSnapshotBeforeUpdate === "function";
        t || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h2 !== d2 || k !== l) && yd(b, g, d2, l);
        hd = false;
        var p = b.memoizedState;
        g.state = p;
        od(b, d2, g, e2);
        k = b.memoizedState;
        h2 !== d2 || p !== k || D2.current || hd ? (typeof n === "function" && (sd(b, c, n, d2), k = b.memoizedState), (h2 = hd || wd(b, c, h2, d2, p, k, l)) ? (t || typeof g.UNSAFE_componentWillMount !== "function" && typeof g.componentWillMount !== "function" || (typeof g.componentWillMount === "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === "function" && (b.flags |= 4)) : (typeof g.componentDidMount === "function" && (b.flags |= 4), b.memoizedProps = d2, b.memoizedState = k), g.props = d2, g.state = k, g.context = l, d2 = h2) : (typeof g.componentDidMount === "function" && (b.flags |= 4), d2 = false);
      } else {
        g = b.stateNode;
        jd(a2, b);
        h2 = b.memoizedProps;
        l = b.type === b.elementType ? h2 : Xc(b.type, h2);
        g.props = l;
        t = b.pendingProps;
        p = g.context;
        k = c.contextType;
        typeof k === "object" && k !== null ? k = J(k) : (k = E2(c) ? Yb : B.current, k = Zb(b, k));
        var y2 = c.getDerivedStateFromProps;
        (n = typeof y2 === "function" || typeof g.getSnapshotBeforeUpdate === "function") || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h2 !== t || p !== k) && yd(b, g, d2, k);
        hd = false;
        p = b.memoizedState;
        g.state = p;
        od(b, d2, g, e2);
        var x = b.memoizedState;
        h2 !== t || p !== x || D2.current || hd ? (typeof y2 === "function" && (sd(b, c, y2, d2), x = b.memoizedState), (l = hd || wd(b, c, l, d2, p, x, k)) ? (n || typeof g.UNSAFE_componentWillUpdate !== "function" && typeof g.componentWillUpdate !== "function" || (typeof g.componentWillUpdate === "function" && g.componentWillUpdate(d2, x, k), typeof g.UNSAFE_componentWillUpdate === "function" && g.UNSAFE_componentWillUpdate(d2, x, k)), typeof g.componentDidUpdate === "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === "function" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== "function" || h2 === a2.memoizedProps && p === a2.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && p === a2.memoizedState || (b.flags |= 256), b.memoizedProps = d2, b.memoizedState = x), g.props = d2, g.state = x, g.context = k, d2 = l) : (typeof g.componentDidUpdate !== "function" || h2 === a2.memoizedProps && p === a2.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && p === a2.memoizedState || (b.flags |= 256), d2 = false);
      }
      return $e(a2, b, c, d2, f, e2);
    }
    function $e(a2, b, c, d2, e2, f) {
      Ye(a2, b);
      var g = (b.flags & 64) !== 0;
      if (!d2 && !g)
        return e2 && dc(b, c, false), Re(a2, b, f);
      d2 = b.stateNode;
      Oe.current = b;
      var h2 = g && typeof c.getDerivedStateFromError !== "function" ? null : d2.render();
      b.flags |= 1;
      a2 !== null && g ? (b.child = Jd(b, a2.child, null, f), b.child = Jd(b, null, h2, f)) : S(a2, b, h2, f);
      b.memoizedState = d2.state;
      e2 && dc(b, c, true);
      return b.child;
    }
    function af(a2) {
      var b = a2.stateNode;
      b.pendingContext ? ac(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ac(a2, b.context, false);
      Pd(a2, b.containerInfo);
    }
    var bf = {dehydrated: null, retryLane: 0};
    function cf(a2, b, c) {
      var d2 = b.pendingProps, e2 = M2.current, f = false, g;
      (g = (b.flags & 64) !== 0) || (g = a2 !== null && a2.memoizedState === null ? false : (e2 & 2) !== 0);
      g ? (f = true, b.flags &= -65) : a2 !== null && a2.memoizedState === null || d2.fallback === void 0 || d2.unstable_avoidThisFallback === true || (e2 |= 1);
      A2(M2, e2 & 1);
      if (a2 === null) {
        d2.fallback !== void 0 && $d(b);
        a2 = d2.children;
        e2 = d2.fallback;
        if (f)
          return a2 = df(b, a2, e2, c), b.child.memoizedState = {baseLanes: c}, b.memoizedState = bf, a2;
        if (typeof d2.unstable_expectedLoadTime === "number")
          return a2 = df(b, a2, e2, c), b.child.memoizedState = {baseLanes: c}, b.memoizedState = bf, b.lanes = 33554432, a2;
        c = ef({mode: "visible", children: a2}, b.mode, c, null);
        c.return = b;
        return b.child = c;
      }
      if (a2.memoizedState !== null) {
        if (f)
          return d2 = ff(a2, b, d2.children, d2.fallback, c), f = b.child, e2 = a2.child.memoizedState, f.memoizedState = e2 === null ? {baseLanes: c} : {baseLanes: e2.baseLanes | c}, f.childLanes = a2.childLanes & ~c, b.memoizedState = bf, d2;
        c = gf(a2, b, d2.children, c);
        b.memoizedState = null;
        return c;
      }
      if (f)
        return d2 = ff(a2, b, d2.children, d2.fallback, c), f = b.child, e2 = a2.child.memoizedState, f.memoizedState = e2 === null ? {baseLanes: c} : {baseLanes: e2.baseLanes | c}, f.childLanes = a2.childLanes & ~c, b.memoizedState = bf, d2;
      c = gf(a2, b, d2.children, c);
      b.memoizedState = null;
      return c;
    }
    function df(a2, b, c, d2) {
      var e2 = a2.mode, f = a2.child;
      b = {mode: "hidden", children: b};
      (e2 & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = ef(b, e2, 0, null);
      c = Id(c, e2, d2, null);
      f.return = a2;
      c.return = a2;
      f.sibling = c;
      a2.child = f;
      return c;
    }
    function gf(a2, b, c, d2) {
      var e2 = a2.child;
      a2 = e2.sibling;
      c = Ed(e2, {mode: "visible", children: c});
      (b.mode & 2) === 0 && (c.lanes = d2);
      c.return = b;
      c.sibling = null;
      a2 !== null && (a2.nextEffect = null, a2.flags = 8, b.firstEffect = b.lastEffect = a2);
      return b.child = c;
    }
    function ff(a2, b, c, d2, e2) {
      var f = b.mode, g = a2.child;
      a2 = g.sibling;
      var h2 = {mode: "hidden", children: c};
      (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h2, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Ed(g, h2);
      a2 !== null ? d2 = Ed(a2, d2) : (d2 = Id(d2, f, e2, null), d2.flags |= 2);
      d2.return = b;
      c.return = b;
      c.sibling = d2;
      b.child = c;
      return d2;
    }
    function hf(a2, b) {
      a2.lanes |= b;
      var c = a2.alternate;
      c !== null && (c.lanes |= b);
      ed(a2.return, b);
    }
    function jf(a2, b, c, d2, e2, f) {
      var g = a2.memoizedState;
      g === null ? a2.memoizedState = {isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e2, lastEffect: f} : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d2, g.tail = c, g.tailMode = e2, g.lastEffect = f);
    }
    function kf(a2, b, c) {
      var d2 = b.pendingProps, e2 = d2.revealOrder, f = d2.tail;
      S(a2, b, d2.children, c);
      d2 = M2.current;
      if ((d2 & 2) !== 0)
        d2 = d2 & 1 | 2, b.flags |= 64;
      else {
        if (a2 !== null && (a2.flags & 64) !== 0)
          a:
            for (a2 = b.child; a2 !== null; ) {
              if (a2.tag === 13)
                a2.memoizedState !== null && hf(a2, c);
              else if (a2.tag === 19)
                hf(a2, c);
              else if (a2.child !== null) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b)
                break a;
              for (; a2.sibling === null; ) {
                if (a2.return === null || a2.return === b)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d2 &= 1;
      }
      A2(M2, d2);
      if ((b.mode & 2) === 0)
        b.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c = b.child;
            for (e2 = null; c !== null; )
              a2 = c.alternate, a2 !== null && Td(a2) === null && (e2 = c), c = c.sibling;
            c = e2;
            c === null ? (e2 = b.child, b.child = null) : (e2 = c.sibling, c.sibling = null);
            jf(b, false, e2, c, f, b.lastEffect);
            break;
          case "backwards":
            c = null;
            e2 = b.child;
            for (b.child = null; e2 !== null; ) {
              a2 = e2.alternate;
              if (a2 !== null && Td(a2) === null) {
                b.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c;
              c = e2;
              e2 = a2;
            }
            jf(b, true, c, null, f, b.lastEffect);
            break;
          case "together":
            jf(b, false, null, null, void 0, b.lastEffect);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function Re(a2, b, c) {
      a2 !== null && (b.dependencies = a2.dependencies);
      pd |= b.lanes;
      if ((c & b.childLanes) !== 0) {
        if (a2 !== null && b.child !== a2.child)
          throw Error(q(153));
        if (b.child !== null) {
          a2 = b.child;
          c = Ed(a2, a2.pendingProps);
          b.child = c;
          for (c.return = b; a2.sibling !== null; )
            a2 = a2.sibling, c = c.sibling = Ed(a2, a2.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      return null;
    }
    function lf(a2) {
      a2.flags |= 4;
    }
    var mf, nf, of, pf;
    if (Ta)
      mf = function(a2, b) {
        for (var c = b.child; c !== null; ) {
          if (c.tag === 5 || c.tag === 6)
            Ja(a2, c.stateNode);
          else if (c.tag !== 4 && c.child !== null) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b)
            break;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === b)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      }, nf = function() {
      }, of = function(a2, b, c, d2, e2) {
        a2 = a2.memoizedProps;
        if (a2 !== d2) {
          var f = b.stateNode, g = Od(L.current);
          c = La(f, c, a2, d2, e2, g);
          (b.updateQueue = c) && lf(b);
        }
      }, pf = function(a2, b, c, d2) {
        c !== d2 && lf(b);
      };
    else if (Ua) {
      mf = function(a2, b, c, d2) {
        for (var e2 = b.child; e2 !== null; ) {
          if (e2.tag === 5) {
            var f = e2.stateNode;
            c && d2 && (f = Db(f, e2.type, e2.memoizedProps, e2));
            Ja(a2, f);
          } else if (e2.tag === 6)
            f = e2.stateNode, c && d2 && (f = Eb(f, e2.memoizedProps, e2)), Ja(a2, f);
          else if (e2.tag !== 4) {
            if (e2.tag === 13 && (e2.flags & 4) !== 0 && (f = e2.memoizedState !== null)) {
              var g = e2.child;
              if (g !== null && (g.child !== null && (g.child.return = g, mf(a2, g, true, f)), f = g.sibling, f !== null)) {
                f.return = e2;
                e2 = f;
                continue;
              }
            }
            if (e2.child !== null) {
              e2.child.return = e2;
              e2 = e2.child;
              continue;
            }
          }
          if (e2 === b)
            break;
          for (; e2.sibling === null; ) {
            if (e2.return === null || e2.return === b)
              return;
            e2 = e2.return;
          }
          e2.sibling.return = e2.return;
          e2 = e2.sibling;
        }
      };
      var qf = function(a2, b, c, d2) {
        for (var e2 = b.child; e2 !== null; ) {
          if (e2.tag === 5) {
            var f = e2.stateNode;
            c && d2 && (f = Db(f, e2.type, e2.memoizedProps, e2));
            Ab(a2, f);
          } else if (e2.tag === 6)
            f = e2.stateNode, c && d2 && (f = Eb(f, e2.memoizedProps, e2)), Ab(a2, f);
          else if (e2.tag !== 4) {
            if (e2.tag === 13 && (e2.flags & 4) !== 0 && (f = e2.memoizedState !== null)) {
              var g = e2.child;
              if (g !== null && (g.child !== null && (g.child.return = g, qf(a2, g, true, f)), f = g.sibling, f !== null)) {
                f.return = e2;
                e2 = f;
                continue;
              }
            }
            if (e2.child !== null) {
              e2.child.return = e2;
              e2 = e2.child;
              continue;
            }
          }
          if (e2 === b)
            break;
          for (; e2.sibling === null; ) {
            if (e2.return === null || e2.return === b)
              return;
            e2 = e2.return;
          }
          e2.sibling.return = e2.return;
          e2 = e2.sibling;
        }
      };
      nf = function(a2) {
        var b = a2.stateNode;
        if (a2.firstEffect !== null) {
          var c = b.containerInfo, d2 = zb(c);
          qf(d2, a2, false, false);
          b.pendingChildren = d2;
          lf(a2);
          Bb(c, d2);
        }
      };
      of = function(a2, b, c, d2, e2) {
        var f = a2.stateNode, g = a2.memoizedProps;
        if ((a2 = b.firstEffect === null) && g === d2)
          b.stateNode = f;
        else {
          var h2 = b.stateNode, k = Od(L.current), l = null;
          g !== d2 && (l = La(h2, c, g, d2, e2, k));
          a2 && l === null ? b.stateNode = f : (f = yb(f, l, c, g, d2, b, a2, h2), Ka(f, c, d2, e2, k) && lf(b), b.stateNode = f, a2 ? lf(b) : mf(f, b, false, false));
        }
      };
      pf = function(a2, b, c, d2) {
        c !== d2 ? (a2 = Od(Nd.current), c = Od(L.current), b.stateNode = Na(d2, a2, c, b), lf(b)) : b.stateNode = a2.stateNode;
      };
    } else
      nf = function() {
      }, of = function() {
      }, pf = function() {
      };
    function rf(a2, b) {
      if (!Wd)
        switch (a2.tailMode) {
          case "hidden":
            b = a2.tail;
            for (var c = null; b !== null; )
              b.alternate !== null && (c = b), b = b.sibling;
            c === null ? a2.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a2.tail;
            for (var d2 = null; c !== null; )
              c.alternate !== null && (d2 = c), c = c.sibling;
            d2 === null ? b || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
    }
    function sf(a2, b, c) {
      var d2 = b.pendingProps;
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return E2(b.type) && $b(), null;
        case 3:
          Qd();
          z2(D2);
          z2(B);
          ee2();
          d2 = b.stateNode;
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (a2 === null || a2.child === null)
            be(b) ? lf(b) : d2.hydrate || (b.flags |= 256);
          nf(b);
          return null;
        case 5:
          Sd(b);
          var e2 = Od(Nd.current);
          c = b.type;
          if (a2 !== null && b.stateNode != null)
            of(a2, b, c, d2, e2), a2.ref !== b.ref && (b.flags |= 128);
          else {
            if (!d2) {
              if (b.stateNode === null)
                throw Error(q(166));
              return null;
            }
            a2 = Od(L.current);
            if (be(b)) {
              if (!Va)
                throw Error(q(175));
              a2 = Lb(b.stateNode, b.type, b.memoizedProps, e2, a2, b);
              b.updateQueue = a2;
              a2 !== null && lf(b);
            } else {
              var f = Ia(c, d2, e2, a2, b);
              mf(f, b, false, false);
              b.stateNode = f;
              Ka(f, c, d2, e2, a2) && lf(b);
            }
            b.ref !== null && (b.flags |= 128);
          }
          return null;
        case 6:
          if (a2 && b.stateNode != null)
            pf(a2, b, a2.memoizedProps, d2);
          else {
            if (typeof d2 !== "string" && b.stateNode === null)
              throw Error(q(166));
            a2 = Od(Nd.current);
            e2 = Od(L.current);
            if (be(b)) {
              if (!Va)
                throw Error(q(176));
              Mb(b.stateNode, b.memoizedProps, b) && lf(b);
            } else
              b.stateNode = Na(d2, a2, e2, b);
          }
          return null;
        case 13:
          z2(M2);
          d2 = b.memoizedState;
          if ((b.flags & 64) !== 0)
            return b.lanes = c, b;
          d2 = d2 !== null;
          e2 = false;
          a2 === null ? b.memoizedProps.fallback !== void 0 && be(b) : e2 = a2.memoizedState !== null;
          if (d2 && !e2 && (b.mode & 2) !== 0)
            if (a2 === null && b.memoizedProps.unstable_avoidThisFallback !== true || (M2.current & 1) !== 0)
              T === 0 && (T = 3);
            else {
              if (T === 0 || T === 3)
                T = 4;
              R === null || (pd & 134217727) === 0 && (tf & 134217727) === 0 || uf(R, U);
            }
          Ua && d2 && (b.flags |= 4);
          Ta && (d2 || e2) && (b.flags |= 4);
          return null;
        case 4:
          return Qd(), nf(b), a2 === null && ab(b.stateNode.containerInfo), null;
        case 10:
          return dd2(b), null;
        case 17:
          return E2(b.type) && $b(), null;
        case 19:
          z2(M2);
          d2 = b.memoizedState;
          if (d2 === null)
            return null;
          e2 = (b.flags & 64) !== 0;
          f = d2.rendering;
          if (f === null)
            if (e2)
              rf(d2, false);
            else {
              if (T !== 0 || a2 !== null && (a2.flags & 64) !== 0)
                for (a2 = b.child; a2 !== null; ) {
                  f = Td(a2);
                  if (f !== null) {
                    b.flags |= 64;
                    rf(d2, false);
                    a2 = f.updateQueue;
                    a2 !== null && (b.updateQueue = a2, b.flags |= 4);
                    d2.lastEffect === null && (b.firstEffect = null);
                    b.lastEffect = d2.lastEffect;
                    a2 = c;
                    for (d2 = b.child; d2 !== null; )
                      e2 = d2, c = a2, e2.flags &= 2, e2.nextEffect = null, e2.firstEffect = null, e2.lastEffect = null, f = e2.alternate, f === null ? (e2.childLanes = 0, e2.lanes = c, e2.child = null, e2.memoizedProps = null, e2.memoizedState = null, e2.updateQueue = null, e2.dependencies = null, e2.stateNode = null) : (e2.childLanes = f.childLanes, e2.lanes = f.lanes, e2.child = f.child, e2.memoizedProps = f.memoizedProps, e2.memoizedState = f.memoizedState, e2.updateQueue = f.updateQueue, e2.type = f.type, c = f.dependencies, e2.dependencies = c === null ? null : {lanes: c.lanes, firstContext: c.firstContext}), d2 = d2.sibling;
                    A2(M2, M2.current & 1 | 2);
                    return b.child;
                  }
                  a2 = a2.sibling;
                }
              d2.tail !== null && G2() > vf && (b.flags |= 64, e2 = true, rf(d2, false), b.lanes = 33554432);
            }
          else {
            if (!e2)
              if (a2 = Td(f), a2 !== null) {
                if (b.flags |= 64, e2 = true, a2 = a2.updateQueue, a2 !== null && (b.updateQueue = a2, b.flags |= 4), rf(d2, true), d2.tail === null && d2.tailMode === "hidden" && !f.alternate && !Wd)
                  return b = b.lastEffect = d2.lastEffect, b !== null && (b.nextEffect = null), null;
              } else
                2 * G2() - d2.renderingStartTime > vf && c !== 1073741824 && (b.flags |= 64, e2 = true, rf(d2, false), b.lanes = 33554432);
            d2.isBackwards ? (f.sibling = b.child, b.child = f) : (a2 = d2.last, a2 !== null ? a2.sibling = f : b.child = f, d2.last = f);
          }
          return d2.tail !== null ? (a2 = d2.tail, d2.rendering = a2, d2.tail = a2.sibling, d2.lastEffect = b.lastEffect, d2.renderingStartTime = G2(), a2.sibling = null, b = M2.current, A2(M2, e2 ? b & 1 | 2 : b & 1), a2) : null;
        case 23:
        case 24:
          return wf(), a2 !== null && a2.memoizedState !== null !== (b.memoizedState !== null) && d2.mode !== "unstable-defer-without-hiding" && (b.flags |= 4), null;
      }
      throw Error(q(156, b.tag));
    }
    function xf(a2) {
      switch (a2.tag) {
        case 1:
          E2(a2.type) && $b();
          var b = a2.flags;
          return b & 4096 ? (a2.flags = b & -4097 | 64, a2) : null;
        case 3:
          Qd();
          z2(D2);
          z2(B);
          ee2();
          b = a2.flags;
          if ((b & 64) !== 0)
            throw Error(q(285));
          a2.flags = b & -4097 | 64;
          return a2;
        case 5:
          return Sd(a2), null;
        case 13:
          return z2(M2), b = a2.flags, b & 4096 ? (a2.flags = b & -4097 | 64, a2) : null;
        case 19:
          return z2(M2), null;
        case 4:
          return Qd(), null;
        case 10:
          return dd2(a2), null;
        case 23:
        case 24:
          return wf(), null;
        default:
          return null;
      }
    }
    function yf(a2, b) {
      try {
        var c = "", d2 = b;
        do
          c += Wc(d2), d2 = d2.return;
        while (d2);
        var e2 = c;
      } catch (f) {
        e2 = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return {value: a2, source: b, stack: e2};
    }
    function zf(a2, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Af = typeof WeakMap === "function" ? WeakMap : Map;
    function Bf(a2, b, c) {
      c = kd(-1, c);
      c.tag = 3;
      c.payload = {element: null};
      var d2 = b.value;
      c.callback = function() {
        Cf || (Cf = true, Df = d2);
        zf(a2, b);
      };
      return c;
    }
    function Ef(a2, b, c) {
      c = kd(-1, c);
      c.tag = 3;
      var d2 = a2.type.getDerivedStateFromError;
      if (typeof d2 === "function") {
        var e2 = b.value;
        c.payload = function() {
          zf(a2, b);
          return d2(e2);
        };
      }
      var f = a2.stateNode;
      f !== null && typeof f.componentDidCatch === "function" && (c.callback = function() {
        typeof d2 !== "function" && (Ff === null ? Ff = new Set([this]) : Ff.add(this), zf(a2, b));
        var c2 = b.stack;
        this.componentDidCatch(b.value, {componentStack: c2 !== null ? c2 : ""});
      });
      return c;
    }
    var Gf = typeof WeakSet === "function" ? WeakSet : Set;
    function Hf(a2) {
      var b = a2.ref;
      if (b !== null)
        if (typeof b === "function")
          try {
            b(null);
          } catch (c) {
            If(a2, c);
          }
        else
          b.current = null;
    }
    function Jf(a2, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b.flags & 256 && a2 !== null) {
            var c = a2.memoizedProps, d2 = a2.memoizedState;
            a2 = b.stateNode;
            b = a2.getSnapshotBeforeUpdate(b.elementType === b.type ? c : Xc(b.type, c), d2);
            a2.__reactInternalSnapshotBeforeUpdate = b;
          }
          return;
        case 3:
          Ta && b.flags & 256 && xb(b.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(q(163));
    }
    function Kf(a2, b) {
      b = b.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        var c = b = b.next;
        do {
          if ((c.tag & a2) === a2) {
            var d2 = c.destroy;
            c.destroy = void 0;
            d2 !== void 0 && d2();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Lf(a2, b, c) {
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b = c.updateQueue;
          b = b !== null ? b.lastEffect : null;
          if (b !== null) {
            a2 = b = b.next;
            do {
              if ((a2.tag & 3) === 3) {
                var d2 = a2.create;
                a2.destroy = d2();
              }
              a2 = a2.next;
            } while (a2 !== b);
          }
          b = c.updateQueue;
          b = b !== null ? b.lastEffect : null;
          if (b !== null) {
            a2 = b = b.next;
            do {
              var e2 = a2;
              d2 = e2.next;
              e2 = e2.tag;
              (e2 & 4) !== 0 && (e2 & 1) !== 0 && (Mf(c, a2), Nf(c, a2));
              a2 = d2;
            } while (a2 !== b);
          }
          return;
        case 1:
          a2 = c.stateNode;
          c.flags & 4 && (b === null ? a2.componentDidMount() : (d2 = c.elementType === c.type ? b.memoizedProps : Xc(c.type, b.memoizedProps), a2.componentDidUpdate(d2, b.memoizedState, a2.__reactInternalSnapshotBeforeUpdate)));
          b = c.updateQueue;
          b !== null && qd(c, b, a2);
          return;
        case 3:
          b = c.updateQueue;
          if (b !== null) {
            a2 = null;
            if (c.child !== null)
              switch (c.child.tag) {
                case 5:
                  a2 = Da(c.child.stateNode);
                  break;
                case 1:
                  a2 = c.child.stateNode;
              }
            qd(c, b, a2);
          }
          return;
        case 5:
          a2 = c.stateNode;
          b === null && c.flags & 4 && mb(a2, c.type, c.memoizedProps, c);
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          Va && c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Pb(c))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(q(163));
    }
    function Of(a2, b) {
      if (Ta)
        for (var c = a2; ; ) {
          if (c.tag === 5) {
            var d2 = c.stateNode;
            b ? tb(d2) : vb(c.stateNode, c.memoizedProps);
          } else if (c.tag === 6)
            d2 = c.stateNode, b ? ub(d2) : wb(d2, c.memoizedProps);
          else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a2) && c.child !== null) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === a2)
            break;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === a2)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
    }
    function Pf(a2, b) {
      if (fc && typeof fc.onCommitFiberUnmount === "function")
        try {
          fc.onCommitFiberUnmount(ec, b);
        } catch (f) {
        }
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a2 = b.updateQueue;
          if (a2 !== null && (a2 = a2.lastEffect, a2 !== null)) {
            var c = a2 = a2.next;
            do {
              var d2 = c, e2 = d2.destroy;
              d2 = d2.tag;
              if (e2 !== void 0)
                if ((d2 & 4) !== 0)
                  Mf(b, c);
                else {
                  d2 = b;
                  try {
                    e2();
                  } catch (f) {
                    If(d2, f);
                  }
                }
              c = c.next;
            } while (c !== a2);
          }
          break;
        case 1:
          Hf(b);
          a2 = b.stateNode;
          if (typeof a2.componentWillUnmount === "function")
            try {
              a2.props = b.memoizedProps, a2.state = b.memoizedState, a2.componentWillUnmount();
            } catch (f) {
              If(b, f);
            }
          break;
        case 5:
          Hf(b);
          break;
        case 4:
          Ta ? Qf(a2, b) : Ua && Ua && (b = b.stateNode.containerInfo, a2 = zb(b), Cb(b, a2));
      }
    }
    function Rf(a2, b) {
      for (var c = b; ; )
        if (Pf(a2, c), c.child === null || Ta && c.tag === 4) {
          if (c === b)
            break;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === b)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        } else
          c.child.return = c, c = c.child;
    }
    function Sf(a2) {
      a2.alternate = null;
      a2.child = null;
      a2.dependencies = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.return = null;
      a2.updateQueue = null;
    }
    function Tf(a2) {
      return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
    }
    function Uf(a2) {
      if (Ta) {
        a: {
          for (var b = a2.return; b !== null; ) {
            if (Tf(b))
              break a;
            b = b.return;
          }
          throw Error(q(160));
        }
        var c = b;
        b = c.stateNode;
        switch (c.tag) {
          case 5:
            var d2 = false;
            break;
          case 3:
            b = b.containerInfo;
            d2 = true;
            break;
          case 4:
            b = b.containerInfo;
            d2 = true;
            break;
          default:
            throw Error(q(161));
        }
        c.flags & 16 && (sb(b), c.flags &= -17);
        a:
          b:
            for (c = a2; ; ) {
              for (; c.sibling === null; ) {
                if (c.return === null || Tf(c.return)) {
                  c = null;
                  break a;
                }
                c = c.return;
              }
              c.sibling.return = c.return;
              for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
                if (c.flags & 2)
                  continue b;
                if (c.child === null || c.tag === 4)
                  continue b;
                else
                  c.child.return = c, c = c.child;
              }
              if (!(c.flags & 2)) {
                c = c.stateNode;
                break a;
              }
            }
        d2 ? Vf(a2, c, b) : Wf(a2, c, b);
      }
    }
    function Vf(a2, b, c) {
      var d2 = a2.tag, e2 = d2 === 5 || d2 === 6;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b ? pb(c, a2, b) : kb(c, a2);
      else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
        for (Vf(a2, b, c), a2 = a2.sibling; a2 !== null; )
          Vf(a2, b, c), a2 = a2.sibling;
    }
    function Wf(a2, b, c) {
      var d2 = a2.tag, e2 = d2 === 5 || d2 === 6;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b ? ob(c, a2, b) : jb(c, a2);
      else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
        for (Wf(a2, b, c), a2 = a2.sibling; a2 !== null; )
          Wf(a2, b, c), a2 = a2.sibling;
    }
    function Qf(a2, b) {
      for (var c = b, d2 = false, e2, f; ; ) {
        if (!d2) {
          d2 = c.return;
          a:
            for (; ; ) {
              if (d2 === null)
                throw Error(q(160));
              e2 = d2.stateNode;
              switch (d2.tag) {
                case 5:
                  f = false;
                  break a;
                case 3:
                  e2 = e2.containerInfo;
                  f = true;
                  break a;
                case 4:
                  e2 = e2.containerInfo;
                  f = true;
                  break a;
              }
              d2 = d2.return;
            }
          d2 = true;
        }
        if (c.tag === 5 || c.tag === 6)
          Rf(a2, c), f ? rb(e2, c.stateNode) : qb(e2, c.stateNode);
        else if (c.tag === 4) {
          if (c.child !== null) {
            e2 = c.stateNode.containerInfo;
            f = true;
            c.child.return = c;
            c = c.child;
            continue;
          }
        } else if (Pf(a2, c), c.child !== null) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === b)
            return;
          c = c.return;
          c.tag === 4 && (d2 = false);
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }
    function Xf(a2, b) {
      if (Ta) {
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            Kf(3, b);
            return;
          case 1:
            return;
          case 5:
            var c = b.stateNode;
            if (c != null) {
              var d2 = b.memoizedProps;
              a2 = a2 !== null ? a2.memoizedProps : d2;
              var e2 = b.type, f = b.updateQueue;
              b.updateQueue = null;
              f !== null && nb(c, f, e2, a2, d2, b);
            }
            return;
          case 6:
            if (b.stateNode === null)
              throw Error(q(162));
            c = b.memoizedProps;
            lb(b.stateNode, a2 !== null ? a2.memoizedProps : c, c);
            return;
          case 3:
            Va && (b = b.stateNode, b.hydrate && (b.hydrate = false, Ob(b.containerInfo)));
            return;
          case 12:
            return;
          case 13:
            Yf(b);
            Zf(b);
            return;
          case 19:
            Zf(b);
            return;
          case 17:
            return;
          case 23:
          case 24:
            Of(b, b.memoizedState !== null);
            return;
        }
        throw Error(q(163));
      }
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          Kf(3, b);
          return;
        case 12:
          return;
        case 13:
          Yf(b);
          Zf(b);
          return;
        case 19:
          Zf(b);
          return;
        case 3:
          Va && (c = b.stateNode, c.hydrate && (c.hydrate = false, Ob(c.containerInfo)));
          break;
        case 23:
        case 24:
          return;
      }
      a:
        if (Ua) {
          switch (b.tag) {
            case 1:
            case 5:
            case 6:
            case 20:
              break a;
            case 3:
            case 4:
              b = b.stateNode;
              Cb(b.containerInfo, b.pendingChildren);
              break a;
          }
          throw Error(q(163));
        }
    }
    function Yf(a2) {
      a2.memoizedState !== null && ($f = G2(), Ta && Of(a2.child, true));
    }
    function Zf(a2) {
      var b = a2.updateQueue;
      if (b !== null) {
        a2.updateQueue = null;
        var c = a2.stateNode;
        c === null && (c = a2.stateNode = new Gf());
        b.forEach(function(b2) {
          var d2 = ag.bind(null, a2, b2);
          c.has(b2) || (c.add(b2), b2.then(d2, d2));
        });
      }
    }
    function bg(a2, b) {
      return a2 !== null && (a2 = a2.memoizedState, a2 === null || a2.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;
    }
    var cg = 0, dg = 1, eg = 2, fg = 3, gg = 4;
    if (typeof Symbol === "function" && Symbol.for) {
      var hg = Symbol.for;
      cg = hg("selector.component");
      dg = hg("selector.has_pseudo_class");
      eg = hg("selector.role");
      fg = hg("selector.test_id");
      gg = hg("selector.text");
    }
    function ig(a2) {
      var b = Wa(a2);
      if (b != null) {
        if (typeof b.memoizedProps["data-testname"] !== "string")
          throw Error(q(364));
        return b;
      }
      a2 = cb(a2);
      if (a2 === null)
        throw Error(q(362));
      return a2.stateNode.current;
    }
    function jg(a2, b) {
      switch (b.$$typeof) {
        case cg:
          if (a2.type === b.value)
            return true;
          break;
        case dg:
          a: {
            b = b.value;
            a2 = [a2, 0];
            for (var c = 0; c < a2.length; ) {
              var d2 = a2[c++], e2 = a2[c++], f = b[e2];
              if (d2.tag !== 5 || !fb(d2)) {
                for (; f != null && jg(d2, f); )
                  e2++, f = b[e2];
                if (e2 === b.length) {
                  b = true;
                  break a;
                } else
                  for (d2 = d2.child; d2 !== null; )
                    a2.push(d2, e2), d2 = d2.sibling;
              }
            }
            b = false;
          }
          return b;
        case eg:
          if (a2.tag === 5 && gb(a2.stateNode, b.value))
            return true;
          break;
        case gg:
          if (a2.tag === 5 || a2.tag === 6) {
            if (a2 = eb(a2), a2 !== null && 0 <= a2.indexOf(b.value))
              return true;
          }
          break;
        case fg:
          if (a2.tag === 5 && (a2 = a2.memoizedProps["data-testname"], typeof a2 === "string" && a2.toLowerCase() === b.value.toLowerCase()))
            return true;
          break;
        default:
          throw Error(q(365, b));
      }
      return false;
    }
    function kg(a2) {
      switch (a2.$$typeof) {
        case cg:
          return "<" + (wa(a2.value) || "Unknown") + ">";
        case dg:
          return ":has(" + (kg(a2) || "") + ")";
        case eg:
          return '[role="' + a2.value + '"]';
        case gg:
          return '"' + a2.value + '"';
        case fg:
          return '[data-testname="' + a2.value + '"]';
        default:
          throw Error(q(365, a2));
      }
    }
    function lg(a2, b) {
      var c = [];
      a2 = [a2, 0];
      for (var d2 = 0; d2 < a2.length; ) {
        var e2 = a2[d2++], f = a2[d2++], g = b[f];
        if (e2.tag !== 5 || !fb(e2)) {
          for (; g != null && jg(e2, g); )
            f++, g = b[f];
          if (f === b.length)
            c.push(e2);
          else
            for (e2 = e2.child; e2 !== null; )
              a2.push(e2, f), e2 = e2.sibling;
        }
      }
      return c;
    }
    function mg(a2, b) {
      if (!bb)
        throw Error(q(363));
      a2 = ig(a2);
      a2 = lg(a2, b);
      b = [];
      a2 = Array.from(a2);
      for (var c = 0; c < a2.length; ) {
        var d2 = a2[c++];
        if (d2.tag === 5)
          fb(d2) || b.push(d2.stateNode);
        else
          for (d2 = d2.child; d2 !== null; )
            a2.push(d2), d2 = d2.sibling;
      }
      return b;
    }
    var ng = null;
    function og(a2) {
      if (ng === null)
        try {
          var b = ("require" + Math.random()).slice(0, 7);
          ng = (module2 && module2[b]).call(module2, "timers").setImmediate;
        } catch (c) {
          ng = function(a3) {
            var b2 = new MessageChannel();
            b2.port1.onmessage = a3;
            b2.port2.postMessage(void 0);
          };
        }
      return ng(a2);
    }
    var pg = Math.ceil, qg = ca.ReactCurrentDispatcher, rg = ca.ReactCurrentOwner, sg = ca.IsSomeRendererActing, V = 0, R = null, W = null, U = 0, tg = 0, ug = Wb(0), T = 0, vg = null, wg = 0, pd = 0, tf = 0, xg = 0, yg = null, $f = 0, vf = Infinity;
    function zg() {
      vf = G2() + 500;
    }
    var X = null, Cf = false, Df = null, Ff = null, Ag = false, Bg = null, Cg = 90, Dg = [], Eg = [], Fg = null, Gg = 0, Hg = null, Ig = -1, Jg = 0, Kg = 0, Lg = null, Mg = false;
    function K() {
      return (V & 48) !== 0 ? G2() : Ig !== -1 ? Ig : Ig = G2();
    }
    function td(a2) {
      a2 = a2.mode;
      if ((a2 & 2) === 0)
        return 1;
      if ((a2 & 4) === 0)
        return Nc() === 99 ? 1 : 2;
      Jg === 0 && (Jg = wg);
      if (Sc.transition !== 0) {
        Kg !== 0 && (Kg = yg !== null ? yg.pendingLanes : 0);
        a2 = Jg;
        var b = 4186112 & ~Kg;
        b &= -b;
        b === 0 && (a2 = 4186112 & ~a2, b = a2 & -a2, b === 0 && (b = 8192));
        return b;
      }
      a2 = Nc();
      (V & 4) !== 0 && a2 === 98 ? a2 = oc(12, Jg) : (a2 = jc(a2), a2 = oc(a2, Jg));
      return a2;
    }
    function ud(a2, b, c) {
      if (50 < Gg)
        throw Gg = 0, Hg = null, Error(q(185));
      a2 = Ng(a2, b);
      if (a2 === null)
        return null;
      rc(a2, b, c);
      a2 === R && (tf |= b, T === 4 && uf(a2, U));
      var d2 = Nc();
      b === 1 ? (V & 8) !== 0 && (V & 48) === 0 ? Og(a2) : (Z2(a2, c), V === 0 && (zg(), H2())) : ((V & 4) === 0 || d2 !== 98 && d2 !== 99 || (Fg === null ? Fg = new Set([a2]) : Fg.add(a2)), Z2(a2, c));
      yg = a2;
    }
    function Ng(a2, b) {
      a2.lanes |= b;
      var c = a2.alternate;
      c !== null && (c.lanes |= b);
      c = a2;
      for (a2 = a2.return; a2 !== null; )
        a2.childLanes |= b, c = a2.alternate, c !== null && (c.childLanes |= b), c = a2, a2 = a2.return;
      return c.tag === 3 ? c.stateNode : null;
    }
    function Z2(a2, b) {
      for (var c = a2.callbackNode, d2 = a2.suspendedLanes, e2 = a2.pingedLanes, f = a2.expirationTimes, g = a2.pendingLanes; 0 < g; ) {
        var h2 = 31 - mc(g), k = 1 << h2, l = f[h2];
        if (l === -1) {
          if ((k & d2) === 0 || (k & e2) !== 0) {
            l = b;
            ic(k);
            var n = F;
            f[h2] = 10 <= n ? l + 250 : 6 <= n ? l + 5e3 : -1;
          }
        } else
          l <= b && (a2.expiredLanes |= k);
        g &= ~k;
      }
      d2 = lc(a2, a2 === R ? U : 0);
      b = F;
      if (d2 === 0)
        c !== null && (c !== Hc && xc(c), a2.callbackNode = null, a2.callbackPriority = 0);
      else {
        if (c !== null) {
          if (a2.callbackPriority === b)
            return;
          c !== Hc && xc(c);
        }
        b === 15 ? (c = Og.bind(null, a2), Jc === null ? (Jc = [c], Kc = wc(Cc, Rc)) : Jc.push(c), c = Hc) : b === 14 ? c = Qc(99, Og.bind(null, a2)) : (c = kc(b), c = Qc(c, Pg.bind(null, a2)));
        a2.callbackPriority = b;
        a2.callbackNode = c;
      }
    }
    function Pg(a2) {
      Ig = -1;
      Kg = Jg = 0;
      if ((V & 48) !== 0)
        throw Error(q(327));
      var b = a2.callbackNode;
      if (Qg() && a2.callbackNode !== b)
        return null;
      var c = lc(a2, a2 === R ? U : 0);
      if (c === 0)
        return null;
      var d2 = c;
      var e2 = V;
      V |= 16;
      var f = Rg();
      if (R !== a2 || U !== d2)
        zg(), Sg(a2, d2);
      do
        try {
          Tg();
          break;
        } catch (h2) {
          Ug(a2, h2);
        }
      while (1);
      bd();
      qg.current = f;
      V = e2;
      W !== null ? d2 = 0 : (R = null, U = 0, d2 = T);
      if ((wg & tf) !== 0)
        Sg(a2, 0);
      else if (d2 !== 0) {
        d2 === 2 && (V |= 64, a2.hydrate && (a2.hydrate = false, xb(a2.containerInfo)), c = nc(a2), c !== 0 && (d2 = Vg(a2, c)));
        if (d2 === 1)
          throw b = vg, Sg(a2, 0), uf(a2, c), Z2(a2, G2()), b;
        a2.finishedWork = a2.current.alternate;
        a2.finishedLanes = c;
        switch (d2) {
          case 0:
          case 1:
            throw Error(q(345));
          case 2:
            Zg(a2);
            break;
          case 3:
            uf(a2, c);
            if ((c & 62914560) === c && (d2 = $f + 500 - G2(), 10 < d2)) {
              if (lc(a2, 0) !== 0)
                break;
              e2 = a2.suspendedLanes;
              if ((e2 & c) !== c) {
                K();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Pa(Zg.bind(null, a2), d2);
              break;
            }
            Zg(a2);
            break;
          case 4:
            uf(a2, c);
            if ((c & 4186112) === c)
              break;
            d2 = a2.eventTimes;
            for (e2 = -1; 0 < c; ) {
              var g = 31 - mc(c);
              f = 1 << g;
              g = d2[g];
              g > e2 && (e2 = g);
              c &= ~f;
            }
            c = e2;
            c = G2() - c;
            c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * pg(c / 1960)) - c;
            if (10 < c) {
              a2.timeoutHandle = Pa(Zg.bind(null, a2), c);
              break;
            }
            Zg(a2);
            break;
          case 5:
            Zg(a2);
            break;
          default:
            throw Error(q(329));
        }
      }
      Z2(a2, G2());
      return a2.callbackNode === b ? Pg.bind(null, a2) : null;
    }
    function uf(a2, b) {
      b &= ~xg;
      b &= ~tf;
      a2.suspendedLanes |= b;
      a2.pingedLanes &= ~b;
      for (a2 = a2.expirationTimes; 0 < b; ) {
        var c = 31 - mc(b), d2 = 1 << c;
        a2[c] = -1;
        b &= ~d2;
      }
    }
    function Og(a2) {
      if ((V & 48) !== 0)
        throw Error(q(327));
      Qg();
      if (a2 === R && (a2.expiredLanes & U) !== 0) {
        var b = U;
        var c = Vg(a2, b);
        (wg & tf) !== 0 && (b = lc(a2, b), c = Vg(a2, b));
      } else
        b = lc(a2, 0), c = Vg(a2, b);
      a2.tag !== 0 && c === 2 && (V |= 64, a2.hydrate && (a2.hydrate = false, xb(a2.containerInfo)), b = nc(a2), b !== 0 && (c = Vg(a2, b)));
      if (c === 1)
        throw c = vg, Sg(a2, 0), uf(a2, b), Z2(a2, G2()), c;
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b;
      Zg(a2);
      Z2(a2, G2());
      return null;
    }
    function $g() {
      if (Fg !== null) {
        var a2 = Fg;
        Fg = null;
        a2.forEach(function(a3) {
          a3.expiredLanes |= 24 & a3.pendingLanes;
          Z2(a3, G2());
        });
      }
      H2();
    }
    function ah(a2, b) {
      var c = V;
      V |= 1;
      try {
        return a2(b);
      } finally {
        V = c, V === 0 && (zg(), H2());
      }
    }
    function bh(a2, b) {
      var c = V;
      if ((c & 48) !== 0)
        return a2(b);
      V |= 1;
      try {
        if (a2)
          return Pc(99, a2.bind(null, b));
      } finally {
        V = c, H2();
      }
    }
    function Xe(a2, b) {
      A2(ug, tg);
      tg |= b;
      wg |= b;
    }
    function wf() {
      tg = ug.current;
      z2(ug);
    }
    function Sg(a2, b) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c = a2.timeoutHandle;
      c !== Ra && (a2.timeoutHandle = Ra, Qa(c));
      if (W !== null)
        for (c = W.return; c !== null; ) {
          var d2 = c;
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              d2 !== null && d2 !== void 0 && $b();
              break;
            case 3:
              Qd();
              z2(D2);
              z2(B);
              ee2();
              break;
            case 5:
              Sd(d2);
              break;
            case 4:
              Qd();
              break;
            case 13:
              z2(M2);
              break;
            case 19:
              z2(M2);
              break;
            case 10:
              dd2(d2);
              break;
            case 23:
            case 24:
              wf();
          }
          c = c.return;
        }
      R = a2;
      W = Ed(a2.current, null);
      U = tg = wg = b;
      T = 0;
      vg = null;
      xg = tf = pd = 0;
    }
    function Ug(a2, b) {
      do {
        var c = W;
        try {
          bd();
          fe.current = pe;
          if (ie) {
            for (var d2 = N.memoizedState; d2 !== null; ) {
              var e2 = d2.queue;
              e2 !== null && (e2.pending = null);
              d2 = d2.next;
            }
            ie = false;
          }
          he = 0;
          P = O = N = null;
          je = false;
          rg.current = null;
          if (c === null || c.return === null) {
            T = 1;
            vg = b;
            W = null;
            break;
          }
          a: {
            var f = a2, g = c.return, h2 = c, k = b;
            b = U;
            h2.flags |= 2048;
            h2.firstEffect = h2.lastEffect = null;
            if (k !== null && typeof k === "object" && typeof k.then === "function") {
              var l = k;
              if ((h2.mode & 2) === 0) {
                var n = h2.alternate;
                n ? (h2.updateQueue = n.updateQueue, h2.memoizedState = n.memoizedState, h2.lanes = n.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
              }
              var t = (M2.current & 1) !== 0, p = g;
              do {
                var y2;
                if (y2 = p.tag === 13) {
                  var x = p.memoizedState;
                  if (x !== null)
                    y2 = x.dehydrated !== null ? true : false;
                  else {
                    var Y = p.memoizedProps;
                    y2 = Y.fallback === void 0 ? false : Y.unstable_avoidThisFallback !== true ? true : t ? false : true;
                  }
                }
                if (y2) {
                  var u = p.updateQueue;
                  if (u === null) {
                    var v = new Set();
                    v.add(l);
                    p.updateQueue = v;
                  } else
                    u.add(l);
                  if ((p.mode & 2) === 0) {
                    p.flags |= 64;
                    h2.flags |= 16384;
                    h2.flags &= -2981;
                    if (h2.tag === 1)
                      if (h2.alternate === null)
                        h2.tag = 17;
                      else {
                        var C = kd(-1, 1);
                        C.tag = 2;
                        md(h2, C);
                      }
                    h2.lanes |= 1;
                    break a;
                  }
                  k = void 0;
                  h2 = b;
                  var Oa = f.pingCache;
                  Oa === null ? (Oa = f.pingCache = new Af(), k = new Set(), Oa.set(l, k)) : (k = Oa.get(l), k === void 0 && (k = new Set(), Oa.set(l, k)));
                  if (!k.has(h2)) {
                    k.add(h2);
                    var Qe = ch.bind(null, f, l, h2);
                    l.then(Qe, Qe);
                  }
                  p.flags |= 4096;
                  p.lanes = b;
                  break a;
                }
                p = p.return;
              } while (p !== null);
              k = Error((wa(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            T !== 5 && (T = 2);
            k = yf(k, h2);
            p = g;
            do {
              switch (p.tag) {
                case 3:
                  f = k;
                  p.flags |= 4096;
                  b &= -b;
                  p.lanes |= b;
                  var Wg = Bf(p, f, b);
                  nd(p, Wg);
                  break a;
                case 1:
                  f = k;
                  var Xg = p.type, ld = p.stateNode;
                  if ((p.flags & 64) === 0 && (typeof Xg.getDerivedStateFromError === "function" || ld !== null && typeof ld.componentDidCatch === "function" && (Ff === null || !Ff.has(ld)))) {
                    p.flags |= 4096;
                    b &= -b;
                    p.lanes |= b;
                    var Yg = Ef(p, f, b);
                    nd(p, Yg);
                    break a;
                  }
              }
              p = p.return;
            } while (p !== null);
          }
          dh(c);
        } catch (w3) {
          b = w3;
          W === c && c !== null && (W = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    function Rg() {
      var a2 = qg.current;
      qg.current = pe;
      return a2 === null ? pe : a2;
    }
    function Vg(a2, b) {
      var c = V;
      V |= 16;
      var d2 = Rg();
      R === a2 && U === b || Sg(a2, b);
      do
        try {
          eh();
          break;
        } catch (e2) {
          Ug(a2, e2);
        }
      while (1);
      bd();
      V = c;
      qg.current = d2;
      if (W !== null)
        throw Error(q(261));
      R = null;
      U = 0;
      return T;
    }
    function eh() {
      for (; W !== null; )
        fh(W);
    }
    function Tg() {
      for (; W !== null && !yc(); )
        fh(W);
    }
    function fh(a2) {
      var b = gh(a2.alternate, a2, tg);
      a2.memoizedProps = a2.pendingProps;
      b === null ? dh(a2) : W = b;
      rg.current = null;
    }
    function dh(a2) {
      var b = a2;
      do {
        var c = b.alternate;
        a2 = b.return;
        if ((b.flags & 2048) === 0) {
          c = sf(c, b, tg);
          if (c !== null) {
            W = c;
            return;
          }
          c = b;
          if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (tg & 1073741824) !== 0 || (c.mode & 4) === 0) {
            for (var d2 = 0, e2 = c.child; e2 !== null; )
              d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
            c.childLanes = d2;
          }
          a2 !== null && (a2.flags & 2048) === 0 && (a2.firstEffect === null && (a2.firstEffect = b.firstEffect), b.lastEffect !== null && (a2.lastEffect !== null && (a2.lastEffect.nextEffect = b.firstEffect), a2.lastEffect = b.lastEffect), 1 < b.flags && (a2.lastEffect !== null ? a2.lastEffect.nextEffect = b : a2.firstEffect = b, a2.lastEffect = b));
        } else {
          c = xf(b);
          if (c !== null) {
            c.flags &= 2047;
            W = c;
            return;
          }
          a2 !== null && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
        }
        b = b.sibling;
        if (b !== null) {
          W = b;
          return;
        }
        W = b = a2;
      } while (b !== null);
      T === 0 && (T = 5);
    }
    function Zg(a2) {
      var b = Nc();
      Pc(99, hh2.bind(null, a2, b));
      return null;
    }
    function hh2(a2, b) {
      do
        Qg();
      while (Bg !== null);
      if ((V & 48) !== 0)
        throw Error(q(327));
      var c = a2.finishedWork;
      if (c === null)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c === a2.current)
        throw Error(q(177));
      a2.callbackNode = null;
      var d2 = c.lanes | c.childLanes, e2 = d2, f = a2.pendingLanes & ~e2;
      a2.pendingLanes = e2;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= e2;
      a2.mutableReadLanes &= e2;
      a2.entangledLanes &= e2;
      e2 = a2.entanglements;
      for (var g = a2.eventTimes, h2 = a2.expirationTimes; 0 < f; ) {
        var k = 31 - mc(f), l = 1 << k;
        e2[k] = 0;
        g[k] = -1;
        h2[k] = -1;
        f &= ~l;
      }
      Fg !== null && (d2 & 24) === 0 && Fg.has(a2) && Fg.delete(a2);
      a2 === R && (W = R = null, U = 0);
      1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d2 = c.firstEffect) : d2 = c : d2 = c.firstEffect;
      if (d2 !== null) {
        e2 = V;
        V |= 32;
        rg.current = null;
        Lg = Ga(a2.containerInfo);
        Mg = false;
        X = d2;
        do
          try {
            ih();
          } catch (v) {
            if (X === null)
              throw Error(q(330));
            If(X, v);
            X = X.nextEffect;
          }
        while (X !== null);
        Lg = null;
        X = d2;
        do
          try {
            for (g = a2; X !== null; ) {
              var n = X.flags;
              n & 16 && Ta && sb(X.stateNode);
              if (n & 128) {
                var t = X.alternate;
                if (t !== null) {
                  var p = t.ref;
                  p !== null && (typeof p === "function" ? p(null) : p.current = null);
                }
              }
              switch (n & 1038) {
                case 2:
                  Uf(X);
                  X.flags &= -3;
                  break;
                case 6:
                  Uf(X);
                  X.flags &= -3;
                  Xf(X.alternate, X);
                  break;
                case 1024:
                  X.flags &= -1025;
                  break;
                case 1028:
                  X.flags &= -1025;
                  Xf(X.alternate, X);
                  break;
                case 4:
                  Xf(X.alternate, X);
                  break;
                case 8:
                  h2 = g;
                  f = X;
                  Ta ? Qf(h2, f) : Rf(h2, f);
                  var y2 = f.alternate;
                  Sf(f);
                  y2 !== null && Sf(y2);
              }
              X = X.nextEffect;
            }
          } catch (v) {
            if (X === null)
              throw Error(q(330));
            If(X, v);
            X = X.nextEffect;
          }
        while (X !== null);
        Mg && $a();
        Ha(a2.containerInfo);
        a2.current = c;
        X = d2;
        do
          try {
            for (n = a2; X !== null; ) {
              var x = X.flags;
              x & 36 && Lf(n, X.alternate, X);
              if (x & 128) {
                t = void 0;
                var Y = X.ref;
                if (Y !== null) {
                  var u = X.stateNode;
                  switch (X.tag) {
                    case 5:
                      t = Da(u);
                      break;
                    default:
                      t = u;
                  }
                  typeof Y === "function" ? Y(t) : Y.current = t;
                }
              }
              X = X.nextEffect;
            }
          } catch (v) {
            if (X === null)
              throw Error(q(330));
            If(X, v);
            X = X.nextEffect;
          }
        while (X !== null);
        X = null;
        Ic();
        V = e2;
      } else
        a2.current = c;
      if (Ag)
        Ag = false, Bg = a2, Cg = b;
      else
        for (X = d2; X !== null; )
          b = X.nextEffect, X.nextEffect = null, X.flags & 8 && (x = X, x.sibling = null, x.stateNode = null), X = b;
      d2 = a2.pendingLanes;
      d2 === 0 && (Ff = null);
      d2 === 1 ? a2 === Hg ? Gg++ : (Gg = 0, Hg = a2) : Gg = 0;
      c = c.stateNode;
      if (fc && typeof fc.onCommitFiberRoot === "function")
        try {
          fc.onCommitFiberRoot(ec, c, void 0, (c.current.flags & 64) === 64);
        } catch (v) {
        }
      Z2(a2, G2());
      if (Cf)
        throw Cf = false, a2 = Df, Df = null, a2;
      if ((V & 8) !== 0)
        return null;
      H2();
      return null;
    }
    function ih() {
      for (; X !== null; ) {
        var a2 = X.alternate;
        Mg || Lg === null || ((X.flags & 8) !== 0 ? Ca(X, Lg) && (Mg = true, Za()) : X.tag === 13 && bg(a2, X) && Ca(X, Lg) && (Mg = true, Za()));
        var b = X.flags;
        (b & 256) !== 0 && Jf(a2, X);
        (b & 512) === 0 || Ag || (Ag = true, Qc(97, function() {
          Qg();
          return null;
        }));
        X = X.nextEffect;
      }
    }
    function Qg() {
      if (Cg !== 90) {
        var a2 = 97 < Cg ? 97 : Cg;
        Cg = 90;
        return Pc(a2, jh);
      }
      return false;
    }
    function Nf(a2, b) {
      Dg.push(b, a2);
      Ag || (Ag = true, Qc(97, function() {
        Qg();
        return null;
      }));
    }
    function Mf(a2, b) {
      Eg.push(b, a2);
      Ag || (Ag = true, Qc(97, function() {
        Qg();
        return null;
      }));
    }
    function jh() {
      if (Bg === null)
        return false;
      var a2 = Bg;
      Bg = null;
      if ((V & 48) !== 0)
        throw Error(q(331));
      var b = V;
      V |= 32;
      var c = Eg;
      Eg = [];
      for (var d2 = 0; d2 < c.length; d2 += 2) {
        var e2 = c[d2], f = c[d2 + 1], g = e2.destroy;
        e2.destroy = void 0;
        if (typeof g === "function")
          try {
            g();
          } catch (k) {
            if (f === null)
              throw Error(q(330));
            If(f, k);
          }
      }
      c = Dg;
      Dg = [];
      for (d2 = 0; d2 < c.length; d2 += 2) {
        e2 = c[d2];
        f = c[d2 + 1];
        try {
          var h2 = e2.create;
          e2.destroy = h2();
        } catch (k) {
          if (f === null)
            throw Error(q(330));
          If(f, k);
        }
      }
      for (h2 = a2.current.firstEffect; h2 !== null; )
        a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
      V = b;
      H2();
      return true;
    }
    function kh(a2, b, c) {
      b = yf(c, b);
      b = Bf(a2, b, 1);
      md(a2, b);
      b = K();
      a2 = Ng(a2, 1);
      a2 !== null && (rc(a2, 1, b), Z2(a2, b));
    }
    function If(a2, b) {
      if (a2.tag === 3)
        kh(a2, a2, b);
      else
        for (var c = a2.return; c !== null; ) {
          if (c.tag === 3) {
            kh(c, a2, b);
            break;
          } else if (c.tag === 1) {
            var d2 = c.stateNode;
            if (typeof c.type.getDerivedStateFromError === "function" || typeof d2.componentDidCatch === "function" && (Ff === null || !Ff.has(d2))) {
              a2 = yf(b, a2);
              var e2 = Ef(c, a2, 1);
              md(c, e2);
              e2 = K();
              c = Ng(c, 1);
              if (c !== null)
                rc(c, 1, e2), Z2(c, e2);
              else if (typeof d2.componentDidCatch === "function" && (Ff === null || !Ff.has(d2)))
                try {
                  d2.componentDidCatch(b, a2);
                } catch (f) {
                }
              break;
            }
          }
          c = c.return;
        }
    }
    function ch(a2, b, c) {
      var d2 = a2.pingCache;
      d2 !== null && d2.delete(b);
      b = K();
      a2.pingedLanes |= a2.suspendedLanes & c;
      R === a2 && (U & c) === c && (T === 4 || T === 3 && (U & 62914560) === U && 500 > G2() - $f ? Sg(a2, 0) : xg |= c);
      Z2(a2, b);
    }
    function ag(a2, b) {
      var c = a2.stateNode;
      c !== null && c.delete(b);
      b = 0;
      b === 0 && (b = a2.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = Nc() === 99 ? 1 : 2 : (Jg === 0 && (Jg = wg), b = pc(62914560 & ~Jg), b === 0 && (b = 4194304)));
      c = K();
      a2 = Ng(a2, b);
      a2 !== null && (rc(a2, b, c), Z2(a2, c));
    }
    var gh;
    gh = function(a2, b, c) {
      var d2 = b.lanes;
      if (a2 !== null)
        if (a2.memoizedProps !== b.pendingProps || D2.current)
          gd = true;
        else if ((c & d2) !== 0)
          gd = (a2.flags & 16384) !== 0 ? true : false;
        else {
          gd = false;
          switch (b.tag) {
            case 3:
              af(b);
              ce();
              break;
            case 5:
              Rd(b);
              break;
            case 1:
              E2(b.type) && cc(b);
              break;
            case 4:
              Pd(b, b.stateNode.containerInfo);
              break;
            case 10:
              cd(b, b.memoizedProps.value);
              break;
            case 13:
              if (b.memoizedState !== null) {
                if ((c & b.child.childLanes) !== 0)
                  return cf(a2, b, c);
                A2(M2, M2.current & 1);
                b = Re(a2, b, c);
                return b !== null ? b.sibling : null;
              }
              A2(M2, M2.current & 1);
              break;
            case 19:
              d2 = (c & b.childLanes) !== 0;
              if ((a2.flags & 64) !== 0) {
                if (d2)
                  return kf(a2, b, c);
                b.flags |= 64;
              }
              var e2 = b.memoizedState;
              e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
              A2(M2, M2.current);
              if (d2)
                break;
              else
                return null;
            case 23:
            case 24:
              return b.lanes = 0, We(a2, b, c);
          }
          return Re(a2, b, c);
        }
      else
        gd = false;
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          d2 = b.type;
          a2 !== null && (a2.alternate = null, b.alternate = null, b.flags |= 2);
          a2 = b.pendingProps;
          e2 = Zb(b, B.current);
          fd(b, c);
          e2 = le(null, b, d2, a2, e2, c);
          b.flags |= 1;
          if (typeof e2 === "object" && e2 !== null && typeof e2.render === "function" && e2.$$typeof === void 0) {
            b.tag = 1;
            b.memoizedState = null;
            b.updateQueue = null;
            if (E2(d2)) {
              var f = true;
              cc(b);
            } else
              f = false;
            b.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null;
            id(b);
            var g = d2.getDerivedStateFromProps;
            typeof g === "function" && sd(b, d2, g, a2);
            e2.updater = vd;
            b.stateNode = e2;
            e2._reactInternals = b;
            zd(b, d2, a2, c);
            b = $e(null, b, d2, true, f, c);
          } else
            b.tag = 0, S(null, b, e2, c), b = b.child;
          return b;
        case 16:
          e2 = b.elementType;
          a: {
            a2 !== null && (a2.alternate = null, b.alternate = null, b.flags |= 2);
            a2 = b.pendingProps;
            f = e2._init;
            e2 = f(e2._payload);
            b.type = e2;
            f = b.tag = lh(e2);
            a2 = Xc(e2, a2);
            switch (f) {
              case 0:
                b = Ve(null, b, e2, a2, c);
                break a;
              case 1:
                b = Ze(null, b, e2, a2, c);
                break a;
              case 11:
                b = Pe(null, b, e2, a2, c);
                break a;
              case 14:
                b = Se(null, b, e2, Xc(e2.type, a2), d2, c);
                break a;
            }
            throw Error(q(306, e2, ""));
          }
          return b;
        case 0:
          return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Xc(d2, e2), Ve(a2, b, d2, e2, c);
        case 1:
          return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Xc(d2, e2), Ze(a2, b, d2, e2, c);
        case 3:
          af(b);
          d2 = b.updateQueue;
          if (a2 === null || d2 === null)
            throw Error(q(282));
          d2 = b.pendingProps;
          e2 = b.memoizedState;
          e2 = e2 !== null ? e2.element : null;
          jd(a2, b);
          od(b, d2, null, c);
          d2 = b.memoizedState.element;
          if (d2 === e2)
            ce(), b = Re(a2, b, c);
          else {
            e2 = b.stateNode;
            if (f = e2.hydrate)
              Va ? (Vd = Kb(b.stateNode.containerInfo), Ud = b, f = Wd = true) : f = false;
            if (f) {
              if (Va && (a2 = e2.mutableSourceEagerHydrationData, a2 != null))
                for (e2 = 0; e2 < a2.length; e2 += 2)
                  f = a2[e2], g = a2[e2 + 1], Sa ? f._workInProgressVersionPrimary = g : f._workInProgressVersionSecondary = g, de.push(f);
              c = Kd(b, null, d2, c);
              for (b.child = c; c; )
                c.flags = c.flags & -3 | 1024, c = c.sibling;
            } else
              S(a2, b, d2, c), ce();
            b = b.child;
          }
          return b;
        case 5:
          return Rd(b), a2 === null && $d(b), d2 = b.type, e2 = b.pendingProps, f = a2 !== null ? a2.memoizedProps : null, g = e2.children, Ma(d2, e2) ? g = null : f !== null && Ma(d2, f) && (b.flags |= 16), Ye(a2, b), S(a2, b, g, c), b.child;
        case 6:
          return a2 === null && $d(b), null;
        case 13:
          return cf(a2, b, c);
        case 4:
          return Pd(b, b.stateNode.containerInfo), d2 = b.pendingProps, a2 === null ? b.child = Jd(b, null, d2, c) : S(a2, b, d2, c), b.child;
        case 11:
          return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Xc(d2, e2), Pe(a2, b, d2, e2, c);
        case 7:
          return S(a2, b, b.pendingProps, c), b.child;
        case 8:
          return S(a2, b, b.pendingProps.children, c), b.child;
        case 12:
          return S(a2, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d2 = b.type._context;
            e2 = b.pendingProps;
            g = b.memoizedProps;
            f = e2.value;
            cd(b, f);
            if (g !== null) {
              var h2 = g.value;
              f = I(h2, f) ? 0 : (typeof d2._calculateChangedBits === "function" ? d2._calculateChangedBits(h2, f) : 1073741823) | 0;
              if (f === 0) {
                if (g.children === e2.children && !D2.current) {
                  b = Re(a2, b, c);
                  break a;
                }
              } else
                for (h2 = b.child, h2 !== null && (h2.return = b); h2 !== null; ) {
                  var k = h2.dependencies;
                  if (k !== null) {
                    g = h2.child;
                    for (var l = k.firstContext; l !== null; ) {
                      if (l.context === d2 && (l.observedBits & f) !== 0) {
                        h2.tag === 1 && (l = kd(-1, c & -c), l.tag = 2, md(h2, l));
                        h2.lanes |= c;
                        l = h2.alternate;
                        l !== null && (l.lanes |= c);
                        ed(h2.return, c);
                        k.lanes |= c;
                        break;
                      }
                      l = l.next;
                    }
                  } else
                    g = h2.tag === 10 ? h2.type === b.type ? null : h2.child : h2.child;
                  if (g !== null)
                    g.return = h2;
                  else
                    for (g = h2; g !== null; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      h2 = g.sibling;
                      if (h2 !== null) {
                        h2.return = g.return;
                        g = h2;
                        break;
                      }
                      g = g.return;
                    }
                  h2 = g;
                }
            }
            S(a2, b, e2.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e2 = b.type, f = b.pendingProps, d2 = f.children, fd(b, c), e2 = J(e2, f.unstable_observedBits), d2 = d2(e2), b.flags |= 1, S(a2, b, d2, c), b.child;
        case 14:
          return e2 = b.type, f = Xc(e2, b.pendingProps), f = Xc(e2.type, f), Se(a2, b, e2, f, d2, c);
        case 15:
          return Ue(a2, b, b.type, b.pendingProps, d2, c);
        case 17:
          return d2 = b.type, e2 = b.pendingProps, e2 = b.elementType === d2 ? e2 : Xc(d2, e2), a2 !== null && (a2.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, E2(d2) ? (a2 = true, cc(b)) : a2 = false, fd(b, c), xd(b, d2, e2), zd(b, d2, e2, c), $e(null, b, d2, true, a2, c);
        case 19:
          return kf(a2, b, c);
        case 23:
          return We(a2, b, c);
        case 24:
          return We(a2, b, c);
      }
      throw Error(q(156, b.tag));
    };
    var mh = {current: false}, nh = m2.unstable_flushAllWithoutAsserting, oh = typeof nh === "function";
    function ph() {
      if (nh !== void 0)
        return nh();
      for (var a2 = false; Qg(); )
        a2 = true;
      return a2;
    }
    function qh(a2) {
      try {
        ph(), og(function() {
          ph() ? qh(a2) : a2();
        });
      } catch (b) {
        a2(b);
      }
    }
    var rh = 0, sh = false;
    function th(a2, b, c, d2) {
      this.tag = a2;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Yd(a2, b, c, d2) {
      return new th(a2, b, c, d2);
    }
    function Te(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function lh(a2) {
      if (typeof a2 === "function")
        return Te(a2) ? 1 : 0;
      if (a2 !== void 0 && a2 !== null) {
        a2 = a2.$$typeof;
        if (a2 === la)
          return 11;
        if (a2 === oa)
          return 14;
      }
      return 2;
    }
    function Ed(a2, b) {
      var c = a2.alternate;
      c === null ? (c = Yd(a2.tag, b, a2.key, a2.mode), c.elementType = a2.elementType, c.type = a2.type, c.stateNode = a2.stateNode, c.alternate = a2, a2.alternate = c) : (c.pendingProps = b, c.type = a2.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
      c.childLanes = a2.childLanes;
      c.lanes = a2.lanes;
      c.child = a2.child;
      c.memoizedProps = a2.memoizedProps;
      c.memoizedState = a2.memoizedState;
      c.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c.dependencies = b === null ? null : {lanes: b.lanes, firstContext: b.firstContext};
      c.sibling = a2.sibling;
      c.index = a2.index;
      c.ref = a2.ref;
      return c;
    }
    function Gd(a2, b, c, d2, e2, f) {
      var g = 2;
      d2 = a2;
      if (typeof a2 === "function")
        Te(a2) && (g = 1);
      else if (typeof a2 === "string")
        g = 5;
      else
        a:
          switch (a2) {
            case fa:
              return Id(c.children, e2, f, b);
            case ra:
              g = 8;
              e2 |= 16;
              break;
            case ha:
              g = 8;
              e2 |= 1;
              break;
            case ia:
              return a2 = Yd(12, c, b, e2 | 8), a2.elementType = ia, a2.type = ia, a2.lanes = f, a2;
            case ma:
              return a2 = Yd(13, c, b, e2), a2.type = ma, a2.elementType = ma, a2.lanes = f, a2;
            case na:
              return a2 = Yd(19, c, b, e2), a2.elementType = na, a2.lanes = f, a2;
            case sa:
              return ef(c, e2, f, b);
            case ta:
              return a2 = Yd(24, c, b, e2), a2.elementType = ta, a2.lanes = f, a2;
            default:
              if (typeof a2 === "object" && a2 !== null)
                switch (a2.$$typeof) {
                  case ja:
                    g = 10;
                    break a;
                  case ka:
                    g = 9;
                    break a;
                  case la:
                    g = 11;
                    break a;
                  case oa:
                    g = 14;
                    break a;
                  case pa:
                    g = 16;
                    d2 = null;
                    break a;
                  case qa:
                    g = 22;
                    break a;
                }
              throw Error(q(130, a2 == null ? a2 : typeof a2, ""));
          }
      b = Yd(g, c, b, e2);
      b.elementType = a2;
      b.type = d2;
      b.lanes = f;
      return b;
    }
    function Id(a2, b, c, d2) {
      a2 = Yd(7, a2, d2, b);
      a2.lanes = c;
      return a2;
    }
    function ef(a2, b, c, d2) {
      a2 = Yd(23, a2, d2, b);
      a2.elementType = sa;
      a2.lanes = c;
      return a2;
    }
    function Fd(a2, b, c) {
      a2 = Yd(6, a2, null, b);
      a2.lanes = c;
      return a2;
    }
    function Hd(a2, b, c) {
      b = Yd(4, a2.children !== null ? a2.children : [], a2.key, b);
      b.lanes = c;
      b.stateNode = {containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation};
      return b;
    }
    function uh(a2, b, c) {
      this.tag = b;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = Ra;
      this.pendingContext = this.context = null;
      this.hydrate = c;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = qc(0);
      this.expirationTimes = qc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = qc(0);
      Va && (this.mutableSourceEagerHydrationData = null);
    }
    function vh(a2) {
      var b = a2._reactInternals;
      if (b === void 0) {
        if (typeof a2.render === "function")
          throw Error(q(188));
        throw Error(q(268, Object.keys(a2)));
      }
      a2 = Aa(b);
      return a2 === null ? null : a2.stateNode;
    }
    function wh(a2, b) {
      a2 = a2.memoizedState;
      if (a2 !== null && a2.dehydrated !== null) {
        var c = a2.retryLane;
        a2.retryLane = c !== 0 && c < b ? c : b;
      }
    }
    function xh(a2, b) {
      wh(a2, b);
      (a2 = a2.alternate) && wh(a2, b);
    }
    function yh(a2) {
      a2 = Aa(a2);
      return a2 === null ? null : a2.stateNode;
    }
    function zh() {
      return null;
    }
    exports3.IsThisRendererActing = mh;
    exports3.act = function(a2) {
      function b() {
        rh--;
        sg.current = c;
        mh.current = d2;
      }
      sh === false && (sh = true, console.error("act(...) is not supported in production builds of React, and might not behave as expected."));
      rh++;
      var c = sg.current, d2 = mh.current;
      sg.current = true;
      mh.current = true;
      try {
        var e2 = ah(a2);
      } catch (f) {
        throw b(), f;
      }
      if (e2 !== null && typeof e2 === "object" && typeof e2.then === "function")
        return {then: function(a3, d3) {
          e2.then(function() {
            1 < rh || oh === true && c === true ? (b(), a3()) : qh(function(c2) {
              b();
              c2 ? d3(c2) : a3();
            });
          }, function(a4) {
            b();
            d3(a4);
          });
        }};
      try {
        rh !== 1 || oh !== false && c !== false || ph(), b();
      } catch (f) {
        throw b(), f;
      }
      return {then: function(a3) {
        a3();
      }};
    };
    exports3.attemptContinuousHydration = function(a2) {
      if (a2.tag === 13) {
        var b = K();
        ud(a2, 67108864, b);
        xh(a2, 67108864);
      }
    };
    exports3.attemptHydrationAtCurrentPriority = function(a2) {
      if (a2.tag === 13) {
        var b = K(), c = td(a2);
        ud(a2, c, b);
        xh(a2, c);
      }
    };
    exports3.attemptSynchronousHydration = function(a2) {
      switch (a2.tag) {
        case 3:
          var b = a2.stateNode;
          if (b.hydrate) {
            var c = ic(b.pendingLanes);
            b.expiredLanes |= c & b.pendingLanes;
            Z2(b, G2());
            (V & 48) === 0 && (zg(), H2());
          }
          break;
        case 13:
          var d2 = K();
          bh(function() {
            return ud(a2, 1, d2);
          });
          xh(a2, 4);
      }
    };
    exports3.attemptUserBlockingHydration = function(a2) {
      if (a2.tag === 13) {
        var b = K();
        ud(a2, 4, b);
        xh(a2, 4);
      }
    };
    exports3.batchedEventUpdates = function(a2, b) {
      var c = V;
      V |= 2;
      try {
        return a2(b);
      } finally {
        V = c, V === 0 && (zg(), H2());
      }
    };
    exports3.batchedUpdates = ah;
    exports3.createComponentSelector = function(a2) {
      return {$$typeof: cg, value: a2};
    };
    exports3.createContainer = function(a2, b, c) {
      a2 = new uh(a2, b, c);
      b = Yd(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);
      a2.current = b;
      b.stateNode = a2;
      id(b);
      return a2;
    };
    exports3.createHasPsuedoClassSelector = function(a2) {
      return {$$typeof: dg, value: a2};
    };
    exports3.createPortal = function(a2, b, c) {
      var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {$$typeof: ea, key: d2 == null ? null : "" + d2, children: a2, containerInfo: b, implementation: c};
    };
    exports3.createRoleSelector = function(a2) {
      return {$$typeof: eg, value: a2};
    };
    exports3.createTestNameSelector = function(a2) {
      return {$$typeof: fg, value: a2};
    };
    exports3.createTextSelector = function(a2) {
      return {$$typeof: gg, value: a2};
    };
    exports3.deferredUpdates = function(a2) {
      return Pc(97, a2);
    };
    exports3.discreteUpdates = function(a2, b, c, d2, e2) {
      var f = V;
      V |= 4;
      try {
        return Pc(98, a2.bind(null, b, c, d2, e2));
      } finally {
        V = f, V === 0 && (zg(), H2());
      }
    };
    exports3.findAllNodes = mg;
    exports3.findBoundingRects = function(a2, b) {
      if (!bb)
        throw Error(q(363));
      b = mg(a2, b);
      a2 = [];
      for (var c = 0; c < b.length; c++)
        a2.push(db(b[c]));
      for (b = a2.length - 1; 0 < b; b--) {
        c = a2[b];
        for (var d2 = c.x, e2 = d2 + c.width, f = c.y, g = f + c.height, h2 = b - 1; 0 <= h2; h2--)
          if (b !== h2) {
            var k = a2[h2], l = k.x, n = l + k.width, t = k.y, p = t + k.height;
            if (d2 >= l && f >= t && e2 <= n && g <= p) {
              a2.splice(b, 1);
              break;
            } else if (!(d2 !== l || c.width !== k.width || p < f || t > g)) {
              t > f && (k.height += t - f, k.y = f);
              p < g && (k.height = g - t);
              a2.splice(b, 1);
              break;
            } else if (!(f !== t || c.height !== k.height || n < d2 || l > e2)) {
              l > d2 && (k.width += l - d2, k.x = d2);
              n < e2 && (k.width = e2 - l);
              a2.splice(b, 1);
              break;
            }
          }
      }
      return a2;
    };
    exports3.findHostInstance = vh;
    exports3.findHostInstanceWithNoPortals = function(a2) {
      a2 = Ba(a2);
      return a2 === null ? null : a2.tag === 20 ? a2.stateNode.instance : a2.stateNode;
    };
    exports3.findHostInstanceWithWarning = function(a2) {
      return vh(a2);
    };
    exports3.flushControlled = function(a2) {
      var b = V;
      V |= 1;
      try {
        Pc(99, a2);
      } finally {
        V = b, V === 0 && (zg(), H2());
      }
    };
    exports3.flushDiscreteUpdates = function() {
      (V & 49) === 0 && ($g(), Qg());
    };
    exports3.flushPassiveEffects = Qg;
    exports3.flushSync = bh;
    exports3.focusWithin = function(a2, b) {
      if (!bb)
        throw Error(q(363));
      a2 = ig(a2);
      b = lg(a2, b);
      b = Array.from(b);
      for (a2 = 0; a2 < b.length; ) {
        var c = b[a2++];
        if (!fb(c)) {
          if (c.tag === 5 && hb(c.stateNode))
            return true;
          for (c = c.child; c !== null; )
            b.push(c), c = c.sibling;
        }
      }
      return false;
    };
    exports3.getCurrentUpdateLanePriority = function() {
      return hc;
    };
    exports3.getFindAllNodesFailureDescription = function(a2, b) {
      if (!bb)
        throw Error(q(363));
      var c = 0, d2 = [];
      a2 = [ig(a2), 0];
      for (var e2 = 0; e2 < a2.length; ) {
        var f = a2[e2++], g = a2[e2++], h2 = b[g];
        if (f.tag !== 5 || !fb(f)) {
          if (jg(f, h2) && (d2.push(kg(h2)), g++, g > c && (c = g)), g < b.length)
            for (f = f.child; f !== null; )
              a2.push(f, g), f = f.sibling;
        }
      }
      if (c < b.length) {
        for (a2 = []; c < b.length; c++)
          a2.push(kg(b[c]));
        return "findAllNodes was able to match part of the selector:\n  " + (d2.join(" > ") + "\n\nNo matching component was found for:\n  ") + a2.join(" > ");
      }
      return null;
    };
    exports3.getPublicRootInstance = function(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return Da(a2.child.stateNode);
        default:
          return a2.child.stateNode;
      }
    };
    exports3.injectIntoDevTools = function(a2) {
      a2 = {
        bundleType: a2.bundleType,
        version: a2.version,
        rendererPackageName: a2.rendererPackageName,
        rendererConfig: a2.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ca.ReactCurrentDispatcher,
        findHostInstanceByFiber: yh,
        findFiberByHostInstance: a2.findFiberByHostInstance || zh,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
      };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        a2 = false;
      else {
        var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!b.isDisabled && b.supportsFiber)
          try {
            ec = b.inject(a2), fc = b;
          } catch (c) {
          }
        a2 = true;
      }
      return a2;
    };
    exports3.observeVisibleRects = function(a2, b, c, d2) {
      if (!bb)
        throw Error(q(363));
      a2 = mg(a2, b);
      var e2 = ib(a2, c, d2).disconnect;
      return {disconnect: function() {
        e2();
      }};
    };
    exports3.registerMutableSourceForHydration = function(a2, b) {
      var c = b._getVersion;
      c = c(b._source);
      a2.mutableSourceEagerHydrationData == null ? a2.mutableSourceEagerHydrationData = [b, c] : a2.mutableSourceEagerHydrationData.push(b, c);
    };
    exports3.runWithPriority = function(a2, b) {
      var c = hc;
      try {
        return hc = a2, b();
      } finally {
        hc = c;
      }
    };
    exports3.shouldSuspend = function() {
      return false;
    };
    exports3.unbatchedUpdates = function(a2, b) {
      var c = V;
      V &= -2;
      V |= 8;
      try {
        return a2(b);
      } finally {
        V = c, V === 0 && (zg(), H2());
      }
    };
    exports3.updateContainer = function(a2, b, c, d2) {
      var e2 = b.current, f = K(), g = td(e2);
      a:
        if (c) {
          c = c._reactInternals;
          b: {
            if (xa(c) !== c || c.tag !== 1)
              throw Error(q(170));
            var h2 = c;
            do {
              switch (h2.tag) {
                case 3:
                  h2 = h2.stateNode.context;
                  break b;
                case 1:
                  if (E2(h2.type)) {
                    h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h2 = h2.return;
            } while (h2 !== null);
            throw Error(q(171));
          }
          if (c.tag === 1) {
            var k = c.type;
            if (E2(k)) {
              c = bc(c, k, h2);
              break a;
            }
          }
          c = h2;
        } else
          c = Xb;
      b.context === null ? b.context = c : b.pendingContext = c;
      b = kd(f, g);
      b.payload = {element: a2};
      d2 = d2 === void 0 ? null : d2;
      d2 !== null && (b.callback = d2);
      md(e2, b);
      ud(e2, g, f);
      return g;
    };
    return exports3;
  };
});

// node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_react_reconciler_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS((exports2, module2) => {
  function E2() {
  }
  E2.prototype = {
    on: function(name2, callback, ctx) {
      var e2 = this.e || (this.e = {});
      (e2[name2] || (e2[name2] = [])).push({
        fn: callback,
        ctx
      });
      return this;
    },
    once: function(name2, callback, ctx) {
      var self2 = this;
      function listener() {
        self2.off(name2, listener);
        callback.apply(ctx, arguments);
      }
      ;
      listener._ = callback;
      return this.on(name2, listener, ctx);
    },
    emit: function(name2) {
      var data3 = [].slice.call(arguments, 1);
      var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
      var i = 0;
      var len = evtArr.length;
      for (i; i < len; i++) {
        evtArr[i].fn.apply(evtArr[i].ctx, data3);
      }
      return this;
    },
    off: function(name2, callback) {
      var e2 = this.e || (this.e = {});
      var evts = e2[name2];
      var liveEvents = [];
      if (evts && callback) {
        for (var i = 0, len = evts.length; i < len; i++) {
          if (evts[i].fn !== callback && evts[i].fn._ !== callback)
            liveEvents.push(evts[i]);
        }
      }
      liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
      return this;
    }
  };
  module2.exports = E2;
  module2.exports.TinyEmitter = E2;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function equal(a2, b) {
    if (a2 === b)
      return true;
    if (a2 && b && typeof a2 == "object" && typeof b == "object") {
      if (a2.constructor !== b.constructor)
        return false;
      var length2, i, keys;
      if (Array.isArray(a2)) {
        length2 = a2.length;
        if (length2 != b.length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!equal(a2[i], b[i]))
            return false;
        return true;
      }
      if (a2.constructor === RegExp)
        return a2.source === b.source && a2.flags === b.flags;
      if (a2.valueOf !== Object.prototype.valueOf)
        return a2.valueOf() === b.valueOf();
      if (a2.toString !== Object.prototype.toString)
        return a2.toString() === b.toString();
      keys = Object.keys(a2);
      length2 = keys.length;
      if (length2 !== Object.keys(b).length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length2; i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a2[key], b[key]))
          return false;
      }
      return true;
    }
    return a2 !== a2 && b !== b;
  };
});

// node_modules/debounce/index.js
var require_debounce = __commonJS((exports2, module2) => {
  function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (wait == null)
      wait = 100;
    function later() {
      var last2 = Date.now() - timestamp;
      if (last2 < wait && last2 >= 0) {
        timeout = setTimeout(later, wait - last2);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    ;
    var debounced = function() {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout)
        timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function() {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }
  debounce.debounce = debounce;
  module2.exports = debounce;
});

// node_modules/react-use-measure/dist/web.js
var require_web = __commonJS((exports2, module2) => {
  __markAsModule(exports2);
  __export(exports2, {
    default: () => web_default
  });
  var import_react20 = __toModule(require("react"));
  var import_debounce = __toModule(require_debounce());
  function useMeasure2({
    debounce: debounce$1,
    scroll,
    polyfill
  } = {
    debounce: 0,
    scroll: false
  }) {
    const ResizeObserver = polyfill || (typeof window === "undefined" ? class ResizeObserver {
    } : window.ResizeObserver);
    if (!ResizeObserver) {
      throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
    }
    const [bounds, set6] = (0, import_react20.useState)({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0
    });
    const state = (0, import_react20.useRef)({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: bounds
    });
    const scrollDebounce = debounce$1 ? typeof debounce$1 === "number" ? debounce$1 : debounce$1.scroll : null;
    const resizeDebounce = debounce$1 ? typeof debounce$1 === "number" ? debounce$1 : debounce$1.resize : null;
    const mounted = (0, import_react20.useRef)(false);
    (0, import_react20.useEffect)(() => {
      mounted.current = true;
      return () => void (mounted.current = false);
    });
    const [forceRefresh, resizeChange, scrollChange] = (0, import_react20.useMemo)(() => {
      const callback = () => {
        if (!state.current.element)
          return;
        const {
          left,
          top,
          width,
          height,
          bottom,
          right,
          x,
          y: y2
        } = state.current.element.getBoundingClientRect();
        const size = {
          left,
          top,
          width,
          height,
          bottom,
          right,
          x,
          y: y2
        };
        Object.freeze(size);
        if (mounted.current && !areBoundsEqual(state.current.lastBounds, size))
          set6(state.current.lastBounds = size);
      };
      return [callback, resizeDebounce ? (0, import_debounce.debounce)(callback, resizeDebounce) : callback, scrollDebounce ? (0, import_debounce.debounce)(callback, scrollDebounce) : callback];
    }, [set6, scrollDebounce, resizeDebounce]);
    function removeListeners() {
      if (state.current.scrollContainers) {
        state.current.scrollContainers.forEach((element) => element.removeEventListener("scroll", scrollChange, true));
        state.current.scrollContainers = null;
      }
      if (state.current.resizeObserver) {
        state.current.resizeObserver.disconnect();
        state.current.resizeObserver = null;
      }
    }
    function addListeners() {
      if (!state.current.element)
        return;
      state.current.resizeObserver = new ResizeObserver(scrollChange);
      state.current.resizeObserver.observe(state.current.element);
      if (scroll && state.current.scrollContainers) {
        state.current.scrollContainers.forEach((scrollContainer) => scrollContainer.addEventListener("scroll", scrollChange, {
          capture: true,
          passive: true
        }));
      }
    }
    const ref = (node2) => {
      if (!node2 || node2 === state.current.element)
        return;
      removeListeners();
      state.current.element = node2;
      state.current.scrollContainers = findScrollContainers(node2);
      addListeners();
    };
    useOnWindowScroll(scrollChange, Boolean(scroll));
    useOnWindowResize(resizeChange);
    (0, import_react20.useEffect)(() => {
      removeListeners();
      addListeners();
    }, [scroll, scrollChange, resizeChange]);
    (0, import_react20.useEffect)(() => removeListeners, []);
    return [ref, bounds, forceRefresh];
  }
  function useOnWindowResize(onWindowResize) {
    (0, import_react20.useEffect)(() => {
      const cb = onWindowResize;
      window.addEventListener("resize", cb);
      return () => void window.removeEventListener("resize", cb);
    }, [onWindowResize]);
  }
  function useOnWindowScroll(onScroll, enabled) {
    (0, import_react20.useEffect)(() => {
      if (enabled) {
        const cb = onScroll;
        window.addEventListener("scroll", cb, {
          capture: true,
          passive: true
        });
        return () => void window.removeEventListener("scroll", cb, true);
      }
    }, [onScroll, enabled]);
  }
  function findScrollContainers(element) {
    const result = [];
    if (!element || element === document.body)
      return result;
    const {
      overflow,
      overflowX,
      overflowY
    } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === "auto" || prop === "scroll"))
      result.push(element);
    return [...result, ...findScrollContainers(element.parentElement)];
  }
  var keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
  var areBoundsEqual = (a2, b) => keys.every((key) => a2[key] === b[key]);
  if (typeof module2 !== "undefined" && Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(module2, "exports").writable) {
    module2.exports = useMeasure2;
  }
  var web_default = useMeasure2;
});

// node_modules/chart.xkcd/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  (function() {
    function wb(a3) {
      return a3 && a3.__esModule ? {d: a3.default} : {d: a3};
    }
    var xb = {};
    function yb(t2, e3) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(t2);
        e3 && (o3 = o3.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t2, e4).enumerable;
        })), i2.push.apply(i2, o3);
      }
      return i2;
    }
    function od(t2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i2 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? yb(i2, true).forEach(function(e4) {
          pd(t2, e4, i2[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : yb(i2).forEach(function(e4) {
          Object.defineProperty(t2, e4, Object.getOwnPropertyDescriptor(i2, e4));
        });
      }
      return t2;
    }
    function pd(t2, e3, i2) {
      return e3 in t2 ? Object.defineProperty(t2, e3, {value: i2, enumerable: true, configurable: true, writable: true}) : t2[e3] = i2, t2;
    }
    function qd() {
    }
    var zb = function($2) {
      return $2 == null ? qd : function() {
        return this.querySelector($2);
      };
    };
    var rd = function(e3) {
      typeof e3 != "function" && (e3 = zb(e3));
      for (var r2 = this._groups, t2 = r2.length, a3 = new Array(t2), l2 = 0; l2 < t2; ++l2)
        for (var $2, _2, o3 = r2[l2], n2 = o3.length, i2 = a3[l2] = new Array(n2), p2 = 0; p2 < n2; ++p2)
          ($2 = o3[p2]) && (_2 = e3.call($2, $2.__data__, p2, o3)) && ("__data__" in $2 && (_2.__data__ = $2.__data__), i2[p2] = _2);
      return new m2(a3, this._parents);
    };
    function sd() {
      return [];
    }
    var td = function(t2) {
      return t2 == null ? sd : function() {
        return this.querySelectorAll(t2);
      };
    };
    var ud = function(e3) {
      typeof e3 != "function" && (e3 = td(e3));
      for (var r2 = this._groups, p2 = r2.length, t2 = [], $2 = [], f2 = 0; f2 < p2; ++f2)
        for (var l2, o3 = r2[f2], a3 = o3.length, u2 = 0; u2 < a3; ++u2)
          (l2 = o3[u2]) && (t2.push(e3.call(l2, l2.__data__, u2, o3)), $2.push(l2));
      return new m2(t2, $2);
    };
    var vd = function(r2) {
      return function() {
        return this.matches(r2);
      };
    };
    var wd = function(r2) {
      typeof r2 != "function" && (r2 = vd(r2));
      for (var e3 = this._groups, a3 = e3.length, t2 = new Array(a3), $2 = 0; $2 < a3; ++$2)
        for (var S2, o3 = e3[$2], n2 = o3.length, p2 = t2[$2] = [], i2 = 0; i2 < n2; ++i2)
          (S2 = o3[i2]) && r2.call(S2, S2.__data__, i2, o3) && p2.push(S2);
      return new m2(t2, this._parents);
    };
    var Ab = function(e3) {
      return new Array(e3.length);
    };
    var xd = function() {
      return new m2(this._enter || this._groups.map(Ab), this._parents);
    };
    function ia(e3, t2) {
      this.ownerDocument = e3.ownerDocument, this.namespaceURI = e3.namespaceURI, this._next = null, this._parent = e3, this.__data__ = t2;
    }
    ia.prototype = {constructor: ia, appendChild: function(e3) {
      return this._parent.insertBefore(e3, this._next);
    }, insertBefore: function(e3, t2) {
      return this._parent.insertBefore(e3, t2);
    }, querySelector: function(e3) {
      return this._parent.querySelector(e3);
    }, querySelectorAll: function(e3) {
      return this._parent.querySelectorAll(e3);
    }};
    var yd = function(r2) {
      return function() {
        return r2;
      };
    };
    var Bb = "$";
    function zd(r2, e3, n2, $2, t2, a3) {
      for (var c2, i2 = 0, o3 = e3.length, l2 = a3.length; i2 < l2; ++i2)
        (c2 = e3[i2]) ? (c2.__data__ = a3[i2], $2[i2] = c2) : n2[i2] = new ia(r2, a3[i2]);
      for (; i2 < o3; ++i2)
        (c2 = e3[i2]) && (t2[i2] = c2);
    }
    function Ad(r2, e3, n2, $2, t2, a3, c2) {
      var i2, o3, l2, f2 = {}, q2 = e3.length, _2 = a3.length, O2 = new Array(q2);
      for (i2 = 0; i2 < q2; ++i2)
        (o3 = e3[i2]) && (O2[i2] = l2 = Bb + c2.call(o3, o3.__data__, i2, e3), l2 in f2 ? t2[i2] = o3 : f2[l2] = o3);
      for (i2 = 0; i2 < _2; ++i2)
        (o3 = f2[l2 = Bb + c2.call(r2, a3[i2], i2, a3)]) ? ($2[i2] = o3, o3.__data__ = a3[i2], f2[l2] = null) : n2[i2] = new ia(r2, a3[i2]);
      for (i2 = 0; i2 < q2; ++i2)
        (o3 = e3[i2]) && f2[O2[i2]] === o3 && (t2[i2] = o3);
    }
    var Bd = function(r2, e3) {
      if (!r2)
        return O2 = new Array(this.size()), l2 = -1, this.each(function(r3) {
          O2[++l2] = r3;
        }), O2;
      var n2 = e3 ? Ad : zd, $2 = this._parents, t2 = this._groups;
      typeof r2 != "function" && (r2 = yd(r2));
      for (var a3 = t2.length, c2 = new Array(a3), i2 = new Array(a3), o3 = new Array(a3), l2 = 0; l2 < a3; ++l2) {
        var f2 = $2[l2], q2 = t2[l2], _2 = q2.length, O2 = r2.call(f2, f2 && f2.__data__, l2, $2), d3 = O2.length, u2 = i2[l2] = new Array(d3), v2 = c2[l2] = new Array(d3);
        n2(f2, q2, u2, v2, o3[l2] = new Array(_2), O2, e3);
        for (var p2, y3, h3 = 0, x2 = 0; h3 < d3; ++h3)
          if (p2 = u2[h3]) {
            for (h3 >= x2 && (x2 = h3 + 1); !(y3 = v2[x2]) && ++x2 < d3; )
              ;
            p2._next = y3 || null;
          }
      }
      return (c2 = new m2(c2, $2))._enter = i2, c2._exit = o3, c2;
    };
    var Cd = function() {
      return new m2(this._exit || this._groups.map(Ab), this._parents);
    };
    var Dd = function(e3, t2, r2) {
      var $2 = this.enter(), n2 = this, o3 = this.exit();
      return $2 = typeof e3 == "function" ? e3($2) : $2.append(e3 + ""), t2 != null && (n2 = t2(n2)), r2 == null ? o3.remove() : r2(o3), $2 && n2 ? $2.merge(n2).order() : n2;
    };
    var Ed = function(r2) {
      for (var e3 = this._groups, t2 = r2._groups, $2 = e3.length, n2 = t2.length, a3 = Math.min($2, n2), o3 = new Array($2), x2 = 0; x2 < a3; ++x2)
        for (var p2, i2 = e3[x2], l2 = t2[x2], u2 = i2.length, f2 = o3[x2] = new Array(u2), s3 = 0; s3 < u2; ++s3)
          (p2 = i2[s3] || l2[s3]) && (f2[s3] = p2);
      for (; x2 < $2; ++x2)
        o3[x2] = e3[x2];
      return new m2(o3, this._parents);
    };
    var Fd = function() {
      for (var e3 = this._groups, t2 = -1, r2 = e3.length; ++t2 < r2; )
        for (var o3, $2 = e3[t2], n2 = $2.length - 1, a3 = $2[n2]; --n2 >= 0; )
          (o3 = $2[n2]) && (a3 && 4 ^ o3.compareDocumentPosition(a3) && a3.parentNode.insertBefore(o3, a3), a3 = o3);
      return this;
    };
    var Gd = function(r2) {
      function e3(e4, t3) {
        return e4 && t3 ? r2(e4.__data__, t3.__data__) : !e4 - !t3;
      }
      r2 || (r2 = Hd);
      for (var t2 = this._groups, n2 = t2.length, $2 = new Array(n2), a3 = 0; a3 < n2; ++a3) {
        for (var w4, o3 = t2[a3], i2 = o3.length, u2 = $2[a3] = new Array(i2), _2 = 0; _2 < i2; ++_2)
          (w4 = o3[_2]) && (u2[_2] = w4);
        u2.sort(e3);
      }
      return new m2($2, this._parents).order();
    };
    function Hd(r2, e3) {
      return r2 < e3 ? -1 : r2 > e3 ? 1 : r2 >= e3 ? 0 : NaN;
    }
    var Id = function() {
      var t2 = arguments[0];
      return arguments[0] = this, t2.apply(null, arguments), this;
    };
    var Jd = function() {
      var t2 = new Array(this.size()), a3 = -1;
      return this.each(function() {
        t2[++a3] = this;
      }), t2;
    };
    var Kd = function() {
      for (var r2 = this._groups, t2 = 0, e3 = r2.length; t2 < e3; ++t2)
        for (var $2 = r2[t2], o3 = 0, u2 = $2.length; o3 < u2; ++o3) {
          var a3 = $2[o3];
          if (a3)
            return a3;
        }
      return null;
    };
    var Ld = function() {
      var e3 = 0;
      return this.each(function() {
        ++e3;
      }), e3;
    };
    var Md = function() {
      return !this.node();
    };
    var Nd = function(t2) {
      for (var r2 = this._groups, e3 = 0, $2 = r2.length; e3 < $2; ++e3)
        for (var a3, n2 = r2[e3], p2 = 0, o3 = n2.length; p2 < o3; ++p2)
          (a3 = n2[p2]) && t2.call(a3, a3.__data__, p2, n2);
      return this;
    };
    function Od(t2) {
      return function() {
        this.removeAttribute(t2);
      };
    }
    function Pd(t2) {
      return function() {
        this.removeAttributeNS(t2.space, t2.local);
      };
    }
    function Qd(t2, r2) {
      return function() {
        this.setAttribute(t2, r2);
      };
    }
    function Rd(t2, r2) {
      return function() {
        this.setAttributeNS(t2.space, t2.local, r2);
      };
    }
    function Sd(t2, r2) {
      return function() {
        var e3 = r2.apply(this, arguments);
        e3 == null ? this.removeAttribute(t2) : this.setAttribute(t2, e3);
      };
    }
    function Td(t2, r2) {
      return function() {
        var e3 = r2.apply(this, arguments);
        e3 == null ? this.removeAttributeNS(t2.space, t2.local) : this.setAttributeNS(t2.space, t2.local, e3);
      };
    }
    var Ha = "http://www.w3.org/1999/xhtml";
    var Cb = {svg: "http://www.w3.org/2000/svg", xhtml: Ha, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/"};
    var Db = function(e3) {
      var $2 = e3 += "", a3 = $2.indexOf(":");
      return a3 >= 0 && ($2 = e3.slice(0, a3)) !== "xmlns" && (e3 = e3.slice(a3 + 1)), Cb.hasOwnProperty($2) ? {space: Cb[$2], local: e3} : e3;
    };
    var Ud = function(t2, r2) {
      var e3 = Db(t2);
      if (arguments.length < 2) {
        var a3 = this.node();
        return e3.local ? a3.getAttributeNS(e3.space, e3.local) : a3.getAttribute(e3);
      }
      return this.each((r2 == null ? e3.local ? Pd : Od : typeof r2 == "function" ? e3.local ? Td : Sd : e3.local ? Rd : Qd)(e3, r2));
    };
    function Vd(e3) {
      return function() {
        this.style.removeProperty(e3);
      };
    }
    function Wd(e3, t2, r2) {
      return function() {
        this.style.setProperty(e3, t2, r2);
      };
    }
    function Xd(e3, t2, r2) {
      return function() {
        var $2 = t2.apply(this, arguments);
        $2 == null ? this.style.removeProperty(e3) : this.style.setProperty(e3, $2, r2);
      };
    }
    var Eb = function(e3) {
      return e3.ownerDocument && e3.ownerDocument.defaultView || e3.document && e3 || e3.defaultView;
    };
    var Yd = function(e3, t2, r2) {
      return arguments.length > 1 ? this.each((t2 == null ? Vd : typeof t2 == "function" ? Xd : Wd)(e3, t2, r2 == null ? "" : r2)) : Zd(this.node(), e3);
    };
    function Zd(e3, t2) {
      return e3.style.getPropertyValue(t2) || Eb(e3).getComputedStyle(e3, null).getPropertyValue(t2);
    }
    function $d(r2) {
      return function() {
        delete this[r2];
      };
    }
    function _d(r2, t2) {
      return function() {
        this[r2] = t2;
      };
    }
    function ae(r2, t2) {
      return function() {
        var n2 = t2.apply(this, arguments);
        n2 == null ? delete this[r2] : this[r2] = n2;
      };
    }
    var be = function(r2, t2) {
      return arguments.length > 1 ? this.each((t2 == null ? $d : typeof t2 == "function" ? ae : _d)(r2, t2)) : this.node()[r2];
    };
    function Fb(s3) {
      return s3.trim().split(/^|\s+/);
    }
    function Ia(s3) {
      return s3.classList || new Gb(s3);
    }
    function Gb(s3) {
      this._node = s3, this._names = Fb(s3.getAttribute("class") || "");
    }
    function Hb(s3, t2) {
      for (var a3 = Ia(s3), $2 = -1, e3 = t2.length; ++$2 < e3; )
        a3.add(t2[$2]);
    }
    function Ib(s3, t2) {
      for (var a3 = Ia(s3), $2 = -1, e3 = t2.length; ++$2 < e3; )
        a3.remove(t2[$2]);
    }
    function ce(s3) {
      return function() {
        Hb(this, s3);
      };
    }
    function de(s3) {
      return function() {
        Ib(this, s3);
      };
    }
    function ee2(s3, t2) {
      return function() {
        (t2.apply(this, arguments) ? Hb : Ib)(this, s3);
      };
    }
    Gb.prototype = {add: function(s3) {
      this._names.indexOf(s3) < 0 && (this._names.push(s3), this._node.setAttribute("class", this._names.join(" ")));
    }, remove: function(s3) {
      var t2 = this._names.indexOf(s3);
      t2 >= 0 && (this._names.splice(t2, 1), this._node.setAttribute("class", this._names.join(" ")));
    }, contains: function(s3) {
      return this._names.indexOf(s3) >= 0;
    }};
    var fe = function(s3, t2) {
      var a3 = Fb(s3 + "");
      if (arguments.length < 2) {
        for (var $2 = Ia(this.node()), e3 = -1, n2 = a3.length; ++e3 < n2; )
          if (!$2.contains(a3[e3]))
            return false;
        return true;
      }
      return this.each((typeof t2 == "function" ? ee2 : t2 ? ce : de)(a3, t2));
    };
    function ge() {
      this.textContent = "";
    }
    function he(t2) {
      return function() {
        this.textContent = t2;
      };
    }
    function ie(t2) {
      return function() {
        var n2 = t2.apply(this, arguments);
        this.textContent = n2 == null ? "" : n2;
      };
    }
    var je = function(t2) {
      return arguments.length ? this.each(t2 == null ? ge : (typeof t2 == "function" ? ie : he)(t2)) : this.node().textContent;
    };
    function ke() {
      this.innerHTML = "";
    }
    function le(n2) {
      return function() {
        this.innerHTML = n2;
      };
    }
    function me(n2) {
      return function() {
        var t2 = n2.apply(this, arguments);
        this.innerHTML = t2 == null ? "" : t2;
      };
    }
    var ne = function(n2) {
      return arguments.length ? this.each(n2 == null ? ke : (typeof n2 == "function" ? me : le)(n2)) : this.node().innerHTML;
    };
    function oe() {
      this.nextSibling && this.parentNode.appendChild(this);
    }
    var pe = function() {
      return this.each(oe);
    };
    function qe() {
      this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    var re = function() {
      return this.each(qe);
    };
    function se(e3) {
      return function() {
        var r2 = this.ownerDocument, t2 = this.namespaceURI;
        return t2 === Ha && r2.documentElement.namespaceURI === Ha ? r2.createElement(e3) : r2.createElementNS(t2, e3);
      };
    }
    function te(e3) {
      return function() {
        return this.ownerDocument.createElementNS(e3.space, e3.local);
      };
    }
    var Jb = function(e3) {
      var r2 = Db(e3);
      return (r2.local ? te : se)(r2);
    };
    var ue = function(t2) {
      var r2 = typeof t2 == "function" ? t2 : Jb(t2);
      return this.select(function() {
        return this.appendChild(r2.apply(this, arguments));
      });
    };
    function ve() {
      return null;
    }
    var we = function(t2, r2) {
      var e3 = typeof t2 == "function" ? t2 : Jb(t2), $2 = r2 == null ? ve : typeof r2 == "function" ? r2 : zb(r2);
      return this.select(function() {
        return this.insertBefore(e3.apply(this, arguments), $2.apply(this, arguments) || null);
      });
    };
    function xe() {
      var e3 = this.parentNode;
      e3 && e3.removeChild(this);
    }
    var ye = function() {
      return this.each(xe);
    };
    function ze() {
      return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
    }
    function Ae() {
      return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
    }
    var Be = function(e3) {
      return this.select(e3 ? Ae : ze);
    };
    var Ce = function(t2) {
      return arguments.length ? this.property("__data__", t2) : this.node().__data__;
    };
    var De = {}, Kb = null;
    if (typeof document != "undefined") {
      var Ee = document.documentElement;
      "onmouseenter" in Ee || (De = {mouseenter: "mouseover", mouseleave: "mouseout"});
    }
    function Fe(e3, t2, n2) {
      return e3 = Lb(e3, t2, n2), function(t3) {
        var n3 = t3.relatedTarget;
        n3 && (n3 === this || 8 & n3.compareDocumentPosition(this)) || e3.call(this, t3);
      };
    }
    function Lb(e3, t2, n2) {
      return function(r2) {
        var $2 = Kb;
        Kb = r2;
        try {
          e3.call(this, this.__data__, t2, n2);
        } finally {
          Kb = $2;
        }
      };
    }
    function Ge(e3) {
      return e3.trim().split(/^|\s+/).map(function(e4) {
        var t2 = "", n2 = e4.indexOf(".");
        return n2 >= 0 && (t2 = e4.slice(n2 + 1), e4 = e4.slice(0, n2)), {type: e4, name: t2};
      });
    }
    function He(e3) {
      return function() {
        var t2 = this.__on;
        if (t2) {
          for (var n2, r2 = 0, $2 = -1, i2 = t2.length; r2 < i2; ++r2)
            n2 = t2[r2], e3.type && n2.type !== e3.type || n2.name !== e3.name ? t2[++$2] = n2 : this.removeEventListener(n2.type, n2.listener, n2.capture);
          ++$2 ? t2.length = $2 : delete this.__on;
        }
      };
    }
    function Ie(e3, t2, n2) {
      var r2 = De.hasOwnProperty(e3.type) ? Fe : Lb;
      return function($2, i2, p2) {
        var o3, a3 = this.__on, v2 = r2(t2, i2, p2);
        if (a3) {
          for (var s3 = 0, u2 = a3.length; s3 < u2; ++s3)
            if ((o3 = a3[s3]).type === e3.type && o3.name === e3.name)
              return this.removeEventListener(o3.type, o3.listener, o3.capture), this.addEventListener(o3.type, o3.listener = v2, o3.capture = n2), void (o3.value = t2);
        }
        this.addEventListener(e3.type, v2, n2), o3 = {type: e3.type, name: e3.name, value: t2, listener: v2, capture: n2}, a3 ? a3.push(o3) : this.__on = [o3];
      };
    }
    var Je = function(e3, t2, n2) {
      var r2, $2, i2 = Ge(e3 + ""), p2 = i2.length;
      if (!(arguments.length < 2)) {
        for (o3 = t2 ? Ie : He, n2 == null && (n2 = false), r2 = 0; r2 < p2; ++r2)
          this.each(o3(i2[r2], t2, n2));
        return this;
      }
      var o3 = this.node().__on;
      if (o3) {
        for (var a3, v2 = 0, s3 = o3.length; v2 < s3; ++v2)
          for (r2 = 0, a3 = o3[v2]; r2 < p2; ++r2)
            if (($2 = i2[r2]).type === a3.type && $2.name === a3.name)
              return a3.value;
      }
    };
    function Mb(t2, n2, e3) {
      var $2 = Eb(t2), a3 = $2.CustomEvent;
      typeof a3 == "function" ? a3 = new a3(n2, e3) : (a3 = $2.document.createEvent("Event"), e3 ? (a3.initEvent(n2, e3.bubbles, e3.cancelable), a3.detail = e3.detail) : a3.initEvent(n2, false, false)), t2.dispatchEvent(a3);
    }
    function Ke(t2, n2) {
      return function() {
        return Mb(this, t2, n2);
      };
    }
    function Le(t2, n2) {
      return function() {
        return Mb(this, t2, n2.apply(this, arguments));
      };
    }
    var Me = function(t2, n2) {
      return this.each((typeof n2 == "function" ? Le : Ke)(t2, n2));
    };
    var Ne = [null];
    function m2(e3, $2) {
      this._groups = e3, this._parents = $2;
    }
    m2.prototype = {constructor: m2, select: rd, selectAll: ud, filter: wd, data: Bd, enter: xd, exit: Cd, join: Dd, merge: Ed, order: Fd, sort: Gd, call: Id, nodes: Jd, node: Kd, size: Ld, empty: Md, each: Nd, attr: Ud, style: Yd, property: be, classed: fe, text: je, html: ne, raise: pe, lower: re, append: ue, insert: we, remove: ye, clone: Be, datum: Ce, on: Je, dispatch: Me};
    var f = function(e3) {
      return typeof e3 == "string" ? new m2([[document.querySelector(e3)]], [document.documentElement]) : new m2([[e3]], Ne);
    };
    var Oe = function() {
      for (var e3, r2 = Kb; e3 = r2.sourceEvent; )
        r2 = e3;
      return r2;
    };
    var Pe = function(e3, t2) {
      var n2 = e3.ownerSVGElement || e3;
      if (n2.createSVGPoint) {
        var r2 = n2.createSVGPoint();
        return r2.x = t2.clientX, r2.y = t2.clientY, [(r2 = r2.matrixTransform(e3.getScreenCTM().inverse())).x, r2.y];
      }
      var i2 = e3.getBoundingClientRect();
      return [t2.clientX - i2.left - e3.clientLeft, t2.clientY - i2.top - e3.clientTop];
    };
    var w3 = function(e3) {
      var $2 = Oe();
      return $2.changedTouches && ($2 = $2.changedTouches[0]), Pe(e3, $2);
    };
    function ja() {
      var n2, r2, t2 = Sb().unknown(void 0), e3 = t2.domain, i2 = t2.range, u2 = 0, a3 = 1, o3 = false, $2 = 0, l2 = 0, g2 = 0.5;
      function d3() {
        var t3 = e3().length, d4 = a3 < u2, p2 = d4 ? a3 : u2, c2 = d4 ? u2 : a3;
        n2 = (c2 - p2) / Math.max(1, t3 - $2 + 2 * l2), o3 && (n2 = Math.floor(n2)), p2 += (c2 - p2 - n2 * (t3 - $2)) * g2, r2 = n2 * (1 - $2), o3 && (p2 = Math.round(p2), r2 = Math.round(r2));
        var f2 = Te(t3).map(function(r3) {
          return p2 + n2 * r3;
        });
        return i2(d4 ? f2.reverse() : f2);
      }
      return delete t2.unknown, t2.domain = function(n3) {
        return arguments.length ? (e3(n3), d3()) : e3();
      }, t2.range = function(n3) {
        return arguments.length ? ([u2, a3] = n3, u2 = +u2, a3 = +a3, d3()) : [u2, a3];
      }, t2.rangeRound = function(n3) {
        return [u2, a3] = n3, u2 = +u2, a3 = +a3, o3 = true, d3();
      }, t2.bandwidth = function() {
        return r2;
      }, t2.step = function() {
        return n2;
      }, t2.round = function(n3) {
        return arguments.length ? (o3 = !!n3, d3()) : o3;
      }, t2.padding = function(n3) {
        return arguments.length ? ($2 = Math.min(1, l2 = +n3), d3()) : $2;
      }, t2.paddingInner = function(n3) {
        return arguments.length ? ($2 = Math.min(1, n3), d3()) : $2;
      }, t2.paddingOuter = function(n3) {
        return arguments.length ? (l2 = +n3, d3()) : l2;
      }, t2.align = function(n3) {
        return arguments.length ? (g2 = Math.max(0, Math.min(1, n3)), d3()) : g2;
      }, t2.copy = function() {
        return ja(e3(), [u2, a3]).round(o3).paddingInner($2).paddingOuter(l2).align(g2);
      }, la.apply(d3(), arguments);
    }
    function Nb(n2) {
      var r2 = n2.copy;
      return n2.padding = n2.paddingOuter, delete n2.paddingInner, delete n2.paddingOuter, n2.copy = function() {
        return Nb(r2());
      }, n2;
    }
    function Qe() {
      return Nb(ja.apply(null, arguments).paddingInner(1));
    }
    var Ob = function($2, t2) {
      return $2 < t2 ? -1 : $2 > t2 ? 1 : $2 >= t2 ? 0 : NaN;
    };
    var Pb = function(r2) {
      return r2.length === 1 && (r2 = Re(r2)), {left: function(n2, t2, e3, $2) {
        for (e3 == null && (e3 = 0), $2 == null && ($2 = n2.length); e3 < $2; ) {
          var a3 = e3 + $2 >>> 1;
          r2(n2[a3], t2) < 0 ? e3 = a3 + 1 : $2 = a3;
        }
        return e3;
      }, right: function(n2, t2, e3, $2) {
        for (e3 == null && (e3 = 0), $2 == null && ($2 = n2.length); e3 < $2; ) {
          var a3 = e3 + $2 >>> 1;
          r2(n2[a3], t2) > 0 ? $2 = a3 : e3 = a3 + 1;
        }
        return e3;
      }};
    };
    function Re(r2) {
      return function(n2, t2) {
        return Ob(r2(n2), t2);
      };
    }
    var Qb = Pb(Ob), Se = Qb.right;
    var ci = Qb.left;
    var Te = function(t2, e3, r2) {
      t2 = +t2, e3 = +e3, r2 = (a3 = arguments.length) < 2 ? (e3 = t2, t2 = 0, 1) : a3 < 3 ? 1 : +r2;
      for (var $2 = -1, a3 = 0 | Math.max(0, Math.ceil((e3 - t2) / r2)), c2 = new Array(a3); ++$2 < a3; )
        c2[$2] = t2 + $2 * r2;
      return c2;
    };
    var Ja = Math.sqrt(50), Ka = Math.sqrt(10), La = Math.sqrt(2), Ue = function($2, t2, r2) {
      var e3, a3, o3, g2, z3 = -1;
      if (r2 = +r2, ($2 = +$2) === (t2 = +t2) && r2 > 0)
        return [$2];
      if ((e3 = t2 < $2) && (a3 = $2, $2 = t2, t2 = a3), (g2 = ka($2, t2, r2)) === 0 || !isFinite(g2))
        return [];
      if (g2 > 0)
        for ($2 = Math.ceil($2 / g2), t2 = Math.floor(t2 / g2), o3 = new Array(a3 = Math.ceil(t2 - $2 + 1)); ++z3 < a3; )
          o3[z3] = ($2 + z3) * g2;
      else
        for ($2 = Math.floor($2 * g2), t2 = Math.ceil(t2 * g2), o3 = new Array(a3 = Math.ceil($2 - t2 + 1)); ++z3 < a3; )
          o3[z3] = ($2 - z3) / g2;
      return e3 && o3.reverse(), o3;
    };
    function ka($2, t2, r2) {
      var e3 = (t2 - $2) / Math.max(0, r2), a3 = Math.floor(Math.log(e3) / Math.LN10), o3 = e3 / Math.pow(10, a3);
      return a3 >= 0 ? (o3 >= Ja ? 10 : o3 >= Ka ? 5 : o3 >= La ? 2 : 1) * Math.pow(10, a3) : -Math.pow(10, -a3) / (o3 >= Ja ? 10 : o3 >= Ka ? 5 : o3 >= La ? 2 : 1);
    }
    function Ma($2, t2, r2) {
      var e3 = Math.abs(t2 - $2) / Math.max(0, r2), a3 = Math.pow(10, Math.floor(Math.log(e3) / Math.LN10)), o3 = e3 / a3;
      return o3 >= Ja ? a3 *= 10 : o3 >= Ka ? a3 *= 5 : o3 >= La && (a3 *= 2), t2 < $2 ? -a3 : a3;
    }
    function la(t2, e3) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(t2);
          break;
        default:
          this.range(e3).domain(t2);
      }
      return this;
    }
    const Rb = Symbol("implicit");
    function Sb() {
      var t2 = new Map(), n2 = [], e3 = [], r2 = Rb;
      function i2(i3) {
        var $2 = i3 + "", o3 = t2.get($2);
        if (!o3) {
          if (r2 !== Rb)
            return r2;
          t2.set($2, o3 = n2.push(i3));
        }
        return e3[(o3 - 1) % e3.length];
      }
      return i2.domain = function(e4) {
        if (!arguments.length)
          return n2.slice();
        n2 = [], t2 = new Map();
        for (const r3 of e4) {
          const e5 = r3 + "";
          t2.has(e5) || t2.set(e5, n2.push(r3));
        }
        return i2;
      }, i2.range = function(t3) {
        return arguments.length ? (e3 = Array.from(t3), i2) : e3.slice();
      }, i2.unknown = function(t3) {
        return arguments.length ? (r2 = t3, i2) : r2;
      }, i2.copy = function() {
        return Sb(n2, e3).unknown(r2);
      }, la.apply(i2, arguments), i2;
    }
    function Ve(t2) {
      var r2 = t2.domain;
      return t2.ticks = function(t3) {
        var $2 = r2();
        return Ue($2[0], $2[$2.length - 1], t3 == null ? 10 : t3);
      }, t2.tickFormat = function(t3, $2) {
        var e3 = r2();
        return Of(e3[0], e3[e3.length - 1], t3 == null ? 10 : t3, $2);
      }, t2.nice = function($2) {
        $2 == null && ($2 = 10);
        var e3, i2 = r2(), n2 = 0, o3 = i2.length - 1, a3 = i2[n2], k2 = i2[o3];
        return k2 < a3 && (e3 = a3, a3 = k2, k2 = e3, e3 = n2, n2 = o3, o3 = e3), (e3 = ka(a3, k2, $2)) > 0 ? (a3 = Math.floor(a3 / e3) * e3, k2 = Math.ceil(k2 / e3) * e3, e3 = ka(a3, k2, $2)) : e3 < 0 && (a3 = Math.ceil(a3 * e3) / e3, k2 = Math.floor(k2 * e3) / e3, e3 = ka(a3, k2, $2)), e3 > 0 ? (i2[n2] = Math.floor(a3 / e3) * e3, i2[o3] = Math.ceil(k2 / e3) * e3, r2(i2)) : e3 < 0 && (i2[n2] = Math.ceil(a3 * e3) / e3, i2[o3] = Math.floor(k2 * e3) / e3, r2(i2)), t2;
      }, t2;
    }
    function A2() {
      var t2 = Bc(z2, z2);
      return t2.copy = function() {
        return Ac(t2, A2());
      }, la.apply(t2, arguments), Ve(t2);
    }
    function x() {
    }
    var G2 = function(t2, e3, r2) {
      t2.prototype = e3.prototype = r2, r2.constructor = t2;
    };
    function P(t2, e3) {
      var r2 = Object.create(t2.prototype);
      for (var o3 in e3)
        r2[o3] = e3[o3];
      return r2;
    }
    var t = 0.7;
    var H2 = 1 / t;
    var I = "\\s*([+-]?\\d+)\\s*", R = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", e2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", We = /^#([0-9a-f]{3})$/, Xe = /^#([0-9a-f]{6})$/, Ye = new RegExp("^rgb\\(" + [I, I, I] + "\\)$"), Ze = new RegExp("^rgb\\(" + [e2, e2, e2] + "\\)$"), $e = new RegExp("^rgba\\(" + [I, I, I, R] + "\\)$"), _e = new RegExp("^rgba\\(" + [e2, e2, e2, R] + "\\)$"), af = new RegExp("^hsl\\(" + [R, e2, e2] + "\\)$"), bf = new RegExp("^hsla\\(" + [R, e2, e2, R] + "\\)$"), Tb = {aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074};
    function Ub() {
      return this.rgb().formatHex();
    }
    function cf() {
      return _b(this).formatHsl();
    }
    function Vb() {
      return this.rgb().formatRgb();
    }
    function S(r2) {
      var a3;
      return r2 = (r2 + "").trim().toLowerCase(), (a3 = We.exec(r2)) ? new g((a3 = parseInt(a3[1], 16)) >> 8 & 15 | a3 >> 4 & 240, a3 >> 4 & 15 | 240 & a3, (15 & a3) << 4 | 15 & a3, 1) : (a3 = Xe.exec(r2)) ? Wb(parseInt(a3[1], 16)) : (a3 = Ye.exec(r2)) ? new g(a3[1], a3[2], a3[3], 1) : (a3 = Ze.exec(r2)) ? new g(255 * a3[1] / 100, 255 * a3[2] / 100, 255 * a3[3] / 100, 1) : (a3 = $e.exec(r2)) ? Xb(a3[1], a3[2], a3[3], a3[4]) : (a3 = _e.exec(r2)) ? Xb(255 * a3[1] / 100, 255 * a3[2] / 100, 255 * a3[3] / 100, a3[4]) : (a3 = af.exec(r2)) ? $b(a3[1], a3[2] / 100, a3[3] / 100, 1) : (a3 = bf.exec(r2)) ? $b(a3[1], a3[2] / 100, a3[3] / 100, a3[4]) : Tb.hasOwnProperty(r2) ? Wb(Tb[r2]) : r2 === "transparent" ? new g(NaN, NaN, NaN, 0) : null;
    }
    function Wb(r2) {
      return new g(r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, 1);
    }
    function Xb(r2, a3, e3, $2) {
      return $2 <= 0 && (r2 = a3 = e3 = NaN), new g(r2, a3, e3, $2);
    }
    function Na(r2) {
      return r2 instanceof x || (r2 = S(r2)), r2 ? new g((r2 = r2.rgb()).r, r2.g, r2.b, r2.opacity) : new g();
    }
    function ma(r2, a3, e3, $2) {
      return arguments.length === 1 ? Na(r2) : new g(r2, a3, e3, $2 == null ? 1 : $2);
    }
    function g(r2, a3, e3, $2) {
      this.r = +r2, this.g = +a3, this.b = +e3, this.opacity = +$2;
    }
    function Yb() {
      return "#" + Oa(this.r) + Oa(this.g) + Oa(this.b);
    }
    function Zb() {
      var r2 = this.opacity;
      return ((r2 = isNaN(r2) ? 1 : Math.max(0, Math.min(1, r2))) === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (r2 === 1 ? ")" : ", " + r2 + ")");
    }
    function Oa(r2) {
      return ((r2 = Math.max(0, Math.min(255, Math.round(r2) || 0))) < 16 ? "0" : "") + r2.toString(16);
    }
    function $b(r2, a3, e3, $2) {
      return $2 <= 0 ? r2 = a3 = e3 = NaN : e3 <= 0 || e3 >= 1 ? r2 = a3 = NaN : a3 <= 0 && (r2 = NaN), new s2(r2, a3, e3, $2);
    }
    function _b(r2) {
      if (r2 instanceof s2)
        return new s2(r2.h, r2.s, r2.l, r2.opacity);
      if (r2 instanceof x || (r2 = S(r2)), !r2)
        return new s2();
      if (r2 instanceof s2)
        return r2;
      var a3 = (r2 = r2.rgb()).r / 255, e3 = r2.g / 255, $2 = r2.b / 255, t2 = Math.min(a3, e3, $2), o3 = Math.max(a3, e3, $2), n2 = NaN, i2 = o3 - t2, f2 = (o3 + t2) / 2;
      return i2 ? (n2 = a3 === o3 ? (e3 - $2) / i2 + 6 * (e3 < $2) : e3 === o3 ? ($2 - a3) / i2 + 2 : (a3 - e3) / i2 + 4, i2 /= f2 < 0.5 ? o3 + t2 : 2 - o3 - t2, n2 *= 60) : i2 = f2 > 0 && f2 < 1 ? 0 : n2, new s2(n2, i2, f2, r2.opacity);
    }
    function Pa(r2, a3, e3, $2) {
      return arguments.length === 1 ? _b(r2) : new s2(r2, a3, e3, $2 == null ? 1 : $2);
    }
    function s2(r2, a3, e3, $2) {
      this.h = +r2, this.s = +a3, this.l = +e3, this.opacity = +$2;
    }
    function Qa(r2, a3, e3) {
      return 255 * (r2 < 60 ? a3 + (e3 - a3) * r2 / 60 : r2 < 180 ? e3 : r2 < 240 ? a3 + (e3 - a3) * (240 - r2) / 60 : a3);
    }
    G2(x, S, {copy: function(r2) {
      return Object.assign(new this.constructor(), this, r2);
    }, displayable: function() {
      return this.rgb().displayable();
    }, hex: Ub, formatHex: Ub, formatHsl: cf, formatRgb: Vb, toString: Vb}), G2(g, ma, P(x, {brighter: function(r2) {
      return r2 = r2 == null ? H2 : Math.pow(H2, r2), new g(this.r * r2, this.g * r2, this.b * r2, this.opacity);
    }, darker: function(r2) {
      return r2 = r2 == null ? t : Math.pow(t, r2), new g(this.r * r2, this.g * r2, this.b * r2, this.opacity);
    }, rgb: function() {
      return this;
    }, displayable: function() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    }, hex: Yb, formatHex: Yb, formatRgb: Zb, toString: Zb})), G2(s2, Pa, P(x, {brighter: function(r2) {
      return r2 = r2 == null ? H2 : Math.pow(H2, r2), new s2(this.h, this.s, this.l * r2, this.opacity);
    }, darker: function(r2) {
      return r2 = r2 == null ? t : Math.pow(t, r2), new s2(this.h, this.s, this.l * r2, this.opacity);
    }, rgb: function() {
      var r2 = this.h % 360 + 360 * (this.h < 0), a3 = isNaN(r2) || isNaN(this.s) ? 0 : this.s, e3 = this.l, $2 = e3 + (e3 < 0.5 ? e3 : 1 - e3) * a3, t2 = 2 * e3 - $2;
      return new g(Qa(r2 >= 240 ? r2 - 240 : r2 + 120, t2, $2), Qa(r2, t2, $2), Qa(r2 < 120 ? r2 + 240 : r2 - 120, t2, $2), this.opacity);
    }, displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    }, formatHsl: function() {
      var r2 = this.opacity;
      return ((r2 = isNaN(r2) ? 1 : Math.max(0, Math.min(1, r2))) === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + 100 * (this.s || 0) + "%, " + 100 * (this.l || 0) + "%" + (r2 === 1 ? ")" : ", " + r2 + ")");
    }}));
    var ac = Math.PI / 180;
    var bc = 180 / Math.PI;
    var na = 18, cc = 0.96422, dc = 1, ec = 0.82521, fc = 4 / 29, J = 6 / 29, gc = 3 * J * J, df = J * J * J;
    function hc($2) {
      if ($2 instanceof i)
        return new i($2.l, $2.a, $2.b, $2.opacity);
      if ($2 instanceof n)
        return ic($2);
      $2 instanceof g || ($2 = Na($2));
      var r2, t2, v2 = Ua($2.r), a3 = Ua($2.g), f2 = Ua($2.b), e3 = Ra((0.2225045 * v2 + 0.7168786 * a3 + 0.0606169 * f2) / dc);
      return v2 === a3 && a3 === f2 ? r2 = t2 = e3 : (r2 = Ra((0.4360747 * v2 + 0.3850649 * a3 + 0.1430804 * f2) / cc), t2 = Ra((0.0139322 * v2 + 0.0971045 * a3 + 0.7141733 * f2) / ec)), new i(116 * e3 - 16, 500 * (r2 - e3), 200 * (e3 - t2), $2.opacity);
    }
    function ef($2, r2, t2, v2) {
      return arguments.length === 1 ? hc($2) : new i($2, r2, t2, v2 == null ? 1 : v2);
    }
    function i($2, r2, t2, v2) {
      this.l = +$2, this.a = +r2, this.b = +t2, this.opacity = +v2;
    }
    function Ra($2) {
      return $2 > df ? Math.pow($2, 1 / 3) : $2 / gc + fc;
    }
    function Sa($2) {
      return $2 > J ? $2 * $2 * $2 : gc * ($2 - fc);
    }
    function Ta($2) {
      return 255 * ($2 <= 31308e-7 ? 12.92 * $2 : 1.055 * Math.pow($2, 1 / 2.4) - 0.055);
    }
    function Ua($2) {
      return ($2 /= 255) <= 0.04045 ? $2 / 12.92 : Math.pow(($2 + 0.055) / 1.055, 2.4);
    }
    function ff($2) {
      if ($2 instanceof n)
        return new n($2.h, $2.c, $2.l, $2.opacity);
      if ($2 instanceof i || ($2 = hc($2)), $2.a === 0 && $2.b === 0)
        return new n(NaN, 0 < $2.l && $2.l < 100 ? 0 : NaN, $2.l, $2.opacity);
      var r2 = Math.atan2($2.b, $2.a) * bc;
      return new n(r2 < 0 ? r2 + 360 : r2, Math.sqrt($2.a * $2.a + $2.b * $2.b), $2.l, $2.opacity);
    }
    function Va($2, r2, t2, v2) {
      return arguments.length === 1 ? ff($2) : new n($2, r2, t2, v2 == null ? 1 : v2);
    }
    function n($2, r2, t2, v2) {
      this.h = +$2, this.c = +r2, this.l = +t2, this.opacity = +v2;
    }
    function ic($2) {
      if (isNaN($2.h))
        return new i($2.l, 0, 0, $2.opacity);
      var r2 = $2.h * ac;
      return new i($2.l, Math.cos(r2) * $2.c, Math.sin(r2) * $2.c, $2.opacity);
    }
    G2(i, ef, P(x, {brighter: function($2) {
      return new i(this.l + na * ($2 == null ? 1 : $2), this.a, this.b, this.opacity);
    }, darker: function($2) {
      return new i(this.l - na * ($2 == null ? 1 : $2), this.a, this.b, this.opacity);
    }, rgb: function() {
      var $2 = (this.l + 16) / 116, r2 = isNaN(this.a) ? $2 : $2 + this.a / 500, t2 = isNaN(this.b) ? $2 : $2 - this.b / 200;
      return r2 = cc * Sa(r2), $2 = dc * Sa($2), t2 = ec * Sa(t2), new g(Ta(3.1338561 * r2 - 1.6168667 * $2 - 0.4906146 * t2), Ta(-0.9787684 * r2 + 1.9161415 * $2 + 0.033454 * t2), Ta(0.0719453 * r2 - 0.2289914 * $2 + 1.4052427 * t2), this.opacity);
    }})), G2(n, Va, P(x, {brighter: function($2) {
      return new n(this.h, this.c, this.l + na * ($2 == null ? 1 : $2), this.opacity);
    }, darker: function($2) {
      return new n(this.h, this.c, this.l - na * ($2 == null ? 1 : $2), this.opacity);
    }, rgb: function() {
      return ic(this).rgb();
    }}));
    var jc = -0.14861, Wa = 1.78277, Xa = -0.29227, oa = -0.90649, T = 1.97294, kc = T * oa, lc = T * Wa, mc = Wa * Xa - oa * jc;
    function gf($2) {
      if ($2 instanceof B)
        return new B($2.h, $2.s, $2.l, $2.opacity);
      $2 instanceof g || ($2 = Na($2));
      var r2 = $2.r / 255, t2 = $2.g / 255, e3 = $2.b / 255, C2 = (mc * e3 + kc * r2 - lc * t2) / (mc + kc - lc), a3 = e3 - C2, M3 = (T * (t2 - C2) - Xa * a3) / oa, i2 = Math.sqrt(M3 * M3 + a3 * a3) / (T * C2 * (1 - C2)), X2 = i2 ? Math.atan2(M3, a3) * bc - 120 : NaN;
      return new B(X2 < 0 ? X2 + 360 : X2, i2, C2, $2.opacity);
    }
    function Ya($2, r2, t2, e3) {
      return arguments.length === 1 ? gf($2) : new B($2, r2, t2, e3 == null ? 1 : e3);
    }
    function B($2, r2, t2, e3) {
      this.h = +$2, this.s = +r2, this.l = +t2, this.opacity = +e3;
    }
    G2(B, Ya, P(x, {brighter: function($2) {
      return $2 = $2 == null ? H2 : Math.pow(H2, $2), new B(this.h, this.s, this.l * $2, this.opacity);
    }, darker: function($2) {
      return $2 = $2 == null ? t : Math.pow(t, $2), new B(this.h, this.s, this.l * $2, this.opacity);
    }, rgb: function() {
      var $2 = isNaN(this.h) ? 0 : (this.h + 120) * ac, r2 = +this.l, t2 = isNaN(this.s) ? 0 : this.s * r2 * (1 - r2), e3 = Math.cos($2), C2 = Math.sin($2);
      return new g(255 * (r2 + t2 * (jc * e3 + Wa * C2)), 255 * (r2 + t2 * (Xa * e3 + oa * C2)), 255 * (r2 + t2 * (T * e3)), this.opacity);
    }}));
    function nc($2, r2, t2, e3, a3) {
      var l2 = $2 * $2, o3 = l2 * $2;
      return ((1 - 3 * $2 + 3 * l2 - o3) * r2 + (4 - 6 * l2 + 3 * o3) * t2 + (1 + 3 * $2 + 3 * l2 - 3 * o3) * e3 + o3 * a3) / 6;
    }
    var hf = function($2) {
      var r2 = $2.length - 1;
      return function(t2) {
        var e3 = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, r2 - 1) : Math.floor(t2 * r2), a3 = $2[e3], l2 = $2[e3 + 1], o3 = e3 > 0 ? $2[e3 - 1] : 2 * a3 - l2, s3 = e3 < r2 - 1 ? $2[e3 + 2] : 2 * l2 - a3;
        return nc((t2 - e3 / r2) * r2, o3, a3, l2, s3);
      };
    };
    var jf = function(r2) {
      var $2 = r2.length;
      return function(t2) {
        var e3 = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * $2), n2 = r2[(e3 + $2 - 1) % $2], a3 = r2[e3 % $2], o3 = r2[(e3 + 1) % $2], h3 = r2[(e3 + 2) % $2];
        return nc((t2 - e3 / $2) * $2, n2, a3, o3, h3);
      };
    };
    function oc($2, t2) {
      return function(r2) {
        return $2 + r2 * t2;
      };
    }
    function kf($2, t2, r2) {
      return $2 = Math.pow($2, r2), t2 = Math.pow(t2, r2) - $2, r2 = 1 / r2, function(n2) {
        return Math.pow($2 + n2 * t2, r2);
      };
    }
    function Za($2, t2) {
      var r2 = t2 - $2;
      return r2 ? oc($2, r2 > 180 || r2 < -180 ? r2 - 360 * Math.round(r2 / 360) : r2) : pa(isNaN($2) ? t2 : $2);
    }
    function lf($2) {
      return ($2 = +$2) == 1 ? j : function(t2, r2) {
        return r2 - t2 ? kf(t2, r2, $2) : pa(isNaN(t2) ? r2 : t2);
      };
    }
    function j($2, t2) {
      var r2 = t2 - $2;
      return r2 ? oc($2, r2) : pa(isNaN($2) ? t2 : $2);
    }
    var pa = function(t2) {
      return function() {
        return t2;
      };
    };
    var pc = function r2($2) {
      var o3 = lf($2);
      function e3(r3, $3) {
        var e4 = o3((r3 = ma(r3)).r, ($3 = ma($3)).r), a3 = o3(r3.g, $3.g), t2 = o3(r3.b, $3.b), i2 = j(r3.opacity, $3.opacity);
        return function($4) {
          return r3.r = e4($4), r3.g = a3($4), r3.b = t2($4), r3.opacity = i2($4), r3 + "";
        };
      }
      return e3.gamma = r2, e3;
    }(1);
    function qc(r2) {
      return function($2) {
        var o3, e3, a3 = $2.length, t2 = new Array(a3), i2 = new Array(a3), v2 = new Array(a3);
        for (o3 = 0; o3 < a3; ++o3)
          e3 = ma($2[o3]), t2[o3] = e3.r || 0, i2[o3] = e3.g || 0, v2[o3] = e3.b || 0;
        return t2 = r2(t2), i2 = r2(i2), v2 = r2(v2), e3.opacity = 1, function(r3) {
          return e3.r = t2(r3), e3.g = i2(r3), e3.b = v2(r3), e3 + "";
        };
      };
    }
    var di = qc(hf);
    var ei = qc(jf);
    var mf = function(r2, e3) {
      var t2, $2 = e3 ? e3.length : 0, a3 = r2 ? Math.min($2, r2.length) : 0, n2 = new Array(a3), o3 = new Array($2);
      for (t2 = 0; t2 < a3; ++t2)
        n2[t2] = ab(r2[t2], e3[t2]);
      for (; t2 < $2; ++t2)
        o3[t2] = e3[t2];
      return function(r3) {
        for (t2 = 0; t2 < a3; ++t2)
          o3[t2] = n2[t2](r3);
        return o3;
      };
    };
    var nf = function(e3, t2) {
      var r2 = new Date();
      return t2 -= e3 = +e3, function($2) {
        return r2.setTime(e3 + t2 * $2), r2;
      };
    };
    var v = function(t2, $2) {
      return $2 -= t2 = +t2, function(e3) {
        return t2 + $2 * e3;
      };
    };
    var of = function(e3, r2) {
      var t2, $2 = {}, i2 = {};
      for (t2 in e3 !== null && typeof e3 == "object" || (e3 = {}), r2 !== null && typeof r2 == "object" || (r2 = {}), r2)
        t2 in e3 ? $2[t2] = ab(e3[t2], r2[t2]) : i2[t2] = r2[t2];
      return function(e4) {
        for (t2 in $2)
          i2[t2] = $2[t2](e4);
        return i2;
      };
    };
    var $a = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, _a = new RegExp($a.source, "g");
    function pf(r2) {
      return function() {
        return r2;
      };
    }
    function qf(r2) {
      return function($2) {
        return r2($2) + "";
      };
    }
    var rf = function(r2, $2) {
      var n2, e3, t2, a3 = $a.lastIndex = _a.lastIndex = 0, u2 = -1, E3 = [], o3 = [];
      for (r2 += "", $2 += ""; (n2 = $a.exec(r2)) && (e3 = _a.exec($2)); )
        (t2 = e3.index) > a3 && (t2 = $2.slice(a3, t2), E3[u2] ? E3[u2] += t2 : E3[++u2] = t2), (n2 = n2[0]) === (e3 = e3[0]) ? E3[u2] ? E3[u2] += e3 : E3[++u2] = e3 : (E3[++u2] = null, o3.push({i: u2, x: v(n2, e3)})), a3 = _a.lastIndex;
      return a3 < $2.length && (t2 = $2.slice(a3), E3[u2] ? E3[u2] += t2 : E3[++u2] = t2), E3.length < 2 ? o3[0] ? qf(o3[0].x) : pf($2) : ($2 = o3.length, function(r3) {
        for (var n3, e4 = 0; e4 < $2; ++e4)
          E3[(n3 = o3[e4]).i] = n3.x(r3);
        return E3.join("");
      });
    };
    var ab = function(r2, $2) {
      var e3, c2 = typeof $2;
      return $2 == null || c2 === "boolean" ? pa($2) : (c2 === "number" ? v : c2 === "string" ? (e3 = S($2)) ? ($2 = e3, pc) : rf : $2 instanceof S ? pc : $2 instanceof Date ? nf : Array.isArray($2) ? mf : typeof $2.valueOf != "function" && typeof $2.toString != "function" || isNaN($2) ? of : v)(r2, $2);
    };
    var sf = function(t2, n2) {
      return n2 -= t2 = +t2, function(r2) {
        return Math.round(t2 + n2 * r2);
      };
    };
    function rc(r2, e3, t2, l2) {
      function n2(r3) {
        return r3.length ? r3.pop() + " " : "";
      }
      return function(a3, $2) {
        var s3 = [], o3 = [];
        return a3 = r2(a3), $2 = r2($2), function(r3, l3, n3, a4, $3, s4) {
          if (r3 !== n3 || l3 !== a4) {
            var o4 = $3.push("translate(", null, e3, null, t2);
            s4.push({i: o4 - 4, x: v(r3, n3)}, {i: o4 - 2, x: v(l3, a4)});
          } else
            (n3 || a4) && $3.push("translate(" + n3 + e3 + a4 + t2);
        }(a3.translateX, a3.translateY, $2.translateX, $2.translateY, s3, o3), function(r3, e4, t3, a4) {
          r3 !== e4 ? (r3 - e4 > 180 ? e4 += 360 : e4 - r3 > 180 && (r3 += 360), a4.push({i: t3.push(n2(t3) + "rotate(", null, l2) - 2, x: v(r3, e4)})) : e4 && t3.push(n2(t3) + "rotate(" + e4 + l2);
        }(a3.rotate, $2.rotate, s3, o3), function(r3, e4, t3, a4) {
          r3 !== e4 ? a4.push({i: t3.push(n2(t3) + "skewX(", null, l2) - 2, x: v(r3, e4)}) : e4 && t3.push(n2(t3) + "skewX(" + e4 + l2);
        }(a3.skewX, $2.skewX, s3, o3), function(r3, e4, t3, l3, a4, $3) {
          if (r3 !== t3 || e4 !== l3) {
            var s4 = a4.push(n2(a4) + "scale(", null, ",", null, ")");
            $3.push({i: s4 - 4, x: v(r3, t3)}, {i: s4 - 2, x: v(e4, l3)});
          } else
            t3 === 1 && l3 === 1 || a4.push(n2(a4) + "scale(" + t3 + "," + l3 + ")");
        }(a3.scaleX, a3.scaleY, $2.scaleX, $2.scaleY, s3, o3), a3 = $2 = null, function(r3) {
          for (var e4, t3 = -1, l3 = o3.length; ++t3 < l3; )
            s3[(e4 = o3[t3]).i] = e4.x(r3);
          return s3.join("");
        };
      };
    }
    var qa, sc, tf, bb;
    function uf($2) {
      return $2 === "none" ? cb : (qa || (qa = document.createElement("DIV"), sc = document.documentElement, tf = document.defaultView), qa.style.transform = $2, $2 = tf.getComputedStyle(sc.appendChild(qa), null).getPropertyValue("transform"), sc.removeChild(qa), $2 = $2.slice(7, -1).split(","), uc(+$2[0], +$2[1], +$2[2], +$2[3], +$2[4], +$2[5]));
    }
    function vf($2) {
      return $2 == null ? cb : (bb || (bb = document.createElementNS("http://www.w3.org/2000/svg", "g")), bb.setAttribute("transform", $2), ($2 = bb.transform.baseVal.consolidate()) ? ($2 = $2.matrix, uc($2.a, $2.b, $2.c, $2.d, $2.e, $2.f)) : cb);
    }
    var tc = 180 / Math.PI, cb = {translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1};
    var uc = function(t2, e3, a3, $2, r2, s3) {
      var X2, n2, w4;
      return (X2 = Math.sqrt(t2 * t2 + e3 * e3)) && (t2 /= X2, e3 /= X2), (w4 = t2 * a3 + e3 * $2) && (a3 -= t2 * w4, $2 -= e3 * w4), (n2 = Math.sqrt(a3 * a3 + $2 * $2)) && (a3 /= n2, $2 /= n2, w4 /= n2), t2 * $2 < e3 * a3 && (t2 = -t2, e3 = -e3, w4 = -w4, X2 = -X2), {translateX: r2, translateY: s3, rotate: Math.atan2(e3, t2) * tc, skewX: Math.atan(w4) * tc, scaleX: X2, scaleY: n2};
    };
    var fi = rc(uf, "px, ", "px)", "deg)");
    var gi = rc(vf, ", ", ")", ")");
    var hi = Math.SQRT2;
    function vc($2) {
      return function(r2, e3) {
        var o3 = $2((r2 = Pa(r2)).h, (e3 = Pa(e3)).h), t2 = j(r2.s, e3.s), l2 = j(r2.l, e3.l), d3 = j(r2.opacity, e3.opacity);
        return function($3) {
          return r2.h = o3($3), r2.s = t2($3), r2.l = l2($3), r2.opacity = d3($3), r2 + "";
        };
      };
    }
    var ii = vc(Za);
    var ji = vc(j);
    function wc($2) {
      return function(r2, o3) {
        var c2 = $2((r2 = Va(r2)).h, (o3 = Va(o3)).h), t2 = j(r2.c, o3.c), x2 = j(r2.l, o3.l), l2 = j(r2.opacity, o3.opacity);
        return function($3) {
          return r2.h = c2($3), r2.c = t2($3), r2.l = x2($3), r2.opacity = l2($3), r2 + "";
        };
      };
    }
    var ki = wc(Za);
    var li = wc(j);
    function xc($2) {
      return function r2(o3) {
        function V2(r3, V3) {
          var e3 = $2((r3 = Ya(r3)).h, (V3 = Ya(V3)).h), t2 = j(r3.s, V3.s), i2 = j(r3.l, V3.l), l2 = j(r3.opacity, V3.opacity);
          return function($3) {
            return r3.h = e3($3), r3.s = t2($3), r3.l = i2(Math.pow($3, o3)), r3.opacity = l2($3), r3 + "";
          };
        }
        return o3 = +o3, V2.gamma = r2, V2;
      }(1);
    }
    var mi = xc(Za);
    var ni = xc(j);
    var wf = function(t2) {
      return function() {
        return t2;
      };
    };
    var xf = function($2) {
      return +$2;
    };
    var yc = [0, 1];
    function z2(r2) {
      return r2;
    }
    function db(r2, n2) {
      return (n2 -= r2 = +r2) ? function(t2) {
        return (t2 - r2) / n2;
      } : wf(isNaN(n2) ? NaN : 0.5);
    }
    function zc(r2) {
      var n2, t2 = r2[0], e3 = r2[r2.length - 1];
      return t2 > e3 && (n2 = t2, t2 = e3, e3 = n2), function(r3) {
        return Math.max(t2, Math.min(e3, r3));
      };
    }
    function yf(r2, n2, t2) {
      var e3 = r2[0], $2 = r2[1], a3 = n2[0], o3 = n2[1];
      return $2 < e3 ? (e3 = db($2, e3), a3 = t2(o3, a3)) : (e3 = db(e3, $2), a3 = t2(a3, o3)), function(r3) {
        return a3(e3(r3));
      };
    }
    function zf(r2, n2, t2) {
      var e3 = Math.min(r2.length, n2.length) - 1, $2 = new Array(e3), a3 = new Array(e3), o3 = -1;
      for (r2[e3] < r2[0] && (r2 = r2.slice().reverse(), n2 = n2.slice().reverse()); ++o3 < e3; )
        $2[o3] = db(r2[o3], r2[o3 + 1]), a3[o3] = t2(n2[o3], n2[o3 + 1]);
      return function(n3) {
        var t3 = Se(r2, n3, 1, e3) - 1;
        return a3[t3]($2[t3](n3));
      };
    }
    function Ac(r2, n2) {
      return n2.domain(r2.domain()).range(r2.range()).interpolate(r2.interpolate()).clamp(r2.clamp()).unknown(r2.unknown());
    }
    function Af() {
      var r2, n2, t2, e3, $2, a3, o3 = yc, i2 = yc, u2 = ab, p2 = z2;
      function l2() {
        return e3 = Math.min(o3.length, i2.length) > 2 ? zf : yf, $2 = a3 = null, c2;
      }
      function c2(n3) {
        return isNaN(n3 = +n3) ? t2 : ($2 || ($2 = e3(o3.map(r2), i2, u2)))(r2(p2(n3)));
      }
      return c2.invert = function(t3) {
        return p2(n2((a3 || (a3 = e3(i2, o3.map(r2), v)))(t3)));
      }, c2.domain = function(r3) {
        return arguments.length ? (o3 = Array.from(r3, xf), p2 === z2 || (p2 = zc(o3)), l2()) : o3.slice();
      }, c2.range = function(r3) {
        return arguments.length ? (i2 = Array.from(r3), l2()) : i2.slice();
      }, c2.rangeRound = function(r3) {
        return i2 = Array.from(r3), u2 = sf, l2();
      }, c2.clamp = function(r3) {
        return arguments.length ? (p2 = r3 ? zc(o3) : z2, c2) : p2 !== z2;
      }, c2.interpolate = function(r3) {
        return arguments.length ? (u2 = r3, l2()) : u2;
      }, c2.unknown = function(r3) {
        return arguments.length ? (t2 = r3, c2) : t2;
      }, function(t3, e4) {
        return r2 = t3, n2 = e4, l2();
      };
    }
    function Bc(r2, n2) {
      return Af()(r2, n2);
    }
    var eb, Bf, Cf;
    function Df($2) {
      return eb = Kf($2), Bf = eb.format, Cf = eb.formatPrefix, eb;
    }
    var ra = function(e3, t2) {
      if ((l2 = (e3 = t2 ? e3.toExponential(t2 - 1) : e3.toExponential()).indexOf("e")) < 0)
        return null;
      var l2, n2 = e3.slice(0, l2);
      return [n2.length > 1 ? n2[0] + n2.slice(2) : n2, +e3.slice(l2 + 1)];
    };
    var K = function(t2) {
      return (t2 = ra(Math.abs(t2))) ? t2[1] : NaN;
    };
    var Ef = function(r2, t2) {
      return function(e3, n2) {
        for (var $2 = e3.length, u2 = [], o3 = 0, a3 = r2[0], f2 = 0; $2 > 0 && a3 > 0 && (f2 + a3 + 1 > n2 && (a3 = Math.max(1, n2 - f2)), u2.push(e3.substring($2 -= a3, $2 + a3)), !((f2 += a3 + 1) > n2)); )
          a3 = r2[o3 = (o3 + 1) % r2.length];
        return u2.reverse().join(t2);
      };
    };
    var Ff = function(t2) {
      return function(e3) {
        return e3.replace(/[0-9]/g, function(e4) {
          return t2[+e4];
        });
      };
    };
    var Gf = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function sa(i2) {
      return new fb(i2);
    }
    function fb(i2) {
      if (!(t2 = Gf.exec(i2)))
        throw new Error("invalid format: " + i2);
      var t2;
      this.fill = t2[1] || " ", this.align = t2[2] || ">", this.sign = t2[3] || "-", this.symbol = t2[4] || "", this.zero = !!t2[5], this.width = t2[6] && +t2[6], this.comma = !!t2[7], this.precision = t2[8] && +t2[8].slice(1), this.trim = !!t2[9], this.type = t2[10] || "";
    }
    sa.prototype = fb.prototype, fb.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
    };
    var Hf = function(e3) {
      e:
        for (var r2, t2 = e3.length, a3 = 1, $2 = -1; a3 < t2; ++a3)
          switch (e3[a3]) {
            case ".":
              $2 = r2 = a3;
              break;
            case "0":
              $2 === 0 && ($2 = a3), r2 = a3;
              break;
            default:
              if ($2 > 0) {
                if (!+e3[a3])
                  break e;
                $2 = 0;
              }
          }
      return $2 > 0 ? e3.slice(0, $2) + e3.slice(r2 + 1) : e3;
    };
    var If;
    var Jf = function(e3, p2) {
      var r2, a3 = ra(e3, p2);
      if (!a3)
        return e3 + "";
      var $2 = a3[0], t2 = a3[1], f2 = t2 - (r2 = If = 3 * Math.max(-8, Math.min(8, Math.floor(t2 / 3))), r2) + 1, o3 = $2.length;
      return f2 === o3 ? $2 : f2 > o3 ? $2 + new Array(f2 - o3 + 1).join("0") : f2 > 0 ? $2.slice(0, f2) + "." + $2.slice(f2) : "0." + new Array(1 - f2).join("0") + ra(e3, Math.max(0, p2 + f2 - 1))[0];
    };
    var Cc = function(r2, e3) {
      var t2 = ra(r2, e3);
      if (!t2)
        return r2 + "";
      var $2 = t2[0], a3 = t2[1];
      return a3 < 0 ? "0." + new Array(-a3).join("0") + $2 : $2.length > a3 + 1 ? $2.slice(0, a3 + 1) + "." + $2.slice(a3 + 1) : $2 + new Array(a3 - $2.length + 2).join("0");
    };
    var Dc = {"%": function(t2, r2) {
      return (100 * t2).toFixed(r2);
    }, b: function(t2) {
      return Math.round(t2).toString(2);
    }, c: function(t2) {
      return t2 + "";
    }, d: function(t2) {
      return Math.round(t2).toString(10);
    }, e: function(t2, r2) {
      return t2.toExponential(r2);
    }, f: function(t2, r2) {
      return t2.toFixed(r2);
    }, g: function(t2, r2) {
      return t2.toPrecision(r2);
    }, o: function(t2) {
      return Math.round(t2).toString(8);
    }, p: function(t2, r2) {
      return Cc(100 * t2, r2);
    }, r: Cc, s: Jf, X: function(t2) {
      return Math.round(t2).toString(16).toUpperCase();
    }, x: function(t2) {
      return Math.round(t2).toString(16);
    }};
    var Ec = function(t2) {
      return t2;
    };
    var Fc = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"], Kf = function(r2) {
      var e3 = r2.grouping && r2.thousands ? Ef(r2.grouping, r2.thousands) : Ec, t2 = r2.currency, a3 = r2.decimal, m3 = r2.numerals ? Ff(r2.numerals) : Ec, $2 = r2.percent || "%";
      function i2(r3) {
        var i3 = (r3 = sa(r3)).fill, o3 = r3.align, n2 = r3.sign, p2 = r3.symbol, f2 = r3.zero, l2 = r3.width, s3 = r3.comma, u2 = r3.precision, M3 = r3.trim, c2 = r3.type;
        c2 === "n" ? (s3 = true, c2 = "g") : Dc[c2] || (u2 == null && (u2 = 12), M3 = true, c2 = "g"), (f2 || i3 === "0" && o3 === "=") && (f2 = true, i3 = "0", o3 = "=");
        var I2 = p2 === "$" ? t2[0] : p2 === "#" && /[boxX]/.test(c2) ? "0" + c2.toLowerCase() : "", V2 = p2 === "$" ? t2[1] : /[%p]/.test(c2) ? $2 : "", h3 = Dc[c2], g2 = /[defgprs%]/.test(c2);
        function x2(r4) {
          var t3, $3, p3, x3 = I2, d3 = V2;
          if (c2 === "c")
            d3 = h3(r4) + d3, r4 = "";
          else {
            var v2 = (r4 = +r4) < 0;
            if (r4 = h3(Math.abs(r4), u2), M3 && (r4 = Hf(r4)), v2 && +r4 == 0 && (v2 = false), x3 = (v2 ? n2 === "(" ? n2 : "-" : n2 === "-" || n2 === "(" ? "" : n2) + x3, d3 = (c2 === "s" ? Fc[8 + If / 3] : "") + d3 + (v2 && n2 === "(" ? ")" : ""), g2) {
              for (t3 = -1, $3 = r4.length; ++t3 < $3; )
                if (48 > (p3 = r4.charCodeAt(t3)) || p3 > 57) {
                  d3 = (p3 === 46 ? a3 + r4.slice(t3 + 1) : r4.slice(t3)) + d3, r4 = r4.slice(0, t3);
                  break;
                }
            }
          }
          s3 && !f2 && (r4 = e3(r4, 1 / 0));
          var y3 = x3.length + r4.length + d3.length, q2 = y3 < l2 ? new Array(l2 - y3 + 1).join(i3) : "";
          switch (s3 && f2 && (r4 = e3(q2 + r4, q2.length ? l2 - d3.length : 1 / 0), q2 = ""), o3) {
            case "<":
              r4 = x3 + r4 + d3 + q2;
              break;
            case "=":
              r4 = x3 + q2 + r4 + d3;
              break;
            case "^":
              r4 = q2.slice(0, y3 = q2.length >> 1) + x3 + r4 + d3 + q2.slice(y3);
              break;
            default:
              r4 = q2 + x3 + r4 + d3;
          }
          return m3(r4);
        }
        return u2 = u2 == null ? 6 : /[gprs]/.test(c2) ? Math.max(1, Math.min(21, u2)) : Math.max(0, Math.min(20, u2)), x2.toString = function() {
          return r3 + "";
        }, x2;
      }
      return {format: i2, formatPrefix: function(r3, e4) {
        var t3 = i2(((r3 = sa(r3)).type = "f", r3)), a4 = 3 * Math.max(-8, Math.min(8, Math.floor(K(e4) / 3))), m4 = Math.pow(10, -a4), $3 = Fc[8 + a4 / 3];
        return function(r4) {
          return t3(m4 * r4) + $3;
        };
      }};
    };
    Df({decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""]});
    var Lf = function(e3) {
      return Math.max(0, -K(Math.abs(e3)));
    };
    var Mf = function(t2, $2) {
      return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(K($2) / 3))) - K(Math.abs(t2)));
    };
    var Nf = function($2, e3) {
      return $2 = Math.abs($2), e3 = Math.abs(e3) - $2, Math.max(0, K(e3) - K($2)) + 1;
    };
    var Of = function(a3, r2, e3, i2) {
      var $2, t2 = Ma(a3, r2, e3);
      switch ((i2 = sa(i2 == null ? ",f" : i2)).type) {
        case "s":
          var p2 = Math.max(Math.abs(a3), Math.abs(r2));
          return i2.precision != null || isNaN($2 = Mf(t2, p2)) || (i2.precision = $2), Cf(i2, p2);
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
          i2.precision != null || isNaN($2 = Nf(t2, Math.max(Math.abs(a3), Math.abs(r2)))) || (i2.precision = $2 - (i2.type === "e"));
          break;
        case "f":
        case "%":
          i2.precision != null || isNaN($2 = Lf(t2)) || (i2.precision = $2 - 2 * (i2.type === "%"));
      }
      return Bf(i2);
    };
    var gb = Array.prototype.slice;
    var Pf = function(x2) {
      return x2;
    };
    var hb = 1, ib = 2, jb = 3, Y = 4, Gc = 1e-6;
    function Qf(t2) {
      return "translate(" + (t2 + 0.5) + ",0)";
    }
    function Rf(t2) {
      return "translate(0," + (t2 + 0.5) + ")";
    }
    function Sf(t2) {
      return function(r2) {
        return +t2(r2);
      };
    }
    function Tf(t2) {
      var r2 = Math.max(0, t2.bandwidth() - 1) / 2;
      return t2.round() && (r2 = Math.round(r2)), function($2) {
        return +t2($2) + r2;
      };
    }
    function Uf() {
      return !this.__axis;
    }
    function Hc(t2, r2) {
      var $2 = [], n2 = null, e3 = null, a3 = 6, i2 = 6, c2 = 3, o3 = t2 === hb || t2 === Y ? -1 : 1, l2 = t2 === Y || t2 === ib ? "x" : "y", s3 = t2 === hb || t2 === jb ? Qf : Rf;
      function u2(u3) {
        var M3 = n2 == null ? r2.ticks ? r2.ticks.apply(r2, $2) : r2.domain() : n2, F2 = e3 == null ? r2.tickFormat ? r2.tickFormat.apply(r2, $2) : Pf : e3, f2 = Math.max(a3, 0) + c2, p2 = r2.range(), v2 = +p2[0] + 0.5, x2 = +p2[p2.length - 1] + 0.5, m3 = (r2.bandwidth ? Tf : Sf)(r2.copy()), h3 = u3.selection ? u3.selection() : u3, g2 = h3.selectAll(".domain").data([null]), d3 = h3.selectAll(".tick").data(M3, r2).order(), k2 = d3.exit(), y3 = d3.enter().append("g").attr("class", "tick"), b2 = d3.select("line"), _2 = d3.select("text");
        g2 = g2.merge(g2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), d3 = d3.merge(y3), b2 = b2.merge(y3.append("line").attr("stroke", "currentColor").attr(l2 + "2", o3 * a3)), _2 = _2.merge(y3.append("text").attr("fill", "currentColor").attr(l2, o3 * f2).attr("dy", t2 === hb ? "0em" : t2 === jb ? "0.71em" : "0.32em")), u3 !== h3 && (g2 = g2.transition(u3), d3 = d3.transition(u3), b2 = b2.transition(u3), _2 = _2.transition(u3), k2 = k2.transition(u3).attr("opacity", Gc).attr("transform", function(t3) {
          return isFinite(t3 = m3(t3)) ? s3(t3) : this.getAttribute("transform");
        }), y3.attr("opacity", Gc).attr("transform", function(t3) {
          var r3 = this.parentNode.__axis;
          return s3(r3 && isFinite(r3 = r3(t3)) ? r3 : m3(t3));
        })), k2.remove(), g2.attr("d", t2 === Y || t2 == ib ? i2 ? "M" + o3 * i2 + "," + v2 + "H0.5V" + x2 + "H" + o3 * i2 : "M0.5," + v2 + "V" + x2 : i2 ? "M" + v2 + "," + o3 * i2 + "V0.5H" + x2 + "V" + o3 * i2 : "M" + v2 + ",0.5H" + x2), d3.attr("opacity", 1).attr("transform", function(t3) {
          return s3(m3(t3));
        }), b2.attr(l2 + "2", o3 * a3), _2.attr(l2, o3 * f2).text(F2), h3.filter(Uf).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t2 === ib ? "start" : t2 === Y ? "end" : "middle"), h3.each(function() {
          this.__axis = m3;
        });
      }
      return u2.scale = function(t3) {
        return arguments.length ? (r2 = t3, u2) : r2;
      }, u2.ticks = function() {
        return $2 = gb.call(arguments), u2;
      }, u2.tickArguments = function(t3) {
        return arguments.length ? ($2 = t3 == null ? [] : gb.call(t3), u2) : $2.slice();
      }, u2.tickValues = function(t3) {
        return arguments.length ? (n2 = t3 == null ? null : gb.call(t3), u2) : n2 && n2.slice();
      }, u2.tickFormat = function(t3) {
        return arguments.length ? (e3 = t3, u2) : e3;
      }, u2.tickSize = function(t3) {
        return arguments.length ? (a3 = i2 = +t3, u2) : a3;
      }, u2.tickSizeInner = function(t3) {
        return arguments.length ? (a3 = +t3, u2) : a3;
      }, u2.tickSizeOuter = function(t3) {
        return arguments.length ? (i2 = +t3, u2) : i2;
      }, u2.tickPadding = function(t3) {
        return arguments.length ? (c2 = +t3, u2) : c2;
      }, u2;
    }
    function Vf(t2) {
      return Hc(jb, t2);
    }
    function Wf(t2) {
      return Hc(Y, t2);
    }
    const Xf = (t2, {yScale: l2, tickCount: e3, fontFamily: i2, unxkcdify: s3, stroke: a3}) => {
      t2.append("g").call(Wf(l2).tickSize(1).tickPadding(10).ticks(e3, "s")), t2.selectAll(".domain").attr("filter", s3 ? null : "url(#xkcdify)").style("stroke", a3), t2.selectAll(".tick > text").style("font-family", i2).style("font-size", "16").style("fill", a3);
    }, Yf = (t2, {xScale: l2, tickCount: e3, moveDown: i2, fontFamily: s3, unxkcdify: a3, stroke: $2}) => {
      t2.append("g").attr("transform", `translate(0,${i2})`).call(Vf(l2).tickSize(0).tickPadding(6).ticks(e3)), t2.selectAll(".domain").attr("filter", a3 ? null : "url(#xkcdify)").style("stroke", $2), t2.selectAll(".tick > text").style("font-family", s3).style("font-size", "16").style("fill", $2);
    };
    var y2 = {xAxis: Yf, yAxis: Xf};
    const Zf = (t2, e3, a3) => {
      t2.append("text").style("font-size", "20").style("font-weight", "bold").style("fill", a3).attr("x", "50%").attr("y", 30).attr("text-anchor", "middle").text(e3);
    }, $f = (t2, e3, a3) => {
      t2.append("text").style("font-size", 17).style("fill", a3).attr("x", "50%").attr("y", t2.attr("height") - 10).attr("text-anchor", "middle").text(e3);
    }, _f = (t2, e3, a3) => {
      t2.append("text").attr("text-anchor", "end").attr("dy", ".75em").attr("transform", "rotate(-90)").style("font-size", 17).style("fill", a3).text(e3).attr("y", 6).call((e4) => {
        const a4 = e4.node().getComputedTextLength();
        e4.attr("x", 0 - t2.attr("height") / 2 + a4 / 2);
      });
    };
    var k = {title: Zf, xLabel: $f, yLabel: _f};
    const b = {positionType: {upLeft: 1, upRight: 2, downLeft: 3, downRight: 4}};
    class L {
      constructor({parent: t2, title: i2, items: e3, position: s3, unxkcdify: r2, backgroundColor: o3, strokeColor: h3}) {
        this.title = i2, this.items = e3, this.position = s3, this.filter = r2 ? null : "url(#xkcdify)", this.backgroundColor = o3, this.strokeColor = h3, this.svg = t2.append("svg").attr("x", this._getUpLeftX()).attr("y", this._getUpLeftY()).style("visibility", "hidden"), this.tipBackground = this.svg.append("rect").style("fill", this.backgroundColor).attr("fill-opacity", 0.9).attr("stroke", h3).attr("stroke-width", 2).attr("rx", 5).attr("ry", 5).attr("filter", this.filter).attr("width", this._getBackgroundWidth()).attr("height", this._getBackgroundHeight()).attr("x", 5).attr("y", 5), this.tipTitle = this.svg.append("text").style("font-size", 15).style("font-weight", "bold").style("fill", this.strokeColor).attr("x", 15).attr("y", 25).text(i2), this.tipItems = e3.map((t3, i3) => {
          return this._generateTipItem(t3, i3);
        });
      }
      show() {
        this.svg.style("visibility", "visible");
      }
      hide() {
        this.svg.style("visibility", "hidden");
      }
      update({title: t2, items: i2, position: e3}) {
        if (t2 && t2 !== this.title && (this.title = t2, this.tipTitle.text(t2)), i2 && JSON.stringify(i2) !== JSON.stringify(this.items)) {
          this.items = i2, this.tipItems.forEach((t4) => t4.svg.remove()), this.tipItems = this.items.map((t4, i3) => {
            return this._generateTipItem(t4, i3);
          });
          const t3 = Math.max(...this.tipItems.map((t4) => t4.width), this.tipTitle.node().getBBox().width);
          this.tipBackground.attr("width", t3 + 15).attr("height", this._getBackgroundHeight());
        }
        e3 && (this.position = e3, this.svg.attr("x", this._getUpLeftX()), this.svg.attr("y", this._getUpLeftY()));
      }
      _generateTipItem(t2, i2) {
        const e3 = this.svg.append("svg");
        e3.append("rect").style("fill", t2.color).attr("width", 8).attr("height", 8).attr("rx", 2).attr("ry", 2).attr("filter", this.filter).attr("x", 15).attr("y", 37 + 20 * i2), e3.append("text").style("font-size", "15").style("fill", this.strokeColor).attr("x", 27).attr("y", 37 + 20 * i2 + 8).text(t2.text);
        const s3 = e3.node().getBBox();
        return {svg: e3, width: s3.width + 15, height: s3.height + 10};
      }
      _getBackgroundWidth() {
        const t2 = this.items.reduce((t3, i2) => t3 > i2.text.length ? t3 : i2.text.length, 0);
        return 7.4 * Math.max(t2, this.title.length) + 25;
      }
      _getBackgroundHeight() {
        return 20 * (this.items.length + 1) + 10;
      }
      _getUpLeftX() {
        return this.position.type === b.positionType.upRight || this.position.type === b.positionType.downRight ? this.position.x : this.position.x - this._getBackgroundWidth() - 20;
      }
      _getUpLeftY() {
        return this.position.type === b.positionType.downLeft || this.position.type === b.positionType.downRight ? this.position.y : this.position.y - this._getBackgroundHeight() - 20;
      }
    }
    function M2(A3) {
      A3.append("defs").append("style").attr("type", "text/css").text(`@font-face {
      font-family: "xkcd";
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAJx4AAsAAAAAxwwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAFGAAAlcwAAL0RC0F+QkZGVE0AAJsAAAAAGgAAABw+UK5QR0RFRgAAmuQAAAAcAAAAHgAnAJFPUy8yAAABZAAAAFUAAABgWJzhv2NtYXAAAAM4AAABywAAAyqDxHFiaGVhZAAAAQgAAAAxAAAANsz4KqBoaGVhAAABPAAAAB4AAAAkCEQESmhtdHgAAJscAAABXAAAAiwGQwpzbWF4cAAAAVwAAAAGAAAABgCLUABuYW1lAAABvAAAAXkAAALBbi7owXBvc3QAAAUEAAAAEwAAACD/gwAzeJxjYGRgYADiynnODfH8Nl8ZuJkjgCIMWyZ9YYDTwv++sSxgDgVyORiYQKIAPLQLYwAAAHicY2BkYGAO/feNwZflBAMQsCxgYGRABd0AbW8ElwAAAABQAACLAAB4nGNgZlzLOIGBlYGBSYcpnIGBoRxCM85i0GK4y8DAzMDKzAAGDQwM7UwMDA4MUBCQ5poCpBT+/2eK+M/A4MscysgF5DOC5BjXMgUwKAAhIwBQMwyLAAAAeJyNkE1OAkEQhV8D/hs3GuOyVwYTBjSewMzCDWEhCfuhaaADTJOexsjaA3gTt17B6Dm8gCfwTdMo0Y1MQn1Vr6rrB8ARniGw+g3wFlngQNxGrmBHqMhVxh8j13AsXiJv4VB8RN7GfmWXmaK2R+81VJUscCpakSs4Et3IVcYnkWs4F0+Rt3Am3iNv40R8IoXFHEs4GIwwhodEHQoXtCYonlGLHC08YEJlgATDEClzVaSyvo8FyZILNKilJI2MMYN7kgzdZvzKmoL+DbXNWhOUBJ1g19maGYpahilrrtHEJW2bEUWtfEkDqZ0vnRmNvayrC2nmSz+2eethogbJ0OZeKv45019464qGTJ3OvLnXMrWzmc0LeeNXqrF50rF5GdZOmWwqr5uXsm2Uzgt2WZ9Aokvrwok8w2wju8qZOZ07jjPiOlMO7Ojq0WKauf/V/px4Myf5/WZYa1WTfL/fC4cq4hElruKh0NOu4F7yipv8tPgzRJzhC2aqiNgAAAB4nI3RW08TQRgG4HdpOYggUBHb0uo4nNSWgwfkoBVBhXLSgoooAuVQjED4CSCnBLjzksQ7Em4Jl/4AErjlGjbwGyThBjK8u7MEDWCc5Nmv8+10951ZAMkAXBQmNx3A4BVJhewadt+FdLvvxqY9F/yVgX5MYhXr2MAWtrGDQ8NjxFwrwieCIiL9MiSjMi4Tckwp/ktg4MLVXhH4Y/WwHFVK7as99UutqZ9qWf1QC2pCdav8o10r1V7YTJhdZq1ZYIrdY530wpGLvHO9JSxiHCPMzmFUOF2vnQ7cD+znDdAk1dOqw7q37ojThsNau+UYpG3HEO04hunQkeArPBpGWWMaxvgJVjR8ZxyvxsQQPo3ZIQIadwER1LgfiIiGb4D0a5hiDWmYZo1qmGGNa5hlZT7JXJhjZSbJLPgK4/eMDVhgxhT846j1MJJc7uSU1LQr6VczMq9lZed4rufeyLvp9fnzA8Fbt8UdWVBYVFxy9979ULi0rLziwcNHjyufVFXX1D59Fnle9wL1DS9fvW5sija3tLa1v3kb6+h89/5D18fuT597vvT2WWc9qA/zP8as9Z3m5vVk+rQ7Ze39bIyPLC0mLn/G0N/TE5rzdrgAeJxjYGYAg/8NDMYMWAAAKBQBtgB4nDx8CYBkVXlutWPDiZpRp+2X5CUCmmhMosY9xriAiIKgICr70MzSM9PTe3d111516+5nvXvtW+/brDDADLuggKKRTYEBFWNekpdoFvN81b7OS95/irxUTfdUd1Xduvec//+W//yn+2Kvf32sr6/vjcnRAwe/emBmZCoe63tdrC924/YnY9uf6tv+9Ou2P7Nr+7dff9FPX7f8H2/addFXFv/jTa+/6A2xtx55539Q+l8P3nRha6f9e69f+PXf9789Fnvdm98M32Oxt8D3XX/wVvn4A/DtAXVP7F3y4Cj25th/i7099sex98U+EPt87KrYNbFrY1+L3Ri7JbY3dkfsQOxQbCQ2FpuMzcTmYtlYMYZjYawRW4mdjj0Q+2bsO7Hv9X2w73N9185NjHzoQx+77LX/Piv/+8CHP3fF+L4DM5MT1x6Zmzi8b2ZufGzfXPzA0OTk0ORVQ0dSU0eGJ4amhmaGJocm4GtuaOKKocsuH7r28qHrrx26fOjKK4au+NrQ164Z+uwVQ9dfP3T9NUOXXTN0zbVDX7586LLrhr76taFrZ/YdHDmwb+yrI4fH941MxIcPz+wb2zc1NTOZHJ6e2zc2MRnv/T82PDvbe3B4ZnhffHim93j/vpmh//xZPj8EP8998PMf/viHPvj+D1w+OZWaGTl8JH7Jew780SUjU6n4kcmJP5Xz8r5DkxPxSw7At5mR/XPxyZnZ915yuTzKyPzwJZdPjo9PTsxecln8tWdHJife9+XJCfnr4ZkDI/vGLvnw+z9wyTUjB4YnZod7R3ttmt93/fDhubF9M/JXl/znzMOtL/a62K7Y62P9sQtiF8aOxH4j9obYG2Nviv1mbDdM2ltib43tiQ3E3hYbhAn8rdhvx34n9t9jvxv7PZjMi2IXxy6JvSP2ztjvx/4g9q7Yu2N/GHtP7I9gkv8k9l6Y6PfH/hQm+4OxD8U+HPtI7KOxj8X+LPbx2J/HPhH7i9gnY5+KfTr2mdilsc/GLo99LnYFBMUXYldCYHwxdjUEx5diX4YAuS72ldj1sa9CoHw9dgMEy02xmyFgbo3dBkFze2wo1oEQORm7M/ZQ7LFYO5bos/rsPtxH+mhspI/18T7R5/S5fV6f3xf0hX1RX6mv3Ffpq/bV+up9jb5mX6uv3dfpW+hb7FvqW+5b6VvtW4NQvSxGZczuggF5vG9uF7vg9y984Tdu+I0H3jD+xve9qf2b2m/+y+4bdp9587m3Drz14MAlb8ODZ37ra789+zvp/779e+/+vb98+3MX8Yv1Sz71Dvb7Y3+gv/vGP5x4z11//LY/6Xtv+X1b73vy/c//6f/6QP1Df/Lhz3/kwEdbf/auj9/75//3E+f+4gef/NdPK59xLt132eHPTlyufc684tor7v78v1z5m1f+3y/uuvqt17z9S9/88qPXWl/54vWzX33v1/Z//aYbbr5x+eY33Hz3LU/d+tJt5/YWb39m6Bf7bt3/y4PewROH3nnonw5/f+TS0bePKeM/nvzc1JHp52Y/Hl+ff3fipdR9mWtzuwpvV/Lahw1qX0VfEDX3j/xM9JXK9bVP11eb/95542Jn+aaVq9dm1s9vXr4VP0aOt068cGrPvcP3Pn72c3O7d27YvdO494UvvDKg/GD7lcHDCraCo1zlo0JDA5cKg16Ld/rxR1je01x9PR+ygAUudSgXnLPI4w5tI3oneYG9jAYU+g/MyJ012qavOcgQNk0ZaP3ftEFCMSecCIvpVKWYZgrJnGUWk1oGz3lJL+mrLkWMurZje5YgFVqGT3AdweEfFTQKo3JQqpftBsJVXFZD07UFHJOml22Kdu9c13nlM+cHYt2P/vq6wSnVs42EmYd35rhCbP2r2tVkwteQZ/R7etledhpCiNBHzQtpzTnrf4P53GeMcxJxJvjc44aHdF+jcxraebMyaNu2QSwYCZy1U3QerpEcwioewjfzYkNxbU7roiUCEpRcn3J2D7ySLbNjrMmXaYQjq+OHuYrpYjpP5yilhoF2v/Kv35195Znn93S//sS1T9XPD8S3/6D7rkGPNlmDbcGweiXHJ8etQK/a7AhN0zlShLtGKEWElV9ljIq/1NdqZS+o6FXsYpdy6pohpvAKGGOEA41N4zzJEoMi5QJe5WV3vfJT6owHKO1qZn9O1UeNuD5BSvowMkZncX+eFIhNihZlrIIGjjGfdXjTucdOkNPkJK5aMDGYpagiJ49YRFOogaiNFaxYCWvUStk5+yZsEWxilejEJHAqcDxMkUkz1pyhwYjZ1KKqlS0WNEUj8mZQgxQZCRQU5j275JVcx647NfFQ4FCP5v8U3qNyetictHx7zkQpy7A11dApYQrPCj0yGoW7wkWGKqwfF2gBT+Mjdsoy4cgmNalGia87lmPCqWBh+yaCa4CwiqgHk82YjN6AOx6P3A4P4YnQ/ykNEHXu9xx4nlK4TJvOkmmyl2DHCLOhXiIR8XDgIc9teMLnHg0xt4XzcwcO6TCI4DINnApFO+h7gxQftXSSsTFhgnHqQ5QtwMUtI7G4zPqrrMI5hDglMFxW/hPUQruD1kt7um+9b//qo984fPbo3Q+/PPBo96rtfxy0DDNBkiSDTZsadFY1LMu2SW+ICYO7BU8gxRCWBrfkKFaIaSTglRhmgNiY3+BkRD7MBiqCk7XlcLTzApKqVXTgpJiN5+A+YSWwwlK2iuTsFUtKWQ+LLUhGH3PL1apwrr7J00baNBnJIDtuB9GYm3PyHHMMaW2H8ROHF7OoorIj/WyWKhyjgUVGuAFzkWesjEPCqOOige+EFVHjW6i1eOFS2UtdTDXHdlRXCUxeYDpgAGngYtsrccEC0iSLFDAAcbgxCPPQWa94InQ9txJtHKcuZfCs45eqZ0QHiRZ5DDesZWUp1VajVEV1UoArMzgJIcEc7oktUkIkatr9j2iClxb9OmPYt0OjlzqYyskcCgoUDTyuUMJZXZwkTsbJCQyAYmsYwhbbLGvCS3UGqVWkZKWfdogvh4kwjSGNwaCb6NzORwdp3MjSOLVtbNhINflaP1tzynQBRcGFPfgkApt5WkSf2z9o30JNC9LDcqzQdokPONBmImj6db8kADSs/SSLupe+d9AxhSXnnRVZgR+yx7UZM01wNqsoqq4BSPkFg5b7yZPsfghhh30TBsgPnRavcccu5dDOhTvvG6QzdJ5hbtg4yVCK9Yum2PSe8Z4guOS4gObyxpJw6nFykM6g3b/afsd3b/vRFwGu7vruX70wcFO3f9satCE7MOSvDjGOBioaTqbNIrYwRJxhpffitHpZ59aHlAivuZHXLi20mouoUgcYX6psRCu5DdvDHmWUySE3PJcaDhr4eLqcL48zlGB5XDDRtz41iJV+feSGL2UDQ1CHLJEGDUXJXeAihAsTDOLC9xteBDntGJ4J59FdOzOIqc1sboqM0OF0sgWbQtqoxCDm4eHrrpuZmZ21DGQZBgxA0dh7w/6vDd9USNAchdns5CoaoIREv069g6qtu+6pNCuNv//HcoXS8y/VG37gewzi4ybHK/kXU4fBPCJWNpZzFF2zk4DP1qlObjUnrtG/bicp9kYpZjbEi1mbLxVPjjzSOrmGji0zUW+Wy9UVtkBdJmPYzzeTdd0brQBjcXiHiwCyBIaQSFVMih7biQGe5DJKQVGShaxZtBnEiumRGm+Klt8WmBEX7qiCH9QAmXc/duer2xe82NdNvLir+yfb3x+cxkmrqFu2BbBh08SMntdyRLen7FF3sn7YVVrjvo5CGAFFNyx4HS6aU+OQuBDwBCeG7b31a0pD7am74mg5S2kdQMHrpcx9FNKSBSLk58rnTp5+BFWUft8oF1w9yvlWRH16ekl4TkBKpod5aq2HPjDlqBgV/UJJieDa3aDh3WMuIDvKOf1JzwL0wrZpWpamMtNUkK2lav2JRrydrKFCFEX9ruf5QpTry6cEZAkTlAmXtUjHfPILD+z1M9zhMwS1PjlYtyOzmqvmQcIkgbksU9UyuXShoMB1GiLjj99vriBzLViucZA0HI5DPeIR9OLOtwY9q6yEKmqmDbXfNnO5QmF6WtFnzKxNaEHknHhZC3XfKpsr+WcbrXuXEER5pr+TXpxt5UCPPLq9t0v7ll7e9dCvvzaYxoQUgb3gyhOQtlmqkXeTWQ6YKb+YXsn5NoqsJeEEkLU9WmCehGa3AqMmSImepM8ER5SXkblFfEtYIs2SNnzKx9rd5K5u9pODoMUkCka0VgxStYkNtZpdTG4VN+zAaJi1yVfI82t/h/wF4TZOdO459XDFc7jjcOGGPnNLSITFdn96UxdjmaJZ0GyrWEzNQpgQyGecLwxflT1kFU0Fmwh+IcEPYgICA+dvtuaAbObIYXK5n6rcFo74hWgGRbOrt1QTtfmlmYVUuegQj1ZpqwbUunvnM3f9+q2DOvCqkbRyBAuDW57umvXsPTfJYBOaq0XpxgE3g4Tijbuq0MWUuFXcoivGPuXK1B37b9XVomIZSibLzQTCGgCoTg1fKamB7tCI3xflWGth69TKydpKUGvdTR0EpAEh6ji1p7BDJCg6wYL4pXHS3LJ89bi+VlzW2khbHH1odt0ItMh2bRde+J98YDmHShpkoQk8inY/1Z359tef2dMdeWmg053frg0aJhBCyk6DjDnM4ixOLaYBWgP4FGAeUjXFS1dQpmyQXK4IQcd0XvRzUS4obEx0Uq2M7ozjSXyZmteBIEAfpWma65EeaU+BdkTH6KHh/sR8KiVPhsp0gwmxLQvUKIibArc7uUahxOt15IBQlif82CPwyHMw1s0Z6yNO2kn79iZugURwXVSKsM+3xGPiNKshXukvZz2zmq6lO0mQMSRirgBFJCGZRHUnCOq+n6ihoj+/nFhCLdx/0j4tqIcG7pAhepFH/YhXmIddO9BrdjsuFR4Zh/hOcwA7trC2uYkq1UoF0juyg3wrvWSIhKpZupFOzc0aejaFcK2fVPF9VolAjDCXl9R10DB83AdmJRSuFEL8kW7m/BfP7+keeeUTPxm4rnv82UEqtRtEL1tlj9JVtgZupArTS3z8qH2cnMV1168jDgSLI1yhdd03XUaG+K38DpES6MyFA3fQBbxKSvaSsWK6lpNl8xYkNdGSaOA6swC0n+NZ/jEMEZ6DCdlPbzZsIFYXeI2oWMOKbWEFrtYo6DlP8QpewbFB8Q1c9whvRN/g6AQjn+snd+BxkGWQ8Y7m54RbUgI1sj0XTh2EJSVA6gwCswqGAbIit/PJl/q6l/zdoIqnVPhcApduWhqE3yyfJBl1rjgzfRh4hRYy3EDMMORjneFaxtMrhuAubwmALnbilAhYTw+hcm35AWfDWRWV4jGzYcEg6B5mGsTwVnf+J5e+smfg0q7oPj04oGTwBP4oHiYzkiaJaRs4oSmQxqWJ0D7jBWyRt+HqLj3JzosNvsK+zdY40Bfz3Aj0L2nhZSIM3/AIBTExy3Zej+clMq1lun19S7/a9eDfD2ayYBiyMHJF+AAbm3JcGHYKwSy3F/SyVcIlH7mAX4wGLCpXVvwKaekV+zVb44DVg9g3hOGi+aZhJFJod/edf7X3+QGl+7G/GaQOkKjDvNICgxAqL0pZ4FaqWw5QEsSyU1pmICwupaK2IUO7eUwK5vo6HJg1j0uh0zrBeRRufUcHY+lpgcUI1bkmJkt5y4pjVc1ZKhDgGPgqqoNxQcW872p5mB4drI559IsStmwQQUrSTubHwRxamq31zI9u60rcmC7Ow290KdOzo/IDUyOgHyidu91QtLxwjGxu1E6HmpD+Cj7EtwOrqgOlchSIeom5MNIVuBoQZgTed/x75CLaOM4u3n1sO/fLvvZPuuGPd3UfWh0Ek8zkLXAjtxZ4TrlaqYalsOQ4nePyakH+Oog7ftNrlo5BDm2wBq1D4gHNUJe3M3+t1YBpXOIgHCVPFsuFmhJlQ1OYjqTruTAn5l2bGZ7lGBxsqIiXjIvA0MF12WKCKbZJiqZhwR1L4Jzp0Qf4FgMVi5kJvVCYn7oUJJYFSWSpE9YhupcOB4drR7nJYQAR1VtTjuKox45W1Yq2qDSNyPLoEu3QEvMgvl0geeTShTJYrHdvjwx6BqHL5Dhpmm2lpXh6abI55N9Gv4Lofj3eXxjOTE3PHhk9oB4sx/3pjcJSfolxa0E/Tu52jot2+RtOiID9yk45XCivAJKJzqojg9IUMngfWX9517e3nxqcMSFydVOjafExNk1vJxNkL965wdyPU4w4OpCDKQgKrZMAMWDvfCHvz4ruR51umk/kXrRaphgHMRbN/vgTP5EZl97+p8EEntXGsiOZRG5+fnLKNPSEVQAm1ITOSUUPrNAE4+RanAkhbaqE/kcfKkdh0PZLXiM6EzTtKu6Yrg12NsxJImZSRNhOEbhlQhvV5s1CcuQ1tsA2MrXRQ8DiRNXU4vTk4UOqmskVsunMxNT1X5FzVIhzguQswg9qMC8ds2+BNsc+ZiAqwdzJOgwRoHJZSCMWsTL3eEm8Qlq0RCsQMZF9t1vGLjmFGeCkAoqe1vzI9Xwa0lKlWowMT5e5KFTQYRrhjoqRRXrnzKb5UQkut7FrgD1tSeVgJpQijsL+WuWZZ8tV149C36tVFldLpUYjKstQFkI4nh9VvQgC2nGAtgS4FshuMIzA88GiqDKYiV461FgD8XXcAZIRRBIH15e0uhVaPqUiHF4ueCa3BGGI8JEAhDbGEqEZubiIR0iBoN3r6fPb177S1/0/53d1/1f3Q4PUtgqmUpyfHlWMojlnTRI0RWaD/skoBXpQ96ce1NtERgZHqpO2+4/o2nx9f2nCrtSnQB3lAq2ZKhtPJE8o69ay23HuEaWoZ25hnNlKJ4jC0tIJOXvyZJsL5XvI3b1RZ0Dy6jf1RaMlrGxDLemuLkxuODL/5nxbaN5NJSATylUYVj/0wnr74e8BtLmBA68Bk1H2ABtB/nCBgoq1XgA6sDl4Vl8VGabSrJAKQ+bnYevjxjRBt5O8MQnBCYitgXS1nJQbd/E6rbMAzmFRHOOnGDoGYwWCxJg5It8NtAU3rWio+QSmhbSah3lOI3OG2p1kM+0Fq/C+CB8rrBdbRUd3dO92CsbLSFAF7SbdlX/88x91pxN72i/f/kr38p985i+vfOEzPxlYj/399v8YTMOImKamanESJypRQAjp2l57Hg2ciZnDSpEMkSmnEGXqMxuZM+CHzpaFLPEwTst0q1QSaOBgrOrcy4UNAA9yDn3mwoF9MXoZv91LcYMrPUItMJVnGQk11/RNTj26CBCBQgFB5iHzTD8cw16wNnHNvJf9jfe3oIUUtuD8M1tgdRIaq2hgf8xqmi3sGGWLjRs5O48BKgemFMotfJFKg9uYwpPkg3ge4Wz/wKlY6oIROm0dUIaVOUOxFTsD00696Am36a+5i6wiOY1zBGMAV+PQdXSfX7v1ot3PNX+4/bEXbvzhnn/9UfcPnxk4u33l9v8eHHjxtvzO7xpftEy4PsBsbrAEyZGCLNeBWCEFexZ/iEwhfBvLhakg6xoefBgkBfaM034Qul4jbAcnKseM5jyqZpw0388mqGWM6sMsKMaNXGJS1TCMOyGKMqtO2wjmmM76WSfvGY4BAS9lquEafrFUrKstMzIpraEKmJWLchSDWyAmLtqaNks1pwBnp0mBDcFKHIsWHQvJOpIUsStT5aJrAQJK4U4lKJfB9Di4YpYsdE/uGW+r5fCVSq/0A+bT5ce3qHgNFcr1pYfAOhPmlJ0oaDm/1BeJa/RMpzwUdYotENflTLUQIBNsVE/lQxoYAkyzyPv7xYyZtidVbAOf+WwTsbOUBsLjp9waXWYPiw5MxtnjzjfcTlj1ym0ztMHcmI7uCl91kObYNG8B3nf/x0/AlsGkaHgkQeDjyWu2G2zkXGLqcOJIfi45bMVBbRXsItLj2k04g3Ps6zzpjPk5bz48un776nyor+bq2sOz36vcvYQC1wOBxKjvhX6z2mr3khmuv1Kt3yUWGeQ+XUC0WtjQAhu0BKCdO7UqS0WKo3gH2yPshsK8eUsmXkQqSBdpJ1gL9MX3fLdxtn6mvnh8Y3M18ktwWBfgFPlu0+QluDchRBxLSBLIlXQ26SrMwOgX//bxQQ9kDkuzBFa1bG4mn5/NDc8dYoeWMqViqNbURu4USC/mNMON0nrJJCeiB6pn7KUJtFvd5uc/+/LVj+3pnvtb0PSf3P7ZYDLD2MUAJeCzQGrP2zkyY86DljBMRcWmk/CPcrzOFpkJ5wNS2wNZEMjTY6ukRU6QJZAK7V4pFJu2aRRHPk8xkvrDUi3VLNi6ngDxNlrYa8xCABvpy4lCTTtr55A+bhwtzKopbAB/Gp65UKjoFQsUQa/cyOQah0Dl1XAxvNs/UTlXethbCxb9VX+Fan6ntNW+r7Ja21i4E+wV8IYU9QMfYJUFdhFoJAa40CRM9cCwQ/BJkgUeZuwib+ed9PMX7Z7Ybr7c13Wf3dX90jZIf3ooXShOzWeU5MjUrf5tp4Zr2VKxpqLI0I3+TGHkSDFjqHq2d0UgSW07f4Ro1gTf60LmwchhKaIOB5pjgU6TdGs79pmxH5jPdhquzatexVtZDMvI8TyfA222z4qSW3NOSU+MfUiwJX2p0MAC95yJGN3KlVRf65XofDf0Qz8qOW6lybVw1WsxTloIRp6AxwrVdVtgnl+kFir4/dRJbtigHORqj+0koryTd4osDUjELYWih/9s0DUh4eGwIC5I78wtqnIDRIeUMHGeVo2ihgrFMYAXk379mBYUI70hArextbVY9kRFlGgA7w9UpO3og45dViN1Y9ovODNOnKRMRU+nZotaAlTnPr6PF93iCjKqznJ/8M1j992/2a5g2syh3Ub3DIz+3u2dQYXM6UVD1tBtQKiJpKaPjs9NFsZBwGsEZ0fZbbWjqDq5Fj+ulu0zxAFegSRhdf5oe6mKCnf0U9NI2KZtpa8zZsyEEsdxUrQytgF8mLdySJvpFwAwwkDLWv+yRiSgCFAy8iIczoUDWN8Rtdb3omPlu/y10ikUHXPXq6tOUDkJstJzvR7UebKMBiagRJrUzvmo4JFKPwFBpAM4aqHpZZoAkr3aMAyrWxCyrjpezQikclVgcDWzpk7QqU8NbhorM9VhoVOaS2eS89nx7HAyrk+TeVJ0jEituif8Gmrcdeb0neUKuLKalMQb3z7fTXcv6Ot0d+16Yjs1mFYmrvQVRgIj1BugJUrC564bgOTzItf1vNIyB4ldJqEVYMfuAS3p2RvFL5A8KYR5DeV3fjZomaYlCVmZBVaPl9J1w7c9M6IoKIH+haG+mMsKo5D1LcFDN4icklvBC4YrbYlcUNScjIfiQUFXCnCe8z/+lz/+EVjDy7YvGOwtDbiuzwWN6KIZqSXLyXngyamsvGmOygFtDDyVkDrYtnp3k9hy2Up6GDsF3KOTCU+uSwqbm26R45LdMao8DDlfKINcpNUmu/jGna3BpAUBVAQpa+nEpGPkZiOTPqLECaSobttAwBikkKyZUfgRWXDBruIWQpANoKYA1AVvlQBjgWqk13Fc4SI/Wjjn1kBsy+UqHhzjZQrDANfkko65ZFdwScpWOdkCe0VXVqlkfQLtvrH70Pa5waJ5y03JWSnI5ODnlXzu8OGDR6aTeTVXsOSw25igHDg0nCFFzDnYh0ZyaW4lvjHmqdW5lWx9vppcnK6nkK8FmgBCAb1pcSvQPKNaKFkVR65MVJqVFvPVCNkCXAOgB5B/NL3s2zOr45tlPHw8W73lkWxF9wxfQqBYX5C6amP95Zd//gvb0qsYQlcN5xdAJ2po96vdq+8cee6fXv7is3sGLum+sn3N4PvpzkVqQlft2zDJIlCLqUDvd+XiL3A+wA5w0+P8Hu9eb5Z0PypAnfIlpyEakKRo4C0gDpggPo4cH+iTedYKrsFVuFqQZFMmOmoUrSFpP360c+XguHmYHXRu8nYuV22Vyqq3rDqAdFKtKYOqctUXbhfZJBiWSuK1chzHgLK91eqALvMF/g33+26bopCu4EX8mHmCrftw+JKo85AtcM8Dz+SxACRL1TKtCBUXDxbGQS/cePf2yUEVHBq29Jzt/PyPzv/F5oRUZ+tzYIqIoetGNn/LDdkcSqbzWduw9SOHpNUePmLr2LYM21aLTK8kKylKSzZIrpJTLXteAHAhM0CADg4CP6g3F1eqrXp7pV5dQF64sbmyuLTQaPEIpCX4J7PDgmQAJk7IsliunA/RdOvgicMn89V8ScYQ6AqRXLrloaKbDogzP4d2z010f7Ov/e1d3T8FBiM4bxbtAoCQoivG2GzPT8BN19Kzet4G8YdTyJrqD8BzLeAqHNHzQLSJHhdIUHX9Enf9uuM2m2h5uR5u+Bt+m3X0Rc0HccYMbkkEsSasopGZOQyjkc3NZ/fPjCbnMpZWiINvS7OZYM5LCMXBEM96SfExEiTiVbftwyh4pXbimLGAI0I8Vwjfcfhi6d6NpTZqVDeOQZ71FFUQNu/02m6LL9htXNEWTIAaLAmcOrmGCbgxX9eYXMXA3HCPhHkaZ1cUTQPV/00MGnYyoQEUGXkYxiR1FubLSkllAOAejUQoOG+2UWuBRv00AmlQUqPptTwzqQ6gg3b/tP5CX/d9z+3qjm//7iDIxXghnZ4pzNDbaIJYrhqmLNbKVYsCMr9GGm5doCXv9CmOpQmDu1ZJRQbkBNh2YVWtOq1RwcoAJAIuHhJl45TrLS6V/zF1mjJtvae1QSVapdy6UkXZ9vi6JiwG5MxVf94rgOjS6TTZb48qo2nNOjyqFdHwrXs/VRwu3A6SdoruZ5qbcFP+rNOrAsk1rvqU6IEl2N8oD/pFL4GoCEFiOJKS7E3cYfez71bPtVDTb5bB3UhAA4YjgenbDu6ZeEC01xbsHaRHKo1r+7LX5kfxJBl1Ct5Ebfpu407jpDgVrTbvP/fc1hpq1GqgyNaC01pHCay1iTAvTD/nFmoHnaHijJkvZGwBMIl9GuAHcFgsGT6QWhkUM9MD2dYgVV6mZsuasw22qRAMuVkjqZt2b329J9wzOXj6Z/sGZceJoQCiqwDmICTB1WBDN/ViIVdIa6Zc/JSQDNo0FBXuhbXqImXNUi0MRAgsyrvixT0Lz3ULz3/u5YGnu1Pbfz+YxnP5dPrA/ukvJm9QJowksKCFdThoMvdnxrB6PR5xhhCobAtkHfipDl2joSNqogxsUKdV8PdbvMa3RBWUtn+XzCV4ht3p/NK800Rstn/gVT6Mb8AJcz+hS/nIKJsCsKoaOMCKAAuAkk9z7q2ysvMt/CPzXhLiOimZZ5N/o3awa0Z2oLVMUawjrTwBbgL3RggVohEnbqG7PjoYGqWUn3YLIFDAPHvT8Cyu/AWMGdWoygy280G5PgpEHIjAa2E3qAvfq4iodGLxdKtRLpVJRUW7k13/V923v7Jn6cUbXuxe/8OBv+v+fPvUIKZKb1lefiQIUay4WX8UkLvIitRmGreNIkd5vh/sk02mdekmFcugOWoXQH6BoJOky0wGztJgs7RIdWdSpJ2kc6ssQvIx9zY08CLL8ZvZ7fz9PAViV3dAW4EFAlyvKOfmW7ZHQrkeWMWPsrIoi43QE2VvoSPRUlbZgxIWbsNrYiHqSCzajxolKzTKtmsFySV56jBrjhYkItUj7I5ObyQEc2AwNpuOw3r21ROLi6VKY6G0xFtS7b1W6Dkna94quEsCwoNQZFMjwBTtxA4OljB8quyIsiKzogMRmsIA+aJoE3sPjRemlKQBusSgM1nLALkhV6NnKCsXItU370yenTuWrCqO7ekgR90iM9xZZ07dq6g28JxqZ01Cx1gK4s2GgTmwQF0ky3Y2Q3ipH1iuQYHHrO9a95rnyMv6KviGECDGV+ueKDlnQ3DHJwSni0BpzWd+3td+aVfX2P73QRXPaXl9Oj98x+gNmanEMFaJDXODLVOdAYkvu1QwwrY+ZaWMWXuWpmkR/BmGrzEA/XiUcrPNr58+cF8arRUfwcuBz8HBQBQ/tRH6rrtYleb02JYXhVUnxAHCAaWZSiEymCrrtyC5LALGKZ9M3TEzpcwUbzFmyijrp1pa1faMilXWO+BnjpMT3hMhOBuY0Ebtvub60klU7axvVvx6WLdrakXfmg3+q0r/GkZFtsMQZ77jOSU4JRbySrYNSeOlm6pf9ONVE8YRvjjSvTEnAwjw4OoPttXEnsWffO7Zgae3+7YbEOWJhjxY0VX8+YrKUuFk9Y5gH0vTDMNEw/OmbqOkKkqZueS0bbAs1ZmUejt92s7r7PeQm60KvQUNvEonISWkQJNsQF8rCDdIxQztNVIRsqPBoWiR/mzFDxmLvJK3WetU15YatVOnpA8Lwl6BBDgULmjhFPdBhFbdqt+Bi2qxiteyuMRQEuAGRFVZDjLJbBWWKEu3wDYHuNcF1IvUTENG6p7sYMUoWxQidS1RUjvJjdloJkj7eTyBU+pBPZMdueWmqRRK5IcTKWNOH8pMU50SIUo88P6KPcwf9/7BfBDcTpX4CLcKdNU/FjyeWQWRv9Q98dPuHYk9x1+66jzA6APbTw9miGencMZO2VkyaRf0GX1CJyRhgB6xTarSAgheZJnKvIw3rgkduQX6qX56HRmzD8LoFXf+G4mLSZaX/XmmKde2iUQwmxulnERVaTWQb91lNAB2v1MugahaCzaDx2tn/DW+xiseXQe6Za91DjqqXOmi8Db3KjMDFzeLJ/WE+d4p05NLsdhB2AOcvk9816nwbyC29SDtf4y1cVV3MYgNUAvLZcd1Xb5scYR5v/DyPXo0edYtijzYZ4DtafEFc9JEpy6kbdKBtwRMql3AqZJzrrbgPhCc9VeZb3pW5AQ2ahgN7oZy3dQBFyVKti8rRNRhjaIAI+Il+SGGEnSeGaBD7tku/Kxv6Qe7uh/afmFw3ppIGjlsy94eQzVnTFCp6pg5k/oATxV33ojj1qS+H1kzZjzIOqqLF+wqXIIvIhCRHuQnrYjQqTiLrIz4ggMgisTWPaJ/ia+CKN50tkStLuCkYIipL6WxryyBiGEK4Dya5FU2asftr1nzGKmEtfv5RvRkeNpbwE7YiJo2+aEakSWzROswZaukRldxi6AWacDRSry2addwZER2bylfKts5dql3iwNoytG89wkvbcv10Mb57kdf7Dv+N13jhV3dm7dfGjSo3utwkP2LGh2aymTTmb2ftFPE1BK0105IJMRaX8JZnGAZnuKHhfCmnLlw0jUZqUz3UhAzDBB76lDJCC1fj+yaadJFbUVds1edEqSVbJxxgYWRx0GtE59873uyJiBcB+5+1FtMcmWbYvkEryB3kwWkQhp2vZeJ8hOqaacInFXgoNnErJinaPRqDUwmwRcD5gG+AhvaLM9nHLukeuYPwiapk6pkcUMbtjWkzeXnEnPx6XxxXlcsm2b5USdRirfTNcyVBa1uRSRE9rKxiLfwKnVEg0fSg7Jy9S4vZL1rpLzU8iPkeEJWisTSQuiW/Q2naTWtZd23Xbtu3lmoWhUTssfBJVnNZm7oRqUlWo2HadCls2HeTfiKMx0JPOWjpDvOZ8HDprrK+S+/vOf+l7qXvnrF+YGp7uPdnw7GWf/AqVvETt8skfW1Cqu5Pya/kGsgEMxweMzm6BzMHShVy8B56+PmToyMgWGY0i7p1ZZ1kFeqnSQZe4piR0UcuJP3BLPUehGMbxukquyDgLmRJU+gGuR16CmxJU7RkjiF+Gq/LwIegZ6vgsRDA1PfKZ1y6hhFBB/pJ0maobJF8F0854wyq55xjRKWBWSHtyIQXZ5VQWaTnGaPo4Ej/KeV7jvIX8MxyF2ipJTB1bIER3O8f+BIJocL+Ms0h8fwLJ4lCQppuXPfyvz2N4E9nvvCCwOv3rP9xOAlbxh4+h1vGHj1nW/Y/c8P/Wv3uRcO/3BPd+0FAMXnt58dvC4/b37BmJBFd90AjYAzeI7akVFVT5ptZ8Hd8ECtcwqDkC1/2c+TS+nX09flpooJ00yn5uIGnjJQyswG/dmgUNaqlq9EJrcBIfL2vGnbEPwZppbnhLEyyaXs9yzfqoPUaRgLWgfEUsPdqDkygoXDfffYcSYQ8wJyEaEAQ2613TkLYqvn0R3fv7cnmb9vg/giEY0QbRt3qqfsil2SgbUgpKE/5bkve5tkiYBkdXyHUt4USxTCzIwstp+hK5mFP59Du1vr37/phQGl+8z2zwZ1MpWW9R1VLSi3DF1+aX7eUPM5WXiUK2yMQd4FiAR2k5TtRZuwFvOA5HyjQwBBaAfeztMQ6EAfhbx9jZsTujNGJQkrTJfe/pPuR8jOG8k+qgrDy3p4mS9xh3ll7rKI3ofoL+l9/YG1AmbKMe8dldphGUw9w4EWqcfH7rmxMsNtqjED8UxQkCTs9OzbquzP6kUhpyGILF6lHaOClKXEcd0zvPSizL6RE5OrqWaijimln31Ya5gRJYaDbHhbWG4t/8OvakHJ21p2y6UFLia3EBYFpkEgkfp838kXdp3dPjdoWKSIryUz+DBOWLfTOXvIuJR92J/wpqqTZcU3CPWAK411JaBtuslrXtNb9Rb8Bxpn/FW8Cp9UWgzqjGPg6NCM/qv86Ohs2p12EqDp5m1w/8Zk/spMRiBD9nt6xbb5mHiMn6LfcDfdTed/4uP4LPEMV9YvExTNU8xUHe3+y+7fvdSNPb+n/eJVL1/zRPfe8wN/vX3h9i8GZf95r1lWNk/juQy4EjoxpuYzs4TNjSYmJkZM2Xaeris1I1SqRmCAvZRRNLolm2vkOgF2cq5sjScZYPtsBufZzhvp1/hNLMtyIL1kf02GF9DA87zAxtgMu4E2nWGe5Rm5JeK7ICBkFZFwS2DXYrQBOPDXIYuYDNLvchbViezyYdJePe+U2QP2Ci6TsuzItR4EZgqMvyUuvAVCbIMcR+TJqNBfyruysYK64PPCYgjGy7Hbdg0YYSXy3dWFUmXzLNo4e/qcrAv5KZFxJ8S7ZK87VUnRvsn4NNasjH0bPYjoCDWcnJNlGHyHEVhCijZH9MhYajxZFEICBsQODNAy3jn3OF10TgbPsS3yMHnIOm2W7KC4SgWi7sSa6qCiM8ZNYEpn+5XEns7Ll//o8093D54fqHT/8dd9g6qWH7NmjFH8GXEVO8pvpTOI7TX8fpCfZS1MLA49ET8xezJ1bOZs4rQRyiUS0lsZsEEcI4vnKzANhQsG1ousYORySpGP0kk08CTZeQubZkfRwDrf5+2lB+it3pddBQ1UIFtMmG/dU71exaDKF0UoZJmXnbFOwOsJeEqA7mX7JNmSBzpnb+J7EN6sT/ev3n78luN3VFP1uUqukjtzrYC8C21w1lYVAoTTBY9SRLHnuUFQFlW+7txHuv3mE3iTPes8wOrhcSeUnWWyidzT/GyAklGB5EGS3tl+sbv24q7udds/GJxRhD8zPzU3OTx7m5bVc6AjbG2aaEQxUrhgZ+wrWR6BscmxghijxE248/UDUaI+ujSzno3MkgHCDE6+zFGZ191QnKjcfezYGc/3fNnd0DreONY8Hi75W06D300XEFlnFWWtsJU4nqmB+Oy33OnFnvcEY6h541XV1cWYq4m0P+/Pqah22aCrtXJl33d90jDr5lK2kark2hNyvwB4PdXLwvDGER0yRvLjynRqVMmkp2+8KW9JN6LZaSNDc77iguwvo2I7dxeuEhAmOLAW7Pt5y3uifvfJR0uN9a1eXQVyDe0Ou9ZLe06/eNWL3aM/BNfz4e23DcpGBLC/DrsfTEOvdRnkUUP2I2CYVKuUK5lg5GR9t7dCS7jpH1zL+jbThS4yvkXSbtIdFTmMxs1pTbWSxYO5XE5KHtPOqVQzs/q8D+mPQpuk+kmRjpJJ/Amb0/cDi9D387HwgJNhYP8cywPUgQPTpteWBcEKD/G6Ddn5NJzHSXzOfoI1ZWdVCeJq03pGdLwz5U55uRH5x44TjgiT7Seu79dkd1a4wC7euaL7zsEt467petxXfLljxgQPSFxTmcwlconb4qNW3L6W5QQqcOmp1/lD/JtkQTISkXVYuZOEn6ie9O5R0e7u2xZe6D7y3K7uHds/H5RLVJikjBuG5iYO700OZ65Xx+0b3cMiTufDpKv6c5AhSzdF6ZX48tzDU01ZdZQqn6yJlttwNltVL3Q6jXIZhWFk9h9Pt/P1bCNDeRWGYGnZEb4nN3QhFiVa/UqpGMpVkOFFCCWWlCzMvAjC0XFrInDrtdO4jogj28rcyFoBZdkAJ1ql7dyG3lKXZs4q9Ww72UqXUD4crcjqjAXaIeelXZXm6ZSmmegHHx+UFBMWI6XsBV4l0xypHKkOOyl6Kx2lppU35q2ckkRqZqbenwszJd3NRxNNGRIA/qRIKC1kiwWCmcZUYQYGEtjXQGor6/MlDXS43Gdmx7MpbSJnsbg76yh+ooNyNSNQG1MPWjXyTXIKUmrBW2s/WGmVaqub1UopotTDKLRqTiWshi4tK2i3tb3y3J72Tz/x9Bef/+zLA52ut/3Pg4RkSZpca92YH0vpVrxg6eCRbIw1TT3sJtGA7aRtW0yjgY67F++8Rf9znCTDBH5+hNzWD7/M9vsJz1ihIUB8T0qDFhESeyJ4SSRLEmv4UXPMeYotsS3ZxbTR34qXC8cmTo5uTgQKt2TBqpxrjjeP+Dk/z7GnR6RX73ZZyVssg5OoM+fwC7KRlcjju2P3qYFMMNtBRnjHPZj0amvwY7aWraCppf6Kd7rVjE60GrWVpU5Lt6vNUpXgUBZARFAD7OvwMmKuVpZdlr21W663TVl7DqXfNQPJy9nApgh8E1cFqPk7PNtGOx/euWCQ1lcqj0dl/rgIiKzeBBAyvt3UUAkMej9NJsfGJo6OfenQqK7hPNYxjGDOps3+AZd2rG/ZVYhjHz63BJIkRLsb+ktd94W+7r+8tOve7sAgwKju6p7uqsDJej3VTh0bf3h6laLFC+6mdy622+fOLpyIzvqbrEa2yKbe0JbV9dG18QaaqYzT/iOsgG8tJM20aQOdTqgYF4tkETK+Salfbd35wLkHXdTiS1ZLrekN3ZH9JjaMAZVtxiUL8iwsN3mkO8Botmx4d3T5LE9VMmE6HC1pMDpYyg6xD/wH0u05U7eL5qFsKpPJTUyaxdSR2dHwqyLJzF4VxuIm4kVfrWcjFcw6yNs1ZyOqOOcXTlLw+riZbie9ND2EyBWFzNHh5LxpKWYBRiYF/sOgRWcqSlcPnzl6ivBcGSUbFk1lcnmSKyeFxXtlXA8mDO0+sa2/MPuDPd33/QiC+gfb/z44ht+XG9V0nLHz9pSRMKbwDDZ0PI5I2jf6I3VNa4tl0fEXHPSeC+nOG72dXfa7SY5Zsu+gbLjMoas2yF/u9XY4yT12SAjmk6fpGfw42bCfZd13SWdrl2E2PcIC9kiYI895qM1bQAdo4A4HdFRAKzB8jhMEQLZAcZ1+0zU900WjpP8QVfE4OERn4YfXPt+Ny3T8/varg7KKCBaWajP+pCj6hR79mMwIDke3OMPOAfewsReZR1L7pofzSVWZn5+a2jc8eqdSyZy0a9pp40l6jJ52zjvH4RREm3d6jTAeuHHIT75Oe6uwwtX9RIgSUX/eMAx1XksQk+hEsWXV2QCGh6DtWKp2FRm13s9u9/a7h4LR1rCrAOYBlnamXXMpWdVOWagFkr0BYBo5AqxMpyS3uC53opLrBYHjbB2795nK3Yh73GccwHaLb/B18hCWRtejnn2X+kjhDJBWQDnCnlWFtC/PLWpyM5fGMIzN7Pbzib72X+0CB/TUIMZmShvPXq9PYQOkSBEX9bH0NXbCni9m5P40uS6NMLYz1iQuyF2gKH97P6VGzWhkztqs8LjVURfMjl2d/y5wvafWZflbqxRrKLXanwWvkVLSRWwBqgMccMst8jlP5a/FmRWOgvPnpDwMqs2sfQ2y0wgmQF0Dk3MjPOrm3ZxTgIHNIT/RHPVNsA4mHEMVuGk0jSUwlXKxVZbEWgt+BXmlynEMMpnIfcFB4yW+4D24/HL0sLvMTH9VlP01bxF5i05bvkWrWHJflMwoV2dZOg+KXQE0737m3Kvd//nM3hc+++LAI9uz278aBDrJgaFTvJxrcSLyPO3dBiP/JTTg8q+zuAmiv0NgHKXw1I/Iba62ZqvZW2+75tBsPKv62mlzwVplHDFuBnI3A+FyJ4NsLDWiWZxWVMMy5w4cuXp+pKghA4wLFoavL1pLuIorvT4YiW0eXsGr2v/mD2qvIBAMNQojPfaIyYrCwOmiahRNgi2TT7gFPx1cKa5EbArcSZHNelfKZTN3HzxWvYRsbOCy9cuqTnpAirYLJxMVlrUWa/Nm2G61mk6weAYctNdrFDIcHTm6pwlL2L334cV8ybozf6K21Ar9wJMedH3D9REXS5u9tQ+QPH7QOe23opXAF6C64dy5z+WS6j04wGX8V6RsrVmnrQ5wmV3Nrxqe6UxHYMsGXAAfuS3YJrm83LndfrEzyC8A7X08ajmBX3G8zrHHfyXnzFOC/OrepfFjQ63p1tEojuRWgBJ2QXSAXHACp9cgyIXnhNLLYBf7BMwvTLpeLnRy7dmtsTOp5bGH43dih4P9aW16pbBx9rnN+9DKnbJSyioYtLHNbAHEW5p2M2paNVSgdWv2YHIS6UpmOj+P4gfTm/2z90ZzM/dPP1joyJ3n86uGAVOIAUOJbuumogHJ6gig3XL0lRscqzbRGq7Ey0m/4CnSEnuKp6DS/JHr+pNHEyNmMR/PJwpxJRkf9RLMOhGXZBGBOUO7n91+zwu7tq/b/vagRXr7HljeNCF4wOkWaNFQ912fnI6PaQWtoBYhbS17+CuyuPmp7oDmYX7oIa1s+kbZ8ottw1NdpDlZs1+1ValLdCsvCqJw/BofNO9LOxd0DoXZ2lwIgolRDGdvEZVo1jDJmvvNO6gb3Mi0QPOpT0/IvWhChLSD6Kb7fcD2OlkSbdGhPKxtPFSrrp1ZvXPzTGe1ueSV/XXEI8qMitbURdpCux8/8cPtN8+ffr6v+w/bL4FqMuG6cjSFDxqXKl/SprAOtiKjzRZydv1oaY6ROkV1Grgt3oY467AmK4tlZ811yDF3y33Ec8EwYDufR+nUl69Opw8duu5q2Z+cS2tqLjc1nE/Hx5OjxanCOLPbsygqPOVvsFPslDjBjrGKOGY/a1TpZlASQcBDHmnHTOBs8IFfYh/kX6WHrUPWftmD6zzwl+0F16vWo/Lyxr3nHnoYnX+52S7VvdCVreyyO1B4vqjZEXGwJ4WA5RsAxqyntHjGBa7nY0GB2WwfxAbavfOWD53f/tb5PYuvXvriwKsL278YZLP94HUT+LPkBpoVU+4QiI1b6SE6Rw7RNCtyHSyI0ECOjJFbrDK5HQ28CnpzDqvagaCwVFgsPFhZAwF7rywzMMkfQJjccZDvw2evk4ZsDNPhcREEgQaKQnX2M0Aukun9FQGF5i8aeHp2/QJal9unuCC/lE6M3kcflYtJ5+kilkrmx/xxxM9UcX8bdwc8JpvvZfmBipAtsw4RtqOFNruejlMAdYJkjwychzfXW7edZXOQ7RrRLZTWcFH2Z22/kNjTfdtzt/80+fyA272/u3sQxI5vhcWOp6rtYsdcURYBa23f8nsl9MAK9FrhOOT1wCOUZ1ckrI9+V/7FA8u3AeA9q1jRSnpJ4oXtmj4qVo1Ir6l13ppnBh1XZNeVLtfT01vXRKoDiChMRJsj5GKKGxOyGtQ8KruDq6NUkjezyjNgLohQHa066uSlqi3Hwb8Z5TlmAHoxqzpNLUTqI5ScuIrKWiYYbUdz88xgZk0JAIgYqfqAT0KeFCClQGGAG7mt3o5nuNku+M4wfj9MA0sfpxfvftf7X7n0O9tPnt/TnX3pU68MrD+3/R+DKWnHMUQ6kTuKwfnppk4Vd95N+Na9uEUiUCdIbtb2ARAXyCJFZwjX+nle7PwWvYp9wIzTd9Kb6V5iIKxkaL9KCzBBs/b1JM50WrRBlQ9MvbbCYVNLsVJWGk7M4GAIXmvVk3c4YRtFpkNatNwr1YJ5dvjd/D66QCsEcN4OmVzHBniVy+Yur7OS062AhRxYd+4yu3P4B+Q4DvTAdrB4TddavV7rafpnQHdZgWaceXOCod1T7b/7yD93P//iwB3dge3fGWRh85hcj/QqftWvBTXuIadUzfQHWiUHDk8L9Nc6XLkNst9cnK1lfUDYIBvokQ0GKBQVdyVyHKsOTOxCggizrNb1sunuvf/L30mDMUZidhmunbGLIFhFzpoxXKOQzSbU5OSX4jdirKqycQnsnKnqFAIG1CVk8UAHpkTuUikyWs80UxzXvEAc25SbTEW1TgXa/eRXXrny2T0Dl25ftjlokxF8QO5neS8eNnYucD7NQRCN29MUe1qUC/Ej5Pu4+y7uCgbJtEnRwwwsjtyt5sjfQZZ5rgeSp6K1+/WGLQzRazDXQbdPdP/m6T2dH179VPf6nw083f3Y9jsGAVQLFlb0sfFiLjmdT2cPFKeUeX6EqqwopYsz7RZg+v5TGcidtsUgVU+G5r2zDfKtmsuWapEfBaFXKUO8+rl+RxO6fKVjukYjsZwr8xJ3vbBVWgA68xU/27DKCPKwYdfMTVYPFktb3n29BU6HuLiBxQzoKIuaNrIwxv+/lwYeeDjCwOw2+EYOB1dlhZIjImbCIpN/tcMkSCdZzaDoyY8Pctl1CHdPc81QhakFAIIjWRC5OjFwzs7RLKKF4qSSTE9+8pOHv21E9gJdoVV/02+GnaXTrY7rnVgUFAXUTbjAR3++/dHEnruev/qpgc43AIZtEw42Bcg6jxV7ThTthHToBp0hc+SreM4esQ5af2jPG3eIRC0faY5e8yHt5BY4GETwNzBTvd0Jbm8jw5JawlV7i1ZF2z3VrlZgKNfuka363BOuX8XUbTrgxkTV6ajnlVM4KLYBtIwgW5N5aPrWa32FYBTjIgU0OakbJiambWJUNDNFEI+6yWr9YJsWWEOcw93XWaGsGKYpSlMTGyrqXr5TGizr0YTY715tTs8fVXOGWdBH0/Ps0ApKVWjQT12n6TSj+yzRPlNZabSWy8tll5V1tPuL23/wVF/369sjg5akCsCgw1OF/MzUxL78mK2ZmtxRVpjAgB7qkDWL9L3Rre1Rv7A67fa6B6Tk7GhVvGWeFQ1PyL+NQFGJPFmXILHY6yWXa0H1gFWVjlGyHVNojkn2KWhKv12bNm/XEm3jpLHlfiuqAyX5svfVr7rl5Yfvf6RDkUdBJsMbooJf9IuBKmVzvVdZ8inwslxpCpFbAy6Wm+blh4vCgloygEJ0z3Dzr3UTATEj3dvPCwbaPbf5zJ7uPecPPwom8qe/ftMglc2/RDdyO33mR0iKZCRez4aYqc5hMmvOWzpPwRTYcpOjTafSujk+O7kvf8hIGwVrCvzTiMg7iepkpKGNqZOFc7RNH3AduSuNuKzCloIIZCsFB+faJ5nPIdIC4bfZKluk/0Jq9lb4PDvD7hRn2D3sHtHhJyUjdfrlQmqBFbjuwPxahsWphq7aeWwwMsOEGxcZNmdfJ4N2jsxLrNIKRn/OyFqH9DnLIDPsdpb2zVPWhr9ZPwXif70cVkvLUcdBi84K9yEjUsce6qLv3PLkntVvA5i8rnvboOyo4biqPsbPOneKDbZaAugAO9xbpV9YDsqlplthi+KMujy1mqsebWedtDsdxA1kkWkT4oBNKwVjtjA0bIKfBP1qZTO56eJk+hbtK8FRxDWuSgcYzZey1cRKcj1/MvMP7t0t0C+9T4gC7qLe3+dhLmehUdGrtlBZBmJs1pw2rjJzIisUL1v7f4S9Z5Rd13UmKC66pLPGFuxGqXqmZ7pJtdwaW3K7bUvuWSPJpqhAkxRFiaKYwASCABErp5ffu/nek26+L6fKhUIhEAAJkAIYQIqkJMqSSDFJVLAcJGs5Ta9pv+Iqz5rZ+xbl/jn1FkGQVa/eveees/f37fBtUq5Tz647kRNzsA3eKZkAk3GtmJPBJwfXjVTtXgH7zESZlZhCHVPXVcYP0Sm2/RtFOLSytVpvk/5qE07AZmvBXdDIrvpW8uZVg19/4+qBsfUXI9gSB4iVlW3FnCqram7MMrR5DNgBncbi6gk2Sfh0gQ3lWYnOWQXHdowK1v7LChbkgJ3w7KHYWLCwPqSeljcKAF/ykGzI/fIg7IoxMRE+xI4QPueP13UwAbwvF11Jg3rc0t6mifG4NbjaWSYsromhb/sej2MShawzxHo2AHQLeMMXbZJNqyM2hAiWwhVGq81GO3ZP0iXm8q7eMgP40Uj3WMhIjbphgu0ziRe7YK9tIKA7xT+2b/uZpfu7+yNCb/XNa3c9t629svvr7kuvDb7w9AM/HP7FYG3r4yNZu2KVdeAkDh6CqRlKpzPlmcqoYwCWB8RiTtI5Yh9wx+KpoFAf941q/uyREAWV0EDQJpDyxOyxZUke807WgWJGYMjL2uembxk9Oj93rDTJ9/G7O+PAQTOLVpVYNaCmsGPiCAtxGf4OR1EcLDDUbRWluWSZyIxfaeSS8onJht5Vzmfx8McAxVb1Fj/ptmGtsfocbvMajy8AOKv66x28Z0BnbrXW6kT1Rr//hKwL3626CQk63gmv49bY15zH6Angtk1vlV2wIsfPY3HT8D/pwmKwin0ZoqAU+ChEHlU9NIOZhiM0oaGGAfYZgLFRwn1y2iRXPjeS0Jrt09iuq9gTBt+1YVeXaYVp4GbBJgA2VAk1AKrN84Oiqs+oY4Y+lqnoNis4R82sl+vM95Xj/Azhb5288mK76zO+YJFdf7D148zuxR9e/+LgY98bPnN+6+2Riulk5I3iEK8giGT4SVln+8P29UAqnAf4lDfjZgRtKjXNpYHAuqBQtjx/GVG9103Okfql+mZvI2k20VC0vKHIDG2hRLdZHxJ3kofex0qu09fbYMPhuPIAGyQxdxCLhJ8D8tDlSwAC3fPmE+qG0WNUq8PW8hyAyOXEBIw642KVyiiYUWLac6ZlwUECkwq2NoMiQo6NF01T2QveY6tgfOi3rSfsK4T1jWAIxQbKnOhALbBqentm6z++cNVzr1/9D1vFkQo9UtINh5qWTYs6K1XngoqLml20FWGKz8OCm8gLnMhLgMrVDHCevA6uhkosmKeBX/UiCrCawHEA/1RMfD4VK57G5xxybPuzI3rFuJ/dyb4K+2SvzEjVK0UzkbkA2wB78zzPx0oFQAgxYFarOmTFAIb69KRxOjjjLdGLZhX7NTBwAYZLWq4tCpxk37vrD7a/+MLW6cH7dw/2vXLzz774/O2v3vLifd8EcxxvnRjJW/PFFLaloiTWLLXU0fYjm7DYXlo5jwEaAoa5B5y04TG5TIZfEg3YrC3HtXwAV05Y9HSH3PT/7AW+5buBu1JP8IgIz/cBcP60WWt1kUHWawjekjpqJlwBX53g08VC4aDO+25HVnlLxmT4WenZAisKWY3XWJ/H4hRvsQZgoFCmvcsAun0y/DyvOTZKM/EAg/cyxAYC3qTwy18Ck73BIi6AGUjL5zwDfOT5ece0gRvMyXmsI3YPpu3nwN/SRlFk1I8IIGnPwqH5HP0Ke5gKOwvXyRwbCyKprVmqWbYMQ4c7MtOYiWs9NFemZipHR5jNYZtxgPyAPE2Rc3M1wCpAIgxZ8SivmCUjlWApYR8giQzPTrPlaZPHYgFN5HIlrUz3sYjhggXETrQ9cS2XLY4yHkb/9YdfGL5+8J7BjSMe7wEtbWqnj7Uyy2NP3rV5NNYiFdmVmzbnYV6TcKfJkB8u+L+qOHJ5WEtLUzCEGDLf8YjjUkw/yom1+y5pcaVhhsfOzi2XUZnBx97v6S5FOYlc5Aeev7HUb3bq0q2FoXei1652a5HXbgS+SOyImNXyggNstSwwl2uD9zKtz9+HbS73Hc2XNKOiGgYpV0Q85K76f8vPsCtc4uNhCO5CS+bArmHPruKYwCbh6pnOzNIn+Yf0P6CTzpedKWA6dFKYbJLOCjswQr1G26IrIh42pCsv8A3SDr8lrtm1fWLr/83sXn7lxte+8Pqwf2Vre8R2qGHlzDl4ROP8sL7976x91l521BsFWCOLYp4rgIS4InJS9ffz6dohjOxjbW29EFmBvUxDN0ICFhBRhf1XZYkdm2JHwMCpWeedNqznP2JW9xmgy+ck0FbZ4V35rKfKF5HVP+Mp/CJv4dV6fVMRXR7C+sPtT/mltNSPAWHeNfg3J175/BuDv3oNaOofbu0ZOaDPTWeOEC2vsSHAxtzSiaWxvUPsS86Cfi9V6e38GB/jdnK/sATuYpQ3MsHSi44gy+AQw6YbpsUzw31wAINPsoglInTrMpEJLnr9ArDfbhAnVRInoQk4Is7Kgptz/4w/wO+QuUgDNuz0USsTkbUXNUVAkueXv71yptnbPFUL61HbD+FkRhPene5X/TXtD5xJ/UtsgrBZzupFEuo9MdSDKwngC3bZYvQTnvMuBa+LDXvVWWKn9RZzsS+D8DC7qcVGmK0ZAEVHecW5r7zv6ME7TQ3OlGQddV1vE7NpebDvk8m2IknZZeDcyK5POatXLbw5+L0Xrx58buv6EQreHoibzQBR5bRcrlDQdMPkGMN1sRMbbLtD5iwR8o+z7TsAQxVcMHhxLipEZpWvorJD3UXRNGzYQNvkV63XjT5z2QJbYpdEVFuL+364uNhshkHVJ1WwyC6N7N6D4XgwW7tLlsMH+aeMQ3bWU2tWQFulUBAs3tnBA9KLql5HAkHjr9jLDMW3Eta2Ttl1VNU8iUWB+acwVOZ4zDO6pYVyHcCVj8QCfKkkZnDYMwBUD27Y+v0RystUo3lLMebmVW1+6t1GQ0stVSb0yeJ9sN/3EIA7tleKj3VHm/AbUAC1U3rM2Ag67ka9HvnYvwUgkq/1k6RabXbDxAsbbS/t7cIWAq8aLidnrCvqKrBxmsoKGpg9k2VcE29mGTZdoAaaX0iO+XM2MZlq2Zz8xUdHJK9PuVg0XpFqcEw5oOaLk3NT47mxvG5nYN/q2DqrLdK+tx5/s33x5OlaPfCAjjt1XHeJ1tm1EzBERGANJaxfo4iubaUJF7xL2/q113YvvP6F14BbTWx9GZ67xUyhiEOpRiDqAJVtnxctIE4Amim1DVUhlZJWRltOTXAFGrxjls1xoP+eLuZpESh/nhUIL9IDdAwzCzfT7WutR+xxtwCM16QelrvDPcu0uoRHvNrjTcI74LVC8HuDj2NBVh/sbMyrhHebxtAi8NAl67j+qHys2gt01o5jLwoaAAY1o9b1Ai9Ky6CiZeDMJ/mmdtapU8upm4uFTaVtxeMbmEQ3XcsjxWrBPxqRrCe4TUl4/UifNoxurl6RdpyNCp7iFrr/tXTfbeVZK8MngynfkrMNUgl110YDQ18fYuf5ORYSVg/joaTeSZbCflgTa2B3Fgbf/+7Vgw8M3hlx+MGHjYpRKWSMItELQwCdDpkAgu1RUeZgE9NCZ1NYfs6bqxV2onlgqXu5utbQenpi942zbAmoeSwj2fZ6YFWsh+m0f5Sgh0VQJudcLHvXpO4VqkfibFiINF+vZzfzTZ/U3MSN4npTBk5sth2rHJcS09ENIwB73xj9Fn2r8XPi9gFWREEsQrtK/eBU8qyMZU0Esl49I07yPhezkmTAr6PDZsyKrIi6lagS2X45LAeuLHsqbKMKJzbcEipEjFlYjW2mUaSZsmE7zDLTfjMTfN/gvZMjNTsxsROzpYLTpqsaNhSX99AcM5xi+UaqWkamTKbyBWPCvs8cbeXX509VX+ic7JxePXVqqdfoeV2D7CpjwvQTW58YOaAdK+VLiErfVbEF649NlrpeOGbO2wX47V8l/Dq3FtzpHvFMb9zNS2wesjB5scRhiaIQwJHdJTRky2yZvmot879CmoB6jtiGWOsttY6Hq+E39RNlUjd9p6q1S00nAQwdYLMmkB0RuV3OSu2Z1cnoWI0UgntqKM5yl4MF+jd2X7vq+EtXD/5k686ROUdzxor3TN1/T+MzfknQeqmdo/4itiGxjnzKq7vn+6SX1FzU6Ii/wlT72Ggmm4Wzbk3AEeNci8s1tQG+k4dazEK758gZJwtrrSmWwQwPyEK1UC+2stRaKZOeyuFAJbwGR6zuHgcL24mafqcd+EkShl+72Hwi+zpYSobQ0XWqyJQpeBAryXYUvxBKd1xgiK9kE8U2aEYlU6UJOlSkpVTHSCR+4vpRNYo63eOdTQUbSKrATYSIW8RPdpIvTkB9O2aoRw3HyhR515MoOvYng5+/fvPru4eVwe9s/fUIh0eGpgRNjaXaBaBZZUByZWPUmnPy9iQweDx495oWtZmmU/gXYMIKoEEaWbEJxEMsiNg3ZwE40gIYnjydYRVnzL8nGgtnZKE5157x7X5pPXfWPlsjEXhyYCv0OKxEFe5B9EQb7sgz4YQXJCkJTRsqlcZ0zM7aUo+ml9TT/FXewYJjEYXfdbFTWLgev8LJN98b8jjCHhyOum4c6IXHAdIYUvMOuIc4OchlNISiPsKVYbjprdf/UljHAkWqGJikukKv3TUav3bV4PnXrx5c2fqDkZKOnYrU5I6nVafhhM+IsqiA2bb5p8ESM1qmJWLuUwpHsvOVg8Y4PyYo1xIVDpbdd7r0ZTT4wRnZA4AVnw66Yc+yvLYH4GAqyYdwStMqI4whYPsMsa3iYUzyw5m1HZ3mbFOv8IP2vPaAf3vzvtaeEzNPa2TdWvIX/EejJzq1KsJfFEBqtWvNRqd63D8tsY/RIzJkP6GbdM1uVlYAT9ctkfWoXVDJrge2/jRz1eB9//3qn2z9xgh3TSw48eHE+jzQZIEVmeUYGpIAOeftr05HR0g45heCsWC8c0f1UJCL825R6p1sYkV2LQ1t9QApkMDvrqEia225efziXwt5anBV47HGOTfwayJCNc6xTprow+ozzi3bwi/dgbUtH648krm1cD+GSVGlg9iaOq1mSPaQ1R5STprNzA+1R0sXzJYT0QizZDrANrKrtfXBzO7ei1/+3hdeu/Kz//79m14dZoPB1n0jhmEfDsCqCYs9RIbb7DbbY3ezg7SgT5TuA9yUVRTB1LbetGvGqrEGcPcE4QlwqZD7BhZRhraryHlPtcsZS7d0Dk535harQsyyXkHxBGudNXlMW7RKhtdplW3SdedF+yxgmOGXkILAq2l485wM1/OY6C7Bj1kq//QQ34NVB3BNAM5KXBWzye2hgWgAHYhreEZzql9elcflyqO1ZTi1Xogq0PE46gcIpLFObwKL16q6xzEow+yEtq5t805tKAmiNPHn+UHQ7y8+HS6HS/XLHAgtY1E4+ACLaN83nEXaNRtaYAIESytrODalBqqhaWTXS1tXb2lYI25T29IVi6oYP7dgW+qKoc2N77sbQ+2f+c7EOik1XLOcKDHDAnxBWQm+0pYfEzip7oFfR+/JAiMw2tnv3Jjqw9q+SWLV0IdS5QowLscO2SZ1dFXTMvPH9hZLul6cs1QtJ83j86RfjN3jZ9r9k+eqjaT+zJWkhYIfrvQ9zn3LdXzbpaSlXtjbnXLtC9d5qZgDhgYSjjHsehWF0P0AjIMb1epqQl2tZtQnL02dHt2o1CoJkFcv03QQNNpfe4l0FrtLWEK0fprVWM0Ki4DO0gZnfxr5/67K9nXfkC9tfThz1cvfGNz+jasHz25/ZMTnJzco8HzX94Jqs7nJw1QmzJeh20R1NX/N2yTBZXpZv2yv0p55HLmpbMtFLnUst0xVlrE0hugV3boWbCCm9FWW5aN8LzzcCjUoZpIsNacUy7n5TKZAZnMHS2XXlGpsx1bNXmA9+qi44p0VdfE8sG/flGVOsHTCNA1TSOugeZBZ9DZ2kBfgSdlCg4c02jrQyJCo7NGumliP6kmEmUhfNOAot6JHu49urJwkYcKODaHxBrrxVeXA3IQNmwG9+kxZty240ilxWFTc+ZDMJdlwvpEFRomxOdNBCRtNBbSn+jp2XMYFiUQbltruFFbKj5UeL7n8FF/msWi4CUCcNA+fNlDyRoK1HIfr377t8p5vDfJPPvD87d9EvzQ3ODVCdZVew3g+j+5iatTBHnJwtmT0yJBg9+xBjZBjY2B9eW6M2Y4qiugwPPBHNq9rISWJU8UKBXEmwL3S8/GcYuMfGf5gzTvOGrLrfk34jmReWhMAP05XrKqIg8iHi6sT9KdmAM5Gh32vAGQ0XApvVhyZxU7V4Q+C2RAGrPL91BTEfu+wDwTcrPAyzzsVRhSaJEPNhqk1281WFDWbUXTpeeCHYTgURusbYSjlxglkAc02FiU0WmkdILxc32JpotTEahds9EewGsO2GSaYiW1s/7HNrx3+Nco+C1bcZvvActl0VlIHfwABIGc7IbA0NqhaMcrGDRs8d5z23Y77LOuJmkCBwIA/IxNGwOFi6cyv3gQHuVhI26j+z9/+8Q2vDDpvDfj3d58d3DmcvTh4Y8TmYCSAYBgloXAVsJwmSpIumB3Lo5FsuB4NKsRXncIQ1ayirRhZU5neq2SpbT5Cy8m9AeAGkdbd93NNjYR2qxj+qgJ++GJgduwe6zJPVH0gsBKJSHZHny7ikQfeJWKx0SNGpxIMVYKKKAP4tBg2el5EsV8zrXbWw0zH6jUXsXILf3frJJzOoL7uJkQGbgRr7InAX/K69qredSInNaXYg15stCK3TgCyYS5KsvN2i0Y0wCegtWhYOVeg2kVid/x4yI/DsFsL/arsyJ6sub7v+f4Cb/HIiHVXdcddgxE4FnaFK3xGLSlAZ1PhpPmMbRhlo8TpztMCJ3gNf1f0Rlii7O91lfZoWI6KruGXqwVZRqlkRSemZTgONuyUdJv//3S5bf/O9nt+tPXfXt/912/f9bc3vz380++/89tAilJVZJNhUiATZ+t6bMJOlz03MWv6UkHbVzhGzMrsI6aulKwCn+JHvEo3Xy8LjsSTIZVgcNZswC0Akio0L0vBDCojmCmjsj21Ng1O0de8nDsjS+b9Zl6fM9SKXbENXvRKWLcLq6CMsTKhM231SbrOTLsbhDJxA9kJFns8AUcHh6DacK9B7QDp1RbjS/Q8WzPPWhE2G2BUGJ9WbCd6x1iXsQjqQUPWpe9X/QgHUgRERnFPw/IebEAH92G4GvgSHUhexVMwjjsfVmKsGwjq1U4ATDYVxUSTNPwSHMW1eCVa8tacdbpktMuotBRh9M9x8QZNdzIkRc/imsBco+oQHb4FEHnX4EOD6uDzV21tbl0/wqMJTzdN2/YtqwzuVOjCGJvMajMV1Zutl6KvPJqGZQxX92arGW+Kz8MWyBqKrdoUluTQnGlX9AP7uUNQERD+FzwSXsF6ikahXnJpwJvci6uBJ1uNZoP0+3FUC1Yaa25Xi+0zs4vFqoHQHPY+kIqavmH3KHnC+v6VxiJ2AGHjrJcuIywfStel4eUdRTOExqi1/MzKjz716vD1a+/8+siwIj7KDtNZhuyDOib/kKtJS+iswgqMAZN0sGmU0IbpXSO5Tz2KyTlTqLKipWNQUsBDFVqxp53t/0UexdKNW3mRPmx/WbBHjY7Deeyhxg3G0xW3gQMo3A3eYJtsgT3Pv8b/gp6yIysp1FS3AawPqz2AMTl/w87yqv+U/xx36bP0AqulnTAIcCO1YWBiSeUqy1FwU4YN5w+PnMpMXiS7XnzlrT0/GNzw1vXP3PP27sGeH97y6vAHlrc+MqJxf8wFkp5YHXbWScQFsPS/8YTke4b4HaKcALbbnZaG74gaUfQfNTAQQYB4MvSAggESSH0boDlMxAMHI8MfsGq0K88QuVljQyFr0gYlwx86bb8sOkHdC3wZCc9ZsjvcRcUmM2BMZ7P2Hn7YI3f7PmMx91iC44REj7eJ2CgtDBk1MwEIIYsc40SapZlwofMVSr1JNyeuxyXHvou74cl/US9RxTEtuA6H7hSVcmaiQ7l+MLedGfkSkL4HdVj5CStrFa15w2aWYhRdGWTBp9HAxtkmGNyuy42QPFU9G5wFs3x9X2AuZI2/TDdYn3UY8nE4ymBAxUnHt4B47pdkn9x+nyiAN/nJ1v5fpqXW/XfeGrFYwQKDyObMVD0fiKVBx2cNrZCp7Kdj8Iw0zEM40TFP9ctLk1VrQe3ZJ6K6V/MQPYB55oFYX/YlqYcnLmMRPHaIS9/t4PgYe4VGTjV7GhslS2EhJnBmeYmSpd8bCUtMUeaVed2YUEjeGNJjwBRLfMVv1RtxIkREMaOA4cIGHA1wzPCsyfbv/MuJkd57T/PYvyiXxUlvwSNnwyFpgt1TvMPhfbLi5vmXnSJVOPUVT/VsHwC4r0eM+LxBsQWkW8XaDr+BFdpsA3NK7IqzbryqPFv8HqlcmXlp4vFy/8hZ3FiA/r1KLRMWA8PF2SI5eBoVnWhmuYJn1gELXioXpvKH84dnbmMKRx0c21LnPuFkiD1rTdrz1qTQzFEnTzM8C1bc9g0X84qs7jyGo0AAv9axNtGNsHDEX/YWvcXgrLcErx6YgMG/HXRH2srCWPtIbSYZA19Btz9eLpiANqTf7FxpnmkuVNvtto+7HDaGTXYt53++9YFfXrX686sHf/nOz0YUx6F3P/jx6wzjwMOZeYBvCrxoKxcriSb4guPJekJCAFoo8rKxDn8JLj+BSaRqXIOvdgNcaztIRAdYtONlu/mWIwo2+c/bT47MOTnnNvUBoxXfM3+sDC5pjEy8j3+Z3uh8wtl+j7jJL7o6RjJsgx4Bi29EamTVjGfYsyHxRUe25FPBL9sXwE17IvbrUdxJVfUjWI4m0HifGN5X2ZhdoiitOencqk47BpsHwi4CgGBoXQA0E4GVR8JGBPUS4d/pyKF177xbZw1a873ES8LQi5Kl6dW8xKYfJhz/S9YRi4jLQ+IUa9FUIQTeCyYsEj9qNIPBe8STHBalFcGRZn3COtSzwnJHslv4IT6Ge3fXU3f/cuvZt68a/Po73xzRwKTqRS1HaZz11Vg5Pn5xr6TNSru0OZuq/qMIR2CdKybwGRGG2QJwsGD2wR00nUXwnejJBZp7ATRUZv39feR3dz1TDi1XCyysZXOxVcmQtiSqb3HFIT/ZXhtxKFL4O/NjB6fuMopaybEBORZs07GVPZhFQmBInKI96ozSOe8rfrZ+x8nbzk1HVpTK1KJGemA2ncgma5VL9uP+m/GFU6uvtZ9gK/7z/lP8KWvTOuvzwuXC0/Nr9y6RqXrZPeTqKGIkDf8hrlnkr7evGvHtiEasSwMjHm/c599owos7ZkYfF+W5nKbbLOcAAM/A4ciBH8qEo1XLVWvHzpS/G307/KbfXXxi9dmlpSWHNNg5cJRk10L2td2PvXrb4DcHf/gPw/7g6XfoyHSlVFAmrbJUo0wydaqykbQCi9fCWtjoujW/H9QqPaI3HPFIlRS8oe2Z7Mjwmcl5pcQLHJhIvbB6JOSPbjTrzRriGIlPPGZuqU1yC5aLU3QcmimSQWf7KyOpDaRlC6i4jvMMvIyX5RW2/R66/e/YATjfurlXOETa6ripZ6dmKgd4htuiHMzW5jfUs5Un7Sts8D8DPGKD32SrNKEAU2a8rItlhaatYaN2qksC1l9hKjGu028K/7N3R/Wz8PAdT3W1cDbOxGXP9FIctzYGDwhzQYHTUzR+2jitr4hTUSQTCYZWdKsBnJeN9XqX1FqOkSwlS8Gy/1hw2X1JDH6bX3C+60RGR2+YrgaU0HKIZcMRAjPxjQH97s0/2D24/a8+++bwBwfKljNCWUH5V6rilFDUSBEsMJqAtE+DswfgHhEvDEO8rgjLXFvcdRIuM3XscCgHOrj5gsWvHfz77U+PDF/P+a3sM/C6AYj1LM2h3OuwAi6PXUNT9Et0Q5SGxLivdmgLSGvfBU+27q6IX4jv8cGHgRl5PElFOtPmKoBG2E9FRUGSvLxLUkq2P7z9KTiBmoP1hmUU46lYjl/yFFGOHRRT3BFmYzsl7gHzHZw9V0uwoi/N/fQxVYIyzG4S86jSrywyrgVqoIocrNE26Q3e84W/2X+8883h3xp86Z3/bQTMTCnNsNvCcisyhn/0JO9YLB1u5U56RsMBk+SBn2kaDS9uYLFOWpjsA2mquT0nBry8wsCjsvIGTzvLcWBLfgXosi9CLUVwOPkgj7MIK6EjMO/ombpuGkzxK2jF8AmFmovlE0kFSPv2H66PDPuG7ZT4HK8IMI1k+DbfOXkUs7etWUCRZVdxARhK7OhTwUEXRd6brgLo+EMpGL2W2wl+l7bSIg/PAdA5fBsOKboGPFOQSrkK0RWAT8FU1xzXadAmgJoq880q0mOBWA9DQKgGChwOUJavttQ2xmTg/vBzAPYFVqTXy9V0Clw6VtERJXHUxbgFAPY/eeGnVw2e2foFtn45FvyjaDgZTjeQ8KUa7Q78l1lWx6aOjhL8Kz7Z+dzM3MEjhm6ULc3WALfr7b2R4to4241Ia2l2Mbc+uzqzduxbn1ufX6rCLbmppKdww2o9vgYMfSD9oEFDta7WbIk9j2agJ8fO3f7cobUjK0bAcBZPUm3UTqyd2dxYW1v+xjfQZ/hBELTazMv2sz0tLitkIP/LCDhgr1LP9kw/SwsscG+945bbm517HiqUyiqKb+azlg50jem8xEbNoDkZKL6GQcvNY57uq8uzG3M1rVOONbI+celgy+wYrVojirywDpjPBYzgRTW1/uDpclJoGAEpNP/4RfApwoy0mBRa3dbQ8mK9vrKw2BVev1WPl5fqoSclhlRCP21A3Vnkja2/HbEpSnfmMsxqFQLTN5HwfuPWtemNiTNHTkw2KomC+Nw2zCNThyZuv+PYfl01DKSqDlUrapkacAwsaYIh0arl0JWMOTU7vqbGl1v9Xhz3F5rttROrS+uLi52lRVSHdVPpufYFhsMK7diKjboRHTw5szCf9kbrgR4d3RhbKSd6oEWOS5x0khh8A4VcIyUGn+Gr1bJOtmfB6aT8j9aM5Zm61i8IezG7MteoLM+Sbr5QHNI0AyOs1tjk2PyBCVs/PPngIaUcVXBTUMc2gjKY1IbeqnTDVnDpzPpaHLfrtXhjYWXRT7xoM5UB8OOgSpqrpsWQ/IRAHqM8dkDyEqz+PY+38rc8f+uV0M4LoggDrM/OilbK1AYrpHmCG2TXxuC6f/rY3w0rW+9/Z2bk3Xogb64KSFVm3BIjZWafGKIdu5UaqbQ1DO/bCCx21J5xuKsXwQNZfJxgk+y74yctwtX5ytB4fjZXzBu6pjsolZM1dNs2FFObOySUpcJqLqRVlwQy9MOoVj97GlCWC38NSa0+NHy9HBsaVuR95v+u348aD27Om+CTxpRTZpNumdvtUsh6TsPpRASLVNB+AZMCtgoH56Tos2VWJ3ShtjjUXPNDpHiBu9poRE8/nYZhsQLW7T8l6sHz6hOjzxFgR3E6U5MmJie3f2qkXqnf40zZR6cPTioY03P44PNDHbcpI5185F+eAI5bdh4aRYVOdEWWZc8CuHdcC556OVJa2mIl4P06Wagn1bATNMTaDgVEuU4VZUuTYw0UyXp70Pr54Hf/9ke/+NiPP/23uxf+bvivBn//Tmdk3KRsj/yiLPAjNhn+fpHmqclNVDMFn6zYCo6shA81TfBUeV4Utq8RF6O7/zp54Em6gUooy16L/wNd5Uvghsnwy5FcCjGQ0Upgv0s3cP1qi/nZRa2qJ2nIQsAimEKzMza5uP152A8P0T10+381N/gtdoYdK02D0bDhk1HTGYi6JrfvFIzAu7Zvob/H7uUTsiArQkG4iHrpkeWxBf4Y/3nvkkdW5HdqxyXZlHVzCBwPjyMXp++Ihhe22Cp23thSiYwA5RvnAHoSd1LOXvMg+6qxfVVu1p5ydEZKVAzeNyS+KZ7hvOW02AZQ/hA+KjJqsoWzFjA0K4FTBqTa1yKrZYOVMAMjGJMPssNMYyZ4dJslQ8yna2zNfpsbvuh5g8+EPbEEziNwqnbVr/KYLyRYKy1Fk7fFSepjix+N0OH+c//vB0/9w9VbN7zz8xGbFcvFUrFUrqTiCQ7K8tqmTU372CPY7gT/wyKWSbH9ohIYC8Wq7rJQxDIJ6g0fvgRPeP9ENSCJv7KC/Qxu4AdJFVxZWyRMGuHcghKUTLAopRFNu+tO01QqhRlbNeZdvV/sFwLR6TSb3Gr0wrjZqddIvV5rAnRvypYV2P5Yn3KDqsjlv7+dA/BkwD6qYNRTs2wb6GeWK3rZKBn33VuaM1Qla5aJWTbKlMLHXG+MafvcaX6YT3oZPx/NBNnGxE7/MeEsUWrl5amV7IqKgplwV/abvO4FsPQuX/ZeXDu9QurJKazrkdjWGgR+PQg8v3n+3TSIB2bse84i0V80LlrLQJaq4JYX5y8Xe8ce27N4W30a1gag4IX/OBLZie3TxO7kgnL7QPuD/Cb+MC0XjpbGDT6XnZ6/N3PAInnq8LK/v1GsFzbNmtEGMNq2v42jfkQAQHq19b36cdK9eObyQg2H2kR2w3SCutHSA1FrBqGfdpAF8C5AVLs2n7/zG0d/9qXvsNeHP/jyO+A0MR8FnLkyjwdM19M/VYkBEWFp/NphBeOc1NJmMn92DgyJFHWv6QMGreKIrI6fuE2wbLg1g7Aqw2gpaYTw5t/1qg2MT0i584+4FtAgUsUqTZSF/yGpVKZ5U3O01IJgjQ8xLF3Dh+DoqDYw+K/b7x8ZBpcVRu+uNpB0m/uh6yeLvny3jjUVRSWB21jh2PzvppY6/YYJzqvcYELjJa6VNR3gt2MjotF1S7cM2M6Go+ZQUZRh+ZBZhgdTIZYqGezDAp03CyytTUVPKDRR5BTTqzhOlYApEtcI1BMHuPdbaC2rcFwTXIl0GhBYwyCdH+J5YPjhCSwQ3pdJsizSunnCg4Rxvyqu2TX4nvz2oP3D276/e+G14TODc1ufH/n8+s2H7703n9fU4uzc0fID9l46D8yvLDSpclvO9fb3Z0mzsJ5fNnDqkktD5yLruBfCK93+MuxHHE3tchaUSWN0beqs1nA2WOwuhIAQ4eOXq9hSsLmw1GpVa9WVNdLpoYbITnWYEK5XXYq73tPWirVKXbPuoGoADniYO6FW55dGO4djXU7wB+gY405eHy/tubH8ELMdMOGEWupDFHgZvyHIpmMacHo1QGucA1LWVH2iVLLJhHaXM1tT/fkFKwHztgwcvxtsxEu1zVrSXWx2PK+TkMW6L3FGR0CbRWBziRoZbhrEFVRase05iQrQJvDagaj09Mb8so1RZNM1PWIiF3LJYOYTIx6vqlh+hhHdgC80ESELHrFT1tq+5EhySN+bnSe2rZQ1ZWZibP5gMatThooYAPy9qU7lpdoLta+3NzdPkVYbdhk4Eex4Jbu2frP++iD71mfe3j14CwWKTm79zoiWZo4cPj5WKebmLCd7UJkvHrAyVAcjiV+hiIjsMoO1ecPxWY1FhZNmyMTUZpo+9Cy/XFODbESGz8wmOa8C/k9GedfeCZy480KhWTgXBUUz9Z06+NysklGypWPgQBmzAFxp5rQ9ZU+7D4dT0gqKQYXEWc+qKrVKe0eTFPX2nU0lciVQIpfWrCcbGMURqOu54D5/CtBYFOwkAdI+h/Zm3CVBleaH6KTIeMVw1is1ckiahBOUnhrFlgisd/bsE2zDI215KsENngoo8Ed7vdpSc32t2onq1U2/5/dYz+iTwqW9Tx5YGe/CQfSpr9f0iEytPqRMFMj2P35xhGvrYGewBQZ7kQOf4KyudIyNDU5P7c7HecAZDPWmpvX8kFG0rLm58fF8ZUzNmRYgtWO8XC0vl5fpin/Gf5Tz2irpXWx3V0IpEgNsy9Z7MiPD343smEWiKX3W0ntqQ61VYq1qBtrCqKdiqIQq1CDaRCF7aHYiN17Zy3Hkg+JPVysL9obTA57W95aDRvM4qS/Xeo1mtYaT6MkuVnvzxh9/4vL939764zduAIJ/01vD7x1sbf23EaA2FPySlbPnuYqTxhkZBpv3e+ZXOdnHdXOooIDVyssjdeMVTh7lMj/kHqAH9Y+Z1/Eb9OsZfHcaTM3uLNPFNDBErSywnVFxVGkY6QTzLMsJx7PgZwDHUkzhfBa5sAfvgls766AAYN/DGmccgwPfXRLL7jL8qt2ropZOzDgLHAr8nYWog3OscI3Bk5PhD6WmloEbqQvpBWzd3NFb963EEDowGMtWXDL8Z5osiEmu8HHHScMYsG2lqKWV6olYk8+xrPsNIl8Us+5T8kn3tLhM+KNVMXRCbLgnIjj3QAZdz8PBVTLs4UC5/Jqxo+aFwm9FOF9w9I6+8tbgI9/64qu3fm/w8ed3P//6Ox97c/jUX269PAIPX9EMyzasdCDHzjw7IK4GmHZYPj0dG18vGCKY93PyiMx4E/JmeUweEtu/5WeFVa2AwTLDkmeT0KzxJb/lPlZfCTcilW/6p/2T4Tl70YlF5AWoWO2QRUdy360Gbs173DsH1/6YrMsGYPVFxhAvoOQ0alxKX8b+ipd4ZLgbyZ+GZ8UK9s/AolRraTSjLFRRig/IgpsRv+uUiVMIx3E6EzoX36pR30uHsIlAtJsChzid4I8S8ZZ9Qe/tSPLyevFS6VTma4e/PnFcrY6tY/764ErJJYacjXQb85XIiwwday7KCv7XzFQln53IH83dT2yE3bBSyuG02FhxlOKd2h3GrdZD8F/S9PdGWUYm2H0mDvIy4ZWlXyigUDagP0pUm/lDcJGDEd4iS+/zMYYslrwnPZTl9Bw0DYs0isnwn4NBkci3g5ilU3WlG1b1hulPLRz1b65g/YfDiQG+0znHWk4XuxmUx+HnvG8td/2nG9/014yQ9oDLEilj7Dd0Y8we+D4mGYAZYP0R89i7bIQw38BpBWC087IovyQr7JC9RwFGiQ2bcAoeLjHMi42VgRhsvbRvpK6dOpqUk3ITLExciPOI9LN8hk/xHMNO7i5lCsVB76em2TyY9QLQlQKcrW7QGnJjGWJ1V3MD56+1TiXtsNbph36EgNsE6v+Dzhtbn/7+Vf3XB5+9PPibt67e2t5aGdkJjTFhgosyYKEr1ULLcuf9qeBArligFBuciMOnJ9SCAWBWze4MS3ccZQpFqZ2KXTHm7Qk7AzuGfQVushiNegWv0jriOaFlAQEwcAAncExuGvibLGo7mdIRfS8nR3g+GCoEYHHao8ddr3JCXac14DPPRierZ5LN1a/1+km1k4Q4Q3Mdo/d0ZQJXBDlYaHdjz6tWPSzLCEqYjnY8E8xGoV6p5oKin5VlarBJDUv80jACP3RULZCje2bvMY7aGStrjlKF3STzctYtejo4EwO2ntrbVyuQX+UUQz3WWoXjc7BBUhWj2PiWsSlb4nTkuSSdTSqafq8ax+nMkobAUdY7g0Hgj15BOkSwEwXs5mjbEa9yZtfheHbcWLTl+aVW3K2ef7S5QIBB+2JHMAhHd8FXGNZPuB1Z87hoiga95NSJ1aM1Zc1s6vW5DbUxeRyTBrk67JsP7xmplSI7ggPqph/s2i5iEOvdCJvj6j7YAowE4GxBV9BaoT0XlJPDftY7SIs4YR5rWlLsC0DbpGbp4JGD+2c/s2/PSuFn2mX3YvuKV/fqOD63dzqukyBeWE6lboD6wb56u//G4OMXnvvRYPTVqwcvbP0ZjvWOvThowTFqs4RhSgdeuC5KHf6MZ8HJET2alAWmwhMyLfxstNWzBSw1PnZELR26V5nN30HMrHmEF9M6EnAzYsqfTG47cef5qdAKEK84G5UQmwxCGrCqc1o0XR+smi+q4ngtCrFeDS7Z7fRxIIAX9YEk+GDIR3FAoGdUs229HrqpDEQERjSskiAS6aWyDmo68kVxXrwsL6MWfj9fNXuVb927MkvOH2rO1R7wSrKUVvDZvk0ivSGG1mF1wygIBGoXpiWwkpsnbFSA8zB6WjhHBXHc/ComrlC8x47ufQK32SNrWkSMYKgLW2wxXAXbvlBrRpvrqWYRfFWTxqmg5VUdRzaI27YYbbJEBdgNpKKFcQWriouHIRaHjy05ghhupoZTUfAuHG+sWk7FH0xhiGOUYfCYp4fapjllujg9k5/C+bdFB+AG9shr7lcBfehCESjn5m6/n8JHAh7NwWuC5Qkd1aIhC6s1UekHOLhhwKfDgysbKB9rAY0pmwadssgtlcPLmSeUFSdmm+xR72S01Hku6Z44s7Cy1OrinMhZniMcNdMB5NvcNRE0hLRh+ziW1nNxz7jAHT0yMP95pGPXrL6ykV+d9HJCt2YsXS/PzZd11cwYhxUbq3Y5yQOXnGEH4dIqCmGrQ2zNZ3bXadBNZKuo+N06sbS81qwCwuwCHX2nGb52zxuDm94Y/Nb8pdd3b+17Y3D6z295fXDd68NlBSzkj1L9Sga27oF7kaOZqq6U5uYetopWwdStjDmnzzvTWGF3WTudf+XeK7d2S96s0KgJG0hpqy0jwirNHNcYqdCsVqyYFth/WLmJCXwUE/vRomHzqGUa5Zl7CAozMdsuGTlrJv9p7+Mre2BZrLT8dBqBv+e4Dmw4VFyNrVUzcRr2xWAh6cXnWrX6zvy/gL/8UqtP/CCsBTG8cLo2TpKWOxOLAD5FMiR+gx8Z4ofd8WAOx1oKx8/2D9SLgelhVay9kqkbi+XH1C6AqqcUT0Q4C4gdj0LhiV7oA7TebLhA1prVHYEEcIkuFlz4xE+GfCCt3TLGp4I0IJEkAdA7xONujflmX4TiHBm+rIhFflYsEXGhQYdCNviwROwHsNR0Ss7d/G6+l5fBOM+Fc4EWl2qZRUoaLJQejnmAxxl7smr3mK9HqSik74R2TEPWIqxGawwL4L4Le+77/lrjH6On/ZedwAnM0PkVmIPTA1ucZMRQGSdAPeKMqZ+z9mFGDju+tz8Px56Ygj09xJ63XnACXIV/bYLF+SU+2F9wzQ61DBxeyg7iDdF7/Qn+IJ/CcDC+wzb4mK+6JrfYMZZhh9kMYQ9ZfMjk81mT51lBzRvTyoQ1znHwVMVXsEiike1Sqa2QyiZt8Mf5BSCmG52XL//keDuA1QnswErKOHnZl65JpB0avhXp0uxE7QiurstxWljVDh2stgvVdrFJSg1bVnwyF03QvEL+5d/80QincdGzPRtLr2HHuIHsRiFvGcvK6ng0KSxPkQpJHsjdmJml1NBNrZR5+OGZ/GyhYkzrZLio5C2LFcA2WwAdNK/QciKwaNjR0qI+69MT3sn4cVL9Wm1j9ULUqLb9IKmtreHqJYBqyCCzfWAEdhJ23IpgSOjwyAGjbN3dnj/z+g1vDO587eZv//OPP/vGLW/uvvTW4O23h48/s/XJyyNuaQjLCASN1Iao6pEJbpYv8LZ7Pl4JHvOX/MfjC+4TkqyJWm2o0eDC7Ntw60Zgu4fcDJtkGWfCuReY+z7zftOwxk1SAICTloSA35Z+9JS3mDwdv8wWUe8adilsbpeSXv4H1pPmcafFMBMZ1JAeSPmu/Ck4OxkxjzD4Y0fB2PZQD0FzK/49/r2A3YpckTmXc8Mioj/Eu3QJOzux3Hchqbonva50+Kp7yns5Ok0l36S+S0IsYdrp7HOxisfGts5mKkQTIXSGsw/OhM/CTvsj50/UrxQBulIb65RUBwDaqIkJZgAUcCgDPR1FbiaGu5NZBCr2DE+2ifMF7F5+5hjbTwv8CMs5U5pqaw5FKU6E1TabZtex3xZLxheJvd/WYAfnmGXutUdpTsxyDWfcViu+LlSphGqI9SfwfNkJ81T4eHU5PO6fcE/CWpyEs7jIGpycBOTWaJDtrw3+YuTp950HvneN5BiuJcPffKYmf+5fgjtuibZYlzG7YEesEWDeKIlTkZYKLxNewl7a4BHjj5x9dHx8+xa+xD0jMHAMOJZxuNu7seE972wPzSmIXHEKuEsjB5va3eWh8NnoRe9ZjmFxHDnF6gCd42d6QMMv8NM4d4xKhl0ODTwSoQfni6eIXuC8HLEG7gl7zEIqFURW3r0So+Z5VuZk9L16KpgMW/jBLfVbe9+8/We7B7t/9uW3BvPfnX5z+Hff+fo77wFyOEfn6B4zw/bCEboJLvOTOgcijhBMA2dgyWLwMfOjBTLsfK5SoA/RuwHBYmcKGKQ8GBse6h7qEbw7yYdwuoahYXqer7ikJoaYhXkMMvU+cbf9QXucDN9mPmJv/0/qI44iDGxduGDEfr/qPAkHZVW0UDrUzciLZPgL7rP+z9gLhF0e6oFNX3ZPu8vBk+6jLlB2QVam38sfNm/WPmsddB6xjjkF82anSIb/k1N27sJwFCakpREqmGbcNNMS/ODd0cZY3YSTeFkQNimSsTpqYVRfA8DlyqpMgjM8EABqVqOneZ2jpAMw/Y/6PfcJfpmvAwCD4/2TpOntqKsChAZq03TPyaZLqrLNU/WGtAE9iLzYTQUVjZZsz3JS4gEtYxnov9z52u6lH1//7UHtJ59+e9h/57qtV0ZsnouxfFZ3NXc+nA4q4iE5ITL0gEX5w5myqSi2SqiJnNXkCiAcG2dTF9yj3n4xiSoFM95X3Zws8u3rgFoGRXcebLvG9pbvLBw0snJeajV9g9hwgewF+n33//IxThyyHuuwCAdj96Wr/pC51NcDhFbIZzMAXkx41hyAGCvBL8PqV3Bqv8sq1n1s+8PeQZlL9kd5AAMY+LAXZyK7bgSO55DQOGUvu5cDRT6WnEvK8nKw7CZp7aMw5YzIBzOeSQK9VgkcpDE4ylGIejk0IlMi1lX9nbwWI77zIsUnhy1aLcBi7fhUpx6efLTTi6rrT/VOtS6xRUI3sU8dXCCqdLupEDr2QIOBKTbfda6SUHe+XgptqaSTf1SGMGRtvd4Mo7jhRV7kwzUAXhBLsiqqRsxj7qs9G0Fppg8MfPvXHxo5Y50vhhVfmzs0mz00diR7RJk3izpLmypRSjt4yHPS6cTS8bXIwTmFT/NlukQDs2+sq/28n/PzxqHyFJnaoxTHx/PgvEqWDfS5wrOY5fe0oNjDvHqlocWE/WKI/TU9Y1+yL7gt7aLVt9baOPkwlcNrhg0XnAw7BYhx64uPvzy447Wbruy++IPBD94clF699YfDbw/+8p1fG7nRmDb2qbPmI0rRKJoHJhXFsqhuTzODHgULewPdS48ROkbvs+eo6hw076TgC30DtcIAW2Zio2XWbClWcCBZRRyXJ+UJfzVY9TV7zV/1X/axTWGH4yHQI1Kiplfs4ohdItQhUQmVCA5YDc5JD34sCMKQ0eCK97i/4p5zT4CvOk5ES7jYRrWQwdnFv7jBtySNjcjoFdYnQrVaqB3gWYIFgoCVDJetA9ngHOdOpiMv0e+J2Nefs1FE3glopB3PHB/dyHbHF+86Syb6ER+q8Y2g63f9S314wBI7weNgsY9GC1EbGf5BHNdX4DIazhpabTu0Q637yBkV2QTw1rn6RG0yIFnvTjeNBaE4N1cAb88ZAc+qBS1TskzqoLMjWWpr4ASLZkYW/fH89oPmfmfemaRTLAvetmO1KT/KyVEwzvea+4y79c9rRU6M97p9uQwYT4I1Cbx+8IL7dbnupCOgqmxBrssVONXEt5aCOCLDl34lcuHHQOVSku1KnuIrLdXmwqn1RI0f8L4IkO/tEpxemobLgbq3rJdkQzZDJw56jcG/XX/aW0F8juVcwMzBpV+gODxJpIMFkhjPHq5wNVKa2OsdAscKqF+Ulks0fx8/5pDBDz88smqdyi/Nk+Fmq+TpKNgkeLGYyzE2pRws3OPcbldY3tSxPUHy84QvsT4Go3jEIkIbUTAExGpnKLsX+mu9k80nddjV/2Wr8+e7T7/1mR8P9rxSf3vAvgt7+v1bPx1BIROLV8Dxl7jGHbajepPKXDLHsW2tpMwTx5L7XAuO4jQ2Z8ovi4+K28WdKHAP76zAGtI5+bBX8QtxIXQie5WFXj0USVADdge0DpbNbtAF+hQ7zpfTNIUTW7HVV9v6ZvFrE+1KU12cDSskVKXuzsi8a8U6CcyWGIqB6wM3kRH6aWQ3WMq7lrY0pbNf61mAbwLpOANioPvhr2YkuV7g11CWr8kTCtaMsB3FkCXn0bRT4W+w7yGyAmAAzwBFE3RlXnLi/eB6+1pON/cjEwu1SG3PMa8xnxQl7By4BNmqLrbg8fvEbVCZW5o6mV2e3Bg7+eBFHfy2GmnwKtXA7gCu9CTx5LmGL1DHpx2sJCpbrK01T640FsNaXPe7XpOetuCYMSnDw5v6tQ4/2sHJKdhbbrj3R1MuwCGRZffSGWuyXNAtu1IklmmDaUGdCkMn4qtDYvs/sO08jVlQ2DCqem30pPOvwyn14N35uJKUkvuXxhq6V8aas2LY9oeWIosvx99ZuXxm9Yn6AjzvDXg0Hh5YLa3XMRo74SLX9Mu1QCskSvhgqyQrct4rCzIr7wrmLfKtm0bO2ptGV4/tyNlJoARWVReoDqpaRjaTy86WjpSJYpdMC8DYpYr5kFK2UGoDsa74uuzIGmDfGmtYy2bXSc67T1lkcGX7UyNMPB5dy+uoUUeb9HJao5ImOxeSltdwQ3GSfZ2u2OdzpGV44Ft5eXpiMp+rPJwvUYerjubMG/srGLYAyIzptP8wyLx90+u7F/5+4PxwsPnD4Ytb39j6y5G0jR6rnkyDqVQtGwbmbzE4aAEpKmesgjpHjKKVM8oUTRWyVwfbMsoPWlPa/WZG/QrR7rTcofnql+dM27Rvnh/VR/V5pkRqoLVpvfTTzuCPZN9dDTb4CuENv2ElZtWRGZdkXd0awkI4RuGxzquftQ5bX6b30bsY4i6WzvuZqe2r5ncCllSYVd2zAr1hRWar8jRd8Y8Hf95bq9eCx2qSEsmMQ9hXLjRPcYHktpUW4NgAYAIq+YRBa0UEBHCZl0adEpG4vehp2RMhDukDk3Fcwq4NAMeQJlsWF4ARZy8FbXmWk9PCrQwFh8PtT1o6QxFxM1BCHYklFv8BFmqhUArm0AhKEHNX/Dm7jCNbWZ37fFF/3F6x141Vc8U4rnWNDslfmLw4vYIdlen8oyUVqGt1MqjY5OTHR5YK5+4IU4bq6o0jnubmyDgdKgAC04EN3WdOAIAqM7xR2fS73e/4nf75zmkvCFyS+C5rqgAKX6ffm/7e7t5bN37nxrcH/reGl/+BjkjM29PIeobXAa/h4MmQr4TwFhlgSYNYjz1wXgdcebGB3SXVBtyTJ1ms1ksBa2irxbPm+WDV+05twydtuRi23Q0/iIwNu8O5Fmg+5wU2R8fsvD2qP4wF6FnnIK+E+cSoGSftHn/DO+8eF8/5ywCJfkw7tFtws4wUwI8AUzVhU4H9ZQa27jh5+2Gm0DIzjX3G9u/7txFuhdMYH4fziKPOhMWz7KBWMsjwck77fG6GwYWPUzPUzlmLzvNy3d3k/xw1yDCm6Gv8JD/L6saq8jiVR7QsKncqwGsqblYWmcbzRByi4xRw77K1h+1lf8oPiZIsSVVqqGsVo9YFYunmMdeQ1upEKurVwOLUXVsfWX5z8He/vKr35uAHrw1Kb129ZX59ZIdQua4Y/HvnMVY1B9dgS2moBZWVPbW51tTqg375/FfJ+dur5XYuAZuZCr+i/LAVq0CDU5IZ0jZKCcOTAWjiyRD1kzjOZfYifp5eppedV9im81MrjgeEiKZsAg6JUIMBfo+bj+YTwBqOSVXVwkn3iv0Isfbyj/gflQdReJKI0aFKY/5EuTW/es9PtJ7ZfOgNvVVeG30FIa+ynMrguY5L9NCUZaqykkGt8hSz+PYH+P/B8s467airxSU7FYQmXB45VUnm2/l6JSiFB5vpiAHsog5sL+3XTlu9BNhsobmmpbECHZvIHFbzpXFt1lZtFR6rlb+BK2RH6RO+FFpxsqwi9oOXddxi/EjzaC8T6gkABlIzHadtgdmkHb4Ia72ZVN2NZuCH4PAQvpw/szPS1/O8lZX+ZuuxsNtYB+OObZ3YobY9wm/jt2FGiGAxYppcTzNaVdgrPY4VtOkpFtwPUHJu+7mt/zQiwaj7wLQXglTegVfNthYa/czaZFQKjyQPaoY6TiqH5w9Ozz24v6LO6hXbZAqfBxieX6KuVbfrxFjkTw3xE6KbRik94dXfdBvdc9WlIAmrpMGG2mBc3DKc318Mpt8YfPHruwdbPxio37j1e8O/GHxqbAQV24DR0AueDxT+2eWlTrsG20UXTs1esqq0mkQ9Uj8RbsrjvB5f4k3C6pve0MvBsliiNaBnVb7EHS98MDjgPyTyooRVxxjmAqKB4QXMkoRFF1DePwX6E1hPO/wL7qYCfanJjGL6tvYYDeF3RbStPGGsFl5UasWniN2oLJuRVjNaakNpHtvEqpS5TopugTqX/fuAjRAMy6f5TNOyC5XMMXW2dEzbrx81M/SICXzBOkynCCvSivUwLYAxwMJ2TJvYjBnCgLOvqZaJ5R8YF6oUtZwyps7ZRUp5xZ0JZ5bK6/t+eXzwkbOvrz935vGTTdIKE94w20BBTx+uVVzRqlYjP7AalfVyr1S1PNNPedxYy9opXZSWd4TnrTlTivlKSdf1bK5cLuYtk4w+WJ7M7S8eLXyFHrXv4H/mqZjg59TNJAdxlAX2TBMgOuWgUpvpT+GosB2FnwsTvWu2Hhn8eEQVQ7PubTxDs3RaFNP6cCT1yeVwo/lC9zTOhPKcmkI6hbhUn07mO/sAk+q1cR+R6+87bw32vTb40+/sfvKNG98cvPry8P89+M3HRlbex654g/dj2D8Ae/G48oN4s9UKm/FSK/JPHH9XRzAgfhAkXkiC2lBwNJ7rZbu5mC1bNdj3kZvOUgF7hvsRjse1Pj9Rb8XN6Hgc0yo9OZ8o9VLjy84cVdQx8//r6UpjJLuq8wymzMV2nNEUBZGSzDhgBEH5QaKQSCiASbAAE2RsJ4DHnmFszz69TndXV3Wtb7/Le+++/dXW3dV79/TsNhgGW4yxAeOxwhYb25iE5UdQBEpYomqrkZJzXtuZ92O6W931qt6995zvu/c736k3p6rNgyUyAbm1JE6LclRaqfcaC9iTxXRgoaBPAqK5fZlcBQsWRR2IP6CdhqlC+i4SeyqdyKWTjjVbXhm7Mva0nLeZmzo99/HZxbbnYqevwD27kSnuZeRF6VK04c47HX6OJcaK1WPYZyBbmdUN0yO1TiOdTivReCuLWIDMVW9I6BZjZmYQO1bLFEtNq25MqzNotpF5f1oul7RrLbuGswSJrNtqkzTdmO3Keb/nL8tl6YhNfcEMRavjQVgB8hKyGJ143Gqqy0o05I/zEX64PkMb7GRluo6CN4Rzp8ayeVDNjrUzsS2F4AsXs3CnzkzUlh6fvsAyFZU0ZCVVA4zrimz4U8lIXHYfCu7TT9Vr5vCMrpPhMWqZ02ZZWLLk1j2zRUlMc/lf2kdz9iE2ZBnUpGO4xy1G6FGS/x3ggkPiEcL/PocFVdIk8zduQhhMIjK4aata6JlrjbbaUTeHgkaAXSsqaI+CALk0oSil8snyGYNge/LT9gh6pQIY+GXT5T/Pia/yL8On53Eic/3oaXsJD0WvbX3yJf2FvYP3vTyofiU/Nhjdeq4wat3fKBkG0xgFajSuNTTNGJ7iCtcc2p5Ja6EZY+5EEii9yPfs1IkhuWGnkABGG5ZSwz4ptt/Phgg7bG6/mQ3zqm06lt8I6Fk2C5QE5jOsFO/fvZ+Lc/ZgD3nBeVbsE8JDomv3nK5z0Xs5QAkFRAp96Pj4PbVPMMC13CTGiPXXciy+c+7Ql466dL2Omp1N5gHjXff6ft+biy+vkNBbmI+T2bnzT0Z9SKi+g2XeV2QfwCJ2oP+Ksjn6JWIGZogFc8cu4djVIzynrPt1gIuXRltFb5ST8o2WhOwnGzD9G4I4nZzT5jYWlI/pqeVOOeRe+fHmQY0Mqtt/WgAMyF1NwlOKLB9IRAp0KXDRiuCS69INLOFc0iLzcnHlVOcLySk61jxVPzr18CT8OzJW1EnJKPGKV/UAMM7pKfOMteZT4nLyPf+yLZKz0drcRYjorpVSH7cL/3Dr8R/sXvqPGwbrr+0BjjE2bhqVM3Je+4B10DyiH9AfpHcbI2ax+WHa4Lr+ADMIsGDP6DTWZK25ZiUwCz3cG0NDh/HlYrsaa1ZplGhNrvmK1LFVT2AsfSos9T/Xrazfj11sHBaoC1YQEOwsiCXKUSijsOevzQ5ydjT3axHbaXARaOJm/JK3Srw1+0vuFeJswmRfMvr8onvJPc/aWYFI4KaeJdIgCYJY68A78YVLfD2x9uHKNoE9m/Y9/K/4tHusTW3TYja59Zef/9FHXv3g724fkK27BoUzcu+Afv+3L+XftfU33yhYotlAQwfOjwmS/4eimOAGwBszmIEkKCr0C7zMVW7u9AgTeia5wv3A9gJuVQWRH5PeqqXPry+ck/7SStqKMk1Re7bT9X2JDwkumxOgz7hljAeU6IQU2pGcZ6ne0+ZmLqB7EXw0gCwOPDq4mh0tBqQTodBx+JLSqfWFHbHnmiL6hkM27Ui0aIjkQpC5G1ndrkK+wYIdeI9rNBUtEfiAY1qu5aVEJtZSLv8WPETEUm/qZQUYEpBd/mbDF0CuT3LDPO40YMEjFfkY04E4HgDWy5z7HCDnFMUBkIuOZ/IJml0mgAaSt2im86XCs7B0k2p2za5KJW66NGz6SmtK8qRIgnpaXRtu1ZJS2gi0hSPAU61jD2On2NPHUeLOLMqIZhRHG9OVsdOHZoqTo8UjTh3AmY4bdy6Wc5mBEUMwUyi/YHVYYO9YSMw5MGAd59ui7SZOwoCriKuoUc6/y7G/bqLxSh6bGONBbmB7QJVsGneitjPPFgnv1NNcrWWLaQ5gopJ1PBq8a/ujg3e+NvzK7sHln93w1PYfFQRdnvRQ/AWYOjRsvgBok4tOCLNXAp+U/cVOn8AcyDxmlp7AspBkzQm8+WhVrsvV2V/JWScQ865PAFG20DnLXXBb6bd4J7qK36OlLGZd4I2pu0qcrrduzznr4ZfDRSLbuUQkOMaRkkOrv3DGpoEemr1mxFO4KfxRaKO4A811WiIkwsMqO+rqkRVp7fFz1s42iKuFDXfIrooqYBwYTgMwlUIn65pWq5UP0hEAWg2qwHWENc0z1lFzlNAKrdrZKTVeQMMUerJ+r35CP175oHnCGrNq1jjRHxi57/hR0qg30pwR1NtqoiZ6nNUxwISpuadHhckV1I/YdHY8c5ZolSA93joY3rrt1fL03le/l+8P/nbrZOGUNqNNlk1LN0yqGpNjOC3QDqg8blWXi61myCIPmG232+rOLc52NuOWTFxXdOwr2qI6r33txMJ0t9bRFylJYRbgKOAWcsgfheSdWQ+5Hfhxp9VtrZ/3E8BBItV9eF8SLbUOa2ExMbLq2MnxkdMz1RljWhP2yMLhzQdXx0IgfDBI2PpGHg6nBBkSbT6ik5XtDxUeMaaUyYlajVn6iD4i+KIW0QQWWCLaHRl1LjzBHpsmsdkzYmtF9Whaj5uxkRiQdbSYtdicSCC/hDa2YhCrMWRDGUIunAs2VhY351dtl8U8MLxiuxGaroG22pZVmqgUK7W6XlYsOmGQklnycxUPSFVU7FPnRGskGW6fCNH3pAEP+reDQ6+++ALKp396PX9p8NmtTxXy371T3E2L1gw1FDGOPVfHQ/Npa5717AX7vPO8jcDFVIym0VSnzQZcCnbUANw6QT+tH1QyYR9aFJsAX4G+S8VnO+QJ0P2SJfG5OxE8gmsB7nIe/wAscJ1iT9CmyTyFuKakgOPqsR13guSxn809Trxkzs5dl7H9MrvKW0DaHDdKHae/ULwyzA/w7XdkXTjDXjxHehfWRe77bNO+4Pt2EmQborFIieirUU5JLGeUzfCPZEIzL/HTeN713K6b1pcUoQtHKm84V5qOgsVsrDZZHyMTD+QUd0wcgAiw+OKPf/Di7sHzW18u0Mlxul9AAsTyzOJ0uXz8hKoPjxSLBpsuKcqn78vKGbBdj6Y4M2FzdiJgT7hz9iwqSJ1vS99J5YBEfdbiEnk8bjplmkkHu9JGZ0UsQghvEF2KmbXYw/YEJQov8Rof40eMCVbljJ1bf/Ti4G2DvViWMb+QNczDAOdJF605fO7OdMpdyHmUiaFRAJU//v0fF3SqiRP2n8kPs/u0CVrdsbHiO0feAPdMTp06cacd07da6iq/6l/1r9vPW9+xVuXcbICj1oKwA7mDKKlYmFDJrV/8rx9d/rfB1end/7n1UqGBRmyqMBzdNT318uHAcrhnudbsmUF++23YEdNiJU4+Y72v+plk3MNNCAXuaZXMKWFKVeqB1bWwrTDkREl/wZfca37fQd6Q2omz6G7I1F5znuyHqRfyFcMnpi9CVHqhozLwbQ8Pxk6vTM810mYWbPRQjUmprwSV+Vrv7m9V0qme4aqZ9LtRI8/+/p0FwSuizI/xh3SY1QbTYdZOopV4aCyKy37PHey1NxhZZ4+zi2INNUCy5XkoOe43XatjdRzxcfuUfdxWbFJ2tknWyPHnW1eu7+3/5I4f5ZuDoa2NQiq6pSfv8rV2JWmsjHZHz46QUNeNXFO7525dsUxNNbSJ4WZl/JHqZHXCNHQl87NruOZcnXSbQKgB88Wt/ubZq6uX55ZmF77/r6i6bc+i50MQ2QkBALm4k+S5o6VabDrArLOSZOog9RhfxzJvZ3K1NF/pHnoGyeWDT1oAVlAfSQGFWXbTPWmbjDRgPFiRlQQHZIZVxFmRtSoF2f7oc4V8H+ZJzT4m/tL6ENvOY/+SD7E7uc7qQONNPNGxGTARHsI6Tt00SWL5TTG4EX3Anw8HVqZSADZqbKJWhHBMcDDm+4FUACsjt/5m689e+cKP87sGV157a6Guq6pSmTo+NXro0Ojo4Qe1BpqNWGajVj1TH68OMT1pEGm5mThs7cxs9fHjL2/ftHDYbwYNLFKcR02GH2dVWrYXJ95+kZUEBm2zX4cIb/pGUl23rclzMyvNztAXd9pdwVOq9ZSk2h1d2imekWHU27xy7sLyqvTW1paWl9baC2T1MQ/L8TvMnQpJKeBCM8ngH61CkTY1XsxOtBnJ3wFwcIYX+TH9Ln6ajVCVH2MPiGV2gE/DWraYQf+ZHSH5plDUv3AVt7pgzFk9a7YDryztTBLrzNvL9rJzyVkg0eAW54lgsAte1rkcfo0/JSLaZbGxRp1hdK6umV996OuDi+21c6d71cXqpvaVwR3f3fub5fmedmViM7mgr17d1M6VHxtZeuVrB79+bL6znD/8zJ4XBy8XnHJODvkH5El30j0iK46B+/2iKS2nLieiyUjBFpMYw80I1eQ8tHFXGBgrDc1E9MJOENoQ8Iw1EfkkkC4sSRjwa3t8ExXhoVjAgz034Fi21cdTNxmKwITEJFKHBHaQKYk87lOSf+jantiyOWQJd5ZGgM1mQ5QAiRZuF8inZBd/hTqBjUqvxG+7aXRp9pvuZRuLIgSeZ71hI03wpHg/qjA8J/aS8P/Px2x7Ad0cxQp1EbZnwNqI1PD4BcUbFRUBwFQy/6imZpjXXbBT2rPwfCxrhuZYoR7urCpcVwJQ10hSRcdaNKoSbpgCtMzOp+Fm+1HODPcKFmdjbzl16YIfOn0l6+nixRn2t13i+KGwIoYjHtshX379TBUw+EPP62qkMlUzTIOha1dR1bK+NpmDFUexsMXqBilr09Vm3TKtbHNULWMtu1bLhJWUUUOVRpWROm6b0hodm4J0l3X1gtugR3LDpHbJnrGdGUpg8Weu4Bxb3mAhN0xkbKimGgDhIQ4D1nDIdHTSKFewbTtlOgDGJm1QE63BsZsvRA9tHIKg0nSGUwD72cwxN4xo33f+p0AhWO/Lv/O7u4DnYS+/zJiI97ODX2yHSPJ//ux7gWegRlNuZFK/nh1I9FL3aWjFIpEt6VmZ/MWF+d+yAAWjuzXv6y1Lii6slcRYYgswhJ0qadcFM2tUtXjFxNNaygyjZIq2kGWum6YFwB7NL5DwNFrVRg0yYENHbY7uYz2ABh8+SCSdTokuAdSoei3gQDUUK6chqbFfb1OL/2fCD+ZUO48cqXQzax6R+SPu53IastyO0xVucGKwKusiysrohAZ/rZqkaXBhhPg+dsw6GGQgBdvZofIGchqEco/oc9zG0ZhBa3WHSy8i+CjRwRirrvGhvdFWxPUAZiRx1ELDebghSbb/qWDX/M86Vafs10WFNNL79X35236xC4cMoIwt9wvJIhYYK6JjnIcAnWrP0CV9mc3zCEipi2pyByYr6iDQHfrB4F4yuC6BBTENrUJpg6m0ahRFXTS0+3F7Xgh056GQWLCpAHxTNzkskHCW03RwO8nfdu0TzoZ3VpwXmzbAsEATwEt7wnQTiUZQjg6pCQIP8U3BWAN//zOsamHHYsVQhQo/eG7X9pkHCtvv1t9iCnwLVc3lvM8XAGX0YWZ1WWJssg5bhsvnfSIChhpFn52Hb11s0+tiZZAbedmJuzXrBfL1UjdYwnf93f5fDPYXnDe6g2KtrNXiiZtg/QXMebPIq6wELzeFPm51rgP1+aR9CkjD03fYZ3SR0yZUuj/ff/oOrP2xsh4mcsZR0Stlng/ewV8Vj6HXtG37NDU6QeT6bi/xDTL41McLQtdVrrIq/GVVPSWcxkF8AISpTBEWfrkHnsIoEJMGd5qw2nhOrsrLThg8mn4r+0gbtuf16GorJKHnqzlpuha6VlaAYsO0eWrX9qHB7QUzrMt9+duf2uV1Erkff+w223SfWVfN/Q/YBXjMQprSxFMjEoQ5dOrD2VVNdmalBUnvPbxgqo6VGCQyc2EYhdWoGVBsqpG//Zld25+nBciINGiS/Puf2RU0JW+FPrwO7iZU+1nPeeBy8Iluv/amwfferkNUszVHcVhot7FjdEhgAO0aJb+/s1HIv/faLksBEkFjyMwyIjLUZU7xKKcaefLt+dt+sgtjI3oZwIiiIFVmhpm2xsjgV6xgAfn1fCmV0NLxGb7ZKhdMzaaJTgLL93MBZBXNI1WY8PD+b93mW5cGo7uv//cNg92vmYBHlOrUwdF7q8d4VahO03m9FtbV0W27m20/kQBb73Sd1EvixfZGstldCBM35a2sLMo2/aG5TOUFUJvCDewtfSB3v/IvN1x+rVFAozujaJbhkyHyyupXdvp6Oq939swUB44VKZ1K+3POAWeUs5YSGLboQ0zDcrZWAndfInbbuqiv0pSmwuVx/SKKFMyIRmavEY0H4wE+c3Lr1nvetvXZwvSjW7e98tJjN27rT75l30273/2/t7y1d8tNr950PXa81i23/PDmH0p5yx/8ya7353fdsHv3no/dX2dakT3MG+72BwCl3wwh8EH7Hnf7TXbRP+6WHUPqUc1lHbEOXM/ruhGfR/lpbPxKvCB+ai3xX5ObxbPsHID81HKAMytCYTAPbv4/3shwe3icY2BkYGDgAWIxIGZiYATCLiBmAfMYAAmMALl4nGNgYGBkAIKrWsf8QfSWSV8YYDQARc4GigAAeJwtks8rRFEUgM+5bwjbezOykLKQifwFUhZSSqwsWFsoJXYWysJONiRFWUiK0cyG8iM1JYkp5VczLDCThcKKlGJ8776Z+vrOuee9c++58zQposLvQKxWijMWn+NW/CNWFnEjxFkz4vRbnORxAafwArUi8RJxlvgRZ8SamnK+jzfwEc/s0O+JfJ5ecW+rSeI64hNIkd/AJ/E9vBMXIM17q/RsZu2WPMM7FfgUXuGCWhc+pn4NLxDWtnhuDN/hatZ+oduf2ekwbELJn8/pOMz48/j99DKaX0fYu+jt9JAZttmrk3iCtbBPOF+OeBdPwyTxOoT3dlXuvwdr0BDNoe306Pd3ZvWPuJbaA3yR5zirEPfhUWqgz9H/YtpY78ElsUFHdM/BMlQB9x07w7MwJy5I4ClgzqAXx/AgZq9giH4f9KGHacIDeAUn6JlnvzfyemgB5pUsZ+Wb+Acw2Fhw) format('woff');
    }`);
    }
    function N(t2) {
      t2.append("filter").attr("id", "xkcdify").attr("filterUnits", "userSpaceOnUse").attr("x", -5).attr("y", -5).attr("width", "100%").attr("height", "100%").call((t3) => t3.append("feTurbulence").attr("type", "fractalNoise").attr("baseFrequency", "0.05").attr("result", "noise")).call((t3) => t3.append("feDisplacementMap").attr("scale", "5").attr("xChannelSelector", "R").attr("yChannelSelector", "G").attr("in", "SourceGraphic").attr("in2", "noise")), t2.append("filter").attr("id", "xkcdify-pie").call((t3) => t3.append("feTurbulence").attr("type", "fractalNoise").attr("baseFrequency", "0.05").attr("result", "noise")).call((t3) => t3.append("feDisplacementMap").attr("scale", "5").attr("xChannelSelector", "R").attr("yChannelSelector", "G").attr("in", "SourceGraphic").attr("in2", "noise"));
    }
    var O = ["#dd4528", "#28a3dd", "#f3db52", "#ed84b5", "#4ab74e", "#9179c0", "#8e6d5a", "#f19839", "#949494"];
    const l = {top: 50, right: 30, bottom: 50, left: 50};
    class ag {
      constructor(t2, {title: e3, xLabel: i2, yLabel: o3, data: {labels: r2, datasets: s3}, options: a3}) {
        this.options = od({unxkcdify: false, yTickCount: 3, dataColors: O, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white"}, a3), e3 && (this.title = e3, l.top = 60), i2 && (this.xLabel = i2, l.bottom = 50), o3 && (this.yLabel = o3, l.left = 70), this.data = {labels: r2, datasets: s3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${l.left},${l.top})`), this.width = this.svgEl.attr("width") - l.left - l.right, this.height = this.svgEl.attr("height") - l.top - l.bottom, M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b.positionType.upRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), e3 = ja().range([0, this.width]).domain(this.data.labels).padding(0.4), i2 = this.data.datasets.reduce((t3, e4) => t3.concat(e4.data), []), o3 = A2().domain([0, Math.max(...i2)]).range([this.height, 0]), r2 = this.chart.append("g");
        y2.xAxis(r2, {xScale: e3, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(r2, {yScale: o3, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), r2.selectAll(".xkcd-chart-bar").data(this.data.datasets[0].data).enter().append("rect").attr("class", "xkcd-chart-bar").attr("x", (t3, i3) => e3(this.data.labels[i3])).attr("width", e3.bandwidth()).attr("y", (t3) => o3(t3)).attr("height", (t3) => this.height - o3(t3)).attr("fill", "none").attr("pointer-events", "all").attr("stroke", this.options.strokeColor).attr("stroke-width", 3).attr("rx", 2).attr("filter", this.filter).on("mouseover", (e4, i3, o4) => {
          f(o4[i3]).attr("fill", this.options.dataColors[i3]), t2.show();
        }).on("mouseout", (e4, i3, o4) => {
          f(o4[i3]).attr("fill", "none"), t2.hide();
        }).on("mousemove", (e4, i3, o4) => {
          const r3 = w3(o4[i3])[0] + l.left + 10, s3 = w3(o4[i3])[1] + l.top + 10;
          let a3 = b.positionType.downRight;
          r3 > this.width / 2 && s3 < this.height / 2 ? a3 = b.positionType.downLeft : r3 > this.width / 2 && s3 > this.height / 2 ? a3 = b.positionType.upLeft : r3 < this.width / 2 && s3 > this.height / 2 && (a3 = b.positionType.upRight), t2.update({title: this.data.labels[i3], items: [{color: this.options.dataColors[i3], text: `${this.data.datasets[0].label || ""}: ${e4}`}], position: {x: r3, y: s3, type: a3}});
        });
      }
      update() {
      }
    }
    function Ic(t2, o3) {
      var e3 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var i2 = Object.getOwnPropertySymbols(t2);
        o3 && (i2 = i2.filter(function(o4) {
          return Object.getOwnPropertyDescriptor(t2, o4).enumerable;
        })), e3.push.apply(e3, i2);
      }
      return e3;
    }
    function bg(t2) {
      for (var o3 = 1; o3 < arguments.length; o3++) {
        var e3 = arguments[o3] != null ? arguments[o3] : {};
        o3 % 2 ? Ic(e3, true).forEach(function(o4) {
          cg(t2, o4, e3[o4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e3)) : Ic(e3).forEach(function(o4) {
          Object.defineProperty(t2, o4, Object.getOwnPropertyDescriptor(e3, o4));
        });
      }
      return t2;
    }
    function cg(t2, o3, e3) {
      return o3 in t2 ? Object.defineProperty(t2, o3, {value: e3, enumerable: true, configurable: true, writable: true}) : t2[o3] = e3, t2;
    }
    function Z2(t2, {items: r2, position: e3, unxkcdify: i2, parentWidth: o3, parentHeight: a3, strokeColor: p2, backgroundColor: n2}) {
      const l2 = i2 ? null : "url(#xkcdify)", $2 = t2.append("svg"), d3 = $2.append("svg"), s3 = $2.append("svg");
      r2.forEach((t3, r3) => {
        s3.append("rect").style("fill", t3.color).attr("width", 8).attr("height", 8).attr("rx", 2).attr("ry", 2).attr("filter", l2).attr("x", 15).attr("y", 17 + 20 * r3), s3.append("text").style("font-size", "15").style("fill", p2).attr("x", 27).attr("y", 17 + 20 * r3 + 8).text(t3.text);
      });
      const f2 = s3.node().getBBox(), c2 = f2.width + 15, g2 = f2.height + 10;
      let y3 = 0, h3 = 0;
      e3 !== b.positionType.downLeft && e3 !== b.positionType.downRight || (h3 = a3 - g2 - 13), e3 !== b.positionType.upRight && e3 !== b.positionType.downRight || (y3 = o3 - c2 - 13), d3.append("rect").style("fill", n2).attr("fill-opacity", 0.85).attr("stroke", p2).attr("stroke-width", 2).attr("rx", 5).attr("ry", 5).attr("filter", l2).attr("width", c2).attr("height", g2).attr("x", 8).attr("y", 5), $2.attr("x", y3).attr("y", h3);
    }
    const p = {top: 50, right: 30, bottom: 50, left: 50};
    class dg {
      constructor(t2, {title: o3, xLabel: e3, yLabel: i2, data: {labels: r2, datasets: s3}, options: a3}) {
        this.options = bg({unxkcdify: false, yTickCount: 3, dataColors: O, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", legendPosition: b.positionType.upLeft, showLegend: true}, a3), o3 && (this.title = o3, p.top = 60), e3 && (this.xLabel = e3, p.bottom = 50), i2 && (this.yLabel = i2, p.left = 70), this.data = {labels: r2, datasets: s3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${p.left},${p.top})`), this.width = this.svgEl.attr("width") - p.left - p.right, this.height = this.svgEl.attr("height") - p.top - p.bottom, M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b.positionType.upRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), o3 = ja().range([0, this.width]).domain(this.data.labels).padding(0.4), e3 = this.data.datasets.reduce((t3, o4) => o4.data.map((o5, e4) => (t3[e4] || 0) + o5), []), i2 = A2().domain([0, Math.max(...e3)]).range([this.height, 0]), r2 = this.chart.append("g");
        y2.xAxis(r2, {xScale: o3, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(r2, {yScale: i2, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor});
        const s3 = this.data.datasets.reduce((t3, o4) => t3.concat(o4.data), []), a3 = this.data.datasets[0].data.length, n2 = this.data.datasets.reduce((t3, o4, e4) => (e4 > 0 ? t3.push(o4.data.map((o5, i3) => this.data.datasets[e4 - 1].data[i3] + t3[e4 - 1][i3])) : t3.push(new Array(o4.data.length).fill(0)), t3), []).flat();
        if (r2.selectAll(".xkcd-chart-stacked-bar").data(s3).enter().append("rect").attr("class", "xkcd-chart-stacked-bar").attr("x", (t3, e4) => o3(this.data.labels[e4 % a3])).attr("width", o3.bandwidth()).attr("y", (t3, o4) => i2(t3 + n2[o4])).attr("height", (t3) => this.height - i2(t3)).attr("fill", (t3, o4) => this.options.dataColors[Math.floor(o4 / a3)]).attr("pointer-events", "all").attr("stroke", this.options.strokeColor).attr("stroke-width", 3).attr("rx", 2).attr("filter", this.filter).on("mouseover", () => t2.show()).on("mouseout", () => t2.hide()).on("mousemove", (o4, e4, i3) => {
          const r3 = w3(i3[e4])[0] + p.left + 10, s4 = w3(i3[e4])[1] + p.top + 10, n3 = this.data.datasets.map((t3, o5) => ({color: this.options.dataColors[o5], text: `${this.data.datasets[o5].label || ""}: ${this.data.datasets[o5].data[e4 % a3]}`})).reverse();
          let l2 = b.positionType.downRight;
          r3 > this.width / 2 && s4 < this.height / 2 ? l2 = b.positionType.downLeft : r3 > this.width / 2 && s4 > this.height / 2 ? l2 = b.positionType.upLeft : r3 < this.width / 2 && s4 > this.height / 2 && (l2 = b.positionType.upRight), t2.update({title: this.data.labels[e4], items: n3, position: {x: r3, y: s4, type: l2}});
        }), this.options.showLegend) {
          const t3 = this.data.datasets.map((t4, o4) => ({color: this.options.dataColors[o4], text: `${this.data.datasets[o4].label || ""}`})).reverse();
          Z2(r2, {items: t3, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        }
      }
      update() {
      }
    }
    function Jc(t2, e3) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(t2);
        e3 && (o3 = o3.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t2, e4).enumerable;
        })), i2.push.apply(i2, o3);
      }
      return i2;
    }
    function eg(t2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i2 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? Jc(i2, true).forEach(function(e4) {
          fg(t2, e4, i2[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : Jc(i2).forEach(function(e4) {
          Object.defineProperty(t2, e4, Object.getOwnPropertyDescriptor(i2, e4));
        });
      }
      return t2;
    }
    function fg(t2, e3, i2) {
      return e3 in t2 ? Object.defineProperty(t2, e3, {value: i2, enumerable: true, configurable: true, writable: true}) : t2[e3] = i2, t2;
    }
    var c = function(e3) {
      return function() {
        return e3;
      };
    };
    var gg = function($2, t2) {
      return t2 < $2 ? -1 : t2 > $2 ? 1 : t2 >= $2 ? 0 : NaN;
    };
    var hg = function($2) {
      return $2;
    };
    var Kc = Math.abs;
    var Q2 = Math.atan2;
    var W = Math.cos;
    var ig = Math.max;
    var kb = Math.min;
    var V = Math.sin;
    var X = Math.sqrt;
    var U = 1e-12;
    var _ = Math.PI;
    var ta = _ / 2;
    var ua = 2 * _;
    function jg($2) {
      return $2 > 1 ? 0 : $2 < -1 ? _ : Math.acos($2);
    }
    function Lc($2) {
      return $2 >= 1 ? ta : $2 <= -1 ? -ta : Math.asin($2);
    }
    var kg = function() {
      var t2 = hg, n2 = gg, r2 = null, e3 = c(0), $2 = c(ua), o3 = c(0);
      function a3(a4) {
        var i2, u2, l2, p2, c2, A3 = a4.length, f2 = 0, s3 = new Array(A3), b2 = new Array(A3), U2 = +e3.apply(this, arguments), Z3 = Math.min(ua, Math.max(-ua, $2.apply(this, arguments) - U2)), m3 = Math.min(Math.abs(Z3) / A3, o3.apply(this, arguments)), d3 = m3 * (Z3 < 0 ? -1 : 1);
        for (i2 = 0; i2 < A3; ++i2)
          (c2 = b2[s3[i2] = i2] = +t2(a4[i2], i2, a4)) > 0 && (f2 += c2);
        for (n2 != null ? s3.sort(function(t3, r3) {
          return n2(b2[t3], b2[r3]);
        }) : r2 != null && s3.sort(function(t3, n3) {
          return r2(a4[t3], a4[n3]);
        }), i2 = 0, l2 = f2 ? (Z3 - A3 * d3) / f2 : 0; i2 < A3; ++i2, U2 = p2)
          u2 = s3[i2], p2 = U2 + ((c2 = b2[u2]) > 0 ? c2 * l2 : 0) + d3, b2[u2] = {data: a4[u2], index: i2, value: c2, startAngle: U2, endAngle: p2, padAngle: m3};
        return b2;
      }
      return a3.value = function(n3) {
        return arguments.length ? (t2 = typeof n3 == "function" ? n3 : c(+n3), a3) : t2;
      }, a3.sortValues = function(t3) {
        return arguments.length ? (n2 = t3, r2 = null, a3) : n2;
      }, a3.sort = function(t3) {
        return arguments.length ? (r2 = t3, n2 = null, a3) : r2;
      }, a3.startAngle = function(t3) {
        return arguments.length ? (e3 = typeof t3 == "function" ? t3 : c(+t3), a3) : e3;
      }, a3.endAngle = function(t3) {
        return arguments.length ? ($2 = typeof t3 == "function" ? t3 : c(+t3), a3) : $2;
      }, a3.padAngle = function(t3) {
        return arguments.length ? (o3 = typeof t3 == "function" ? t3 : c(+t3), a3) : o3;
      }, a3;
    };
    function lg($2) {
      return $2.innerRadius;
    }
    function mg($2) {
      return $2.outerRadius;
    }
    function ng($2) {
      return $2.startAngle;
    }
    function og($2) {
      return $2.endAngle;
    }
    function pg($2) {
      return $2 && $2.padAngle;
    }
    function qg($2, t2, r2, n2, i2, o3, a3, p2) {
      var e3 = r2 - $2, c2 = n2 - t2, I2 = a3 - i2, B2 = p2 - o3, L2 = B2 * e3 - I2 * c2;
      if (!(L2 * L2 < U))
        return [$2 + (L2 = (I2 * (t2 - o3) - B2 * ($2 - i2)) / L2) * e3, t2 + L2 * c2];
    }
    function va($2, t2, r2, n2, i2, o3, a3) {
      var p2 = $2 - r2, e3 = t2 - n2, c2 = (a3 ? o3 : -o3) / X(p2 * p2 + e3 * e3), I2 = c2 * e3, B2 = -c2 * p2, L2 = $2 + I2, m3 = t2 + B2, s3 = r2 + I2, l2 = n2 + B2, u2 = (L2 + s3) / 2, y3 = (m3 + l2) / 2, f2 = s3 - L2, x2 = l2 - m3, v2 = f2 * f2 + x2 * x2, g2 = i2 - o3, h3 = L2 * l2 - s3 * m3, d3 = (x2 < 0 ? -1 : 1) * X(ig(0, g2 * g2 * v2 - h3 * h3)), T2 = (h3 * x2 - f2 * d3) / v2, A3 = (-h3 * f2 - x2 * d3) / v2, R2 = (h3 * x2 + f2 * d3) / v2, q2 = (-h3 * f2 + x2 * d3) / v2, P2 = T2 - u2, b2 = A3 - y3, E3 = R2 - u2, O2 = q2 - y3;
      return P2 * P2 + b2 * b2 > E3 * E3 + O2 * O2 && (T2 = R2, A3 = q2), {cx: T2, cy: A3, x01: -I2, y01: -B2, x11: T2 * (i2 / g2 - 1), y11: A3 * (i2 / g2 - 1)};
    }
    var lb = Math.PI, mb = 2 * lb, C = 1e-6, rg = mb - C;
    function nb() {
      this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
    }
    function ob() {
      return new nb();
    }
    nb.prototype = ob.prototype = {constructor: nb, moveTo: function(t2, h3) {
      this._ += "M" + (this._x0 = this._x1 = +t2) + "," + (this._y0 = this._y1 = +h3);
    }, closePath: function() {
      this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
    }, lineTo: function(t2, h3) {
      this._ += "L" + (this._x1 = +t2) + "," + (this._y1 = +h3);
    }, quadraticCurveTo: function(t2, h3, i2, s3) {
      this._ += "Q" + +t2 + "," + +h3 + "," + (this._x1 = +i2) + "," + (this._y1 = +s3);
    }, bezierCurveTo: function(t2, h3, i2, s3, $2, o3) {
      this._ += "C" + +t2 + "," + +h3 + "," + +i2 + "," + +s3 + "," + (this._x1 = +$2) + "," + (this._y1 = +o3);
    }, arcTo: function(t2, h3, i2, s3, $2) {
      t2 = +t2, h3 = +h3, i2 = +i2, s3 = +s3, $2 = +$2;
      var o3 = this._x1, a3 = this._y1, r2 = i2 - t2, _2 = s3 - h3, n2 = o3 - t2, M3 = a3 - h3, e3 = n2 * n2 + M3 * M3;
      if ($2 < 0)
        throw new Error("negative radius: " + $2);
      if (this._x1 === null)
        this._ += "M" + (this._x1 = t2) + "," + (this._y1 = h3);
      else if (e3 > C) {
        if (Math.abs(M3 * r2 - _2 * n2) > C && $2) {
          var u2 = i2 - o3, b2 = s3 - a3, v2 = r2 * r2 + _2 * _2, l2 = u2 * u2 + b2 * b2, x2 = Math.sqrt(v2), p2 = Math.sqrt(e3), c2 = $2 * Math.tan((lb - Math.acos((v2 + e3 - l2) / (2 * x2 * p2))) / 2), f2 = c2 / p2, y3 = c2 / x2;
          Math.abs(f2 - 1) > C && (this._ += "L" + (t2 + f2 * n2) + "," + (h3 + f2 * M3)), this._ += "A" + $2 + "," + $2 + ",0,0," + +(M3 * u2 > n2 * b2) + "," + (this._x1 = t2 + y3 * r2) + "," + (this._y1 = h3 + y3 * _2);
        } else
          this._ += "L" + (this._x1 = t2) + "," + (this._y1 = h3);
      } else
        ;
    }, arc: function(t2, h3, i2, s3, $2, o3) {
      t2 = +t2, h3 = +h3, o3 = !!o3;
      var a3 = (i2 = +i2) * Math.cos(s3), r2 = i2 * Math.sin(s3), _2 = t2 + a3, n2 = h3 + r2, M3 = 1 ^ o3, e3 = o3 ? s3 - $2 : $2 - s3;
      if (i2 < 0)
        throw new Error("negative radius: " + i2);
      this._x1 === null ? this._ += "M" + _2 + "," + n2 : (Math.abs(this._x1 - _2) > C || Math.abs(this._y1 - n2) > C) && (this._ += "L" + _2 + "," + n2), i2 && (e3 < 0 && (e3 = e3 % mb + mb), e3 > rg ? this._ += "A" + i2 + "," + i2 + ",0,1," + M3 + "," + (t2 - a3) + "," + (h3 - r2) + "A" + i2 + "," + i2 + ",0,1," + M3 + "," + (this._x1 = _2) + "," + (this._y1 = n2) : e3 > C && (this._ += "A" + i2 + "," + i2 + ",0," + +(e3 >= lb) + "," + M3 + "," + (this._x1 = t2 + i2 * Math.cos($2)) + "," + (this._y1 = h3 + i2 * Math.sin($2))));
    }, rect: function(t2, h3, i2, s3) {
      this._ += "M" + (this._x0 = this._x1 = +t2) + "," + (this._y0 = this._y1 = +h3) + "h" + +i2 + "v" + +s3 + "h" + -i2 + "Z";
    }, toString: function() {
      return this._;
    }};
    var sg = function() {
      var $2 = lg, t2 = mg, r2 = c(0), n2 = null, i2 = ng, o3 = og, a3 = pg, p2 = null;
      function e3() {
        var e4, c2, I2 = +$2.apply(this, arguments), B2 = +t2.apply(this, arguments), L2 = i2.apply(this, arguments) - ta, m3 = o3.apply(this, arguments) - ta, s3 = Kc(m3 - L2), l2 = m3 > L2;
        if (p2 || (p2 = e4 = ob()), B2 < I2 && (c2 = B2, B2 = I2, I2 = c2), B2 > U) {
          if (s3 > ua - U)
            p2.moveTo(B2 * W(L2), B2 * V(L2)), p2.arc(0, 0, B2, L2, m3, !l2), I2 > U && (p2.moveTo(I2 * W(m3), I2 * V(m3)), p2.arc(0, 0, I2, m3, L2, l2));
          else {
            var u2, y3, f2 = L2, x2 = m3, v2 = L2, g2 = m3, h3 = s3, d3 = s3, T2 = a3.apply(this, arguments) / 2, A3 = T2 > U && (n2 ? +n2.apply(this, arguments) : X(I2 * I2 + B2 * B2)), R2 = kb(Kc(B2 - I2) / 2, +r2.apply(this, arguments)), q2 = R2, P2 = R2;
            if (A3 > U) {
              var b2 = Lc(A3 / I2 * V(T2)), E3 = Lc(A3 / B2 * V(T2));
              (h3 -= 2 * b2) > U ? (v2 += b2 *= l2 ? 1 : -1, g2 -= b2) : (h3 = 0, v2 = g2 = (L2 + m3) / 2), (d3 -= 2 * E3) > U ? (f2 += E3 *= l2 ? 1 : -1, x2 -= E3) : (d3 = 0, f2 = x2 = (L2 + m3) / 2);
            }
            var O2 = B2 * W(f2), S2 = B2 * V(f2), j2 = I2 * W(g2), k2 = I2 * V(g2);
            if (R2 > U) {
              var w4, z3 = B2 * W(x2), C2 = B2 * V(x2), D3 = I2 * W(v2), F2 = I2 * V(v2);
              if (s3 < _ && (w4 = qg(O2, S2, D3, F2, z3, C2, j2, k2))) {
                var G3 = O2 - w4[0], H3 = S2 - w4[1], J2 = z3 - w4[0], K2 = C2 - w4[1], M3 = 1 / V(jg((G3 * J2 + H3 * K2) / (X(G3 * G3 + H3 * H3) * X(J2 * J2 + K2 * K2))) / 2), N2 = X(w4[0] * w4[0] + w4[1] * w4[1]);
                q2 = kb(R2, (I2 - N2) / (M3 - 1)), P2 = kb(R2, (B2 - N2) / (M3 + 1));
              }
            }
            d3 > U ? P2 > U ? (u2 = va(D3, F2, O2, S2, B2, P2, l2), y3 = va(z3, C2, j2, k2, B2, P2, l2), p2.moveTo(u2.cx + u2.x01, u2.cy + u2.y01), P2 < R2 ? p2.arc(u2.cx, u2.cy, P2, Q2(u2.y01, u2.x01), Q2(y3.y01, y3.x01), !l2) : (p2.arc(u2.cx, u2.cy, P2, Q2(u2.y01, u2.x01), Q2(u2.y11, u2.x11), !l2), p2.arc(0, 0, B2, Q2(u2.cy + u2.y11, u2.cx + u2.x11), Q2(y3.cy + y3.y11, y3.cx + y3.x11), !l2), p2.arc(y3.cx, y3.cy, P2, Q2(y3.y11, y3.x11), Q2(y3.y01, y3.x01), !l2))) : (p2.moveTo(O2, S2), p2.arc(0, 0, B2, f2, x2, !l2)) : p2.moveTo(O2, S2), I2 > U && h3 > U ? q2 > U ? (u2 = va(j2, k2, z3, C2, I2, -q2, l2), y3 = va(O2, S2, D3, F2, I2, -q2, l2), p2.lineTo(u2.cx + u2.x01, u2.cy + u2.y01), q2 < R2 ? p2.arc(u2.cx, u2.cy, q2, Q2(u2.y01, u2.x01), Q2(y3.y01, y3.x01), !l2) : (p2.arc(u2.cx, u2.cy, q2, Q2(u2.y01, u2.x01), Q2(u2.y11, u2.x11), !l2), p2.arc(0, 0, I2, Q2(u2.cy + u2.y11, u2.cx + u2.x11), Q2(y3.cy + y3.y11, y3.cx + y3.x11), l2), p2.arc(y3.cx, y3.cy, q2, Q2(y3.y11, y3.x11), Q2(y3.y01, y3.x01), !l2))) : p2.arc(0, 0, I2, g2, v2, l2) : p2.lineTo(j2, k2);
          }
        } else
          p2.moveTo(0, 0);
        if (p2.closePath(), e4)
          return p2 = null, e4 + "" || null;
      }
      return e3.centroid = function() {
        var r3 = (+$2.apply(this, arguments) + +t2.apply(this, arguments)) / 2, n3 = (+i2.apply(this, arguments) + +o3.apply(this, arguments)) / 2 - _ / 2;
        return [W(n3) * r3, V(n3) * r3];
      }, e3.innerRadius = function(t3) {
        return arguments.length ? ($2 = typeof t3 == "function" ? t3 : c(+t3), e3) : $2;
      }, e3.outerRadius = function($3) {
        return arguments.length ? (t2 = typeof $3 == "function" ? $3 : c(+$3), e3) : t2;
      }, e3.cornerRadius = function($3) {
        return arguments.length ? (r2 = typeof $3 == "function" ? $3 : c(+$3), e3) : r2;
      }, e3.padRadius = function($3) {
        return arguments.length ? (n2 = $3 == null ? null : typeof $3 == "function" ? $3 : c(+$3), e3) : n2;
      }, e3.startAngle = function($3) {
        return arguments.length ? (i2 = typeof $3 == "function" ? $3 : c(+$3), e3) : i2;
      }, e3.endAngle = function($3) {
        return arguments.length ? (o3 = typeof $3 == "function" ? $3 : c(+$3), e3) : o3;
      }, e3.padAngle = function($3) {
        return arguments.length ? (a3 = typeof $3 == "function" ? $3 : c(+$3), e3) : a3;
      }, e3.context = function($3) {
        return arguments.length ? (p2 = $3 == null ? null : $3, e3) : p2;
      }, e3;
    };
    const tg = 50;
    class ug {
      constructor(t2, {title: e3, data: {labels: i2, datasets: o3}, options: r2}) {
        this.options = eg({unxkcdify: false, innerRadius: 0.5, legendPosition: b.positionType.upLeft, dataColors: O, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, r2), this.title = e3, this.data = {labels: i2, datasets: o3}, this.filter = "url(#xkcdify-pie)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.width = this.svgEl.attr("width"), this.height = this.svgEl.attr("height"), this.chart = this.svgEl.append("g").attr("transform", `translate(${this.width / 2},${this.height / 2})`), M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b.positionType.upRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor}), e3 = Math.min(this.width, this.height) / 2 - tg, i2 = kg()(this.data.datasets[0].data), o3 = sg().innerRadius(e3 * (this.options.innerRadius === void 0 ? 0.5 : this.options.innerRadius)).outerRadius(e3);
        this.chart.selectAll(".xkcd-chart-arc").data(i2).enter().append("path").attr("class", ".xkcd-chart-arc").attr("d", o3).attr("fill", "none").attr("stroke", this.options.strokeColor).attr("stroke-width", 2).attr("fill", (t3, e4) => this.options.dataColors[e4]).attr("filter", this.filter).on("mouseover", (e4, i3, o4) => {
          f(o4[i3]).attr("fill-opacity", 0.6), t2.show();
        }).on("mouseout", (e4, i3, o4) => {
          f(o4[i3]).attr("fill-opacity", 1), t2.hide();
        }).on("mousemove", (e4, i3, o4) => {
          const r3 = w3(o4[i3])[0] + this.width / 2 + 10, s4 = w3(o4[i3])[1] + this.height / 2 + 10;
          t2.update({title: this.data.labels[i3], items: [{color: this.options.dataColors[i3], text: `${this.data.datasets[0].label || ""}: ${e4.data}`}], position: {x: r3, y: s4, type: b.positionType.downRight}});
        });
        const r2 = this.data.datasets[0].data.map((t3, e4) => ({color: this.options.dataColors[e4], text: this.data.labels[e4]})), s3 = this.svgEl.append("g").attr("transform", "translate(0, 30)");
        this.options.showLegend && Z2(s3, {items: r2, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
      }
      update() {
      }
    }
    function Mc(t2, i2) {
      var o3 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var e3 = Object.getOwnPropertySymbols(t2);
        i2 && (e3 = e3.filter(function(i3) {
          return Object.getOwnPropertyDescriptor(t2, i3).enumerable;
        })), o3.push.apply(o3, e3);
      }
      return o3;
    }
    function vg(t2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var o3 = arguments[i2] != null ? arguments[i2] : {};
        i2 % 2 ? Mc(o3, true).forEach(function(i3) {
          wg(t2, i3, o3[i3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(o3)) : Mc(o3).forEach(function(i3) {
          Object.defineProperty(t2, i3, Object.getOwnPropertyDescriptor(o3, i3));
        });
      }
      return t2;
    }
    function wg(t2, i2, o3) {
      return i2 in t2 ? Object.defineProperty(t2, i2, {value: o3, enumerable: true, configurable: true, writable: true}) : t2[i2] = o3, t2;
    }
    function Nc(t2) {
      this._context = t2;
    }
    Nc.prototype = {areaStart: function() {
      this._line = 0;
    }, areaEnd: function() {
      this._line = NaN;
    }, lineStart: function() {
      this._point = 0;
    }, lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    }, point: function(t2, i2) {
      switch (t2 = +t2, i2 = +i2, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t2, i2) : this._context.moveTo(t2, i2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(t2, i2);
      }
    }};
    var xg = function(t2) {
      return new Nc(t2);
    };
    function yg($2) {
      return $2[0];
    }
    function zg($2) {
      return $2[1];
    }
    var pb = function() {
      var n2 = yg, t2 = zg, r2 = c(true), e3 = null, $2 = xg, o3 = null;
      function u2(u3) {
        var i2, l2, p2, h3 = u3.length, c2 = false;
        for (e3 == null && (o3 = $2(p2 = ob())), i2 = 0; i2 <= h3; ++i2)
          !(i2 < h3 && r2(l2 = u3[i2], i2, u3)) === c2 && ((c2 = !c2) ? o3.lineStart() : o3.lineEnd()), c2 && o3.point(+n2(l2, i2, u3), +t2(l2, i2, u3));
        if (p2)
          return o3 = null, p2 + "" || null;
      }
      return u2.x = function(t3) {
        return arguments.length ? (n2 = typeof t3 == "function" ? t3 : c(+t3), u2) : n2;
      }, u2.y = function(n3) {
        return arguments.length ? (t2 = typeof n3 == "function" ? n3 : c(+n3), u2) : t2;
      }, u2.defined = function(n3) {
        return arguments.length ? (r2 = typeof n3 == "function" ? n3 : c(!!n3), u2) : r2;
      }, u2.curve = function(n3) {
        return arguments.length ? ($2 = n3, e3 != null && (o3 = $2(e3)), u2) : $2;
      }, u2.context = function(n3) {
        return arguments.length ? (n3 == null ? e3 = o3 = null : o3 = $2(e3 = n3), u2) : e3;
      }, u2;
    };
    function Oc(t2) {
      return t2 < 0 ? -1 : 1;
    }
    function Pc(t2, o3, n2) {
      var i2 = t2._x1 - t2._x0, e3 = o3 - t2._x1, $2 = (t2._y1 - t2._y0) / (i2 || e3 < 0 && -0), s3 = (n2 - t2._y1) / (e3 || i2 < 0 && -0), x2 = ($2 * e3 + s3 * i2) / (i2 + e3);
      return (Oc($2) + Oc(s3)) * Math.min(Math.abs($2), Math.abs(s3), 0.5 * Math.abs(x2)) || 0;
    }
    function Qc(t2, o3) {
      var n2 = t2._x1 - t2._x0;
      return n2 ? (3 * (t2._y1 - t2._y0) / n2 - o3) / 2 : o3;
    }
    function qb(t2, o3, n2) {
      var i2 = t2._x0, e3 = t2._y0, $2 = t2._x1, s3 = t2._y1, x2 = ($2 - i2) / 3;
      t2._context.bezierCurveTo(i2 + x2, e3 + x2 * o3, $2 - x2, s3 - x2 * n2, $2, s3);
    }
    function $(t2) {
      this._context = t2;
    }
    function Rc(t2) {
      return new $(t2);
    }
    $.prototype = {areaStart: function() {
      this._line = 0;
    }, areaEnd: function() {
      this._line = NaN;
    }, lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    }, lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          qb(this, this._t0, Qc(this, this._t0));
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    }, point: function(t2, o3) {
      var n2 = NaN;
      if (o3 = +o3, (t2 = +t2) !== this._x1 || o3 !== this._y1) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(t2, o3) : this._context.moveTo(t2, o3);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, qb(this, Qc(this, n2 = Pc(this, t2, o3)), n2);
            break;
          default:
            qb(this, this._t0, n2 = Pc(this, t2, o3));
        }
        this._x0 = this._x1, this._x1 = t2, this._y0 = this._y1, this._y1 = o3, this._t0 = n2;
      }
    }}, Object.create($.prototype).point = function(t2, o3) {
      $.prototype.point.call(this, o3, t2);
    };
    const q = {top: 50, right: 30, bottom: 50, left: 50};
    class Ag {
      constructor(t2, {title: i2, xLabel: o3, yLabel: e3, data: {labels: s3, datasets: r2}, options: a3}) {
        this.options = vg({unxkcdify: false, yTickCount: 3, legendPosition: b.positionType.upLeft, dataColors: O, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, a3), i2 && (this.title = i2, q.top = 60), o3 && (this.xLabel = o3, q.bottom = 50), e3 && (this.yLabel = e3, q.left = 70), this.data = {labels: s3, datasets: r2}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${q.left},${q.top})`), this.width = this.svgEl.attr("width") - q.left - q.right, this.height = this.svgEl.attr("height") - q.top - q.bottom, M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "", items: [{color: "red", text: "weweyang"}, {color: "blue", text: "timqian"}], position: {x: 60, y: 60, type: b.positionType.downRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), i2 = Qe().domain(this.data.labels).range([0, this.width]), o3 = this.data.datasets.reduce((t3, i3) => t3.concat(i3.data), []), e3 = A2().domain([Math.min(...o3), Math.max(...o3)]).range([this.height, 0]), s3 = this.chart.append("g").attr("pointer-events", "all");
        y2.xAxis(s3, {xScale: i2, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(s3, {yScale: e3, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), this.svgEl.selectAll(".domain").attr("filter", this.filter);
        const r2 = pb().x((t3, o4) => i2(this.data.labels[o4])).y((t3) => e3(t3)).curve(Rc);
        s3.selectAll(".xkcd-chart-line").data(this.data.datasets).enter().append("path").attr("class", "xkcd-chart-line").attr("d", (t3) => r2(t3.data)).attr("fill", "none").attr("stroke", (t3, i3) => this.options.dataColors[i3]).attr("filter", this.filter);
        const a3 = s3.append("line").attr("x1", 30).attr("y1", 0).attr("x2", 30).attr("y2", this.height).attr("stroke", "#aaa").attr("stroke-width", 1.5).attr("stroke-dasharray", "7,7").style("visibility", "hidden"), l2 = this.data.datasets.map((t3, i3) => s3.append("circle").style("stroke", this.options.dataColors[i3]).style("fill", this.options.dataColors[i3]).attr("r", 3.5).style("visibility", "hidden"));
        if (s3.append("rect").attr("width", this.width).attr("height", this.height).attr("fill", "none").on("mouseover", () => {
          l2.forEach((t3) => t3.style("visibility", "visible")), a3.style("visibility", "visible"), t2.show();
        }).on("mouseout", () => {
          l2.forEach((t3) => t3.style("visibility", "hidden")), a3.style("visibility", "hidden"), t2.hide();
        }).on("mousemove", (o4, s4, r3) => {
          const n2 = w3(r3[s4])[0] + q.left + 10, $2 = w3(r3[s4])[1] + q.top + 10, h3 = this.data.labels.map((t3) => i2(t3) + q.left).map((t3) => Math.abs(t3 - w3(r3[s4])[0] - q.left)), d3 = h3.indexOf(Math.min(...h3));
          a3.attr("x1", i2(this.data.labels[d3])).attr("x2", i2(this.data.labels[d3])), this.data.datasets.forEach((t3, o5) => {
            l2[o5].style("visibility", "visible").attr("cx", i2(this.data.labels[d3])).attr("cy", e3(t3.data[d3]));
          });
          const m3 = this.data.datasets.map((t3, i3) => ({color: this.options.dataColors[i3], text: `${this.data.datasets[i3].label || ""}: ${this.data.datasets[i3].data[d3]}`}));
          let p2 = b.positionType.downRight;
          n2 > this.width / 2 && $2 < this.height / 2 ? p2 = b.positionType.downLeft : n2 > this.width / 2 && $2 > this.height / 2 ? p2 = b.positionType.upLeft : n2 < this.width / 2 && $2 > this.height / 2 && (p2 = b.positionType.upRight), t2.update({title: this.data.labels[d3], items: m3, position: {x: n2, y: $2, type: p2}});
        }), this.options.showLegend) {
          const t3 = this.data.datasets.map((t4, i3) => ({color: this.options.dataColors[i3], text: t4.label}));
          Z2(s3, {items: t3, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor});
        }
      }
      update() {
      }
    }
    function Sc(t2, o3) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var e3 = Object.getOwnPropertySymbols(t2);
        o3 && (e3 = e3.filter(function(o4) {
          return Object.getOwnPropertyDescriptor(t2, o4).enumerable;
        })), i2.push.apply(i2, e3);
      }
      return i2;
    }
    function Bg(t2) {
      for (var o3 = 1; o3 < arguments.length; o3++) {
        var i2 = arguments[o3] != null ? arguments[o3] : {};
        o3 % 2 ? Sc(i2, true).forEach(function(o4) {
          Cg(t2, o4, i2[o4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i2)) : Sc(i2).forEach(function(o4) {
          Object.defineProperty(t2, o4, Object.getOwnPropertyDescriptor(i2, o4));
        });
      }
      return t2;
    }
    function Cg(t2, o3, i2) {
      return o3 in t2 ? Object.defineProperty(t2, o3, {value: i2, enumerable: true, configurable: true, writable: true}) : t2[o3] = i2, t2;
    }
    var rb = new Date(), sb = new Date();
    function d2(t2, r2, e3, n2) {
      function o3(r3) {
        return t2(r3 = new Date(+r3)), r3;
      }
      return o3.floor = o3, o3.ceil = function(e4) {
        return t2(e4 = new Date(e4 - 1)), r2(e4, 1), t2(e4), e4;
      }, o3.round = function(t3) {
        var r3 = o3(t3), e4 = o3.ceil(t3);
        return t3 - r3 < e4 - t3 ? r3 : e4;
      }, o3.offset = function(t3, e4) {
        return r2(t3 = new Date(+t3), e4 == null ? 1 : Math.floor(e4)), t3;
      }, o3.range = function(e4, n3, $2) {
        var u2, f2 = [];
        if (e4 = o3.ceil(e4), $2 = $2 == null ? 1 : Math.floor($2), !(e4 < n3 && $2 > 0))
          return f2;
        do {
          f2.push(u2 = new Date(+e4)), r2(e4, $2), t2(e4);
        } while (u2 < e4 && e4 < n3);
        return f2;
      }, o3.filter = function(e4) {
        return d2(function(r3) {
          if (r3 >= r3)
            for (; t2(r3), !e4(r3); )
              r3.setTime(r3 - 1);
        }, function(t3, n3) {
          if (t3 >= t3)
            if (n3 < 0)
              for (; ++n3 <= 0; )
                for (; r2(t3, -1), !e4(t3); )
                  ;
            else
              for (; --n3 >= 0; )
                for (; r2(t3, 1), !e4(t3); )
                  ;
        });
      }, e3 && (o3.count = function(r3, n3) {
        return rb.setTime(+r3), sb.setTime(+n3), t2(rb), t2(sb), Math.floor(e3(rb, sb));
      }, o3.every = function(t3) {
        return t3 = Math.floor(t3), isFinite(t3) && t3 > 0 ? t3 > 1 ? o3.filter(n2 ? function(r3) {
          return n2(r3) % t3 == 0;
        } : function(r3) {
          return o3.count(0, r3) % t3 == 0;
        }) : o3 : null;
      }), o3;
    }
    var wa = d2(function() {
    }, function(e3, t2) {
      e3.setTime(+e3 + t2);
    }, function(e3, t2) {
      return t2 - e3;
    });
    wa.every = function(e3) {
      return e3 = Math.floor(e3), isFinite(e3) && e3 > 0 ? e3 > 1 ? d2(function(t2) {
        t2.setTime(Math.floor(t2 / e3) * e3);
      }, function(t2, $2) {
        t2.setTime(+t2 + $2 * e3);
      }, function(t2, $2) {
        return ($2 - t2) / e3;
      }) : wa : null;
    };
    var oi = wa.range;
    var xa = 1e3;
    var D2 = 6e4;
    var ya = 36e5;
    var Tc = 864e5;
    var Uc = 6048e5;
    var Vc = d2(function(e3) {
      e3.setTime(e3 - e3.getMilliseconds());
    }, function(e3, $2) {
      e3.setTime(+e3 + $2 * xa);
    }, function(e3, $2) {
      return ($2 - e3) / xa;
    }, function(e3) {
      return e3.getUTCSeconds();
    });
    var pi = Vc.range;
    var Wc = d2(function(e3) {
      e3.setTime(e3 - e3.getMilliseconds() - e3.getSeconds() * xa);
    }, function(e3, t2) {
      e3.setTime(+e3 + t2 * D2);
    }, function(e3, t2) {
      return (t2 - e3) / D2;
    }, function(e3) {
      return e3.getMinutes();
    });
    var qi = Wc.range;
    var Xc = d2(function(r2) {
      r2.setTime(r2 - r2.getMilliseconds() - r2.getSeconds() * xa - r2.getMinutes() * D2);
    }, function(r2, $2) {
      r2.setTime(+r2 + $2 * ya);
    }, function(r2, $2) {
      return ($2 - r2) / ya;
    }, function(r2) {
      return r2.getHours();
    });
    var ri = Xc.range;
    var za = d2(function(r2) {
      r2.setHours(0, 0, 0, 0);
    }, function(r2, e3) {
      r2.setDate(r2.getDate() + e3);
    }, function(r2, e3) {
      return (e3 - r2 - (e3.getTimezoneOffset() - r2.getTimezoneOffset()) * D2) / Tc;
    }, function(r2) {
      return r2.getDate() - 1;
    });
    var si = za.range;
    function r(e3) {
      return d2(function($2) {
        $2.setDate($2.getDate() - ($2.getDay() + 7 - e3) % 7), $2.setHours(0, 0, 0, 0);
      }, function(e4, $2) {
        e4.setDate(e4.getDate() + 7 * $2);
      }, function(e4, $2) {
        return ($2 - e4 - ($2.getTimezoneOffset() - e4.getTimezoneOffset()) * D2) / Uc;
      });
    }
    var tb = r(0);
    var Aa = r(1);
    var Dg = r(2);
    var Eg = r(3);
    var Ba = r(4);
    var Fg = r(5);
    var Gg = r(6);
    var ti = tb.range;
    var ui = Aa.range;
    var vi = Dg.range;
    var wi = Eg.range;
    var xi = Ba.range;
    var yi = Fg.range;
    var zi = Gg.range;
    var Yc = d2(function(t2) {
      t2.setDate(1), t2.setHours(0, 0, 0, 0);
    }, function(t2, e3) {
      t2.setMonth(t2.getMonth() + e3);
    }, function(t2, e3) {
      return e3.getMonth() - t2.getMonth() + 12 * (e3.getFullYear() - t2.getFullYear());
    }, function(t2) {
      return t2.getMonth();
    });
    var Ai = Yc.range;
    var o2 = d2(function(e3) {
      e3.setMonth(0, 1), e3.setHours(0, 0, 0, 0);
    }, function(e3, t2) {
      e3.setFullYear(e3.getFullYear() + t2);
    }, function(e3, t2) {
      return t2.getFullYear() - e3.getFullYear();
    }, function(e3) {
      return e3.getFullYear();
    });
    o2.every = function(e3) {
      return isFinite(e3 = Math.floor(e3)) && e3 > 0 ? d2(function(t2) {
        t2.setFullYear(Math.floor(t2.getFullYear() / e3) * e3), t2.setMonth(0, 1), t2.setHours(0, 0, 0, 0);
      }, function(t2, r2) {
        t2.setFullYear(t2.getFullYear() + r2 * e3);
      }) : null;
    };
    var Bi = o2.range;
    var Hg = d2(function(t2) {
      t2.setUTCSeconds(0, 0);
    }, function(t2, e3) {
      t2.setTime(+t2 + e3 * D2);
    }, function(t2, e3) {
      return (e3 - t2) / D2;
    }, function(t2) {
      return t2.getUTCMinutes();
    });
    var Ci = Hg.range;
    var Ig = d2(function(r2) {
      r2.setUTCMinutes(0, 0, 0);
    }, function(r2, $2) {
      r2.setTime(+r2 + $2 * ya);
    }, function(r2, $2) {
      return ($2 - r2) / ya;
    }, function(r2) {
      return r2.getUTCHours();
    });
    var Di = Ig.range;
    var ub = d2(function(t2) {
      t2.setUTCHours(0, 0, 0, 0);
    }, function(t2, $2) {
      t2.setUTCDate(t2.getUTCDate() + $2);
    }, function(t2, $2) {
      return ($2 - t2) / Tc;
    }, function(t2) {
      return t2.getUTCDate() - 1;
    });
    var Ei = ub.range;
    function E2($2) {
      return d2(function(t2) {
        t2.setUTCDate(t2.getUTCDate() - (t2.getUTCDay() + 7 - $2) % 7), t2.setUTCHours(0, 0, 0, 0);
      }, function($3, t2) {
        $3.setUTCDate($3.getUTCDate() + 7 * t2);
      }, function($3, t2) {
        return (t2 - $3) / Uc;
      });
    }
    var Zc = E2(0);
    var Ca = E2(1);
    var Jg = E2(2);
    var Kg = E2(3);
    var Da = E2(4);
    var Lg = E2(5);
    var Mg = E2(6);
    var Fi = Zc.range;
    var Gi = Ca.range;
    var Hi = Jg.range;
    var Ii = Kg.range;
    var Ji = Da.range;
    var Ki = Lg.range;
    var Li = Mg.range;
    var Ng = d2(function(t2) {
      t2.setUTCDate(1), t2.setUTCHours(0, 0, 0, 0);
    }, function(t2, e3) {
      t2.setUTCMonth(t2.getUTCMonth() + e3);
    }, function(t2, e3) {
      return e3.getUTCMonth() - t2.getUTCMonth() + 12 * (e3.getUTCFullYear() - t2.getUTCFullYear());
    }, function(t2) {
      return t2.getUTCMonth();
    });
    var Mi = Ng.range;
    var F = d2(function(e3) {
      e3.setUTCMonth(0, 1), e3.setUTCHours(0, 0, 0, 0);
    }, function(e3, t2) {
      e3.setUTCFullYear(e3.getUTCFullYear() + t2);
    }, function(e3, t2) {
      return t2.getUTCFullYear() - e3.getUTCFullYear();
    }, function(e3) {
      return e3.getUTCFullYear();
    });
    F.every = function(e3) {
      return isFinite(e3 = Math.floor(e3)) && e3 > 0 ? d2(function(t2) {
        t2.setUTCFullYear(Math.floor(t2.getUTCFullYear() / e3) * e3), t2.setUTCMonth(0, 1), t2.setUTCHours(0, 0, 0, 0);
      }, function(t2, r2) {
        t2.setUTCFullYear(t2.getUTCFullYear() + r2 * e3);
      }) : null;
    };
    var Ni = F.range;
    var aa2, Og, Oi, Pg, Qg;
    function Rg($2) {
      return aa2 = Tg($2), Og = aa2.format, Oi = aa2.parse, Pg = aa2.utcFormat, Qg = aa2.utcParse, aa2;
    }
    function Sg(r2) {
      if (0 <= r2.y && r2.y < 100) {
        var $2 = new Date(-1, r2.m, r2.d, r2.H, r2.M, r2.S, r2.L);
        return $2.setFullYear(r2.y), $2;
      }
      return new Date(r2.y, r2.m, r2.d, r2.H, r2.M, r2.S, r2.L);
    }
    function Ea(r2) {
      if (0 <= r2.y && r2.y < 100) {
        var $2 = new Date(Date.UTC(-1, r2.m, r2.d, r2.H, r2.M, r2.S, r2.L));
        return $2.setUTCFullYear(r2.y), $2;
      }
      return new Date(Date.UTC(r2.y, r2.m, r2.d, r2.H, r2.M, r2.S, r2.L));
    }
    function ba(r2) {
      return {y: r2, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
    }
    function Tg(r2) {
      var $2 = r2.dateTime, e3 = r2.date, a3 = r2.time, t2 = r2.periods, U2 = r2.days, n2 = r2.shortDays, o3 = r2.months, u2 = r2.shortMonths, b2 = ca(t2), i2 = da(t2), H3 = ca(U2), v2 = da(U2), c2 = ca(n2), f2 = da(n2), m3 = ca(o3), s3 = da(o3), l2 = ca(u2), d3 = da(u2), p2 = {a: function(r3) {
        return n2[r3.getDay()];
      }, A: function(r3) {
        return U2[r3.getDay()];
      }, b: function(r3) {
        return u2[r3.getMonth()];
      }, B: function(r3) {
        return o3[r3.getMonth()];
      }, c: null, d: bd, e: bd, f: ph, H: mh, I: nh, j: oh, L: cd, m: qh, M: rh, p: function(r3) {
        return t2[+(r3.getHours() >= 12)];
      }, Q: gd, s: hd, S: sh, u: th, U: uh, V: vh, w: wh, W: xh, x: null, X: null, y: yh, Y: zh, Z: Ah, "%": fd}, y3 = {a: function(r3) {
        return n2[r3.getUTCDay()];
      }, A: function(r3) {
        return U2[r3.getUTCDay()];
      }, b: function(r3) {
        return u2[r3.getUTCMonth()];
      }, B: function(r3) {
        return o3[r3.getUTCMonth()];
      }, c: null, d: dd2, e: dd2, f: Eh, H: Bh, I: Ch, j: Dh, L: ed, m: Fh, M: Gh, p: function(r3) {
        return t2[+(r3.getUTCHours() >= 12)];
      }, Q: gd, s: hd, S: Hh, u: Ih, U: Jh, V: Kh, w: Lh, W: Mh, x: null, X: null, y: Nh, Y: Oh, Z: Ph, "%": fd}, g2 = {a: function(r3, $3, e4) {
        var a4 = c2.exec($3.slice(e4));
        return a4 ? (r3.w = f2[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, A: function(r3, $3, e4) {
        var a4 = H3.exec($3.slice(e4));
        return a4 ? (r3.w = v2[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, b: function(r3, $3, e4) {
        var a4 = l2.exec($3.slice(e4));
        return a4 ? (r3.m = d3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, B: function(r3, $3, e4) {
        var a4 = m3.exec($3.slice(e4));
        return a4 ? (r3.m = s3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, c: function(r3, e4, a4) {
        return h3(r3, $2, e4, a4);
      }, d: _c, e: _c, f: ih, H: ad, I: ad, j: eh, L: hh2, m: dh, M: fh, p: function(r3, $3, e4) {
        var a4 = b2.exec($3.slice(e4));
        return a4 ? (r3.p = i2[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, Q: kh, s: lh, S: gh, u: Yg, U: Zg, V: $g, w: Xg, W: _g, x: function(r3, $3, a4) {
        return h3(r3, e3, $3, a4);
      }, X: function(r3, $3, e4) {
        return h3(r3, a3, $3, e4);
      }, y: bh, Y: ah, Z: ch, "%": jh};
      function T2(r3, $3) {
        return function(e4) {
          var a4, t3, U3, n3 = [], o4 = -1, u3 = 0, b3 = r3.length;
          for (e4 instanceof Date || (e4 = new Date(+e4)); ++o4 < b3; )
            r3.charCodeAt(o4) === 37 && (n3.push(r3.slice(u3, o4)), (t3 = $c[a4 = r3.charAt(++o4)]) != null ? a4 = r3.charAt(++o4) : t3 = a4 === "e" ? " " : "0", (U3 = $3[a4]) && (a4 = U3(e4, t3)), n3.push(a4), u3 = o4 + 1);
          return n3.push(r3.slice(u3, o4)), n3.join("");
        };
      }
      function M3(r3, $3) {
        return function(e4) {
          var a4, t3, U3 = ba(1900);
          if (h3(U3, r3, e4 += "", 0) != e4.length)
            return null;
          if ("Q" in U3)
            return new Date(U3.Q);
          if ("p" in U3 && (U3.H = U3.H % 12 + 12 * U3.p), "V" in U3) {
            if (U3.V < 1 || U3.V > 53)
              return null;
            "w" in U3 || (U3.w = 1), "Z" in U3 ? (t3 = (a4 = Ea(ba(U3.y))).getUTCDay(), a4 = t3 > 4 || t3 === 0 ? Ca.ceil(a4) : Ca(a4), a4 = ub.offset(a4, 7 * (U3.V - 1)), U3.y = a4.getUTCFullYear(), U3.m = a4.getUTCMonth(), U3.d = a4.getUTCDate() + (U3.w + 6) % 7) : (t3 = (a4 = $3(ba(U3.y))).getDay(), a4 = t3 > 4 || t3 === 0 ? Aa.ceil(a4) : Aa(a4), a4 = za.offset(a4, 7 * (U3.V - 1)), U3.y = a4.getFullYear(), U3.m = a4.getMonth(), U3.d = a4.getDate() + (U3.w + 6) % 7);
          } else
            ("W" in U3 || "U" in U3) && ("w" in U3 || (U3.w = "u" in U3 ? U3.u % 7 : "W" in U3 ? 1 : 0), t3 = "Z" in U3 ? Ea(ba(U3.y)).getUTCDay() : $3(ba(U3.y)).getDay(), U3.m = 0, U3.d = "W" in U3 ? (U3.w + 6) % 7 + 7 * U3.W - (t3 + 5) % 7 : U3.w + 7 * U3.U - (t3 + 6) % 7);
          return "Z" in U3 ? (U3.H += U3.Z / 100 | 0, U3.M += U3.Z % 100, Ea(U3)) : $3(U3);
        };
      }
      function h3(r3, $3, e4, a4) {
        for (var t3, U3, n3 = 0, o4 = $3.length, u3 = e4.length; n3 < o4; ) {
          if (a4 >= u3)
            return -1;
          if ((t3 = $3.charCodeAt(n3++)) === 37) {
            if (t3 = $3.charAt(n3++), !(U3 = g2[t3 in $c ? $3.charAt(n3++) : t3]) || (a4 = U3(r3, e4, a4)) < 0)
              return -1;
          } else if (t3 != e4.charCodeAt(a4++))
            return -1;
        }
        return a4;
      }
      return p2.x = T2(e3, p2), p2.X = T2(a3, p2), p2.c = T2($2, p2), y3.x = T2(e3, y3), y3.X = T2(a3, y3), y3.c = T2($2, y3), {format: function(r3) {
        var $3 = T2(r3 += "", p2);
        return $3.toString = function() {
          return r3;
        }, $3;
      }, parse: function(r3) {
        var $3 = M3(r3 += "", Sg);
        return $3.toString = function() {
          return r3;
        }, $3;
      }, utcFormat: function(r3) {
        var $3 = T2(r3 += "", y3);
        return $3.toString = function() {
          return r3;
        }, $3;
      }, utcParse: function(r3) {
        var $3 = M3(r3, Ea);
        return $3.toString = function() {
          return r3;
        }, $3;
      }};
    }
    var $c = {"-": "", _: " ", 0: "0"}, h2 = /^\s*\d+/, Ug = /^%/, Vg = /[\\^$*+?|[\]().{}]/g;
    function a2(r2, $2, e3) {
      var a3 = r2 < 0 ? "-" : "", t2 = (a3 ? -r2 : r2) + "", U2 = t2.length;
      return a3 + (U2 < e3 ? new Array(e3 - U2 + 1).join($2) + t2 : t2);
    }
    function Wg(r2) {
      return r2.replace(Vg, "\\$&");
    }
    function ca(r2) {
      return new RegExp("^(?:" + r2.map(Wg).join("|") + ")", "i");
    }
    function da(r2) {
      for (var $2 = {}, e3 = -1, a3 = r2.length; ++e3 < a3; )
        $2[r2[e3].toLowerCase()] = e3;
      return $2;
    }
    function Xg(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 1));
      return a3 ? (r2.w = +a3[0], e3 + a3[0].length) : -1;
    }
    function Yg(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 1));
      return a3 ? (r2.u = +a3[0], e3 + a3[0].length) : -1;
    }
    function Zg(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.U = +a3[0], e3 + a3[0].length) : -1;
    }
    function $g(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.V = +a3[0], e3 + a3[0].length) : -1;
    }
    function _g(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.W = +a3[0], e3 + a3[0].length) : -1;
    }
    function ah(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 4));
      return a3 ? (r2.y = +a3[0], e3 + a3[0].length) : -1;
    }
    function bh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.y = +a3[0] + (+a3[0] > 68 ? 1900 : 2e3), e3 + a3[0].length) : -1;
    }
    function ch(r2, $2, e3) {
      var a3 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec($2.slice(e3, e3 + 6));
      return a3 ? (r2.Z = a3[1] ? 0 : -(a3[2] + (a3[3] || "00")), e3 + a3[0].length) : -1;
    }
    function dh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.m = a3[0] - 1, e3 + a3[0].length) : -1;
    }
    function _c(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.d = +a3[0], e3 + a3[0].length) : -1;
    }
    function eh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 3));
      return a3 ? (r2.m = 0, r2.d = +a3[0], e3 + a3[0].length) : -1;
    }
    function ad(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.H = +a3[0], e3 + a3[0].length) : -1;
    }
    function fh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.M = +a3[0], e3 + a3[0].length) : -1;
    }
    function gh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 2));
      return a3 ? (r2.S = +a3[0], e3 + a3[0].length) : -1;
    }
    function hh2(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 3));
      return a3 ? (r2.L = +a3[0], e3 + a3[0].length) : -1;
    }
    function ih(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3, e3 + 6));
      return a3 ? (r2.L = Math.floor(a3[0] / 1e3), e3 + a3[0].length) : -1;
    }
    function jh(r2, $2, e3) {
      var a3 = Ug.exec($2.slice(e3, e3 + 1));
      return a3 ? e3 + a3[0].length : -1;
    }
    function kh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3));
      return a3 ? (r2.Q = +a3[0], e3 + a3[0].length) : -1;
    }
    function lh(r2, $2, e3) {
      var a3 = h2.exec($2.slice(e3));
      return a3 ? (r2.Q = 1e3 * +a3[0], e3 + a3[0].length) : -1;
    }
    function bd(r2, $2) {
      return a2(r2.getDate(), $2, 2);
    }
    function mh(r2, $2) {
      return a2(r2.getHours(), $2, 2);
    }
    function nh(r2, $2) {
      return a2(r2.getHours() % 12 || 12, $2, 2);
    }
    function oh(r2, $2) {
      return a2(1 + za.count(o2(r2), r2), $2, 3);
    }
    function cd(r2, $2) {
      return a2(r2.getMilliseconds(), $2, 3);
    }
    function ph(r2, $2) {
      return cd(r2, $2) + "000";
    }
    function qh(r2, $2) {
      return a2(r2.getMonth() + 1, $2, 2);
    }
    function rh(r2, $2) {
      return a2(r2.getMinutes(), $2, 2);
    }
    function sh(r2, $2) {
      return a2(r2.getSeconds(), $2, 2);
    }
    function th(r2) {
      var $2 = r2.getDay();
      return $2 === 0 ? 7 : $2;
    }
    function uh(r2, $2) {
      return a2(tb.count(o2(r2), r2), $2, 2);
    }
    function vh(r2, $2) {
      var e3 = r2.getDay();
      return r2 = e3 >= 4 || e3 === 0 ? Ba(r2) : Ba.ceil(r2), a2(Ba.count(o2(r2), r2) + (o2(r2).getDay() === 4), $2, 2);
    }
    function wh(r2) {
      return r2.getDay();
    }
    function xh(r2, $2) {
      return a2(Aa.count(o2(r2), r2), $2, 2);
    }
    function yh(r2, $2) {
      return a2(r2.getFullYear() % 100, $2, 2);
    }
    function zh(r2, $2) {
      return a2(r2.getFullYear() % 1e4, $2, 4);
    }
    function Ah(r2) {
      var $2 = r2.getTimezoneOffset();
      return ($2 > 0 ? "-" : ($2 *= -1, "+")) + a2($2 / 60 | 0, "0", 2) + a2($2 % 60, "0", 2);
    }
    function dd2(r2, $2) {
      return a2(r2.getUTCDate(), $2, 2);
    }
    function Bh(r2, $2) {
      return a2(r2.getUTCHours(), $2, 2);
    }
    function Ch(r2, $2) {
      return a2(r2.getUTCHours() % 12 || 12, $2, 2);
    }
    function Dh(r2, $2) {
      return a2(1 + ub.count(F(r2), r2), $2, 3);
    }
    function ed(r2, $2) {
      return a2(r2.getUTCMilliseconds(), $2, 3);
    }
    function Eh(r2, $2) {
      return ed(r2, $2) + "000";
    }
    function Fh(r2, $2) {
      return a2(r2.getUTCMonth() + 1, $2, 2);
    }
    function Gh(r2, $2) {
      return a2(r2.getUTCMinutes(), $2, 2);
    }
    function Hh(r2, $2) {
      return a2(r2.getUTCSeconds(), $2, 2);
    }
    function Ih(r2) {
      var $2 = r2.getUTCDay();
      return $2 === 0 ? 7 : $2;
    }
    function Jh(r2, $2) {
      return a2(Zc.count(F(r2), r2), $2, 2);
    }
    function Kh(r2, $2) {
      var e3 = r2.getUTCDay();
      return r2 = e3 >= 4 || e3 === 0 ? Da(r2) : Da.ceil(r2), a2(Da.count(F(r2), r2) + (F(r2).getUTCDay() === 4), $2, 2);
    }
    function Lh(r2) {
      return r2.getUTCDay();
    }
    function Mh(r2, $2) {
      return a2(Ca.count(F(r2), r2), $2, 2);
    }
    function Nh(r2, $2) {
      return a2(r2.getUTCFullYear() % 100, $2, 2);
    }
    function Oh(r2, $2) {
      return a2(r2.getUTCFullYear() % 1e4, $2, 4);
    }
    function Ph() {
      return "+0000";
    }
    function fd() {
      return "%";
    }
    function gd(r2) {
      return +r2;
    }
    function hd(r2) {
      return Math.floor(+r2 / 1e3);
    }
    Rg({dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]});
    var id = "%Y-%m-%dT%H:%M:%S.%LZ";
    function Qh($2) {
      return $2.toISOString();
    }
    var Pi = Date.prototype.toISOString ? Qh : Pg(id);
    function Rh(e3) {
      var $2 = new Date(e3);
      return isNaN($2) ? null : $2;
    }
    var Qi = +new Date("2000-01-01T00:00:00.000Z") ? Rh : Qg(id);
    var Sh = function(e3, t2) {
      var $2, r2 = 0, M3 = (e3 = e3.slice()).length - 1, l2 = e3[r2], o3 = e3[M3];
      return o3 < l2 && ($2 = r2, r2 = M3, M3 = $2, $2 = l2, l2 = o3, o3 = $2), e3[r2] = t2.floor(l2), e3[M3] = t2.ceil(o3), e3;
    };
    var ea = 1e3, fa = 60 * ea, ga = 60 * fa, ha = 24 * ga, Th = 7 * ha, jd = 30 * ha, vb = 365 * ha;
    function Uh(t2) {
      return new Date(t2);
    }
    function Vh(t2) {
      return t2 instanceof Date ? +t2 : +new Date(+t2);
    }
    function kd(t2, $2, r2, a3, n2, e3, i2, o3, u2) {
      var k2 = Bc(z2, z2), V2 = k2.invert, X2 = k2.domain, d3 = u2(".%L"), v2 = u2(":%S"), c2 = u2("%I:%M"), p2 = u2("%I %p"), m3 = u2("%a %d"), l2 = u2("%b %d"), f2 = u2("%B"), y3 = u2("%Y"), M3 = [[i2, 1, ea], [i2, 5, 5 * ea], [i2, 15, 15 * ea], [i2, 30, 30 * ea], [e3, 1, fa], [e3, 5, 5 * fa], [e3, 15, 15 * fa], [e3, 30, 30 * fa], [n2, 1, ga], [n2, 3, 3 * ga], [n2, 6, 6 * ga], [n2, 12, 12 * ga], [a3, 1, ha], [a3, 2, 2 * ha], [r2, 1, Th], [$2, 1, jd], [$2, 3, 3 * jd], [t2, 1, vb]];
      function D3(o4) {
        return (i2(o4) < o4 ? d3 : e3(o4) < o4 ? v2 : n2(o4) < o4 ? c2 : a3(o4) < o4 ? p2 : $2(o4) < o4 ? r2(o4) < o4 ? m3 : l2 : t2(o4) < o4 ? f2 : y3)(o4);
      }
      function h3($3, r3, a4) {
        if ($3 == null && ($3 = 10), typeof $3 == "number") {
          var n3, e4 = Math.abs(a4 - r3) / $3, i3 = Pb(function(t3) {
            return t3[2];
          }).right(M3, e4);
          return i3 === M3.length ? (n3 = Ma(r3 / vb, a4 / vb, $3), $3 = t2) : i3 ? (n3 = (i3 = M3[e4 / M3[i3 - 1][2] < M3[i3][2] / e4 ? i3 - 1 : i3])[1], $3 = i3[0]) : (n3 = Math.max(Ma(r3, a4, $3), 1), $3 = o3), $3.every(n3);
        }
        return $3;
      }
      return k2.invert = function(t3) {
        return new Date(V2(t3));
      }, k2.domain = function(t3) {
        return arguments.length ? X2(Array.from(t3, Vh)) : X2().map(Uh);
      }, k2.ticks = function(t3) {
        var $3, r3 = X2(), a4 = r3[0], n3 = r3[r3.length - 1], e4 = n3 < a4;
        return e4 && ($3 = a4, a4 = n3, n3 = $3), $3 = ($3 = h3(t3, a4, n3)) ? $3.range(a4, n3 + 1) : [], e4 ? $3.reverse() : $3;
      }, k2.tickFormat = function(t3, $3) {
        return $3 == null ? D3 : u2($3);
      }, k2.nice = function(t3) {
        var $3 = X2();
        return (t3 = h3(t3, $3[0], $3[$3.length - 1])) ? X2(Sh($3, t3)) : k2;
      }, k2.copy = function() {
        return Ac(k2, kd(t2, $2, r2, a3, n2, e3, i2, o3, u2));
      }, k2;
    }
    var Wh = function() {
      return la.apply(kd(o2, Yc, tb, za, Xc, Wc, Vc, wa, Og).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
    };
    var Fa = {};
    !function(t2, n2) {
      typeof Fa == "object" ? Fa = n2() : typeof define == "function" && define.amd ? define(n2) : t2.dayjs = n2();
    }(Fa, function() {
      var t2 = "millisecond", n2 = "second", e3 = "minute", r2 = "hour", i2 = "day", s3 = "week", u2 = "month", a3 = "quarter", o3 = "year", h3 = /^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/, f2 = /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, c2 = function(t3, n3, e4) {
        var r3 = String(t3);
        return !r3 || r3.length >= n3 ? t3 : "" + Array(n3 + 1 - r3.length).join(e4) + t3;
      }, d3 = {s: c2, z: function(t3) {
        var n3 = -t3.utcOffset(), e4 = Math.abs(n3), r3 = Math.floor(e4 / 60), i3 = e4 % 60;
        return (n3 <= 0 ? "+" : "-") + c2(r3, 2, "0") + ":" + c2(i3, 2, "0");
      }, m: function(t3, n3) {
        var e4 = 12 * (n3.year() - t3.year()) + (n3.month() - t3.month()), r3 = t3.clone().add(e4, u2), i3 = n3 - r3 < 0, s4 = t3.clone().add(e4 + (i3 ? -1 : 1), u2);
        return Number(-(e4 + (n3 - r3) / (i3 ? r3 - s4 : s4 - r3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(h4) {
        return {M: u2, y: o3, w: s3, d: i2, h: r2, m: e3, s: n2, ms: t2, Q: a3}[h4] || String(h4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return t3 === void 0;
      }}, $2 = {name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")}, l2 = "en", m3 = {};
      m3[l2] = $2;
      var y3 = function(t3) {
        return t3 instanceof v2;
      }, M3 = function(t3, n3, e4) {
        var r3;
        if (!t3)
          return l2;
        if (typeof t3 == "string")
          m3[t3] && (r3 = t3), n3 && (m3[t3] = n3, r3 = t3);
        else {
          var i3 = t3.name;
          m3[i3] = t3, r3 = i3;
        }
        return e4 || (l2 = r3), r3;
      }, g2 = function(t3, n3, e4) {
        if (y3(t3))
          return t3.clone();
        var r3 = n3 ? typeof n3 == "string" ? {format: n3, pl: e4} : n3 : {};
        return r3.date = t3, new v2(r3);
      }, D3 = d3;
      D3.l = M3, D3.i = y3, D3.w = function(t3, n3) {
        return g2(t3, {locale: n3.$L, utc: n3.$u});
      };
      var v2 = function() {
        function c3(t3) {
          this.$L = this.$L || M3(t3.locale, null, true), this.parse(t3);
        }
        var d4 = c3.prototype;
        return d4.parse = function(t3) {
          this.$d = function(t4) {
            var n3 = t4.date, e4 = t4.utc;
            if (n3 === null)
              return new Date(NaN);
            if (D3.u(n3))
              return new Date();
            if (n3 instanceof Date)
              return new Date(n3);
            if (typeof n3 == "string" && !/Z$/i.test(n3)) {
              var r3 = n3.match(h3);
              if (r3)
                return e4 ? new Date(Date.UTC(r3[1], r3[2] - 1, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, r3[7] || 0)) : new Date(r3[1], r3[2] - 1, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, r3[7] || 0);
            }
            return new Date(n3);
          }(t3), this.init();
        }, d4.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, d4.$utils = function() {
          return D3;
        }, d4.isValid = function() {
          return !(this.$d.toString() === "Invalid Date");
        }, d4.isSame = function(t3, n3) {
          var e4 = g2(t3);
          return this.startOf(n3) <= e4 && e4 <= this.endOf(n3);
        }, d4.isAfter = function(t3, n3) {
          return g2(t3) < this.startOf(n3);
        }, d4.isBefore = function(t3, n3) {
          return this.endOf(n3) < g2(t3);
        }, d4.$g = function(t3, n3, e4) {
          return D3.u(t3) ? this[n3] : this.set(e4, t3);
        }, d4.year = function(t3) {
          return this.$g(t3, "$y", o3);
        }, d4.month = function(t3) {
          return this.$g(t3, "$M", u2);
        }, d4.day = function(t3) {
          return this.$g(t3, "$W", i2);
        }, d4.date = function(t3) {
          return this.$g(t3, "$D", "date");
        }, d4.hour = function(t3) {
          return this.$g(t3, "$H", r2);
        }, d4.minute = function(t3) {
          return this.$g(t3, "$m", e3);
        }, d4.second = function(t3) {
          return this.$g(t3, "$s", n2);
        }, d4.millisecond = function(n3) {
          return this.$g(n3, "$ms", t2);
        }, d4.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, d4.valueOf = function() {
          return this.$d.getTime();
        }, d4.startOf = function(t3, a4) {
          var h4 = this, f3 = !!D3.u(a4) || a4, c4 = D3.p(t3), d5 = function(t4, n3) {
            var e4 = D3.w(h4.$u ? Date.UTC(h4.$y, n3, t4) : new Date(h4.$y, n3, t4), h4);
            return f3 ? e4 : e4.endOf(i2);
          }, $3 = function(t4, n3) {
            return D3.w(h4.toDate()[t4].apply(h4.toDate(), (f3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(n3)), h4);
          }, l3 = this.$W, m4 = this.$M, y4 = this.$D, M4 = "set" + (this.$u ? "UTC" : "");
          switch (c4) {
            case o3:
              return f3 ? d5(1, 0) : d5(31, 11);
            case u2:
              return f3 ? d5(1, m4) : d5(0, m4 + 1);
            case s3:
              var g3 = this.$locale().weekStart || 0, v3 = (l3 < g3 ? l3 + 7 : l3) - g3;
              return d5(f3 ? y4 - v3 : y4 + (6 - v3), m4);
            case i2:
            case "date":
              return $3(M4 + "Hours", 0);
            case r2:
              return $3(M4 + "Minutes", 1);
            case e3:
              return $3(M4 + "Seconds", 2);
            case n2:
              return $3(M4 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, d4.endOf = function(t3) {
          return this.startOf(t3, false);
        }, d4.$set = function(s4, a4) {
          var h4, f3 = D3.p(s4), c4 = "set" + (this.$u ? "UTC" : ""), d5 = (h4 = {}, h4[i2] = c4 + "Date", h4.date = c4 + "Date", h4[u2] = c4 + "Month", h4[o3] = c4 + "FullYear", h4[r2] = c4 + "Hours", h4[e3] = c4 + "Minutes", h4[n2] = c4 + "Seconds", h4[t2] = c4 + "Milliseconds", h4)[f3], $3 = f3 === i2 ? this.$D + (a4 - this.$W) : a4;
          if (f3 === u2 || f3 === o3) {
            var l3 = this.clone().set("date", 1);
            l3.$d[d5]($3), l3.init(), this.$d = l3.set("date", Math.min(this.$D, l3.daysInMonth())).toDate();
          } else
            d5 && this.$d[d5]($3);
          return this.init(), this;
        }, d4.set = function(t3, n3) {
          return this.clone().$set(t3, n3);
        }, d4.get = function(t3) {
          return this[D3.p(t3)]();
        }, d4.add = function(t3, a4) {
          var h4, f3 = this;
          t3 = Number(t3);
          var c4 = D3.p(a4), d5 = function(n3) {
            var e4 = g2(f3);
            return D3.w(e4.date(e4.date() + Math.round(n3 * t3)), f3);
          };
          if (c4 === u2)
            return this.set(u2, this.$M + t3);
          if (c4 === o3)
            return this.set(o3, this.$y + t3);
          if (c4 === i2)
            return d5(1);
          if (c4 === s3)
            return d5(7);
          var $3 = (h4 = {}, h4[e3] = 6e4, h4[r2] = 36e5, h4[n2] = 1e3, h4)[c4] || 1, l3 = this.valueOf() + t3 * $3;
          return D3.w(l3, this);
        }, d4.subtract = function(t3, n3) {
          return this.add(-1 * t3, n3);
        }, d4.format = function(t3) {
          var n3 = this;
          if (!this.isValid())
            return "Invalid Date";
          var e4 = t3 || "YYYY-MM-DDTHH:mm:ssZ", r3 = D3.z(this), i3 = this.$locale(), s4 = this.$H, u3 = this.$m, a4 = this.$M, o4 = i3.weekdays, h4 = i3.months, c4 = function(t4, r4, i4, s5) {
            return t4 && (t4[r4] || t4(n3, e4)) || i4[r4].substr(0, s5);
          }, d5 = function(t4) {
            return D3.s(s4 % 12 || 12, t4, "0");
          }, $3 = i3.meridiem || function(t4, n4, e5) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return e5 ? r4.toLowerCase() : r4;
          }, l3 = {YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: D3.s(a4 + 1, 2, "0"), MMM: c4(i3.monthsShort, a4, h4, 3), MMMM: h4[a4] || h4(this, e4), D: this.$D, DD: D3.s(this.$D, 2, "0"), d: String(this.$W), dd: c4(i3.weekdaysMin, this.$W, o4, 2), ddd: c4(i3.weekdaysShort, this.$W, o4, 3), dddd: o4[this.$W], H: String(s4), HH: D3.s(s4, 2, "0"), h: d5(1), hh: d5(2), a: $3(s4, u3, true), A: $3(s4, u3, false), m: String(u3), mm: D3.s(u3, 2, "0"), s: String(this.$s), ss: D3.s(this.$s, 2, "0"), SSS: D3.s(this.$ms, 3, "0"), Z: r3};
          return e4.replace(f2, function(t4, n4) {
            return n4 || l3[t4] || r3.replace(":", "");
          });
        }, d4.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, d4.diff = function(t3, h4, f3) {
          var c4, d5 = D3.p(h4), $3 = g2(t3), l3 = 6e4 * ($3.utcOffset() - this.utcOffset()), m4 = this - $3, y4 = D3.m(this, $3);
          return y4 = (c4 = {}, c4[o3] = y4 / 12, c4[u2] = y4, c4[a3] = y4 / 3, c4[s3] = (m4 - l3) / 6048e5, c4[i2] = (m4 - l3) / 864e5, c4[r2] = m4 / 36e5, c4[e3] = m4 / 6e4, c4[n2] = m4 / 1e3, c4)[d5] || m4, f3 ? y4 : D3.a(y4);
        }, d4.daysInMonth = function() {
          return this.endOf(u2).$D;
        }, d4.$locale = function() {
          return m3[this.$L];
        }, d4.locale = function(t3, n3) {
          if (!t3)
            return this.$L;
          var e4 = this.clone();
          return e4.$L = M3(t3, n3, true), e4;
        }, d4.clone = function() {
          return D3.w(this.toDate(), this);
        }, d4.toDate = function() {
          return new Date(this.$d);
        }, d4.toJSON = function() {
          return this.toISOString();
        }, d4.toISOString = function() {
          return this.$d.toISOString();
        }, d4.toString = function() {
          return this.$d.toUTCString();
        }, c3;
      }();
      return g2.prototype = v2.prototype, g2.extend = function(t3, n3) {
        return t3(n3, v2, g2), g2;
      }, g2.locale = M3, g2.isDayjs = y3, g2.unix = function(t3) {
        return g2(1e3 * t3);
      }, g2.en = m3[l2], g2.Ls = m3, g2;
    });
    const u = {top: 50, right: 30, bottom: 50, left: 50};
    class Xh {
      constructor(t2, {title: o3, xLabel: i2, yLabel: e3, data: {datasets: r2}, options: s3}) {
        this.options = Bg({unxkcdify: false, dotSize: 1, showLine: false, timeFormat: "", xTickCount: 3, yTickCount: 3, legendPosition: b.positionType.upLeft, dataColors: O, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, s3), o3 && (this.title = o3, u.top = 60), i2 && (this.xLabel = i2, u.bottom = 50), e3 && (this.yLabel = e3, u.left = 70), this.data = {datasets: r2}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", 3).style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${u.left},${u.top})`), this.width = this.svgEl.attr("width") - u.left - u.right, this.height = this.svgEl.attr("height") - u.top - u.bottom, M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "", items: [{color: "red", text: "weweyang"}, {color: "blue", text: "timqian"}], position: {x: 60, y: 60, type: b.positionType.dowfnRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        this.options.timeFormat && this.data.datasets.forEach((t3) => {
          t3.data.forEach((t4) => {
            var $dZYI$$interop$default = wb(Fa);
            t4.x = $dZYI$$interop$default.d(t4.x);
          });
        });
        const o3 = this.data.datasets.reduce((t3, o4) => t3.concat(o4.data), []), i2 = o3.map((t3) => t3.x), e3 = o3.map((t3) => t3.y);
        let r2 = A2().domain([Math.min(...i2), Math.max(...i2)]).range([0, this.width]);
        this.options.timeFormat && (r2 = Wh().domain([Math.min(...i2), Math.max(...i2)]).range([0, this.width]));
        const s3 = A2().domain([Math.min(...e3), Math.max(...e3)]).range([this.height, 0]), a3 = this.chart.append("g").attr("pointer-events", "all");
        if (y2.xAxis(a3, {xScale: r2, tickCount: this.options.xTickCount === void 0 ? 3 : this.options.xTickCount, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(a3, {yScale: s3, tickCount: this.options.yTickCount === void 0 ? 3 : this.options.yTickCount, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), this.options.showLine) {
          const t3 = pb().x((t4) => r2(t4.x)).y((t4) => s3(t4.y)).curve(Rc);
          a3.selectAll(".xkcd-chart-xyline").data(this.data.datasets).enter().append("path").attr("class", "xkcd-chart-xyline").attr("d", (o4) => t3(o4.data)).attr("fill", "none").attr("stroke", (t4, o4) => this.options.dataColors[o4]).attr("filter", this.filter);
        }
        const n2 = 3.5 * (this.options.dotSize === void 0 ? 1 : this.options.dotSize), l2 = 6 * (this.options.dotSize === void 0 ? 1 : this.options.dotSize);
        if (a3.selectAll(".xkcd-chart-xycircle-group").data(this.data.datasets).enter().append("g").attr("class", ".xkcd-chart-xycircle-group").attr("filter", this.filter).attr("xy-group-index", (t3, o4) => o4).selectAll(".xkcd-chart-xycircle-circle").data((t3) => t3.data).enter().append("circle").style("stroke", (t3, o4, i3) => {
          const e4 = Number(f(i3[o4].parentElement).attr("xy-group-index"));
          return this.options.dataColors[e4];
        }).style("fill", (t3, o4, i3) => {
          const e4 = Number(f(i3[o4].parentElement).attr("xy-group-index"));
          return this.options.dataColors[e4];
        }).attr("r", n2).attr("cx", (t3) => r2(t3.x)).attr("cy", (t3) => s3(t3.y)).attr("pointer-events", "all").on("mouseover", (o4, i3, e4) => {
          const a4 = Number(f(e4[i3].parentElement).attr("xy-group-index"));
          f(e4[i3]).attr("r", l2);
          const n3 = r2(o4.x) + u.left + 5, $2 = s3(o4.y) + u.top + 5;
          let p2 = b.positionType.downRight;
          var $dZYI$$interop$default = wb(Fa);
          n3 > this.width / 2 && $2 < this.height / 2 ? p2 = b.positionType.downLeft : n3 > this.width / 2 && $2 > this.height / 2 ? p2 = b.positionType.upLeft : n3 < this.width / 2 && $2 > this.height / 2 && (p2 = b.positionType.upRight), t2.update({title: this.options.timeFormat ? $dZYI$$interop$default.d(this.data.datasets[a4].data[i3].x).format(this.options.timeFormat) : `${this.data.datasets[a4].data[i3].x}`, items: [{color: this.options.dataColors[a4], text: `${this.data.datasets[a4].label || ""}: ${o4.y}`}], position: {x: n3, y: $2, type: p2}}), t2.show();
        }).on("mouseout", (o4, i3, e4) => {
          f(e4[i3]).attr("r", n2), t2.hide();
        }), this.options.showLegend) {
          const t3 = this.data.datasets.map((t4, o4) => ({color: this.options.dataColors[o4], text: t4.label}));
          Z2(a3, {items: t3, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        }
      }
      update() {
      }
    }
    function ld(t2, e3) {
      var a3 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var r2 = Object.getOwnPropertySymbols(t2);
        e3 && (r2 = r2.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t2, e4).enumerable;
        })), a3.push.apply(a3, r2);
      }
      return a3;
    }
    function Yh(t2) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var a3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? ld(a3, true).forEach(function(e4) {
          Zh(t2, e4, a3[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(a3)) : ld(a3).forEach(function(e4) {
          Object.defineProperty(t2, e4, Object.getOwnPropertyDescriptor(a3, e4));
        });
      }
      return t2;
    }
    function Zh(t2, e3, a3) {
      return e3 in t2 ? Object.defineProperty(t2, e3, {value: a3, enumerable: true, configurable: true, writable: true}) : t2[e3] = a3, t2;
    }
    function md(t2) {
      this._context = t2;
    }
    var nd = function() {
    };
    md.prototype = {areaStart: nd, areaEnd: nd, lineStart: function() {
      this._point = 0;
    }, lineEnd: function() {
      this._point && this._context.closePath();
    }, point: function(t2, o3) {
      t2 = +t2, o3 = +o3, this._point ? this._context.lineTo(t2, o3) : (this._point = 1, this._context.moveTo(t2, o3));
    }};
    var $h = function(t2) {
      return new md(t2);
    };
    const _h = 50, Ga = -Math.PI / 2, ai = 0.2;
    class bi {
      constructor(t2, {title: e3, data: {labels: a3, datasets: r2}, options: i2}) {
        this.options = Yh({showLabels: false, ticksCount: 3, showLegend: false, legendPosition: b.positionType.upLeft, dataColors: O, fontFamily: "xkcd", dotSize: 1, strokeColor: "black", backgroundColor: "white"}, i2), this.title = e3, this.data = {labels: a3, datasets: r2}, this.directionsCount = r2[0].data.length, this.filter = "url(#xkcdify-pie)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f(t2).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t2.parentElement.clientWidth).attr("height", Math.min(2 * t2.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.width = this.svgEl.attr("width"), this.height = this.svgEl.attr("height"), this.chart = this.svgEl.append("g").attr("transform", `translate(${this.width / 2},${this.height / 2})`), M2(this.svgEl), N(this.svgEl), this.render();
      }
      render() {
        this.title && k.title(this.svgEl, this.title, this.options.strokeColor);
        const t2 = new L({parent: this.svgEl, title: "", items: [], position: {x: 0, y: 0, type: b.positionType.downRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor}), e3 = 3.5 * (this.options.dotSize || 1), a3 = 6 * (this.options.dotSize || 1), r2 = Math.min(this.width, this.height) / 2 - _h, i2 = 2 * Math.PI / this.directionsCount, o3 = this.data.datasets.reduce((t3, e4) => t3.concat(e4.data), []), s3 = Math.max(...o3), n2 = Array(this.directionsCount).fill(s3), l2 = A2().domain([0, s3]).range([0, r2]), h3 = (t3, e4) => l2(t3) * Math.cos(i2 * e4 + Ga), d3 = (t3, e4) => l2(t3) * Math.sin(i2 * e4 + Ga), c2 = pb().x(h3).y(d3).curve($h), p2 = l2.ticks(this.options.ticksCount || 3), $2 = this.chart.append("g").attr("class", "xkcd-chart-radar-grid").attr("stroke-width", "1").attr("filter", this.filter);
        $2.selectAll(".xkcd-chart-radar-level").data(p2).enter().append("path").attr("class", "xkcd-chart-radar-level").attr("d", (t3) => c2(Array(this.directionsCount).fill(t3))).style("fill", "none").attr("stroke", this.options.strokeColor).attr("stroke-dasharray", "7,7"), $2.selectAll(".xkcd-chart-radar-line").data(n2).enter().append("line").attr("class", ".xkcd-chart-radar-line").attr("stroke", this.options.strokeColor).attr("x1", 0).attr("y1", 0).attr("x2", h3).attr("y2", d3), $2.selectAll(".xkcd-chart-radar-tick").data(p2).enter().append("text").attr("class", "xkcd-chart-radar-tick").attr("x", (t3) => h3(t3, 0)).attr("y", (t3) => d3(t3, 0)).style("font-size", "16").style("fill", this.options.strokeColor).attr("text-anchor", "end").attr("dx", "-.125em").attr("dy", ".35em").text((t3) => t3), this.options.showLabels && $2.selectAll(".xkcd-chart-radar-label").data(n2.map((t3) => 1.15 * t3)).enter().append("text").attr("class", "xkcd-chart-radar-label").style("font-size", "16").style("fill", this.options.strokeColor).attr("x", (t3, e4) => (r2 + 10) * Math.cos(i2 * e4 + Ga)).attr("y", (t3, e4) => (r2 + 10) * Math.sin(i2 * e4 + Ga)).attr("dy", ".35em").attr("text-anchor", (t3, e4, a4) => {
          let r3 = "start";
          return f(a4[e4]).attr("x") < 0 && (r3 = "end"), r3;
        }).text((t3, e4) => this.data.labels[e4]);
        const g2 = this.chart.selectAll(".xkcd-chart-radar-group").data(this.data.datasets).enter().append("g").attr("class", "xkcd-chart-radar-group").attr("filter", this.filter).attr("stroke", (t3, e4) => this.options.dataColors[e4]).attr("fill", (t3, e4) => this.options.dataColors[e4]);
        if (g2.selectAll("circle").data((t3) => t3.data).enter().append("circle").attr("r", e3).attr("cx", h3).attr("cy", d3).attr("pointer-events", "all").on("mouseover", (e4, r3, i3) => {
          f(i3[r3]).attr("r", a3);
          const o4 = h3(e4, r3) + this.width / 2, s4 = d3(e4, r3) + this.height / 2;
          let n3 = b.positionType.downRight;
          o4 > this.width / 2 && s4 < this.height / 2 ? n3 = b.positionType.downLeft : o4 > this.width / 2 && s4 > this.height / 2 ? n3 = b.positionType.upLeft : o4 < this.width / 2 && s4 > this.height / 2 && (n3 = b.positionType.upRight), t2.update({title: this.data.labels[r3], items: this.data.datasets.map((t3, e5) => ({color: this.options.dataColors[e5], text: `${t3.label || ""}: ${t3.data[r3]}`})), position: {x: o4, y: s4, type: n3}}), t2.show();
        }).on("mouseout", (a4, r3, i3) => {
          f(i3[r3]).attr("r", e3), t2.hide();
        }), g2.selectAll("path").data((t3) => [t3.data]).enter().append("path").attr("d", c2).attr("pointer-events", "none").style("fill-opacity", ai), this.options.showLegend) {
          const t3 = this.data.datasets.map((t4, e5) => ({color: this.options.dataColors[e5], text: t4.label || ""})), e4 = this.svgEl.append("g").attr("transform", "translate(0, 30)");
          Z2(e4, {items: t3, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor});
        }
      }
      update() {
      }
    }
    xb = {config: b, Bar: ag, StackedBar: dg, Pie: ug, Line: Ag, XY: Xh, Radar: bi};
    if (typeof exports2 === "object" && typeof module2 !== "undefined") {
      module2.exports = xb;
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return xb;
      });
    }
  })();
});

// node_modules/chart.xkcd-react/build/index.js
var require_build = __commonJS((exports2, module2) => {
  !function(e2, t) {
    if (typeof exports2 === "object" && typeof module2 === "object")
      module2.exports = t(require("react"), require_dist());
    else if (typeof define === "function" && define.amd)
      define(["react", "chart.xkcd"], t);
    else {
      var r = typeof exports2 === "object" ? t(require("react"), require_dist()) : t(e2.react, e2["chart.xkcd"]);
      for (var n in r)
        (typeof exports2 === "object" ? exports2 : e2)[n] = r[n];
    }
  }(window, function(e2, t) {
    return function(e3) {
      var t2 = {};
      function r(n) {
        if (t2[n])
          return t2[n].exports;
        var c = t2[n] = {i: n, l: false, exports: {}};
        return e3[n].call(c.exports, c, c.exports, r), c.l = true, c.exports;
      }
      return r.m = e3, r.c = t2, r.d = function(e4, t3, n) {
        r.o(e4, t3) || Object.defineProperty(e4, t3, {enumerable: true, get: n});
      }, r.r = function(e4) {
        typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e4, "__esModule", {value: true});
      }, r.t = function(e4, t3) {
        if (1 & t3 && (e4 = r(e4)), 8 & t3)
          return e4;
        if (4 & t3 && typeof e4 === "object" && e4 && e4.__esModule)
          return e4;
        var n = Object.create(null);
        if (r.r(n), Object.defineProperty(n, "default", {enumerable: true, value: e4}), 2 & t3 && typeof e4 != "string")
          for (var c in e4)
            r.d(n, c, function(t4) {
              return e4[t4];
            }.bind(null, c));
        return n;
      }, r.n = function(e4) {
        var t3 = e4 && e4.__esModule ? function() {
          return e4.default;
        } : function() {
          return e4;
        };
        return r.d(t3, "a", t3), t3;
      }, r.o = function(e4, t3) {
        return Object.prototype.hasOwnProperty.call(e4, t3);
      }, r.p = "/obiwankenoobi/chart.xkcd-react/", r(r.s = 2);
    }([function(t2, r) {
      t2.exports = e2;
    }, function(e3, r) {
      e3.exports = t;
    }, function(e3, t2, r) {
      e3.exports = r(3);
    }, function(e3, t2, r) {
      "use strict";
      r.r(t2);
      var n = r(1), c = r.n(n), u = r(0), o2 = r.n(u), f = function(e4) {
        var t3 = e4.config, r2 = Object(u.useRef)();
        return Object(u.useEffect)(function() {
          r2.current && new c.a.Bar(r2.current, t3);
        }), o2.a.createElement("svg", {ref: r2});
      }, i = function(e4) {
        var t3 = e4.config, r2 = Object(u.useRef)();
        return Object(u.useEffect)(function() {
          r2.current && new c.a.Pie(r2.current, t3);
        }), o2.a.createElement("svg", {ref: r2});
      }, a2 = function(e4) {
        var t3 = e4.config, r2 = Object(u.useRef)();
        return Object(u.useEffect)(function() {
          r2.current && new c.a.Line(r2.current, t3);
        }), o2.a.createElement("svg", {ref: r2});
      }, s2 = function(e4) {
        var t3 = e4.config, r2 = Object(u.useRef)();
        return Object(u.useEffect)(function() {
          r2.current && new c.a.XY(r2.current, t3);
        }), o2.a.createElement("svg", {ref: r2});
      }, d2 = function(e4) {
        var t3 = e4.config, r2 = Object(u.useRef)();
        return Object(u.useEffect)(function() {
          r2.current && new c.a.Radar(r2.current, t3);
        }), o2.a.createElement("svg", {ref: r2});
      };
      r.d(t2, "Bar", function() {
        return f;
      }), r.d(t2, "Pie", function() {
        return i;
      }), r.d(t2, "Line", function() {
        return a2;
      }), r.d(t2, "XY", function() {
        return s2;
      }), r.d(t2, "Radar", function() {
        return d2;
      });
    }]);
  });
});

// src/chart.xkcd/chart-xkcd.tsx
var require_chart_xkcd = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    BarChartDescription: () => BarChartDescription,
    LineChartDescription: () => LineChartDescription,
    PieChartDescription: () => PieChartDescription,
    RadarChartDescription: () => RadarChartDescription,
    StackedBarChartDescription: () => StackedBarChartDescription,
    XYChartDescription: () => XYChartDescription
  });
  var import_chart = __toModule(require_dist());
  var import_chart2 = __toModule(require_build());
  var import_react20 = __toModule(require("react"));
  var PositionType;
  (function(PositionType2) {
    PositionType2[PositionType2["upLeft"] = 1] = "upLeft";
    PositionType2[PositionType2["upRight"] = 2] = "upRight";
    PositionType2[PositionType2["downLeft"] = 3] = "downLeft";
    PositionType2[PositionType2["downRight"] = 4] = "downRight";
  })(PositionType || (PositionType = {}));
  function LineChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      legendPosition,
      showLegend,
      strokeColor,
      backgroundColor,
      unkcdify,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Line, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          legendPosition,
          showLegend,
          strokeColor,
          backgroundColor,
          unkcdify,
          fontFamily
        }
      }
    });
  }
  var LineChartDescription = {
    name: "LineChart",
    title: "Line Chart",
    description: "The Line Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: LineChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"],
  datasets: [
    {
      label: "Plan",
      data: [30, 70, 200, 300, 500, 800, 1500, 2900, 5000, 8000],
    },
    {
      label: "Reality",
      data: [0, 1, 30, 70, 80, 100, 50, 80, 40, 150],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Title"},
      xLabel: {type: "string", default: "X"},
      yLabel: {type: "string", default: "Y"},
      yTickCount: {
        type: "number",
        default: "3",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  function BarChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      unxkcdify,
      strokeColor,
      backgroundColor,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Bar, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          unxkcdify,
          strokeColor,
          backgroundColor,
          fontFamily
        }
      }
    });
  }
  var BarChartDescription = {
    name: "BarChart",
    title: "Bar Chart",
    description: "The Bar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: BarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["github stars", "patrons"],
  datasets: [
    {
      data: [100, 2],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "github stars VS patron number"},
      xLabel: {type: "string", default: "X"},
      yLabel: {type: "string", default: "Y"},
      yTickCount: {
        type: "number",
        default: "2",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  function StackedBarChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      unxkcdify,
      strokeColor,
      backgroundColor,
      fontFamily,
      showLegend,
      legendPosition
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(StackedBar, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          unxkcdify,
          strokeColor,
          backgroundColor,
          fontFamily,
          showLegend,
          legendPosition
        }
      }
    });
  }
  var StackedBarChartDescription = {
    name: "StackedBarChart",
    title: "Stacked Bar Chart",
    description: "The Stacked Bar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: StackedBarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ['Jan', 'Feb', 'Mar', 'April', 'May'],
  datasets: [{
    label: 'Issues',
    data: [12, 19, 11, 29, 17],
  }, {
    label: 'PRs',
    data: [3, 5, 2, 4, 1],
  }, {
    label: 'Merges',
    data: [2, 3, 0, 1, 1],
  }],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Issues and PR Submissions"},
      xLabel: {type: "string", default: "Month"},
      yLabel: {type: "string", default: "Count"},
      yTickCount: {
        type: "number",
        default: "2",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  function PieChart(props) {
    const {title, innerRadius, data} = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Pie, {
      config: {
        title,
        data: eval(`(${data})`) || {},
        options: {
          innerRadius,
          legendPosition: import_chart.default.config.positionType.upRight
        }
      }
    });
  }
  var PieChartDescription = {
    name: "PieChart",
    title: "Pie Chart",
    description: "The Pie Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: PieChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["a", "b", "e", "f", "g"],
  datasets: [
    {
      data: [500, 200, 80, 90, 100],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "What Tim made of"},
      innerRadius: {type: "number", default: 0.5},
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  function XYChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      xTickCount,
      yTickCount,
      showLine,
      dotSize,
      data,
      showLegend,
      legendPosition,
      unkcdify,
      strokeColor,
      backgroundColor,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.XY, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          xTickCount,
          yTickCount,
          legendPosition,
          showLine,
          timeFormat: void 0,
          dotSize,
          showLegend,
          unkcdify,
          strokeColor,
          backgroundColor,
          fontFamily
        }
      }
    });
  }
  var XYChartDescription = {
    name: "XYChart",
    title: "XY Chart",
    description: "The XY Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: XYChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  datasets: [
    {
      label: "Pikachu",
      data: [
        { x: 3, y: 10 },
        { x: 4, y: 122 },
        { x: 10, y: 100 },
        { x: 1, y: 2 },
        { x: 2, y: 4 },
      ],
    },
    {
      label: "Squirtle",
      data: [
        { x: 3, y: 122 },
        { x: 4, y: 212 },
        { x: -3, y: 100 },
        { x: 1, y: 1 },
        { x: 1.5, y: 12 },
      ],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Pokemon farms"},
      xLabel: {type: "string", default: "Coordinate"},
      yLabel: {type: "string", default: "Count"},
      showLine: {type: "boolean", default: false},
      dotSize: {type: "number", default: 1},
      xTickCount: {
        type: "number",
        default: "5",
        editor: {type: "Number", min: 0, max: 8}
      },
      yTickCount: {
        type: "number",
        default: "5",
        editor: {type: "Number", min: 0, max: 8}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 2,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  function RadarChart(props) {
    const {
      title,
      data,
      ticksCount,
      dotSize,
      legendPosition,
      showLegend,
      strokeColor,
      backgroundColor,
      unkcdify,
      fontFamily,
      showLabels
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Radar, {
      config: {
        title,
        data: eval(`(${data})`) || {},
        options: {
          ticksCount,
          dotSize,
          legendPosition,
          showLegend,
          strokeColor,
          backgroundColor,
          unkcdify,
          fontFamily,
          showLabels
        }
      }
    });
  }
  var RadarChartDescription = {
    name: "RadarChart",
    title: "Radar Chart",
    description: "The Radar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: RadarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ['c', 'h', 'a', 'r', 't'],
  datasets: [{
    label: 'ccharrrt',
    data: [2, 1, 1, 3, 1],
  }, {
    label: 'chhaart',
    data: [1, 2, 2, 1, 1],
  }],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Letters in random words"},
      dotSize: {type: "number", default: 1},
      ticksCount: {
        type: "number",
        default: "3",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLabels: {type: "boolean", default: false},
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 2,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false}
    }
  };
  var StackedBar = ({config}) => {
    const ref = (0, import_react20.useRef)();
    (0, import_react20.useEffect)(() => {
      if (ref.current) {
        const myChart = new import_chart.default.StackedBar(ref.current, config);
      }
    });
    return /* @__PURE__ */ import_react20.default.createElement("svg", {
      ref
    });
  };
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS((exports2, module2) => {
  "use strict";
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  module2.exports = ReactPropTypesSecret;
});

// node_modules/prop-types/factoryWithThrowingShims.js
var require_factoryWithThrowingShims = __commonJS((exports2, module2) => {
  "use strict";
  var ReactPropTypesSecret = require_ReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  module2.exports = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      err.name = "Invariant Violation";
      throw err;
    }
    ;
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    ;
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS((exports2, module2) => {
  if (false) {
    ReactIs = null;
    throwOnDirectAccess = true;
    module2.exports = null(ReactIs.isElement, throwOnDirectAccess);
  } else {
    module2.exports = require_factoryWithThrowingShims()();
  }
  var ReactIs;
  var throwOnDirectAccess;
});

// node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS((exports2) => {
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var b = typeof Symbol === "function" && Symbol.for;
  var c = b ? Symbol.for("react.element") : 60103;
  var d2 = b ? Symbol.for("react.portal") : 60106;
  var e2 = b ? Symbol.for("react.fragment") : 60107;
  var f = b ? Symbol.for("react.strict_mode") : 60108;
  var g = b ? Symbol.for("react.profiler") : 60114;
  var h2 = b ? Symbol.for("react.provider") : 60109;
  var k = b ? Symbol.for("react.context") : 60110;
  var l = b ? Symbol.for("react.async_mode") : 60111;
  var m2 = b ? Symbol.for("react.concurrent_mode") : 60111;
  var n = b ? Symbol.for("react.forward_ref") : 60112;
  var p = b ? Symbol.for("react.suspense") : 60113;
  var q = b ? Symbol.for("react.suspense_list") : 60120;
  var r = b ? Symbol.for("react.memo") : 60115;
  var t = b ? Symbol.for("react.lazy") : 60116;
  var v = b ? Symbol.for("react.block") : 60121;
  var w3 = b ? Symbol.for("react.fundamental") : 60117;
  var x = b ? Symbol.for("react.responder") : 60118;
  var y2 = b ? Symbol.for("react.scope") : 60119;
  function z2(a2) {
    if (typeof a2 === "object" && a2 !== null) {
      var u = a2.$$typeof;
      switch (u) {
        case c:
          switch (a2 = a2.type, a2) {
            case l:
            case m2:
            case e2:
            case g:
            case f:
            case p:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k:
                case n:
                case t:
                case r:
                case h2:
                  return a2;
                default:
                  return u;
              }
          }
        case d2:
          return u;
      }
    }
  }
  function A2(a2) {
    return z2(a2) === m2;
  }
  exports2.AsyncMode = l;
  exports2.ConcurrentMode = m2;
  exports2.ContextConsumer = k;
  exports2.ContextProvider = h2;
  exports2.Element = c;
  exports2.ForwardRef = n;
  exports2.Fragment = e2;
  exports2.Lazy = t;
  exports2.Memo = r;
  exports2.Portal = d2;
  exports2.Profiler = g;
  exports2.StrictMode = f;
  exports2.Suspense = p;
  exports2.isAsyncMode = function(a2) {
    return A2(a2) || z2(a2) === l;
  };
  exports2.isConcurrentMode = A2;
  exports2.isContextConsumer = function(a2) {
    return z2(a2) === k;
  };
  exports2.isContextProvider = function(a2) {
    return z2(a2) === h2;
  };
  exports2.isElement = function(a2) {
    return typeof a2 === "object" && a2 !== null && a2.$$typeof === c;
  };
  exports2.isForwardRef = function(a2) {
    return z2(a2) === n;
  };
  exports2.isFragment = function(a2) {
    return z2(a2) === e2;
  };
  exports2.isLazy = function(a2) {
    return z2(a2) === t;
  };
  exports2.isMemo = function(a2) {
    return z2(a2) === r;
  };
  exports2.isPortal = function(a2) {
    return z2(a2) === d2;
  };
  exports2.isProfiler = function(a2) {
    return z2(a2) === g;
  };
  exports2.isStrictMode = function(a2) {
    return z2(a2) === f;
  };
  exports2.isSuspense = function(a2) {
    return z2(a2) === p;
  };
  exports2.isValidElementType = function(a2) {
    return typeof a2 === "string" || typeof a2 === "function" || a2 === e2 || a2 === m2 || a2 === g || a2 === f || a2 === p || a2 === q || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h2 || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w3 || a2.$$typeof === x || a2.$$typeof === y2 || a2.$$typeof === v);
  };
  exports2.typeOf = z2;
});

// node_modules/react-is/index.js
var require_react_is = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_react_is_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS((exports2, module2) => {
  "use strict";
  var reactIs = require_react_is();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  module2.exports = hoistNonReactStatics2;
});

// node_modules/react-display-name/lib/getDisplayName.js
var require_getDisplayName = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDisplayName2;
  function getDisplayName2(Component6) {
    return Component6.displayName || Component6.name || (typeof Component6 === "string" && Component6.length > 0 ? Component6 : "Unknown");
  }
});

// node_modules/symbol-observable/es/index.js
var require_es = __commonJS((exports2, module2) => {
  __markAsModule(exports2);
  __export(exports2, {
    default: () => es_default
  });
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof global !== "undefined") {
    root = global;
  } else if (typeof module2 !== "undefined") {
    root = module2;
  } else {
    root = Function("return this")();
  }
  var result = symbolObservablePonyfill(root);
  var es_default = result;
});

// node_modules/react-input-autosize/lib/AutosizeInput.js
var require_AutosizeInput = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _createClass2 = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _react = require("react");
  var _react2 = _interopRequireDefault(_react);
  var _propTypes = require_prop_types();
  var _propTypes2 = _interopRequireDefault(_propTypes);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _objectWithoutProperties2(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i))
        continue;
      target[i] = obj[i];
    }
    return target;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, enumerable: false, writable: true, configurable: true}});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var sizerStyle = {
    position: "absolute",
    top: 0,
    left: 0,
    visibility: "hidden",
    height: 0,
    overflow: "scroll",
    whiteSpace: "pre"
  };
  var INPUT_PROPS_BLACKLIST = ["extraWidth", "injectStyles", "inputClassName", "inputRef", "inputStyle", "minWidth", "onAutosize", "placeholderIsMinWidth"];
  var cleanInputProps = function cleanInputProps2(inputProps) {
    INPUT_PROPS_BLACKLIST.forEach(function(field) {
      return delete inputProps[field];
    });
    return inputProps;
  };
  var copyStyles = function copyStyles2(styles, node2) {
    node2.style.fontSize = styles.fontSize;
    node2.style.fontFamily = styles.fontFamily;
    node2.style.fontWeight = styles.fontWeight;
    node2.style.fontStyle = styles.fontStyle;
    node2.style.letterSpacing = styles.letterSpacing;
    node2.style.textTransform = styles.textTransform;
  };
  var isIE = typeof window !== "undefined" && window.navigator ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent) : false;
  var generateId = function generateId2() {
    return isIE ? "_" + Math.random().toString(36).substr(2, 12) : void 0;
  };
  var AutosizeInput2 = function(_Component) {
    _inherits2(AutosizeInput3, _Component);
    _createClass2(AutosizeInput3, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var id = props.id;
        return id !== state.prevId ? {inputId: id || generateId(), prevId: id} : null;
      }
    }]);
    function AutosizeInput3(props) {
      _classCallCheck2(this, AutosizeInput3);
      var _this = _possibleConstructorReturn2(this, (AutosizeInput3.__proto__ || Object.getPrototypeOf(AutosizeInput3)).call(this, props));
      _this.inputRef = function(el2) {
        _this.input = el2;
        if (typeof _this.props.inputRef === "function") {
          _this.props.inputRef(el2);
        }
      };
      _this.placeHolderSizerRef = function(el2) {
        _this.placeHolderSizer = el2;
      };
      _this.sizerRef = function(el2) {
        _this.sizer = el2;
      };
      _this.state = {
        inputWidth: props.minWidth,
        inputId: props.id || generateId(),
        prevId: props.id
      };
      return _this;
    }
    _createClass2(AutosizeInput3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.mounted = true;
        this.copyInputStyles();
        this.updateInputWidth();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevState.inputWidth !== this.state.inputWidth) {
          if (typeof this.props.onAutosize === "function") {
            this.props.onAutosize(this.state.inputWidth);
          }
        }
        this.updateInputWidth();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.mounted = false;
      }
    }, {
      key: "copyInputStyles",
      value: function copyInputStyles() {
        if (!this.mounted || !window.getComputedStyle) {
          return;
        }
        var inputStyles = this.input && window.getComputedStyle(this.input);
        if (!inputStyles) {
          return;
        }
        copyStyles(inputStyles, this.sizer);
        if (this.placeHolderSizer) {
          copyStyles(inputStyles, this.placeHolderSizer);
        }
      }
    }, {
      key: "updateInputWidth",
      value: function updateInputWidth() {
        if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === "undefined") {
          return;
        }
        var newInputWidth = void 0;
        if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
          newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
        } else {
          newInputWidth = this.sizer.scrollWidth + 2;
        }
        var extraWidth = this.props.type === "number" && this.props.extraWidth === void 0 ? 16 : parseInt(this.props.extraWidth) || 0;
        newInputWidth += extraWidth;
        if (newInputWidth < this.props.minWidth) {
          newInputWidth = this.props.minWidth;
        }
        if (newInputWidth !== this.state.inputWidth) {
          this.setState({
            inputWidth: newInputWidth
          });
        }
      }
    }, {
      key: "getInput",
      value: function getInput() {
        return this.input;
      }
    }, {
      key: "focus",
      value: function focus() {
        this.input.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.input.blur();
      }
    }, {
      key: "select",
      value: function select() {
        this.input.select();
      }
    }, {
      key: "renderStyles",
      value: function renderStyles() {
        var injectStyles = this.props.injectStyles;
        return isIE && injectStyles ? _react2.default.createElement("style", {dangerouslySetInnerHTML: {
          __html: "input#" + this.state.inputId + "::-ms-clear {display: none;}"
        }}) : null;
      }
    }, {
      key: "render",
      value: function render2() {
        var sizerValue = [this.props.defaultValue, this.props.value, ""].reduce(function(previousValue, currentValue) {
          if (previousValue !== null && previousValue !== void 0) {
            return previousValue;
          }
          return currentValue;
        });
        var wrapperStyle = _extends3({}, this.props.style);
        if (!wrapperStyle.display)
          wrapperStyle.display = "inline-block";
        var inputStyle3 = _extends3({
          boxSizing: "content-box",
          width: this.state.inputWidth + "px"
        }, this.props.inputStyle);
        var inputProps = _objectWithoutProperties2(this.props, []);
        cleanInputProps(inputProps);
        inputProps.className = this.props.inputClassName;
        inputProps.id = this.state.inputId;
        inputProps.style = inputStyle3;
        return _react2.default.createElement("div", {className: this.props.className, style: wrapperStyle}, this.renderStyles(), _react2.default.createElement("input", _extends3({}, inputProps, {ref: this.inputRef})), _react2.default.createElement("div", {ref: this.sizerRef, style: sizerStyle}, sizerValue), this.props.placeholder ? _react2.default.createElement("div", {ref: this.placeHolderSizerRef, style: sizerStyle}, this.props.placeholder) : null);
      }
    }]);
    return AutosizeInput3;
  }(_react.Component);
  AutosizeInput2.propTypes = {
    className: _propTypes2.default.string,
    defaultValue: _propTypes2.default.any,
    extraWidth: _propTypes2.default.oneOfType([
      _propTypes2.default.number,
      _propTypes2.default.string
    ]),
    id: _propTypes2.default.string,
    injectStyles: _propTypes2.default.bool,
    inputClassName: _propTypes2.default.string,
    inputRef: _propTypes2.default.func,
    inputStyle: _propTypes2.default.object,
    minWidth: _propTypes2.default.oneOfType([
      _propTypes2.default.number,
      _propTypes2.default.string
    ]),
    onAutosize: _propTypes2.default.func,
    onChange: _propTypes2.default.func,
    placeholder: _propTypes2.default.string,
    placeholderIsMinWidth: _propTypes2.default.bool,
    style: _propTypes2.default.object,
    value: _propTypes2.default.any
  };
  AutosizeInput2.defaultProps = {
    minWidth: 1,
    injectStyles: true
  };
  exports2.default = AutosizeInput2;
});

// src/warpspeed/WarpSpeed.js
var require_WarpSpeed = __commonJS((exports2, module2) => {
  (function(root, factory) {
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = factory();
    } else {
      root.warpspeed = factory();
    }
  })(typeof window.self !== "undefined" ? window.self : exports2, function() {
    (function() {
      var lastTime = 0;
      var vendors = ["ms", "moz", "webkit", "o"];
      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      }
    })();
    function timeStamp() {
      if (window.performance.now)
        return window.performance.now();
      else
        return Date.now();
    }
    function isVisible(el2) {
      var r = el2.getBoundingClientRect();
      return r.top + r.height >= 0 && r.left + r.width >= 0 && r.bottom - r.height <= (window.innerHeight || document.documentElement.clientHeight) && r.right - r.width <= (window.innerWidth || document.documentElement.clientWidth);
    }
    function Star(x, y2, z2) {
      this.x = x;
      this.y = y2;
      this.z = z2;
      this.size = 0.5 + Math.random();
    }
    function WarpSpeed2(targetId, config) {
      console.log(config);
      this.targetId = targetId;
      if (WarpSpeed2.RUNNING_INSTANCES === void 0)
        WarpSpeed2.RUNNING_INSTANCES = {};
      if (WarpSpeed2.RUNNING_INSTANCES[targetId]) {
        WarpSpeed2.RUNNING_INSTANCES[targetId].destroy();
      }
      config = config || {};
      if (typeof config === "string")
        try {
          config = JSON.parse(config);
        } catch (e2) {
          config = {};
        }
      this.SPEED = config.speed === void 0 || config.speed < 0 ? 0.7 : config.speed;
      this.TARGET_SPEED = config.targetSpeed === void 0 || config.targetSpeed < 0 ? this.SPEED : config.targetSpeed;
      this.SPEED_ADJ_FACTOR = config.speedAdjFactor === void 0 ? 0.03 : config.speedAdjFactor < 0 ? 0 : config.speedAdjFactor > 1 ? 1 : config.speedAdjFactor;
      this.DENSITY = config.density === void 0 || config.density <= 0 ? 0.7 : config.density;
      this.USE_CIRCLES = config.shape === void 0 ? true : config.shape === "circle";
      this.DEPTH_ALPHA = config.depthFade === void 0 ? true : config.depthFade;
      this.WARP_EFFECT = config.warpEffect === void 0 ? true : config.warpEffect;
      this.WARP_EFFECT_LENGTH = config.warpEffectLength === void 0 ? 5 : config.warpEffectLength < 0 ? 0 : config.warpEffectLength;
      this.STAR_SCALE = config.starSize === void 0 || config.starSize <= 0 ? 3 : config.starSize;
      this.BACKGROUND_COLOR = config.backgroundColor === void 0 ? "hsl(263,45%,7%)" : config.backgroundColor;
      var canvas = document.getElementById(this.targetId);
      canvas.width = 1;
      canvas.height = 1;
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = this.BACKGROUND_COLOR;
      ctx.fillRect(0, 0, 1, 1);
      ctx.fillStyle = config.starColor === void 0 ? "#FFFFFF" : config.starColor;
      ctx.fillRect(0, 0, 1, 1);
      var color = ctx.getImageData(0, 0, 1, 1).data;
      this.STAR_R = color[0];
      this.STAR_G = color[1];
      this.STAR_B = color[2];
      this.prevW = -1;
      this.prevH = -1;
      this.stars = [];
      for (var i = 0; i < this.DENSITY * 1e3; i++) {
        this.stars.push(new Star((Math.random() - 0.5) * 1e3, (Math.random() - 0.5) * 1e3, 1e3 * Math.random()));
      }
      this.lastMoveTS = timeStamp();
      this.drawRequest = null;
      this.LAST_RENDER_T = 0;
      WarpSpeed2.RUNNING_INSTANCES[targetId] = this;
      this.draw();
    }
    WarpSpeed2.prototype = {
      constructor: WarpSpeed2,
      draw: function() {
        var TIME = timeStamp();
        if (!document.getElementById(this.targetId)) {
          this.destroy();
          return;
        }
        this.move();
        var canvas = document.getElementById(this.targetId);
        if (!this.PAUSED && isVisible(canvas)) {
          if (this.prevW !== canvas.clientWidth || this.prevH !== canvas.clientHeight) {
            canvas.width = (canvas.clientWidth < 10 ? 10 : canvas.clientWidth) * (window.devicePixelRatio || 1);
            canvas.height = (canvas.clientHeight < 10 ? 10 : canvas.clientHeight) * (window.devicePixelRatio || 1);
          }
          this.size = (canvas.height < canvas.width ? canvas.height : canvas.width) / (10 / (this.STAR_SCALE <= 0 ? 0 : this.STAR_SCALE));
          if (this.WARP_EFFECT)
            this.maxLineWidth = this.size / 30;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = this.BACKGROUND_COLOR;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          var rgb = "rgb(" + this.STAR_R + "," + this.STAR_G + "," + this.STAR_B + ")", rgba = "rgba(" + this.STAR_R + "," + this.STAR_G + "," + this.STAR_B + ",";
          for (var i = 0; i < this.stars.length; i++) {
            var s2 = this.stars[i];
            var xOnDisplay = s2.x / s2.z, yOnDisplay = s2.y / s2.z;
            if (!this.WARP_EFFECT && (xOnDisplay < -0.5 || xOnDisplay > 0.5 || yOnDisplay < -0.5 || yOnDisplay > 0.5))
              continue;
            var size = s2.size * this.size / s2.z;
            if (size < 0.3)
              continue;
            if (this.DEPTH_ALPHA) {
              var alpha = (1e3 - s2.z) / 1e3;
              ctx.fillStyle = rgba + (alpha > 1 ? 1 : alpha) + ")";
            } else {
              ctx.fillStyle = rgb;
            }
            if (this.WARP_EFFECT) {
              ctx.beginPath();
              var x2OnDisplay = s2.x / (s2.z + this.WARP_EFFECT_LENGTH * this.SPEED), y2OnDisplay = s2.y / (s2.z + this.WARP_EFFECT_LENGTH * this.SPEED);
              if (x2OnDisplay < -0.5 || x2OnDisplay > 0.5 || y2OnDisplay < -0.5 || y2OnDisplay > 0.5)
                continue;
              ctx.moveTo(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2);
              ctx.lineTo(canvas.width * (x2OnDisplay + 0.5) - size / 2, canvas.height * (y2OnDisplay + 0.5) - size / 2);
              ctx.lineWidth = size > this.maxLineWidth ? this.maxLineWidth : size;
              if (this.USE_CIRCLES) {
                ctx.lineCap = "round";
              } else {
                ctx.lineCap = "butt";
              }
              ctx.strokeStyle = ctx.fillStyle;
              ctx.stroke();
            } else if (this.USE_CIRCLES) {
              ctx.beginPath();
              ctx.arc(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2, size / 2, 0, 2 * Math.PI);
              ctx.fill();
            } else {
              ctx.fillRect(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2, size, size);
            }
          }
          this.prevW = canvas.clientWidth;
          this.prevH = canvas.clientHeight;
        }
        if (this.drawRequest !== -1)
          this.drawRequest = requestAnimationFrame(this.draw.bind(this));
        this.LAST_RENDER_T = timeStamp() - TIME;
      },
      move: function() {
        var t = timeStamp(), speedMulF = (t - this.lastMoveTS) / (1e3 / 60);
        this.lastMoveTS = t;
        if (this.PAUSED)
          return;
        var speedAdjF = Math.pow(this.SPEED_ADJ_FACTOR < 0 ? 0 : this.SPEED_ADJ_FACTOR > 1 ? 1 : this.SPEED_ADJ_FACTOR, 1 / speedMulF);
        this.SPEED = this.TARGET_SPEED * speedAdjF + this.SPEED * (1 - speedAdjF);
        if (this.SPEED < 0)
          this.SPEED = 0;
        var speed = this.SPEED * speedMulF;
        for (var i = 0; i < this.stars.length; i++) {
          var s2 = this.stars[i];
          s2.z -= speed;
          while (s2.z < 1) {
            s2.z += 1e3;
            s2.x = (Math.random() - 0.5) * s2.z;
            s2.y = (Math.random() - 0.5) * s2.z;
          }
        }
      },
      destroy: function(targetId) {
        if (targetId) {
          if (WarpSpeed2.RUNNING_INSTANCES[targetId])
            WarpSpeed2.RUNNING_INSTANCES[targetId].destroy();
        } else {
          try {
            cancelAnimationFrame(this.drawRequest);
          } catch (e2) {
            this.drawRequest = -1;
          }
          WarpSpeed2.RUNNING_INSTANCES[this.targetId] = void 0;
        }
      },
      pause: function() {
        this.PAUSED = true;
      },
      resume: function() {
        this.PAUSED = false;
      }
    };
    WarpSpeed2.destroy = WarpSpeed2.prototype.destroy;
    return WarpSpeed2;
  });
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  BarChartDescription: () => import_chart_xkcd.BarChartDescription,
  ClockDescription: () => ClockDescription,
  LineChartDescription: () => import_chart_xkcd.LineChartDescription,
  PieChartDescription: () => import_chart_xkcd.PieChartDescription,
  RadarChartDescription: () => import_chart_xkcd.RadarChartDescription,
  StackedBarChartDescription: () => import_chart_xkcd.StackedBarChartDescription,
  ThreeDescription: () => ThreeDescription,
  WarpSpeedDescription: () => WarpSpeedDescription,
  XKCDDescription: () => XKCDDescription,
  XYChartDescription: () => import_chart_xkcd.XYChartDescription,
  kit: () => kit
});

// src/r3f.tsx
var import_react3 = __toModule(require("react"));

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/three/build/three.module.js
var three_module_exports = {};
__export(three_module_exports, {
  ACESFilmicToneMapping: () => ACESFilmicToneMapping,
  AddEquation: () => AddEquation,
  AddOperation: () => AddOperation,
  AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
  AdditiveBlending: () => AdditiveBlending,
  AlphaFormat: () => AlphaFormat,
  AlwaysDepth: () => AlwaysDepth,
  AlwaysStencilFunc: () => AlwaysStencilFunc,
  AmbientLight: () => AmbientLight,
  AmbientLightProbe: () => AmbientLightProbe,
  AnimationClip: () => AnimationClip,
  AnimationLoader: () => AnimationLoader,
  AnimationMixer: () => AnimationMixer,
  AnimationObjectGroup: () => AnimationObjectGroup,
  AnimationUtils: () => AnimationUtils,
  ArcCurve: () => ArcCurve,
  ArrayCamera: () => ArrayCamera,
  ArrowHelper: () => ArrowHelper,
  Audio: () => Audio,
  AudioAnalyser: () => AudioAnalyser,
  AudioContext: () => AudioContext,
  AudioListener: () => AudioListener,
  AudioLoader: () => AudioLoader,
  AxesHelper: () => AxesHelper,
  AxisHelper: () => AxisHelper,
  BackSide: () => BackSide,
  BasicDepthPacking: () => BasicDepthPacking,
  BasicShadowMap: () => BasicShadowMap,
  BinaryTextureLoader: () => BinaryTextureLoader,
  Bone: () => Bone,
  BooleanKeyframeTrack: () => BooleanKeyframeTrack,
  BoundingBoxHelper: () => BoundingBoxHelper,
  Box2: () => Box2,
  Box3: () => Box3,
  Box3Helper: () => Box3Helper,
  BoxBufferGeometry: () => BoxGeometry,
  BoxGeometry: () => BoxGeometry,
  BoxHelper: () => BoxHelper,
  BufferAttribute: () => BufferAttribute,
  BufferGeometry: () => BufferGeometry,
  BufferGeometryLoader: () => BufferGeometryLoader,
  ByteType: () => ByteType,
  Cache: () => Cache,
  Camera: () => Camera,
  CameraHelper: () => CameraHelper,
  CanvasRenderer: () => CanvasRenderer,
  CanvasTexture: () => CanvasTexture,
  CatmullRomCurve3: () => CatmullRomCurve3,
  CineonToneMapping: () => CineonToneMapping,
  CircleBufferGeometry: () => CircleGeometry,
  CircleGeometry: () => CircleGeometry,
  ClampToEdgeWrapping: () => ClampToEdgeWrapping,
  Clock: () => Clock,
  Color: () => Color,
  ColorKeyframeTrack: () => ColorKeyframeTrack,
  CompressedTexture: () => CompressedTexture,
  CompressedTextureLoader: () => CompressedTextureLoader,
  ConeBufferGeometry: () => ConeGeometry,
  ConeGeometry: () => ConeGeometry,
  CubeCamera: () => CubeCamera,
  CubeReflectionMapping: () => CubeReflectionMapping,
  CubeRefractionMapping: () => CubeRefractionMapping,
  CubeTexture: () => CubeTexture,
  CubeTextureLoader: () => CubeTextureLoader,
  CubeUVReflectionMapping: () => CubeUVReflectionMapping,
  CubeUVRefractionMapping: () => CubeUVRefractionMapping,
  CubicBezierCurve: () => CubicBezierCurve,
  CubicBezierCurve3: () => CubicBezierCurve3,
  CubicInterpolant: () => CubicInterpolant,
  CullFaceBack: () => CullFaceBack,
  CullFaceFront: () => CullFaceFront,
  CullFaceFrontBack: () => CullFaceFrontBack,
  CullFaceNone: () => CullFaceNone,
  Curve: () => Curve,
  CurvePath: () => CurvePath,
  CustomBlending: () => CustomBlending,
  CustomToneMapping: () => CustomToneMapping,
  CylinderBufferGeometry: () => CylinderGeometry,
  CylinderGeometry: () => CylinderGeometry,
  Cylindrical: () => Cylindrical,
  DataTexture: () => DataTexture,
  DataTexture2DArray: () => DataTexture2DArray,
  DataTexture3D: () => DataTexture3D,
  DataTextureLoader: () => DataTextureLoader,
  DataUtils: () => DataUtils,
  DecrementStencilOp: () => DecrementStencilOp,
  DecrementWrapStencilOp: () => DecrementWrapStencilOp,
  DefaultLoadingManager: () => DefaultLoadingManager,
  DepthFormat: () => DepthFormat,
  DepthStencilFormat: () => DepthStencilFormat,
  DepthTexture: () => DepthTexture,
  DirectionalLight: () => DirectionalLight,
  DirectionalLightHelper: () => DirectionalLightHelper,
  DiscreteInterpolant: () => DiscreteInterpolant,
  DodecahedronBufferGeometry: () => DodecahedronGeometry,
  DodecahedronGeometry: () => DodecahedronGeometry,
  DoubleSide: () => DoubleSide,
  DstAlphaFactor: () => DstAlphaFactor,
  DstColorFactor: () => DstColorFactor,
  DynamicBufferAttribute: () => DynamicBufferAttribute,
  DynamicCopyUsage: () => DynamicCopyUsage,
  DynamicDrawUsage: () => DynamicDrawUsage,
  DynamicReadUsage: () => DynamicReadUsage,
  EdgesGeometry: () => EdgesGeometry,
  EdgesHelper: () => EdgesHelper,
  EllipseCurve: () => EllipseCurve,
  EqualDepth: () => EqualDepth,
  EqualStencilFunc: () => EqualStencilFunc,
  EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
  Euler: () => Euler,
  EventDispatcher: () => EventDispatcher,
  ExtrudeBufferGeometry: () => ExtrudeGeometry,
  ExtrudeGeometry: () => ExtrudeGeometry,
  FaceColors: () => FaceColors,
  FileLoader: () => FileLoader,
  FlatShading: () => FlatShading,
  Float16BufferAttribute: () => Float16BufferAttribute,
  Float32Attribute: () => Float32Attribute,
  Float32BufferAttribute: () => Float32BufferAttribute,
  Float64Attribute: () => Float64Attribute,
  Float64BufferAttribute: () => Float64BufferAttribute,
  FloatType: () => FloatType,
  Fog: () => Fog,
  FogExp2: () => FogExp2,
  Font: () => Font,
  FontLoader: () => FontLoader,
  FrontSide: () => FrontSide,
  Frustum: () => Frustum,
  GLBufferAttribute: () => GLBufferAttribute,
  GLSL1: () => GLSL1,
  GLSL3: () => GLSL3,
  GammaEncoding: () => GammaEncoding,
  GreaterDepth: () => GreaterDepth,
  GreaterEqualDepth: () => GreaterEqualDepth,
  GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
  GreaterStencilFunc: () => GreaterStencilFunc,
  GridHelper: () => GridHelper,
  Group: () => Group,
  HalfFloatType: () => HalfFloatType,
  HemisphereLight: () => HemisphereLight,
  HemisphereLightHelper: () => HemisphereLightHelper,
  HemisphereLightProbe: () => HemisphereLightProbe,
  IcosahedronBufferGeometry: () => IcosahedronGeometry,
  IcosahedronGeometry: () => IcosahedronGeometry,
  ImageBitmapLoader: () => ImageBitmapLoader,
  ImageLoader: () => ImageLoader,
  ImageUtils: () => ImageUtils,
  ImmediateRenderObject: () => ImmediateRenderObject,
  IncrementStencilOp: () => IncrementStencilOp,
  IncrementWrapStencilOp: () => IncrementWrapStencilOp,
  InstancedBufferAttribute: () => InstancedBufferAttribute,
  InstancedBufferGeometry: () => InstancedBufferGeometry,
  InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
  InstancedMesh: () => InstancedMesh,
  Int16Attribute: () => Int16Attribute,
  Int16BufferAttribute: () => Int16BufferAttribute,
  Int32Attribute: () => Int32Attribute,
  Int32BufferAttribute: () => Int32BufferAttribute,
  Int8Attribute: () => Int8Attribute,
  Int8BufferAttribute: () => Int8BufferAttribute,
  IntType: () => IntType,
  InterleavedBuffer: () => InterleavedBuffer,
  InterleavedBufferAttribute: () => InterleavedBufferAttribute,
  Interpolant: () => Interpolant,
  InterpolateDiscrete: () => InterpolateDiscrete,
  InterpolateLinear: () => InterpolateLinear,
  InterpolateSmooth: () => InterpolateSmooth,
  InvertStencilOp: () => InvertStencilOp,
  JSONLoader: () => JSONLoader,
  KeepStencilOp: () => KeepStencilOp,
  KeyframeTrack: () => KeyframeTrack,
  LOD: () => LOD,
  LatheBufferGeometry: () => LatheGeometry,
  LatheGeometry: () => LatheGeometry,
  Layers: () => Layers,
  LensFlare: () => LensFlare,
  LessDepth: () => LessDepth,
  LessEqualDepth: () => LessEqualDepth,
  LessEqualStencilFunc: () => LessEqualStencilFunc,
  LessStencilFunc: () => LessStencilFunc,
  Light: () => Light,
  LightProbe: () => LightProbe,
  Line: () => Line,
  Line3: () => Line3,
  LineBasicMaterial: () => LineBasicMaterial,
  LineCurve: () => LineCurve,
  LineCurve3: () => LineCurve3,
  LineDashedMaterial: () => LineDashedMaterial,
  LineLoop: () => LineLoop,
  LinePieces: () => LinePieces,
  LineSegments: () => LineSegments,
  LineStrip: () => LineStrip,
  LinearEncoding: () => LinearEncoding,
  LinearFilter: () => LinearFilter,
  LinearInterpolant: () => LinearInterpolant,
  LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
  LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
  LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
  LinearToneMapping: () => LinearToneMapping,
  Loader: () => Loader,
  LoaderUtils: () => LoaderUtils,
  LoadingManager: () => LoadingManager,
  LogLuvEncoding: () => LogLuvEncoding,
  LoopOnce: () => LoopOnce,
  LoopPingPong: () => LoopPingPong,
  LoopRepeat: () => LoopRepeat,
  LuminanceAlphaFormat: () => LuminanceAlphaFormat,
  LuminanceFormat: () => LuminanceFormat,
  MOUSE: () => MOUSE,
  Material: () => Material,
  MaterialLoader: () => MaterialLoader,
  Math: () => MathUtils,
  MathUtils: () => MathUtils,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  MaxEquation: () => MaxEquation,
  Mesh: () => Mesh,
  MeshBasicMaterial: () => MeshBasicMaterial,
  MeshDepthMaterial: () => MeshDepthMaterial,
  MeshDistanceMaterial: () => MeshDistanceMaterial,
  MeshFaceMaterial: () => MeshFaceMaterial,
  MeshLambertMaterial: () => MeshLambertMaterial,
  MeshMatcapMaterial: () => MeshMatcapMaterial,
  MeshNormalMaterial: () => MeshNormalMaterial,
  MeshPhongMaterial: () => MeshPhongMaterial,
  MeshPhysicalMaterial: () => MeshPhysicalMaterial,
  MeshStandardMaterial: () => MeshStandardMaterial,
  MeshToonMaterial: () => MeshToonMaterial,
  MinEquation: () => MinEquation,
  MirroredRepeatWrapping: () => MirroredRepeatWrapping,
  MixOperation: () => MixOperation,
  MultiMaterial: () => MultiMaterial,
  MultiplyBlending: () => MultiplyBlending,
  MultiplyOperation: () => MultiplyOperation,
  NearestFilter: () => NearestFilter,
  NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
  NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
  NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
  NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
  NeverDepth: () => NeverDepth,
  NeverStencilFunc: () => NeverStencilFunc,
  NoBlending: () => NoBlending,
  NoColors: () => NoColors,
  NoToneMapping: () => NoToneMapping,
  NormalAnimationBlendMode: () => NormalAnimationBlendMode,
  NormalBlending: () => NormalBlending,
  NotEqualDepth: () => NotEqualDepth,
  NotEqualStencilFunc: () => NotEqualStencilFunc,
  NumberKeyframeTrack: () => NumberKeyframeTrack,
  Object3D: () => Object3D,
  ObjectLoader: () => ObjectLoader,
  ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
  OctahedronBufferGeometry: () => OctahedronGeometry,
  OctahedronGeometry: () => OctahedronGeometry,
  OneFactor: () => OneFactor,
  OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
  OneMinusDstColorFactor: () => OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
  OrthographicCamera: () => OrthographicCamera,
  PCFShadowMap: () => PCFShadowMap,
  PCFSoftShadowMap: () => PCFSoftShadowMap,
  PMREMGenerator: () => PMREMGenerator,
  ParametricBufferGeometry: () => ParametricGeometry,
  ParametricGeometry: () => ParametricGeometry,
  Particle: () => Particle,
  ParticleBasicMaterial: () => ParticleBasicMaterial,
  ParticleSystem: () => ParticleSystem,
  ParticleSystemMaterial: () => ParticleSystemMaterial,
  Path: () => Path,
  PerspectiveCamera: () => PerspectiveCamera,
  Plane: () => Plane,
  PlaneBufferGeometry: () => PlaneGeometry,
  PlaneGeometry: () => PlaneGeometry,
  PlaneHelper: () => PlaneHelper,
  PointCloud: () => PointCloud,
  PointCloudMaterial: () => PointCloudMaterial,
  PointLight: () => PointLight,
  PointLightHelper: () => PointLightHelper,
  Points: () => Points,
  PointsMaterial: () => PointsMaterial,
  PolarGridHelper: () => PolarGridHelper,
  PolyhedronBufferGeometry: () => PolyhedronGeometry,
  PolyhedronGeometry: () => PolyhedronGeometry,
  PositionalAudio: () => PositionalAudio,
  PropertyBinding: () => PropertyBinding,
  PropertyMixer: () => PropertyMixer,
  QuadraticBezierCurve: () => QuadraticBezierCurve,
  QuadraticBezierCurve3: () => QuadraticBezierCurve3,
  Quaternion: () => Quaternion,
  QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
  QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
  REVISION: () => REVISION,
  RGBADepthPacking: () => RGBADepthPacking,
  RGBAFormat: () => RGBAFormat,
  RGBAIntegerFormat: () => RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format: () => RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
  RGBDEncoding: () => RGBDEncoding,
  RGBEEncoding: () => RGBEEncoding,
  RGBEFormat: () => RGBEFormat,
  RGBFormat: () => RGBFormat,
  RGBIntegerFormat: () => RGBIntegerFormat,
  RGBM16Encoding: () => RGBM16Encoding,
  RGBM7Encoding: () => RGBM7Encoding,
  RGB_ETC1_Format: () => RGB_ETC1_Format,
  RGB_ETC2_Format: () => RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
  RGFormat: () => RGFormat,
  RGIntegerFormat: () => RGIntegerFormat,
  RawShaderMaterial: () => RawShaderMaterial,
  Ray: () => Ray,
  Raycaster: () => Raycaster,
  RectAreaLight: () => RectAreaLight,
  RedFormat: () => RedFormat,
  RedIntegerFormat: () => RedIntegerFormat,
  ReinhardToneMapping: () => ReinhardToneMapping,
  RepeatWrapping: () => RepeatWrapping,
  ReplaceStencilOp: () => ReplaceStencilOp,
  ReverseSubtractEquation: () => ReverseSubtractEquation,
  RingBufferGeometry: () => RingGeometry,
  RingGeometry: () => RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format: () => SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format: () => SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format: () => SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format: () => SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format: () => SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format: () => SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format: () => SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format: () => SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format: () => SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format: () => SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format: () => SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format: () => SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format: () => SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format: () => SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene: () => Scene,
  SceneUtils: () => SceneUtils,
  ShaderChunk: () => ShaderChunk,
  ShaderLib: () => ShaderLib,
  ShaderMaterial: () => ShaderMaterial,
  ShadowMaterial: () => ShadowMaterial,
  Shape: () => Shape,
  ShapeBufferGeometry: () => ShapeGeometry,
  ShapeGeometry: () => ShapeGeometry,
  ShapePath: () => ShapePath,
  ShapeUtils: () => ShapeUtils,
  ShortType: () => ShortType,
  Skeleton: () => Skeleton,
  SkeletonHelper: () => SkeletonHelper,
  SkinnedMesh: () => SkinnedMesh,
  SmoothShading: () => SmoothShading,
  Sphere: () => Sphere,
  SphereBufferGeometry: () => SphereGeometry,
  SphereGeometry: () => SphereGeometry,
  Spherical: () => Spherical,
  SphericalHarmonics3: () => SphericalHarmonics3,
  SplineCurve: () => SplineCurve,
  SpotLight: () => SpotLight,
  SpotLightHelper: () => SpotLightHelper,
  Sprite: () => Sprite,
  SpriteMaterial: () => SpriteMaterial,
  SrcAlphaFactor: () => SrcAlphaFactor,
  SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
  SrcColorFactor: () => SrcColorFactor,
  StaticCopyUsage: () => StaticCopyUsage,
  StaticDrawUsage: () => StaticDrawUsage,
  StaticReadUsage: () => StaticReadUsage,
  StereoCamera: () => StereoCamera,
  StreamCopyUsage: () => StreamCopyUsage,
  StreamDrawUsage: () => StreamDrawUsage,
  StreamReadUsage: () => StreamReadUsage,
  StringKeyframeTrack: () => StringKeyframeTrack,
  SubtractEquation: () => SubtractEquation,
  SubtractiveBlending: () => SubtractiveBlending,
  TOUCH: () => TOUCH,
  TangentSpaceNormalMap: () => TangentSpaceNormalMap,
  TetrahedronBufferGeometry: () => TetrahedronGeometry,
  TetrahedronGeometry: () => TetrahedronGeometry,
  TextBufferGeometry: () => TextGeometry,
  TextGeometry: () => TextGeometry,
  Texture: () => Texture,
  TextureLoader: () => TextureLoader,
  TorusBufferGeometry: () => TorusGeometry,
  TorusGeometry: () => TorusGeometry,
  TorusKnotBufferGeometry: () => TorusKnotGeometry,
  TorusKnotGeometry: () => TorusKnotGeometry,
  Triangle: () => Triangle,
  TriangleFanDrawMode: () => TriangleFanDrawMode,
  TriangleStripDrawMode: () => TriangleStripDrawMode,
  TrianglesDrawMode: () => TrianglesDrawMode,
  TubeBufferGeometry: () => TubeGeometry,
  TubeGeometry: () => TubeGeometry,
  UVMapping: () => UVMapping,
  Uint16Attribute: () => Uint16Attribute,
  Uint16BufferAttribute: () => Uint16BufferAttribute,
  Uint32Attribute: () => Uint32Attribute,
  Uint32BufferAttribute: () => Uint32BufferAttribute,
  Uint8Attribute: () => Uint8Attribute,
  Uint8BufferAttribute: () => Uint8BufferAttribute,
  Uint8ClampedAttribute: () => Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
  Uniform: () => Uniform,
  UniformsLib: () => UniformsLib,
  UniformsUtils: () => UniformsUtils,
  UnsignedByteType: () => UnsignedByteType,
  UnsignedInt248Type: () => UnsignedInt248Type,
  UnsignedIntType: () => UnsignedIntType,
  UnsignedShort4444Type: () => UnsignedShort4444Type,
  UnsignedShort5551Type: () => UnsignedShort5551Type,
  UnsignedShort565Type: () => UnsignedShort565Type,
  UnsignedShortType: () => UnsignedShortType,
  VSMShadowMap: () => VSMShadowMap,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  VectorKeyframeTrack: () => VectorKeyframeTrack,
  Vertex: () => Vertex,
  VertexColors: () => VertexColors,
  VideoTexture: () => VideoTexture,
  WebGL1Renderer: () => WebGL1Renderer,
  WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
  WebGLMultisampleRenderTarget: () => WebGLMultisampleRenderTarget,
  WebGLRenderTarget: () => WebGLRenderTarget,
  WebGLRenderTargetCube: () => WebGLRenderTargetCube,
  WebGLRenderer: () => WebGLRenderer,
  WebGLUtils: () => WebGLUtils,
  WireframeGeometry: () => WireframeGeometry,
  WireframeHelper: () => WireframeHelper,
  WrapAroundEnding: () => WrapAroundEnding,
  XHRLoader: () => XHRLoader,
  ZeroCurvatureEnding: () => ZeroCurvatureEnding,
  ZeroFactor: () => ZeroFactor,
  ZeroSlopeEnding: () => ZeroSlopeEnding,
  ZeroStencilOp: () => ZeroStencilOp,
  sRGBEncoding: () => sRGBEncoding
});
var REVISION = "126";
var MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2};
var TOUCH = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3};
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;
var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;
var GLSL1 = "100";
var GLSL3 = "300 es";
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index4 = listenerArray.indexOf(listener);
      if (index4 !== -1) {
        listenerArray.splice(index4, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
var _seed = 1234567;
var MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n, m2) {
    return (n % m2 + m2) % m2;
  },
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  lerp: function(x, y2, t) {
    return (1 - t) * x + t * y2;
  },
  damp: function(x, y2, lambda, dt) {
    return MathUtils.lerp(x, y2, 1 - Math.exp(-lambda * dt));
  },
  pingpong: function(x, length2 = 1) {
    return length2 - Math.abs(MathUtils.euclideanModulo(x, length2 * 2) - length2);
  },
  smoothstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s2) {
    if (s2 !== void 0)
      _seed = s2 % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q, a2, b, c, order2) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a2 + c) / 2);
    const s13 = sin((a2 + c) / 2);
    const c1_3 = cos((a2 - c) / 2);
    const s1_3 = sin((a2 - c) / 2);
    const c3_1 = cos((c - a2) / 2);
    const s3_1 = sin((c - a2) / 2);
    switch (order2) {
      case "XYX":
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case "YZY":
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case "ZXZ":
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case "XZX":
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case "YXY":
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case "ZYZ":
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order2);
    }
  }
};
var Vector2 = class {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y2) {
    this.x = x;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w3);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    return this;
  }
  sub(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w3);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x + e2[3] * y2 + e2[6];
    this.y = e2[1] * x + e2[4] * y2 + e2[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s2 = Math.sin(angle);
    const x = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x * c - y2 * s2 + center.x;
    this.y = x * s2 + y2 * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b) {
    const ae = a2.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a2 = te[0], b = te[1], c = te[2], d2 = te[3], e2 = te[4], f = te[5], g = te[6], h2 = te[7], i = te[8];
    return a2 * e2 * i - a2 * f * h2 - b * d2 * i + b * f * g + c * d2 * h2 - c * e2 * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m2 = this.elements;
    r[0] = m2[0];
    r[1] = m2[3];
    r[2] = m2[6];
    r[3] = m2[1];
    r[4] = m2[4];
    r[5] = m2[7];
    r[6] = m2[2];
    r[7] = m2[5];
    r[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx * c, sx * s2, -sx * (c * cx + s2 * cy) + cx + tx, -sy * s2, sy * c, -sy * (-s2 * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s2 * a21;
    te[3] = c * a12 + s2 * a22;
    te[6] = c * a13 + s2 * a23;
    te[1] = -s2 * a11 + c * a21;
    te[4] = -s2 * a12 + c * a22;
    te[7] = -s2 * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset3 = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset3];
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const te = this.elements;
    array[offset3] = te[0];
    array[offset3 + 1] = te[1];
    array[offset3 + 2] = te[2];
    array[offset3 + 3] = te[3];
    array[offset3 + 4] = te[4];
    array[offset3 + 5] = te[5];
    array[offset3 + 6] = te[6];
    array[offset3 + 7] = te[7];
    array[offset3 + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
var _canvas;
var ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping3 = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format3 = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping3;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format3;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i = 0, l = image.length; i < l; i++) {
            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x = 0, y2 = 0, z2 = 0, w3 = 1) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w3;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y2, z2, w3) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w3) {
    this.w = w3;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w3);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    this.z = a2.z + b.z;
    this.w = a2.w + b.w;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    this.w += v.w * s2;
    return this;
  }
  sub(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w3);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    this.z = a2.z - b.z;
    this.w = a2.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x = this.x, y2 = this.y, z2 = this.z, w3 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x + e2[4] * y2 + e2[8] * z2 + e2[12] * w3;
    this.y = e2[1] * x + e2[5] * y2 + e2[9] * z2 + e2[13] * w3;
    this.z = e2[2] * x + e2[6] * y2 + e2[10] * z2 + e2[14] * w3;
    this.w = e2[3] * x + e2[7] * y2 + e2[11] * z2 + e2[15] * w3;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s2 = Math.sqrt(1 - q.w * q.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s2;
      this.y = q.y / s2;
      this.z = q.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy2 = (m22 + 1) / 2;
      const zz2 = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy2 && xx > zz2) {
        if (xx < epsilon) {
          x = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y2 = xy / x;
          z2 = xz / x;
        }
      } else if (yy2 > zz2) {
        if (yy2 < epsilon) {
          x = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy2);
          x = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz2 < epsilon) {
          x = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz2);
          x = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    this.z = array[offset3 + 2];
    this.w = array[offset3 + 3];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    array[offset3 + 2] = this.z;
    array[offset3 + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    this.z = attribute.getZ(index4);
    this.w = attribute.getW(index4);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options2) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options2 = options2 || {};
    this.texture = new Texture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
    this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
    this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options2) {
    super(width, height, options2);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x = 0, y2 = 0, z2 = 0, w3 = 1) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._w = w3;
  }
  static slerp(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y2, z2, w3) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._w = w3;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y2 = euler._y, z2 = euler._z, order2 = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order2) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order2);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    const EPS = 1e-6;
    let r = vFrom.dot(vTo) + 1;
    if (r < EPS) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a2, b) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y2 = this._y, z2 = this._z, w3 = this._w;
    let cosHalfTheta = w3 * qb._w + x * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w3;
      this._x = x;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t;
      this._w = s2 * w3 + t * this._w;
      this._x = s2 * x + t * this._x;
      this._y = s2 * y2 + t * this._y;
      this._z = s2 * z2 + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w3 * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset3 = 0) {
    this._x = array[offset3];
    this._y = array[offset3 + 1];
    this._z = array[offset3 + 2];
    this._w = array[offset3 + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this._x;
    array[offset3 + 1] = this._y;
    array[offset3 + 2] = this._z;
    array[offset3 + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index4) {
    this._x = attribute.getX(index4);
    this._y = attribute.getY(index4);
    this._z = attribute.getZ(index4);
    this._w = attribute.getW(index4);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x = 0, y2 = 0, z2 = 0) {
    this.x = x;
    this.y = y2;
    this.z = z2;
  }
  set(x, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w3);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b) {
    this.x = a2.x + b.x;
    this.y = a2.y + b.y;
    this.z = a2.z + b.z;
    return this;
  }
  addScaledVector(v, s2) {
    this.x += v.x * s2;
    this.y += v.y * s2;
    this.z += v.z * s2;
    return this;
  }
  sub(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w3);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b) {
    this.x = a2.x - b.x;
    this.y = a2.y - b.y;
    this.z = a2.z - b.z;
    return this;
  }
  multiply(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w3);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b) {
    this.x = a2.x * b.x;
    this.y = a2.y * b.y;
    this.z = a2.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w3 = 1 / (e2[3] * x + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x + e2[4] * y2 + e2[8] * z2 + e2[12]) * w3;
    this.y = (e2[1] * x + e2[5] * y2 + e2[9] * z2 + e2[13]) * w3;
    this.z = (e2[2] * x + e2[6] * y2 + e2[10] * z2 + e2[14]) * w3;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x;
    const iw = -qx * x - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w3);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a2, b) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index4) {
    return this.fromArray(m2.elements, index4 * 4);
  }
  setFromMatrix3Column(m2, index4) {
    return this.fromArray(m2.elements, index4 * 3);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    this.z = array[offset3 + 2];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    array[offset3 + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    this.z = attribute.getZ(index4);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
};
Vector3.prototype.isVector3 = true;
var _vector = /* @__PURE__ */ new Vector3();
var _quaternion = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y2 = array[i + 1];
      const z2 = array[i + 2];
      if (x < minX)
        minX = x;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x > maxX)
        maxX = x;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y2 = attribute.getY(i);
      const z2 = attribute.getZ(i);
      if (x < minX)
        minX = x;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x > maxX)
        maxX = x;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box.copy(geometry.boundingBox);
      _box.applyMatrix4(object.matrixWorld);
      this.union(_box);
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$1);
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0.subVectors(triangle.a, _center);
    _v1.subVectors(triangle.b, _center);
    _v2.subVectors(triangle.c, _center);
    _f0.subVectors(_v1, _v0);
    _f1.subVectors(_v2, _v1);
    _f2.subVectors(_v0, _v2);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset3) {
    this.min.add(offset3);
    this.max.add(offset3);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$1 = /* @__PURE__ */ new Vector3();
var _box = /* @__PURE__ */ new Box3();
var _v0 = /* @__PURE__ */ new Vector3();
var _v1 = /* @__PURE__ */ new Vector3();
var _v2 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
var _box$1 = /* @__PURE__ */ new Box3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset3) {
    this.center.add(offset3);
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$2 = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$2));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$2.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);
    const tca = _vector$2.dot(this.direction);
    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$2) !== null;
  }
  intersectTriangle(a2, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a2);
    _edge2.subVectors(c, a2);
    _normal.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v1$1.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$1.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m2, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae = a2 * e2, af = a2 * f, be = b * e2, bf = b * f;
      te[0] = c * e2;
      te[4] = -c * f;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b * c;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e2, cf = c * f, de = d2 * e2, df = d2 * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f;
      te[5] = a2 * e2;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a2 * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e2, cf = c * f, de = d2 * e2, df = d2 * f;
      te[0] = ce - df * b;
      te[4] = -a2 * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a2 * e2;
      te[9] = df - ce * b;
      te[2] = -a2 * d2;
      te[6] = b;
      te[10] = a2 * c;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2, af = a2 * f, be = b * e2, bf = b * f;
      te[0] = c * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c * f;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b * c;
      te[10] = a2 * c;
    } else if (euler.order === "YZX") {
      const ac = a2 * c, ad = a2 * d2, bc = b * c, bd = b * d2;
      te[0] = c * e2;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a2 * e2;
      te[9] = -b * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a2 * c, ad = a2 * d2, bc = b * c, bd = b * d2;
      te[0] = c * e2;
      te[4] = -f;
      te[8] = d2 * e2;
      te[1] = ac * f + bd;
      te[5] = a2 * e2;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e2;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m2, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b) {
    const ae = a2.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y2, z2) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y2;
      te[14] = z2;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y2 = v.y, z2 = v.z;
    te[0] *= x;
    te[4] *= y2;
    te[8] *= z2;
    te[1] *= x;
    te[5] *= y2;
    te[9] *= z2;
    te[2] *= x;
    te[6] *= y2;
    te[10] *= z2;
    te[3] *= x;
    te[7] *= y2;
    te[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y2, z2) {
    this.set(1, 0, 0, x, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t * x, ty = t * y2;
    this.set(tx * x + c, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c, ty * z2 - s2 * x, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x, t * z2 * z2 + c, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y2, z2) {
    this.set(x, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x, y2, z2) {
    this.set(1, y2, z2, 0, x, 1, z2, 0, x, y2, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position2, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w3 = quaternion._w;
    const x2 = x + x, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x * x2, xy = x * y22, xz = x * z22;
    const yy2 = y2 * y22, yz = y2 * z22, zz2 = z2 * z22;
    const wx = w3 * x2, wy = w3 * y22, wz = w3 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy2 + zz2)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz2)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy2)) * sz;
    te[11] = 0;
    te[12] = position2.x;
    te[13] = position2.y;
    te[14] = position2.z;
    te[15] = 1;
    return this;
  }
  decompose(position2, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$1.set(te[0], te[1], te[2]).length();
    const sy = _v1$1.set(te[4], te[5], te[6]).length();
    const sz = _v1$1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position2.x = te[12];
    position2.y = te[13];
    position2.z = te[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w3 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w3;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p;
    te[0] = 2 * w3;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset3 = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset3];
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const te = this.elements;
    array[offset3] = te[0];
    array[offset3 + 1] = te[1];
    array[offset3 + 2] = te[2];
    array[offset3 + 3] = te[3];
    array[offset3 + 4] = te[4];
    array[offset3 + 5] = te[5];
    array[offset3 + 6] = te[6];
    array[offset3 + 7] = te[7];
    array[offset3 + 8] = te[8];
    array[offset3 + 9] = te[9];
    array[offset3 + 10] = te[10];
    array[offset3 + 11] = te[11];
    array[offset3 + 12] = te[12];
    array[offset3 + 13] = te[13];
    array[offset3 + 14] = te[14];
    array[offset3 + 15] = te[15];
    return array;
  }
};
Matrix4.prototype.isMatrix4 = true;
var _v1$1 = /* @__PURE__ */ new Vector3();
var _m1 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix4();
var _quaternion$1 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x = 0, y2 = 0, z2 = 0, order2 = Euler.DefaultOrder) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._order = order2;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y2, z2, order2) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._order = order2 || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order2, update) {
    const clamp = MathUtils.clamp;
    const te = m2.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    order2 = order2 || this._order;
    switch (order2) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order2);
    }
    this._order = order2;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order2, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order2, update);
  }
  setFromVector3(v, order2) {
    return this.set(v.x, v.y, v.z, order2 || this._order);
  }
  reorder(newOrder) {
    _quaternion$1.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$1, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this._x;
    array[offset3 + 1] = this._y;
    array[offset3 + 2] = this._z;
    array[offset3 + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
var _object3DId = 0;
var _v1$2 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position = new Vector3();
var _scale = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = {type: "added"};
var _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position2 = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position2
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x, y2, z2) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index4 = this.children.indexOf(object);
    if (index4 !== -1) {
      object.parent = null;
      this.children.splice(index4, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name2) {
    return this.getObjectByProperty("name", name2);
  },
  getObjectByProperty: function(name2, value) {
    if (this[name2] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name2, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    }
    function serialize2(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize2(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize2(meta.shapes, shape);
          }
        } else {
          serialize2(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize2(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize2(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize2(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize2(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data3 = cache3[key];
        delete data3.metadata;
        values.push(data3);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y2, z2, w3) {
    this.normal.set(x, y2, z2);
    this.constant = w3;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a2, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line2, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target = new Vector3();
    }
    const direction = line2.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line2.start) === 0) {
        return target.copy(line2.start);
      }
      return void 0;
    }
    const t = -(line2.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return void 0;
    }
    return target.copy(direction).multiplyScalar(t).add(line2.start);
  }
  intersectsLine(line2) {
    const startSign = this.distanceToPoint(line2.start);
    const endSign = this.distanceToPoint(line2.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset3) {
    this.constant -= offset3.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$1 = /* @__PURE__ */ new Vector3();
var _v3 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a2 = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a2;
    this.b = b;
    this.c = c;
  }
  static getNormal(a2, b, c, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target = new Vector3();
    }
    target.subVectors(c, b);
    _v0$1.subVectors(a2, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a2, b, c, target) {
    _v0$1.subVectors(c, a2);
    _v1$3.subVectors(b, a2);
    _v2$1.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$1);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$1);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target = new Vector3();
    }
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a2, b, c) {
    this.getBarycoord(point, a2, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  }
  static isFrontFacing(a2, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a2, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a2, b, c) {
    this.a.copy(a2);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    const a2 = this.a, b = this.b, c = this.c;
    let v, w3;
    _vab.subVectors(b, a2);
    _vac.subVectors(c, a2);
    _vap.subVectors(p, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w3 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w3);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w3);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w3 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v).addScaledVector(_vac, w3);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data3 = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data3.uuid = this.uuid;
    data3.type = this.type;
    if (this.name !== "")
      data3.name = this.name;
    if (this.color && this.color.isColor)
      data3.color = this.color.getHex();
    if (this.roughness !== void 0)
      data3.roughness = this.roughness;
    if (this.metalness !== void 0)
      data3.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data3.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data3.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data3.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data3.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data3.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data3.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data3.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data3.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data3.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data3.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data3.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data3.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data3.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data3.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data3.lightMap = this.lightMap.toJSON(meta).uuid;
      data3.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data3.aoMap = this.aoMap.toJSON(meta).uuid;
      data3.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data3.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data3.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data3.normalMap = this.normalMap.toJSON(meta).uuid;
      data3.normalMapType = this.normalMapType;
      data3.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data3.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data3.displacementScale = this.displacementScale;
      data3.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data3.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data3.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data3.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data3.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data3.envMap = this.envMap.toJSON(meta).uuid;
      data3.reflectivity = this.reflectivity;
      data3.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data3.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data3.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data3.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data3.size = this.size;
    if (this.sizeAttenuation !== void 0)
      data3.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data3.blending = this.blending;
    if (this.side !== FrontSide)
      data3.side = this.side;
    if (this.vertexColors)
      data3.vertexColors = true;
    if (this.opacity < 1)
      data3.opacity = this.opacity;
    if (this.transparent === true)
      data3.transparent = this.transparent;
    data3.depthFunc = this.depthFunc;
    data3.depthTest = this.depthTest;
    data3.depthWrite = this.depthWrite;
    data3.stencilWrite = this.stencilWrite;
    data3.stencilWriteMask = this.stencilWriteMask;
    data3.stencilFunc = this.stencilFunc;
    data3.stencilRef = this.stencilRef;
    data3.stencilFuncMask = this.stencilFuncMask;
    data3.stencilFail = this.stencilFail;
    data3.stencilZFail = this.stencilZFail;
    data3.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data3.rotation = this.rotation;
    if (this.polygonOffset === true)
      data3.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data3.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data3.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data3.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data3.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data3.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data3.scale = this.scale;
    if (this.dithering === true)
      data3.dithering = true;
    if (this.alphaTest > 0)
      data3.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data3.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data3.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data3.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data3.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data3.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data3.morphTargets = true;
    if (this.morphNormals === true)
      data3.morphNormals = true;
    if (this.skinning === true)
      data3.skinning = true;
    if (this.flatShading === true)
      data3.flatShading = this.flatShading;
    if (this.visible === false)
      data3.visible = false;
    if (this.toneMapped === false)
      data3.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data3.userData = this.userData;
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data4 = cache3[key];
        delete data4.metadata;
        values.push(data4);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data3.textures = textures;
      if (images.length > 0)
        data3.images = images;
    }
    return data3;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var _hslA = {h: 0, s: 0, l: 0};
var _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var Color = class {
  constructor(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  setHSL(h2, s2, l) {
    h2 = MathUtils.euclideanModulo(h2, 1);
    s2 = MathUtils.clamp(s2, 0, 1);
    l = MathUtils.clamp(l, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s2) : l + s2 - l * s2;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h2 + 1 / 3);
      this.g = hue2rgb(q, p, h2);
      this.b = hue2rgb(q, p, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name2 = m2[1];
      const components2 = m2[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            const h2 = parseFloat(color[1]) / 360;
            const s2 = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h2, s2, l);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = {h: 0, s: 0, l: 0};
    }
    const r = this.r, g = this.g, b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s2 = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset3 = 0) {
    this.r = array[offset3];
    this.g = array[offset3 + 1];
    this.b = array[offset3 + 2];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.r;
    array[offset3 + 1] = this.g;
    array[offset3 + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index4) {
    this.r = attribute.getX(index4);
    this.g = attribute.getY(index4);
    this.b = attribute.getZ(index4);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$3 = new Vector3();
var _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index22) {
    index1 *= this.itemSize;
    index22 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index22 + i];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors2) {
    const array = this.array;
    let offset3 = 0;
    for (let i = 0, l = colors2.length; i < l; i++) {
      let color = colors2[i];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color = new Color();
      }
      array[offset3++] = color.r;
      array[offset3++] = color.g;
      array[offset3++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
      array[offset3++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
      array[offset3++] = vector.z;
      array[offset3++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m2) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.fromBufferAttribute(this, i);
        _vector$3.applyMatrix3(m2);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m2) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyMatrix4(m2);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  applyNormalMatrix: function(m2) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyNormalMatrix(m2);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  transformDirection: function(m2) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.transformDirection(m2);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  set: function(value, offset3 = 0) {
    this.array.set(value, offset3);
    return this;
  },
  getX: function(index4) {
    return this.array[index4 * this.itemSize];
  },
  setX: function(index4, x) {
    this.array[index4 * this.itemSize] = x;
    return this;
  },
  getY: function(index4) {
    return this.array[index4 * this.itemSize + 1];
  },
  setY: function(index4, y2) {
    this.array[index4 * this.itemSize + 1] = y2;
    return this;
  },
  getZ: function(index4) {
    return this.array[index4 * this.itemSize + 2];
  },
  setZ: function(index4, z2) {
    this.array[index4 * this.itemSize + 2] = z2;
    return this;
  },
  getW: function(index4) {
    return this.array[index4 * this.itemSize + 3];
  },
  setW: function(index4, w3) {
    this.array[index4 * this.itemSize + 3] = w3;
    return this;
  },
  setXY: function(index4, x, y2) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x;
    this.array[index4 + 1] = y2;
    return this;
  },
  setXYZ: function(index4, x, y2, z2) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x;
    this.array[index4 + 1] = y2;
    this.array[index4 + 2] = z2;
    return this;
  },
  setXYZW: function(index4, x, y2, z2, w3) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x;
    this.array[index4 + 1] = y2;
    this.array[index4 + 2] = z2;
    this.array[index4 + 3] = w3;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max)
      max = array[i];
  }
  return max;
}
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
var _id = 0;
var _m1$2 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index4) {
    if (Array.isArray(index4)) {
      this.index = new (arrayMax(index4) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index4, 1);
    } else {
      this.index = index4;
    }
    return this;
  },
  getAttribute: function(name2) {
    return this.attributes[name2];
  },
  setAttribute: function(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  },
  deleteAttribute: function(name2) {
    delete this.attributes[name2];
    return this;
  },
  hasAttribute: function(name2) {
    return this.attributes[name2] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position2 = this.attributes.position;
    if (position2 !== void 0) {
      position2.applyMatrix4(matrix);
      position2.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function(x, y2, z2) {
    _m1$2.makeTranslation(x, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function(x, y2, z2) {
    _m1$2.makeScale(x, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position2 = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position2.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position2, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$4);
            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position2) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$4);
            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position2.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position2, j);
              _vector$4.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index4 = this.index;
    const attributes = this.attributes;
    if (index4 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index4.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b, c) {
      vA.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a2].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a2].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w3 = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp2.x;
      tangents[v * 4 + 1] = tmp2.y;
      tangents[v * 4 + 2] = tmp2.z;
      tangents[v * 4 + 3] = w3;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index4 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index4) {
        for (let i = 0, il = index4.count; i < il; i += 3) {
          const vA = index4.getX(i + 0);
          const vB = index4.getX(i + 1);
          const vC = index4.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset3) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset3 === void 0) {
      offset3 = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset3;
      const length2 = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length2; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$4.fromBufferAttribute(normals, i);
      _vector$4.normalize();
      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index4 = 0, index22 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        index4 = indices2[i] * itemSize;
        for (let j = 0; j < itemSize; j++) {
          array2[index22++] = array[index4++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data3 = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data3.uuid = this.uuid;
    data3.type = this.type;
    if (this.name !== "")
      data3.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data3.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data3[key] = parameters[key];
      }
      return data3;
    }
    data3.data = {attributes: {}};
    const index4 = this.index;
    if (index4 !== null) {
      data3.data.index = {
        type: index4.array.constructor.name,
        array: Array.prototype.slice.call(index4.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data3.data);
      if (attribute.name !== "")
        attributeData.name = attribute.name;
      data3.data.attributes[key] = attributeData;
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        const attributeData = attribute.toJSON(data3.data);
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data3.data.morphAttributes = morphAttributes;
      data3.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data3.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data3.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data3;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data3 = {};
    this.name = source.name;
    const index4 = source.index;
    if (index4 !== null) {
      this.setIndex(index4.clone(data3));
    }
    const attributes = source.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data3));
    }
    const morphAttributes = source.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data3));
      }
      this.morphAttributes[name2] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const position2 = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index4 !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a2 = index4.getX(j);
              const b = index4.getX(j + 1);
              const c = index4.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index4.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a2 = index4.getX(i);
            const b = index4.getX(i + 1);
            const c = index4.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position2 !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a2 = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position2.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a2 = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b, c) {
  _vA.fromBufferAttribute(position2, a2);
  _vB.fromBufferAttribute(position2, b);
  _vC.fromBufferAttribute(position2, c);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);
        _morphB.addScaledVector(_tempB.sub(_vB), influence);
        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }
    _vA.add(_morphA);
    _vB.add(_morphB);
    _vC.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a2, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a2);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a2);
      _uvB.fromBufferAttribute(uv2, b);
      _uvC.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    const face = {
      a: a2,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w3, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y2 * vdir;
          vector[w3] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w3] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b, d2);
          indices.push(b, c, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
};
function cloneUniforms(src3) {
  const dst = {};
  for (const u in src3) {
    dst[u] = {};
    for (const p in src3[u]) {
      const property = src3[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
var UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data3 = Material.prototype.toJSON.call(this, meta);
  data3.glslVersion = this.glslVersion;
  data3.uniforms = {};
  for (const name2 in this.uniforms) {
    const uniform = this.uniforms[name2];
    const value = uniform.value;
    if (value && value.isTexture) {
      data3.uniforms[name2] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data3.uniforms[name2] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data3.uniforms[name2] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data3.uniforms[name2] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data3.uniforms[name2] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data3.uniforms[name2] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data3.uniforms[name2] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data3.uniforms[name2] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data3.defines = this.defines;
  data3.vertexShader = this.vertexShader;
  data3.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data3.extensions = extensions;
  return data3;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data3 = Object3D.prototype.toJSON.call(this, meta);
    data3.object.fov = this.fov;
    data3.object.zoom = this.zoom;
    data3.object.near = this.near;
    data3.object.far = this.far;
    data3.object.focus = this.focus;
    data3.object.aspect = this.aspect;
    if (this.view !== null)
      data3.object.view = Object.assign({}, this.view);
    data3.object.filmGauge = this.filmGauge;
    data3.object.filmOffset = this.filmOffset;
    return data3;
  }
});
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping3 = mapping3 !== void 0 ? mapping3 : CubeReflectionMapping;
    format3 = format3 !== void 0 ? format3 : RGBFormat;
    super(images, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options2, dummy) {
    if (Number.isInteger(options2)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options2 = dummy;
    }
    super(size, size, options2);
    options2 = options2 || {};
    this.texture = new CubeTexture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var DataTexture = class extends Texture {
  constructor(data3, width, height, format3, type, mapping3, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy, encoding);
    this.image = {data: data3 || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _sphere$1 = /* @__PURE__ */ new Sphere();
var _vector$5 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me = m2.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);
    _sphere$1.radius = 0.7071067811865476;
    _sphere$1.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time4, frame) {
    animationLoop(time4, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data3 = buffers.get(attribute);
    if (data3) {
      gl.deleteBuffer(data3.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data3 = buffers.get(attribute);
    if (data3 === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data3.version < attribute.version) {
      updateBuffer(data3.buffer, attribute, bufferType);
      data3.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b, d2);
        indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
var UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      if (background.isWebGLCubeRenderTarget) {
        background = background.texture;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index4) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index4);
      if (updateBuffers)
        saveCache(geometry, index4);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index4 !== null) {
      attributes.update(index4, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index4 !== null) {
        gl.bindBuffer(34963, attributes.get(index4).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index4) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index4)
      return true;
    return false;
  }
  function saveCache(geometry, index4) {
    const cache3 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data3 = {};
      data3.attribute = attribute;
      if (attribute.data) {
        data3.data = attribute.data;
      }
      cache3[key] = data3;
      attributesNum++;
    }
    currentState.attributes = cache3;
    currentState.attributesNum = attributesNum;
    currentState.index = index4;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index4, size, type, normalized, stride, offset3) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index4, size, type, stride, offset3);
    } else {
      gl.vertexAttribPointer(index4, size, type, normalized, stride, offset3);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data3 = geometryAttribute.data;
            const stride = data3.stride;
            const offset3 = geometryAttribute.offset;
            if (data3 && data3.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data3.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data3.meshPerAttribute * data3.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset3 * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name2 === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name2 === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose2() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose: dispose2,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render2(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping3) {
    if (mapping3 === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping3 === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping3 = texture.mapping;
      if (mapping3 === EquirectangularReflectionMapping || mapping3 === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose2() {
    cubemaps = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name2);
    }
    extensions[name2] = extension;
    return extension;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name2) {
      const extension = getExtension(name2);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name2 in geometry.attributes) {
      attributes.remove(geometry.attributes[name2]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = morphAttributes[name2];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a2 = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a2, b, b, c, c, a2);
      }
    } else {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a2 = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a2, b, b, c, c, a2);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render2.calls++;
    switch (mode) {
      case 4:
        render2.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render2.lines += instanceCount * (count / 2);
        break;
      case 3:
        render2.lines += instanceCount * (count - 1);
        break;
      case 2:
        render2.lines += instanceCount * count;
        break;
      case 0:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render2.frame++;
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a2, b) {
  return a2[0] - b[0];
}
function absNumericalSort(a2, b) {
  return Math.abs(b[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length2 = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i = 0; i < length2; i++) {
        influences[i] = [i, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i = 0; i < length2; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }
    influences.sort(absNumericalSort);
    for (let i = 0; i < 8; i++) {
      if (i < length2 && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index4 = influence[0];
      const value = influence[1];
      if (index4 !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index4]) {
          geometry.setAttribute("morphTarget" + i, morphTargets[index4]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index4]) {
          geometry.setAttribute("morphNormal" + i, morphNormals[index4]);
        }
        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
          geometry.deleteAttribute("morphTarget" + i);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
          geometry.deleteAttribute("morphNormal" + i);
        }
        morphInfluences[i] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose2() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose: dispose2
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data3 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data: data3, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
var DataTexture3D = class extends Texture {
  constructor(data3 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data: data3, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset3 = 0; i !== nBlocks; ++i) {
      offset3 += blockSize;
      array[i].toArray(r, offset3);
    }
  }
  return r;
}
function arraysEqual(a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i = 0, l = a2.length; i < l; i++) {
    if (a2[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a2, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a2[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache3 = this.cache;
  if (cache3[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache3[0] = v;
}
function setValueV2f(gl, v) {
  const cache3 = this.cache;
  if (v.x !== void 0) {
    if (cache3[0] !== v.x || cache3[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache3[0] = v.x;
      cache3[1] = v.y;
    }
  } else {
    if (arraysEqual(cache3, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache3, v);
  }
}
function setValueV3f(gl, v) {
  const cache3 = this.cache;
  if (v.x !== void 0) {
    if (cache3[0] !== v.x || cache3[1] !== v.y || cache3[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache3[0] = v.x;
      cache3[1] = v.y;
      cache3[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache3[0] !== v.r || cache3[1] !== v.g || cache3[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache3[0] = v.r;
      cache3[1] = v.g;
      cache3[2] = v.b;
    }
  } else {
    if (arraysEqual(cache3, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache3, v);
  }
}
function setValueV4f(gl, v) {
  const cache3 = this.cache;
  if (v.x !== void 0) {
    if (cache3[0] !== v.x || cache3[1] !== v.y || cache3[2] !== v.z || cache3[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache3[0] = v.x;
      cache3[1] = v.y;
      cache3[2] = v.z;
      cache3[3] = v.w;
    }
  } else {
    if (arraysEqual(cache3, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache3, v);
  }
}
function setValueM2(gl, v) {
  const cache3 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache3, v);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache3, elements);
  }
}
function setValueM3(gl, v) {
  const cache3 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache3, v);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache3, elements);
  }
}
function setValueM4(gl, v) {
  const cache3 = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache3, v);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache3, elements);
  }
}
function setValueT1(gl, v, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueV1i(gl, v) {
  const cache3 = this.cache;
  if (cache3[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache3[0] = v;
}
function setValueV2i(gl, v) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache3, v);
}
function setValueV3i(gl, v) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache3, v);
}
function setValueV4i(gl, v) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache3, v);
}
function setValueV1ui(gl, v) {
  const cache3 = this.cache;
  if (cache3[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache3[0] = v;
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data3 = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data3);
}
function setValueV3fArray(gl, v) {
  const data3 = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data3);
}
function setValueV4fArray(gl, v) {
  const data3 = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data3);
}
function setValueM2Array(gl, v) {
  const data3 = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data3);
}
function setValueM3Array(gl, v) {
  const data3 = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data3);
}
function setValueM4Array(gl, v) {
  const data3 = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data3);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units3 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units3);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units3[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units3 = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units3);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units3[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data3) {
  const cache3 = this.cache;
  if (data3 instanceof Float32Array && cache3.length !== data3.length) {
    this.cache = new Float32Array(data3.length);
  }
  copyArray(cache3, data3);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match2 = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match2[1];
    const idIsIndex = match2[2] === "]", subscript = match2[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next3 = map[id];
      if (next3 === void 0) {
        next3 = new StructuredUniform(id);
        addUniform(container, next3);
      }
      container = next3;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name2, value, textures) {
  const u = this.map[name2];
  if (u !== void 0)
    u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name2) {
  const v = object[name2];
  if (v !== void 0)
    this.setValue(gl, name2, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values)
      r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log2 = gl.getShaderInfoLog(shader).trim();
  if (status && log2 === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log2 + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components2 = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components2[0] + "ToLinear" + components2[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components2 = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components2[0] + components2[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false)
      continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name2 = info.name;
    attributes[name2] = gl.getAttribLocation(program, name2);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match2, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match2, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match2, start, end, snippet);
}
function loopReplacer(match2, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array.push(name2);
        array.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose2() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose: dispose2
  };
}
function painterSortStable(a2, b) {
  if (a2.groupOrder !== b.groupOrder) {
    return a2.groupOrder - b.groupOrder;
  } else if (a2.renderOrder !== b.renderOrder) {
    return a2.renderOrder - b.renderOrder;
  } else if (a2.program !== b.program) {
    return a2.program.id - b.program.id;
  } else if (a2.material.id !== b.material.id) {
    return a2.material.id - b.material.id;
  } else if (a2.z !== b.z) {
    return a2.z - b.z;
  } else {
    return a2.id - b.id;
  }
}
function reversePainterSortStable(a2, b) {
  if (a2.groupOrder !== b.groupOrder) {
    return a2.groupOrder - b.groupOrder;
  } else if (a2.renderOrder !== b.renderOrder) {
    return a2.renderOrder - b.renderOrder;
  } else if (a2.z !== b.z) {
    return b.z - a2.z;
  } else {
    return a2.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose2() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache3 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache3.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache3.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index4 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index4];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index4] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index4 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index4];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index4] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a2;
          g *= a2;
          b *= a2;
        }
        color.set(r, g, b, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target, count) {
    const data3 = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data3);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units3) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units3) {
        gl.polygonOffset(factor, units3);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units3;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask2 = 16384;
        if (renderTarget.depthBuffer)
          mask2 |= 256;
        if (renderTarget.stencilBuffer)
          mask2 |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask2, 9728);
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === UnsignedShort565Type)
      return 33635;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBFormat)
      return 6407;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBIntegerFormat)
      return 36248;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {convert};
}
function ArrayCamera(array = []) {
  PerspectiveCamera.call(this);
  this.cameras = array;
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    }
    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i = 0; i < cameras2.length; i++) {
      updateCamera(cameras2[i], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time4, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time4, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  const _this = this;
  let _isContextLost = false;
  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y2, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y2, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target = new Color();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index4 = geometry.index;
    const position2 = geometry.attributes.position;
    if (index4 === null) {
      if (position2 === void 0 || position2.count === 0)
        return;
    } else if (index4.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index4 = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index4);
    let attribute;
    let renderer = bufferRenderer;
    if (index4 !== null) {
      attribute = attributes.get(index4);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index4 !== null ? index4.count : position2.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    const compiled = new WeakMap();
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time4) {
    if (xr.isPresenting)
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time4);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function initMaterial(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let program = materialProperties.program;
    let programChange = true;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters2.uniforms;
      materialProperties.outputEncoding = parameters2.outputEncoding;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value && _currentRenderTarget === null)
      _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position2, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position2.x, position2.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position2, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position2.x, position2.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position2.x, position2.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position2.x, position2.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position2, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data: data3} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data3);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density) {
    this.name = "";
    this.color = new Color(color);
    this.density = density !== void 0 ? density : 25e-5;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near, far) {
    this.name = "";
    this.color = new Color(color);
    this.near = near !== void 0 ? near : 1;
    this.far = far !== void 0 ? far : 1e3;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data3 = super.toJSON(meta);
    if (this.background !== null)
      data3.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data3.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data3.object.fog = this.fog.toJSON();
    return data3;
  }
};
Scene.prototype.isScene = true;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index22) {
    index1 *= this.stride;
    index22 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index22 + i];
    }
    return this;
  },
  set: function(value, offset3 = 0) {
    this.array.set(value, offset3);
    return this;
  },
  clone: function(data3) {
    if (data3.arrayBuffers === void 0) {
      data3.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data3.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data3.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data3.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data3) {
    if (data3.arrayBuffers === void 0) {
      data3.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data3.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data3.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
var _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset3, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset3;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m2) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index4, x) {
    this.data.array[index4 * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function(index4, y2) {
    this.data.array[index4 * this.data.stride + this.offset + 1] = y2;
    return this;
  },
  setZ: function(index4, z2) {
    this.data.array[index4 * this.data.stride + this.offset + 2] = z2;
    return this;
  },
  setW: function(index4, w3) {
    this.data.array[index4 * this.data.stride + this.offset + 3] = w3;
    return this;
  },
  getX: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset];
  },
  getY: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 1];
  },
  getZ: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 2];
  },
  getW: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 3];
  },
  setXY: function(index4, x, y2) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x;
    this.data.array[index4 + 1] = y2;
    return this;
  },
  setXYZ: function(index4, x, y2, z2) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x;
    this.data.array[index4 + 1] = y2;
    this.data.array[index4 + 2] = z2;
    return this;
  },
  setXYZW: function(index4, x, y2, z2, w3) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x;
    this.data.array[index4 + 1] = y2;
    this.data.array[index4 + 2] = z2;
    this.data.array[index4 + 3] = w3;
    return this;
  },
  clone: function(data3) {
    if (data3 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index4 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index4 + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data3.interleavedBuffers === void 0) {
        data3.interleavedBuffers = {};
      }
      if (data3.interleavedBuffers[this.data.uuid] === void 0) {
        data3.interleavedBuffers[this.data.uuid] = this.data.clone(data3);
      }
      return new InterleavedBufferAttribute(data3.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data3) {
    if (data3 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index4 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index4 + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data3.interleavedBuffers === void 0) {
        data3.interleavedBuffers = {};
      }
      if (data3.interleavedBuffers[this.data.uuid] === void 0) {
        data3.interleavedBuffers[this.data.uuid] = this.data.toJSON(data3);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB$1.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$4 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, {distance, object});
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);
      _v2$2.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data3 = super.toJSON(meta);
    if (this.autoUpdate === false)
      data3.object.autoUpdate = false;
    data3.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data3.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data3;
  }
};
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$7 = new Vector3();
var _matrix$1 = new Matrix4();
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index4, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index4);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index4);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index4).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name2) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name2) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json3, bones) {
    this.uuid = json3.uuid;
    for (let i = 0, l = json3.bones.length; i < l; i++) {
      const uuid = json3.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json3.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data3 = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data3.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data3.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data3.boneInverses.push(boneInverse.toArray());
    }
    return data3;
  }
};
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index4, color) {
    color.fromArray(this.instanceColor.array, index4 * 3);
  },
  getMatrixAt: function(index4, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index4 * 16);
  },
  raycast: function(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId2 = 0; instanceId2 < raycastTimes; instanceId2++) {
      this.getMatrixAt(instanceId2, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId2;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index4, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index4 * 3);
  },
  setMatrixAt: function(index4, matrix) {
    matrix.toArray(this.instanceMatrix.array, index4 * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);
          _end.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index4 !== null) {
        const indices = index4.array;
        for (let i = 0, l = indices.length - 1; i < l; i += step) {
          const a2 = indices[i];
          const b = indices[i + 1];
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i = 0, l = positionAttribute.count - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
var _start$1 = new Vector3();
var _end$1 = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);
          _end$1.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index4 !== null) {
        const indices = index4.array;
        for (let i = 0, il = indices.length; i < il; i++) {
          const a2 = indices[i];
          _position$1.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$1, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          _position$1.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index4, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$2.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index4,
      face: null,
      object
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy) {
    super(video, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy);
    this.format = format3 !== void 0 ? format3 : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format3, type, mapping3, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy) {
    super(canvas, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping3, wrapS, wrapT, magFilter, minFilter, anisotropy, format3) {
    format3 = format3 !== void 0 ? format3 : DepthFormat;
    if (format3 !== DepthFormat && format3 !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format3 === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format3 === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping3, wrapS, wrapT, magFilter, minFilter, format3, type, anisotropy);
    this.image = {width, height};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var CircleGeometry = class extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i = 3; s2 <= segments; s2++, i += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var CylinderGeometry = class extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index4 = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v = y2 / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index4++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x];
          const b = indexArray[y2 + 1][x];
          const c = indexArray[y2 + 1][x + 1];
          const d2 = indexArray[y2][x + 1];
          indices.push(a2, b, d2);
          indices.push(b, c, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index4;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index4++;
      }
      const centerIndexEnd = index4;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign2;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index4++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
};
var ConeGeometry = class extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
};
var PolyhedronGeometry = class extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a2 = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a2);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a2, b, c, detail2);
      }
    }
    function subdivideFace(a2, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a2.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index4, vertex) {
      const stride = index4 * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a2 = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a2.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a2).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a2, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
};
var DodecahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var _v0$2 = new Vector3();
var _v1$5 = new Vector3();
var _normal$1 = new Vector3();
var _triangle = new Triangle();
var EdgesGeometry = class extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      thresholdAngle
    };
    thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
    if (geometry.isGeometry === true) {
      console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const precisionPoints = 4;
    const precision = Math.pow(10, precisionPoints);
    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute("position");
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ["a", "b", "c"];
    const hashes = new Array(3);
    const edgeData = {};
    const vertices = [];
    for (let i = 0; i < indexCount; i += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i);
        indexArr[1] = indexAttr.getX(i + 1);
        indexArr[2] = indexAttr.getX(i + 2);
      } else {
        indexArr[0] = i;
        indexArr[1] = i + 1;
        indexArr[2] = i + 2;
      }
      const {a: a2, b, c} = _triangle;
      a2.fromBufferAttribute(positionAttr, indexArr[0]);
      b.fromBufferAttribute(positionAttr, indexArr[1]);
      c.fromBufferAttribute(positionAttr, indexArr[2]);
      _triangle.getNormal(_normal$1);
      hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
      hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
      hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      }
      for (let j = 0; j < 3; j++) {
        const jNext = (j + 1) % 3;
        const vecHash0 = hashes[j];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash2 = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;
        if (reverseHash in edgeData && edgeData[reverseHash]) {
          if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
            vertices.push(v0.x, v0.y, v0.z);
            vertices.push(v1.x, v1.y, v1.z);
          }
          edgeData[reverseHash] = null;
        } else if (!(hash2 in edgeData)) {
          edgeData[hash2] = {
            index0: indexArr[j],
            index1: indexArr[jNext],
            normal: _normal$1.clone()
          };
        }
      }
    }
    for (const key in edgeData) {
      if (edgeData[key]) {
        const {index0, index1} = edgeData[key];
        _v0$2.fromBufferAttribute(positionAttr, index0);
        _v1$5.fromBufferAttribute(positionAttr, index1);
        vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
        vertices.push(_v1$5.x, _v1$5.y, _v1$5.z);
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
var Earcut = {
  triangulate: function(data3, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data3.length;
    let outerNode = linkedList(data3, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data3, holeIndices, outerNode, dim);
    if (data3.length > 80 * dim) {
      minX = maxX = data3[0];
      minY = maxY = data3[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data3[i];
        y2 = data3[i + 1];
        if (x < minX)
          minX = x;
        if (y2 < minY)
          minY = y2;
        if (x > maxX)
          maxX = x;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data3, start, end, dim, clockwise) {
  let i, last2;
  if (clockwise === signedArea(data3, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last2 = insertNode(i, data3[i], data3[i + 1], last2);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last2 = insertNode(i, data3[i], data3[i + 1], last2);
  }
  if (last2 && equals(last2, last2.next)) {
    removeNode(last2);
    last2 = last2.next;
  }
  return last2;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev2, next3;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next3 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next3.i / dim);
      removeNode(ear);
      ear = next3.next;
      stop = next3.next;
      continue;
    }
    ear = next3;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b = ear, c = ear.next;
  if (area(a2, b, c) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b = ear, c = ear.next;
  if (area(a2, b, c) >= 0)
    return false;
  const minTX = a2.x < b.x ? a2.x < c.x ? a2.x : c.x : b.x < c.x ? b.x : c.x, minTY = a2.y < b.y ? a2.y < c.y ? a2.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a2.x > b.x ? a2.x > c.x ? a2.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a2.y > b.y ? a2.y > c.y ? a2.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a2 = p.prev, b = p.next.next;
    if (!equals(a2, b) && intersects(a2, p, p.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b = a2.next.next;
    while (b !== a2.prev) {
      if (a2.i !== b.i && isValidDiagonal(a2, b)) {
        let c = splitPolygon(a2, b);
        a2 = filterPoints(a2, a2.next);
        c = filterPoints(c, c.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data3, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data3.length;
    list = linkedList(data3, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b) {
  return a2.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m2;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m2 = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p = m2;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m2.x || p.x === m2.x && sectorContainsSector(m2, p)))) {
        m2 = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m2;
}
function sectorContainsSector(m2, p) {
  return area(m2.prev, m2, p.prev) < 0 && area(p.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x | y2 << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px3, py2) {
  return (cx - px3) * (ay - py2) - (ax - px3) * (cy - py2) >= 0 && (ax - px3) * (by - py2) - (bx - px3) * (ay - py2) >= 0 && (bx - px3) * (cy - py2) - (cx - px3) * (by - py2) >= 0;
}
function isValidDiagonal(a2, b) {
  return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b) {
  let p = a2;
  do {
    if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a2, b))
      return true;
    p = p.next;
  } while (p !== a2);
  return false;
}
function locallyInside(a2, b) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
}
function middleInside(a2, b) {
  let p = a2, inside = false;
  const px3 = (a2.x + b.x) / 2, py2 = (a2.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px3 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a2);
  return inside;
}
function splitPolygon(a2, b) {
  const a22 = new Node(a2.i, a2.x, a2.y), b2 = new Node(b.i, b.x, b.y), an = a2.next, bp = b.prev;
  a2.next = b;
  b.prev = a2;
  a22.next = an;
  an.prev = a22;
  b2.next = a22;
  a22.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y2, last2) {
  const p = new Node(i, x, y2);
  if (!last2) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last2.next;
    p.prev = last2;
    last2.next.prev = p;
    last2.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y2) {
  this.i = i;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data3, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data3[j] - data3[i]) * (data3[i + 1] + data3[j + 1]);
    j = i;
  }
  return sum;
}
var ShapeUtils = {
  area: function(contour) {
    const n = contour.length;
    let a2 = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a2 += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a2 * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(shapes, options2) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options2
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
      const steps = options2.steps !== void 0 ? options2.steps : 1;
      let depth = options2.depth !== void 0 ? options2.depth : 100;
      let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
      let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 6;
      let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 2;
      let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
      let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
      const extrudePath = options2.extrudePath;
      const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
      if (options2.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options2.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z2 = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z2 = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z2);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset3 = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset3, face[1] + offset3, face[0] + offset3);
          }
          layer = steps + bevelSegments * 2;
          offset3 = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset3, face[1] + offset3, face[2] + offset3);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0)
            k = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d2 = layeroffset + j + slen2;
            f4(a2, b, c, d2);
          }
        }
      }
      function v(x, y2, z2) {
        placeholder.push(x);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a2, b, c) {
        addVertex(a2);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b, c, d2) {
        addVertex(a2);
        addVertex(b);
        addVertex(d2);
        addVertex(b);
        addVertex(c);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index4) {
        verticesArray.push(placeholder[index4 * 3 + 0]);
        verticesArray.push(placeholder[index4 * 3 + 1]);
        verticesArray.push(placeholder[index4 * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data3 = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options2 = this.parameters.options;
    return toJSON(shapes, options2, data3);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON(shapes, options2, data3) {
  data3.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data3.shapes.push(shape.uuid);
    }
  } else {
    data3.shapes.push(shapes.uuid);
  }
  if (options2.extrudePath !== void 0)
    data3.options.extrudePath = options2.extrudePath.toJSON();
  return data3;
}
var IcosahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var LatheGeometry = class extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const inverseSegments = 1 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a2 = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d2 = base + 1;
        indices.push(a2, b, d2);
        indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n = new Vector3();
      const base = segments * points.length * 3;
      for (let i = 0, j = 0; i < points.length; i++, j += 3) {
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];
        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2];
        n.addVectors(n1, n2).normalize();
        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }
};
var OctahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;
    for (let j = 0; j <= slices; j++) {
      const u = j / slices;
      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, v);
    }
  }
  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a2 = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d2 = (i + 1) * sliceCount + j;
      indices.push(a2, b, d2);
      indices.push(b, c, d2);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
var RingGeometry = class extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a2 = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d2 = segment + 1;
        indices.push(a2, b, d2);
        indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var ShapeGeometry = class extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a2 = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a2, b, c);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data3 = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data3);
  }
};
function toJSON$1(shapes, data3) {
  data3.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data3.shapes.push(shape.uuid);
    }
  } else {
    data3.shapes.push(shapes.uuid);
  }
  return data3;
}
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index4 = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index4++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a2, b, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var TetrahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (!(font && font.isFont)) {
      console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
      return new BufferGeometry();
    }
    const shapes = font.generateShapes(text, parameters.size);
    parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
    if (parameters.bevelThickness === void 0)
      parameters.bevelThickness = 10;
    if (parameters.bevelSize === void 0)
      parameters.bevelSize = 8;
    if (parameters.bevelEnabled === void 0)
      parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = "TextGeometry";
  }
};
var TorusGeometry = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a2 = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d2 = (tubularSegments + 1) * j + i;
        indices.push(a2, b, d2);
        indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var TorusKnotGeometry = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a2 = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d2 = (radialSegments + 1) * (j - 1) + i;
        indices.push(a2, b, d2);
        indices.push(b, c, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position2) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p2 * u;
      const cs = Math.cos(quOverP);
      position2.x = radius2 * (2 + cs) * 0.5 * cu;
      position2.y = radius2 * (2 + cs) * su * 0.5;
      position2.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
};
var TubeGeometry = class extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a2 = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d2 = (radialSegments + 1) * (j - 1) + i;
          indices.push(a2, b, d2);
          indices.push(b, c, d2);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data3 = BufferGeometry.prototype.toJSON.call(this);
    data3.path = this.parameters.path.toJSON();
    return data3;
  }
};
var WireframeGeometry = class extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = "WireframeGeometry";
    if (geometry.isGeometry === true) {
      console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const vertices = [];
    const edge = [0, 0], edges = {};
    const vertex = new Vector3();
    if (geometry.index !== null) {
      const position2 = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;
      if (groups.length === 0) {
        groups = [{start: 0, count: indices.count, materialIndex: 0}];
      }
      for (let o2 = 0, ol = groups.length; o2 < ol; ++o2) {
        const group = groups[o2];
        const start = group.start;
        const count = group.count;
        for (let i = start, l = start + count; i < l; i += 3) {
          for (let j = 0; j < 3; j++) {
            const edge1 = indices.getX(i + j);
            const edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = {index1: edge[0], index2: edge[1]};
            }
          }
        }
      }
      for (const key in edges) {
        const e2 = edges[key];
        vertex.fromBufferAttribute(position2, e2.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position2, e2.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      const position2 = geometry.attributes.position;
      for (let i = 0, l = position2.count / 3; i < l; i++) {
        for (let j = 0; j < 3; j++) {
          const index1 = 3 * i + j;
          vertex.fromBufferAttribute(position2, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index22 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position2, index22);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {TOON: ""};
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {MATCAP: ""};
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = {MATCAP: ""};
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
var AnimationUtils = {
  arraySlice: function(array, from3, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from3, to !== void 0 ? to : array.length));
    }
    return array.slice(from3, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order2) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order2[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name2, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name2;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index4) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset3 = index4 * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset3 + i];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
var KeyframeTrack = class {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json3;
    if (trackType.toJSON !== this.toJSON) {
      json3 = trackType.toJSON(track);
    } else {
      json3 = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json3.interpolation = interpolation;
      }
    }
    json3.type = track.ValueTypeName;
    return json3;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from3 = 0, to = nKeys - 1;
    while (from3 !== nKeys && times[from3] < startTime) {
      ++from3;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from3 !== 0 || to !== nKeys) {
      if (from3 >= to) {
        to = Math.max(to, 1);
        from3 = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from3, to);
      this.values = AnimationUtils.arraySlice(this.values, from3 * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid8 = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid8 = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid8 = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid8 = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid8 = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid8 = false;
            break;
          }
        }
      }
    }
    return valid8;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep2 = false;
      const time4 = times[i];
      const timeNext = times[i + 1];
      if (time4 !== timeNext && (i !== 1 || time4 !== times[0])) {
        if (!smoothInterpolation) {
          const offset3 = i * stride, offsetP = offset3 - stride, offsetN = offset3 + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset3 + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep2 = true;
              break;
            }
          }
        } else {
          keep2 = true;
        }
      }
      if (keep2) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset3 = i1 * stride;
    for (let end = offset3 + stride; offset3 !== end; offset3 += 4) {
      Quaternion.slerpFlat(result, 0, values, offset3 - stride, values, offset3, alpha);
    }
    return result;
  }
});
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json3) {
    const tracks = [], jsonTracks = json3.tracks, frameTime = 1 / (json3.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json3.name, json3.duration, tracks, json3.blendMode);
    clip.uuid = json3.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json3 = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json3;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order2 = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order2);
      values = AnimationUtils.sortedArray(values, 1, order2);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name2) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid8 = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid8 = valid8 && this.tracks[i].validate();
    }
    return valid8;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json3) {
  if (json3.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json3.type);
  if (json3.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json3.keys, times, values, "value");
    json3.times = times;
    json3.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json3);
  } else {
    return new trackType(json3.name, json3.times, json3.values, json3.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform2) {
    urlModifier = transform2;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index4 = handlers.indexOf(regex);
    if (index4 !== -1) {
      handlers.splice(index4, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
var DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
var loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data3 = dataUriRegexResult[3];
      data3 = decodeURIComponent(data3);
      if (isBase64)
        data3 = atob(data3);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data3.length);
            for (let i = 0; i < data3.length; i++) {
              view[i] = data3.charCodeAt(i);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data3, mimeType);
            break;
          case "json":
            response = JSON.parse(data3);
            break;
          default:
            response = data3;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
var AnimationLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json3) {
    const animations = [];
    for (let i = 0; i < json3.length; i++) {
      const clip = AnimationClip.parse(json3[i]);
      animations.push(clip);
    }
    return animations;
  }
};
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = {mipmaps: []};
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
};
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache3 = [];
    let current, last2 = this.getPoint(0);
    let sum = 0;
    cache3.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last2);
      cache3.push(sum);
      last2 = current;
    }
    this.cacheArcLengths = cache3;
    return cache3;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  getTangent: function(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data3 = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data3.arcLengthDivisions = this.arcLengthDivisions;
    data3.type = this.type;
    return data3;
  },
  fromJSON: function(json3) {
    this.arcLengthDivisions = json3.arcLengthDivisions;
    return this;
  }
});
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y2 - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.aX = this.aX;
    data3.aY = this.aY;
    data3.xRadius = this.xRadius;
    data3.yRadius = this.yRadius;
    data3.aStartAngle = this.aStartAngle;
    data3.aEndAngle = this.aEndAngle;
    data3.aClockwise = this.aClockwise;
    data3.aRotation = this.aRotation;
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.aX = json3.aX;
    this.aY = json3.aY;
    this.xRadius = json3.xRadius;
    this.yRadius = json3.yRadius;
    this.aStartAngle = json3.aStartAngle;
    this.aEndAngle = json3.aEndAngle;
    this.aClockwise = json3.aClockwise;
    this.aRotation = json3.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data3.points.push(point.toArray());
    }
    data3.closed = this.closed;
    data3.curveType = this.curveType;
    data3.tension = this.tension;
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.points = [];
    for (let i = 0, l = json3.points.length; i < l; i++) {
      const point = json3.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json3.closed;
    this.curveType = json3.curveType;
    this.tension = json3.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v0 = this.v0.toArray();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    data3.v3 = this.v3.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v0.fromArray(json3.v0);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    this.v3.fromArray(json3.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v0 = this.v0.toArray();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    data3.v3 = this.v3.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v0.fromArray(json3.v0);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    this.v3.fromArray(json3.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v0 = this.v0.toArray();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v0.fromArray(json3.v0);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.v0 = this.v0.toArray();
    data3.v1 = this.v1.toArray();
    data3.v2 = this.v2.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.v0.fromArray(json3.v0);
    this.v1.fromArray(json3.v1);
    this.v2.fromArray(json3.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data3.points.push(point.toArray());
    }
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.points = [];
    for (let i = 0, l = json3.points.length; i < l; i++) {
      const point = json3.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t) {
    const d2 = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d2) {
        const diff3 = curveLengths[i] - d2;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff3 / segmentLength;
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last2;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last2 && last2.equals(point))
          continue;
        points.push(point);
        last2 = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.autoClose = this.autoClose;
    data3.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data3.curves.push(curve.toJSON());
    }
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.autoClose = json3.autoClose;
    this.curves = [];
    for (let i = 0, l = json3.curves.length; i < l; i++) {
      const curve = json3.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y2) {
    this.currentPoint.set(x, y2);
    return this;
  }
  lineTo(x, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y2));
    this.curves.push(curve);
    this.currentPoint.set(x, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.currentPoint = this.currentPoint.toArray();
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.currentPoint.fromArray(json3.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data3 = super.toJSON();
    data3.uuid = this.uuid;
    data3.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data3.holes.push(hole.toJSON());
    }
    return data3;
  }
  fromJSON(json3) {
    super.fromJSON(json3);
    this.uuid = json3.uuid;
    this.holes = [];
    for (let i = 0, l = json3.holes.length; i < l; i++) {
      const hole = json3.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data3 = super.toJSON(meta);
    data3.object.color = this.color.getHex();
    data3.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data3.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data3.object.distance = this.distance;
    if (this.angle !== void 0)
      data3.object.angle = this.angle;
    if (this.decay !== void 0)
      data3.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data3.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data3.object.shadow = this.shadow.toJSON();
    return data3;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld);
    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.copy(camera.position);
    _lookTarget$1.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget$1);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z);
    _projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data3 = Object3D.prototype.toJSON.call(this, meta);
    data3.object.zoom = this.zoom;
    data3.object.left = this.left;
    data3.object.right = this.right;
    data3.object.top = this.top;
    data3.object.bottom = this.bottom;
    data3.object.near = this.near;
    data3.object.far = this.far;
    if (this.view !== null)
      data3.object.view = Object.assign({}, this.view);
    return data3;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data3 = super.toJSON(meta);
    data3.object.width = this.width;
    data3.object.height = this.height;
    return data3;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y2 * y2));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset3 = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset3 + i * 3);
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset3 + i * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x * z2;
    shBasis[8] = 0.546274 * (x * x - y2 * y2);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json3) {
    this.intensity = json3.intensity;
    this.sh.fromArray(json3.sh);
    return this;
  }
  toJSON(meta) {
    const data3 = super.toJSON(meta);
    data3.object.sh = this.sh.toArray();
    return data3;
  }
};
LightProbe.prototype.isLightProbe = true;
var MaterialLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json3) {
    const textures = this.textures;
    function getTexture(name2) {
      if (textures[name2] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name2);
      }
      return textures[name2];
    }
    const material = new Materials[json3.type]();
    if (json3.uuid !== void 0)
      material.uuid = json3.uuid;
    if (json3.name !== void 0)
      material.name = json3.name;
    if (json3.color !== void 0 && material.color !== void 0)
      material.color.setHex(json3.color);
    if (json3.roughness !== void 0)
      material.roughness = json3.roughness;
    if (json3.metalness !== void 0)
      material.metalness = json3.metalness;
    if (json3.sheen !== void 0)
      material.sheen = new Color().setHex(json3.sheen);
    if (json3.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json3.emissive);
    if (json3.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json3.specular);
    if (json3.shininess !== void 0)
      material.shininess = json3.shininess;
    if (json3.clearcoat !== void 0)
      material.clearcoat = json3.clearcoat;
    if (json3.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json3.clearcoatRoughness;
    if (json3.fog !== void 0)
      material.fog = json3.fog;
    if (json3.flatShading !== void 0)
      material.flatShading = json3.flatShading;
    if (json3.blending !== void 0)
      material.blending = json3.blending;
    if (json3.combine !== void 0)
      material.combine = json3.combine;
    if (json3.side !== void 0)
      material.side = json3.side;
    if (json3.opacity !== void 0)
      material.opacity = json3.opacity;
    if (json3.transparent !== void 0)
      material.transparent = json3.transparent;
    if (json3.alphaTest !== void 0)
      material.alphaTest = json3.alphaTest;
    if (json3.depthTest !== void 0)
      material.depthTest = json3.depthTest;
    if (json3.depthWrite !== void 0)
      material.depthWrite = json3.depthWrite;
    if (json3.colorWrite !== void 0)
      material.colorWrite = json3.colorWrite;
    if (json3.stencilWrite !== void 0)
      material.stencilWrite = json3.stencilWrite;
    if (json3.stencilWriteMask !== void 0)
      material.stencilWriteMask = json3.stencilWriteMask;
    if (json3.stencilFunc !== void 0)
      material.stencilFunc = json3.stencilFunc;
    if (json3.stencilRef !== void 0)
      material.stencilRef = json3.stencilRef;
    if (json3.stencilFuncMask !== void 0)
      material.stencilFuncMask = json3.stencilFuncMask;
    if (json3.stencilFail !== void 0)
      material.stencilFail = json3.stencilFail;
    if (json3.stencilZFail !== void 0)
      material.stencilZFail = json3.stencilZFail;
    if (json3.stencilZPass !== void 0)
      material.stencilZPass = json3.stencilZPass;
    if (json3.wireframe !== void 0)
      material.wireframe = json3.wireframe;
    if (json3.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json3.wireframeLinewidth;
    if (json3.wireframeLinecap !== void 0)
      material.wireframeLinecap = json3.wireframeLinecap;
    if (json3.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json3.wireframeLinejoin;
    if (json3.rotation !== void 0)
      material.rotation = json3.rotation;
    if (json3.linewidth !== 1)
      material.linewidth = json3.linewidth;
    if (json3.dashSize !== void 0)
      material.dashSize = json3.dashSize;
    if (json3.gapSize !== void 0)
      material.gapSize = json3.gapSize;
    if (json3.scale !== void 0)
      material.scale = json3.scale;
    if (json3.polygonOffset !== void 0)
      material.polygonOffset = json3.polygonOffset;
    if (json3.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json3.polygonOffsetFactor;
    if (json3.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json3.polygonOffsetUnits;
    if (json3.skinning !== void 0)
      material.skinning = json3.skinning;
    if (json3.morphTargets !== void 0)
      material.morphTargets = json3.morphTargets;
    if (json3.morphNormals !== void 0)
      material.morphNormals = json3.morphNormals;
    if (json3.dithering !== void 0)
      material.dithering = json3.dithering;
    if (json3.vertexTangents !== void 0)
      material.vertexTangents = json3.vertexTangents;
    if (json3.visible !== void 0)
      material.visible = json3.visible;
    if (json3.toneMapped !== void 0)
      material.toneMapped = json3.toneMapped;
    if (json3.userData !== void 0)
      material.userData = json3.userData;
    if (json3.vertexColors !== void 0) {
      if (typeof json3.vertexColors === "number") {
        material.vertexColors = json3.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json3.vertexColors;
      }
    }
    if (json3.uniforms !== void 0) {
      for (const name2 in json3.uniforms) {
        const uniform = json3.uniforms[name2];
        material.uniforms[name2] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name2].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name2].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name2].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name2].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name2].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name2].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name2].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name2].value = uniform.value;
        }
      }
    }
    if (json3.defines !== void 0)
      material.defines = json3.defines;
    if (json3.vertexShader !== void 0)
      material.vertexShader = json3.vertexShader;
    if (json3.fragmentShader !== void 0)
      material.fragmentShader = json3.fragmentShader;
    if (json3.extensions !== void 0) {
      for (const key in json3.extensions) {
        material.extensions[key] = json3.extensions[key];
      }
    }
    if (json3.shading !== void 0)
      material.flatShading = json3.shading === 1;
    if (json3.size !== void 0)
      material.size = json3.size;
    if (json3.sizeAttenuation !== void 0)
      material.sizeAttenuation = json3.sizeAttenuation;
    if (json3.map !== void 0)
      material.map = getTexture(json3.map);
    if (json3.matcap !== void 0)
      material.matcap = getTexture(json3.matcap);
    if (json3.alphaMap !== void 0)
      material.alphaMap = getTexture(json3.alphaMap);
    if (json3.bumpMap !== void 0)
      material.bumpMap = getTexture(json3.bumpMap);
    if (json3.bumpScale !== void 0)
      material.bumpScale = json3.bumpScale;
    if (json3.normalMap !== void 0)
      material.normalMap = getTexture(json3.normalMap);
    if (json3.normalMapType !== void 0)
      material.normalMapType = json3.normalMapType;
    if (json3.normalScale !== void 0) {
      let normalScale = json3.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json3.displacementMap !== void 0)
      material.displacementMap = getTexture(json3.displacementMap);
    if (json3.displacementScale !== void 0)
      material.displacementScale = json3.displacementScale;
    if (json3.displacementBias !== void 0)
      material.displacementBias = json3.displacementBias;
    if (json3.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json3.roughnessMap);
    if (json3.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json3.metalnessMap);
    if (json3.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json3.emissiveMap);
    if (json3.emissiveIntensity !== void 0)
      material.emissiveIntensity = json3.emissiveIntensity;
    if (json3.specularMap !== void 0)
      material.specularMap = getTexture(json3.specularMap);
    if (json3.envMap !== void 0)
      material.envMap = getTexture(json3.envMap);
    if (json3.envMapIntensity !== void 0)
      material.envMapIntensity = json3.envMapIntensity;
    if (json3.reflectivity !== void 0)
      material.reflectivity = json3.reflectivity;
    if (json3.refractionRatio !== void 0)
      material.refractionRatio = json3.refractionRatio;
    if (json3.lightMap !== void 0)
      material.lightMap = getTexture(json3.lightMap);
    if (json3.lightMapIntensity !== void 0)
      material.lightMapIntensity = json3.lightMapIntensity;
    if (json3.aoMap !== void 0)
      material.aoMap = getTexture(json3.aoMap);
    if (json3.aoMapIntensity !== void 0)
      material.aoMapIntensity = json3.aoMapIntensity;
    if (json3.gradientMap !== void 0)
      material.gradientMap = getTexture(json3.gradientMap);
    if (json3.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json3.clearcoatMap);
    if (json3.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json3.clearcoatRoughnessMap);
    if (json3.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json3.clearcoatNormalMap);
    if (json3.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(json3.clearcoatNormalScale);
    if (json3.transmission !== void 0)
      material.transmission = json3.transmission;
    if (json3.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json3.transmissionMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s2 += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  },
  extractUrlBase: function(url) {
    const index4 = url.lastIndexOf("/");
    if (index4 === -1)
      return "./";
    return url.substr(0, index4 + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data3 = BufferGeometry.prototype.toJSON.call(this);
    data3.instanceCount = this.instanceCount;
    data3.isInstancedBufferGeometry = true;
    return data3;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data3 = BufferAttribute.prototype.toJSON.call(this);
    data3.meshPerAttribute = this.meshPerAttribute;
    data3.isInstancedBufferAttribute = true;
    return data3;
  }
});
var BufferGeometryLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json3) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json4, uuid) {
      if (interleavedBufferMap[uuid] !== void 0)
        return interleavedBufferMap[uuid];
      const interleavedBuffers = json4.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json4, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json4, uuid) {
      if (arrayBufferMap[uuid] !== void 0)
        return arrayBufferMap[uuid];
      const arrayBuffers = json4.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json3.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index4 = json3.data.index;
    if (index4 !== void 0) {
      const typedArray = getTypedArray(index4.type, index4.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json3.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json3.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0)
        bufferAttribute.name = attribute.name;
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json3.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json3.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json3.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json3.data.groups || json3.data.drawcalls || json3.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json3.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json3.name)
      geometry.name = json3.name;
    if (json3.userData)
      geometry.userData = json3.userData;
    return geometry;
  }
};
var ObjectLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json3 = null;
      try {
        json3 = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0)
          onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json3.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json3, onLoad);
    }, onProgress, onError);
  }
  parse(json3, onLoad) {
    const animations = this.parseAnimations(json3.animations);
    const shapes = this.parseShapes(json3.shapes);
    const geometries = this.parseGeometries(json3.geometries, shapes);
    const images = this.parseImages(json3.images, function() {
      if (onLoad !== void 0)
        onLoad(object);
    });
    const textures = this.parseTextures(json3.textures, images);
    const materials = this.parseMaterials(json3.materials, textures);
    const object = this.parseObject(json3.object, geometries, materials, animations);
    const skeletons = this.parseSkeletons(json3.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false)
        onLoad(object);
    }
    return object;
  }
  parseShapes(json3) {
    const shapes = {};
    if (json3 !== void 0) {
      for (let i = 0, l = json3.length; i < l; i++) {
        const shape = new Shape().fromJSON(json3[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json3, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone)
        bones[child.uuid] = child;
    });
    if (json3 !== void 0) {
      for (let i = 0, l = json3.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json3[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json3, shapes) {
    const geometries = {};
    let geometryShapes;
    if (json3 !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json3.length; i < l; i++) {
        let geometry;
        const data3 = json3[i];
        switch (data3.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            geometry = new Geometries[data3.type](data3.width, data3.height, data3.widthSegments, data3.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
            geometry = new Geometries[data3.type](data3.width, data3.height, data3.depth, data3.widthSegments, data3.heightSegments, data3.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.segments, data3.thetaStart, data3.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            geometry = new Geometries[data3.type](data3.radiusTop, data3.radiusBottom, data3.height, data3.radialSegments, data3.heightSegments, data3.openEnded, data3.thetaStart, data3.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.height, data3.radialSegments, data3.heightSegments, data3.openEnded, data3.thetaStart, data3.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.widthSegments, data3.heightSegments, data3.phiStart, data3.phiLength, data3.thetaStart, data3.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            geometry = new Geometries[data3.type](data3.innerRadius, data3.outerRadius, data3.thetaSegments, data3.phiSegments, data3.thetaStart, data3.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.tube, data3.radialSegments, data3.tubularSegments, data3.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            geometry = new Geometries[data3.type](data3.radius, data3.tube, data3.tubularSegments, data3.radialSegments, data3.p, data3.q);
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            geometry = new Geometries[data3.type](new Curves[data3.path.type]().fromJSON(data3.path), data3.tubularSegments, data3.radius, data3.radialSegments, data3.closed);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            geometry = new Geometries[data3.type](data3.points, data3.segments, data3.phiStart, data3.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            geometry = new Geometries[data3.type](data3.vertices, data3.indices, data3.radius, data3.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            geometryShapes = [];
            for (let j = 0, jl = data3.shapes.length; j < jl; j++) {
              const shape = shapes[data3.shapes[j]];
              geometryShapes.push(shape);
            }
            geometry = new Geometries[data3.type](geometryShapes, data3.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            geometryShapes = [];
            for (let j = 0, jl = data3.shapes.length; j < jl; j++) {
              const shape = shapes[data3.shapes[j]];
              geometryShapes.push(shape);
            }
            const extrudePath = data3.options.extrudePath;
            if (extrudePath !== void 0) {
              data3.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            geometry = new Geometries[data3.type](geometryShapes, data3.options);
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data3);
            break;
          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data3.type + '"');
            continue;
        }
        geometry.uuid = data3.uuid;
        if (data3.name !== void 0)
          geometry.name = data3.name;
        if (geometry.isBufferGeometry === true && data3.userData !== void 0)
          geometry.userData = data3.userData;
        geometries[data3.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json3, textures) {
    const cache3 = {};
    const materials = {};
    if (json3 !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json3.length; i < l; i++) {
        const data3 = json3[i];
        if (data3.type === "MultiMaterial") {
          const array = [];
          for (let j = 0; j < data3.materials.length; j++) {
            const material = data3.materials[j];
            if (cache3[material.uuid] === void 0) {
              cache3[material.uuid] = loader.parse(material);
            }
            array.push(cache3[material.uuid]);
          }
          materials[data3.uuid] = array;
        } else {
          if (cache3[data3.uuid] === void 0) {
            cache3[data3.uuid] = loader.parse(data3);
          }
          materials[data3.uuid] = cache3[data3.uuid];
        }
      }
    }
    return materials;
  }
  parseAnimations(json3) {
    const animations = {};
    if (json3 !== void 0) {
      for (let i = 0; i < json3.length; i++) {
        const data3 = json3[i];
        const clip = AnimationClip.parse(data3);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json3, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json3 !== void 0 && json3.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json3.length; i < il; i++) {
        const image = json3[i];
        const url = image.url;
        if (Array.isArray(url)) {
          images[image.uuid] = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          const deserializedImage = deserializeImage(image.url);
          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }
    return images;
  }
  parseTextures(json3, images) {
    function parseConstant(value, type) {
      if (typeof value === "number")
        return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json3 !== void 0) {
      for (let i = 0, l = json3.length; i < l; i++) {
        const data3 = json3[i];
        if (data3.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data3.uuid);
        }
        if (images[data3.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data3.image);
        }
        let texture;
        const image = images[data3.image];
        if (Array.isArray(image)) {
          texture = new CubeTexture(image);
          if (image.length === 6)
            texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture(image.data, image.width, image.height);
          } else {
            texture = new Texture(image);
          }
          if (image)
            texture.needsUpdate = true;
        }
        texture.uuid = data3.uuid;
        if (data3.name !== void 0)
          texture.name = data3.name;
        if (data3.mapping !== void 0)
          texture.mapping = parseConstant(data3.mapping, TEXTURE_MAPPING);
        if (data3.offset !== void 0)
          texture.offset.fromArray(data3.offset);
        if (data3.repeat !== void 0)
          texture.repeat.fromArray(data3.repeat);
        if (data3.center !== void 0)
          texture.center.fromArray(data3.center);
        if (data3.rotation !== void 0)
          texture.rotation = data3.rotation;
        if (data3.wrap !== void 0) {
          texture.wrapS = parseConstant(data3.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data3.wrap[1], TEXTURE_WRAPPING);
        }
        if (data3.format !== void 0)
          texture.format = data3.format;
        if (data3.type !== void 0)
          texture.type = data3.type;
        if (data3.encoding !== void 0)
          texture.encoding = data3.encoding;
        if (data3.minFilter !== void 0)
          texture.minFilter = parseConstant(data3.minFilter, TEXTURE_FILTER);
        if (data3.magFilter !== void 0)
          texture.magFilter = parseConstant(data3.magFilter, TEXTURE_FILTER);
        if (data3.anisotropy !== void 0)
          texture.anisotropy = data3.anisotropy;
        if (data3.flipY !== void 0)
          texture.flipY = data3.flipY;
        if (data3.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data3.premultiplyAlpha;
        if (data3.unpackAlignment !== void 0)
          texture.unpackAlignment = data3.unpackAlignment;
        textures[data3.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data3, geometries, materials, animations) {
    let object;
    function getGeometry(name2) {
      if (geometries[name2] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name2);
      }
      return geometries[name2];
    }
    function getMaterial(name2) {
      if (name2 === void 0)
        return void 0;
      if (Array.isArray(name2)) {
        const array = [];
        for (let i = 0, l = name2.length; i < l; i++) {
          const uuid = name2[i];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name2] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name2);
      }
      return materials[name2];
    }
    let geometry, material;
    switch (data3.type) {
      case "Scene":
        object = new Scene();
        if (data3.background !== void 0) {
          if (Number.isInteger(data3.background)) {
            object.background = new Color(data3.background);
          }
        }
        if (data3.fog !== void 0) {
          if (data3.fog.type === "Fog") {
            object.fog = new Fog(data3.fog.color, data3.fog.near, data3.fog.far);
          } else if (data3.fog.type === "FogExp2") {
            object.fog = new FogExp2(data3.fog.color, data3.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data3.fov, data3.aspect, data3.near, data3.far);
        if (data3.focus !== void 0)
          object.focus = data3.focus;
        if (data3.zoom !== void 0)
          object.zoom = data3.zoom;
        if (data3.filmGauge !== void 0)
          object.filmGauge = data3.filmGauge;
        if (data3.filmOffset !== void 0)
          object.filmOffset = data3.filmOffset;
        if (data3.view !== void 0)
          object.view = Object.assign({}, data3.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data3.left, data3.right, data3.top, data3.bottom, data3.near, data3.far);
        if (data3.zoom !== void 0)
          object.zoom = data3.zoom;
        if (data3.view !== void 0)
          object.view = Object.assign({}, data3.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data3.color, data3.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data3.color, data3.intensity);
        break;
      case "PointLight":
        object = new PointLight(data3.color, data3.intensity, data3.distance, data3.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data3.color, data3.intensity, data3.width, data3.height);
        break;
      case "SpotLight":
        object = new SpotLight(data3.color, data3.intensity, data3.distance, data3.angle, data3.penumbra, data3.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data3.color, data3.groundColor, data3.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data3);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data3.geometry);
        material = getMaterial(data3.material);
        object = new SkinnedMesh(geometry, material);
        if (data3.bindMode !== void 0)
          object.bindMode = data3.bindMode;
        if (data3.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data3.bindMatrix);
        if (data3.skeleton !== void 0)
          object.skeleton = data3.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data3.geometry);
        material = getMaterial(data3.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data3.geometry);
        material = getMaterial(data3.material);
        const count = data3.count;
        const instanceMatrix = data3.instanceMatrix;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data3.geometry), getMaterial(data3.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data3.geometry), getMaterial(data3.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data3.geometry), getMaterial(data3.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data3.geometry), getMaterial(data3.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data3.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data3.uuid;
    if (data3.name !== void 0)
      object.name = data3.name;
    if (data3.matrix !== void 0) {
      object.matrix.fromArray(data3.matrix);
      if (data3.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data3.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data3.position !== void 0)
        object.position.fromArray(data3.position);
      if (data3.rotation !== void 0)
        object.rotation.fromArray(data3.rotation);
      if (data3.quaternion !== void 0)
        object.quaternion.fromArray(data3.quaternion);
      if (data3.scale !== void 0)
        object.scale.fromArray(data3.scale);
    }
    if (data3.castShadow !== void 0)
      object.castShadow = data3.castShadow;
    if (data3.receiveShadow !== void 0)
      object.receiveShadow = data3.receiveShadow;
    if (data3.shadow) {
      if (data3.shadow.bias !== void 0)
        object.shadow.bias = data3.shadow.bias;
      if (data3.shadow.normalBias !== void 0)
        object.shadow.normalBias = data3.shadow.normalBias;
      if (data3.shadow.radius !== void 0)
        object.shadow.radius = data3.shadow.radius;
      if (data3.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data3.shadow.mapSize);
      if (data3.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data3.shadow.camera);
    }
    if (data3.visible !== void 0)
      object.visible = data3.visible;
    if (data3.frustumCulled !== void 0)
      object.frustumCulled = data3.frustumCulled;
    if (data3.renderOrder !== void 0)
      object.renderOrder = data3.renderOrder;
    if (data3.userData !== void 0)
      object.userData = data3.userData;
    if (data3.layers !== void 0)
      object.layers.mask = data3.layers;
    if (data3.children !== void 0) {
      const children = data3.children;
      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, animations));
      }
    }
    if (data3.animations !== void 0) {
      const objectAnimations = data3.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data3.type === "LOD") {
      if (data3.autoUpdate !== void 0)
        object.autoUpdate = data3.autoUpdate;
      const levels = data3.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0)
      return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  setTexturePath(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
};
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options2) {
    this.options = options2;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError)
        onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x, y2) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y2);
    return this;
  }
  lineTo(x, y2) {
    this.currentPath.lineTo(x, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
};
var Font = class {
  constructor(data3) {
    this.type = "Font";
    this.data = data3;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data3) {
  const chars = Array.from(text);
  const scale = size / data3.resolution;
  const line_height = (data3.boundingBox.yMax - data3.boundingBox.yMin + data3.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char2 = chars[i];
    if (char2 === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char2, scale, offsetX, offsetY, data3);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char2, scale, offsetX, offsetY, data3) {
  const glyph = data3.glyphs[char2] || data3.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char2 + '" does not exists in font family ' + data3.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y2, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale + offsetX;
          y2 = outline[i++] * scale + offsetY;
          path.moveTo(x, y2);
          break;
        case "l":
          x = outline[i++] * scale + offsetX;
          y2 = outline[i++] * scale + offsetY;
          path.lineTo(x, y2);
          break;
        case "q":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {offsetX: glyph.ha * scale, path};
}
Font.prototype.isFont = true;
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      let json3;
      try {
        json3 = JSON.parse(text);
      } catch (e2) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json3 = JSON.parse(text.substring(65, text.length - 2));
      }
      const font = scope.parse(json3);
      if (onLoad)
        onLoad(font);
    }, onProgress, onError);
  }
  parse(json3) {
    return new Font(json3);
  }
};
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var StereoCamera = class {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache3 = this._cache;
    const needsUpdate = cache3.focus !== camera.focus || cache3.fov !== camera.fov || cache3.aspect !== camera.aspect * this.aspect || cache3.near !== camera.near || cache3.far !== camera.far || cache3.zoom !== camera.zoom || cache3.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache3.focus = camera.focus;
      cache3.fov = camera.fov;
      cache3.aspect = camera.aspect * this.aspect;
      cache3.near = camera.near;
      cache3.far = camera.far;
      cache3.zoom = camera.zoom;
      cache3.eyeSep = this.eyeSep;
      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache3.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache3.near / cache3.focus;
      const ymax = cache3.near * Math.tan(MathUtils.DEG2RAD * cache3.fov * 0.5) / cache3.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache3.aspect + eyeSepOnProjection;
      xmax = ymax * cache3.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache3.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix);
      xmin = -ymax * cache3.aspect - eyeSepOnProjection;
      xmax = ymax * cache3.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache3.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
};
var Clock = class {
  constructor(autoStart) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff3 = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff3 = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff3;
    }
    return diff3;
  }
};
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
var _position$2 = /* @__PURE__ */ new Vector3();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var _scale$1 = /* @__PURE__ */ new Vector3();
var _orientation = /* @__PURE__ */ new Vector3();
var AudioListener = class extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
};
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var _position$3 = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _orientation$1 = /* @__PURE__ */ new Vector3();
var PositionalAudio = class extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false)
      return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data3 = this.getFrequencyData();
    for (let i = 0; i < data3.length; i++) {
      value += data3[i];
    }
    return value / data3.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset3 = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset3 + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset3, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset3 = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset3, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset3 = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset3, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset3, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e2 = stride + stride; i !== e2; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset3);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e2 = originalValueOffset; i !== e2; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s2 = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s2 + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset3) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset3);
  },
  setValue: function(array, offset3) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset3);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset3) {
      buffer[offset3] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset3) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset3++] = source[i];
      }
    },
    function getValue_arrayElement(buffer, offset3) {
      buffer[offset3] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset3) {
      this.resolvedProperty.toArray(buffer, offset3);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset3++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset3++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset3++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset3) {
    this.bind();
    this.getValue(targetArray, offset3);
  },
  setValue: function getValue_unbound2(sourceArray, offset3) {
    this.bind();
    this.setValue(sourceArray, offset3);
  },
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid;
      let index4 = indicesByUUID[uuid];
      if (index4 === void 0) {
        index4 = nObjects++;
        indicesByUUID[uuid] = index4;
        objects.push(object);
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index4 < nCachedObjects) {
        knownObject = objects[index4];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index4;
        objects[index4] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index4];
          bindingsForPath[index4] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index4] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index4 = indicesByUUID[uuid];
      if (index4 !== void 0 && index4 >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index4;
        objects[index4] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index4];
          bindingsForPath[index4] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i], uuid = object.uuid, index4 = indicesByUUID[uuid];
      if (index4 !== void 0) {
        delete indicesByUUID[uuid];
        if (index4 < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index4;
          objects[index4] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m2 = nBindings; j !== m2; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last2 = bindingsForPath[lastIndex];
            bindingsForPath[index4] = lastCached;
            bindingsForPath[firstActiveIndex] = last2;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index4;
          }
          objects[index4] = lastObject;
          objects.pop();
          for (let j = 0, m2 = nBindings; j !== m2; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index4] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index4 = indicesByPath[path];
    const bindings = this._bindings;
    if (index4 !== void 0)
      return bindings[index4];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index4 = bindings.length;
    indicesByPath[path] = index4;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index4 = indicesByPath[path];
    if (index4 !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index4;
      bindings[index4] = lastBindings;
      bindings.pop();
      parsedPaths[index4] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index4] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time4) {
    this._startTime = time4;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now4 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now4;
    times[1] = now4 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time4, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time4);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time4 - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time4);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time4);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time4) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time4)[0];
        weight *= interpolantValue;
        if (time4 > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time4) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time4)[0];
        timeScale *= interpolantValue;
        if (time4 > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time4 = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time4;
      return pingPong && (loopCount & 1) === 1 ? duration - time4 : time4;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time4 >= duration) {
          time4 = duration;
        } else if (time4 < 0) {
          time4 = 0;
        } else {
          this.time = time4;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time4;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time4 >= duration || time4 < 0) {
        const loopDelta = Math.floor(time4 / duration);
        time4 -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time4 = deltaTime > 0 ? duration : 0;
          this.time = time4;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time4;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time4;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time4;
      }
    }
    return time4;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now4 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now4;
    values[0] = weightNow;
    times[1] = now4 + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index4 = action._cacheIndex;
    return index4 !== null && index4 < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time4 = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time4, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data3) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data3);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data3) {
    const json3 = InterleavedBuffer.prototype.toJSON.call(this, data3);
    json3.isInstancedInterleavedBuffer = true;
    json3.meshPerAttribute = this.meshPerAttribute;
    return json3;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a2, b) {
  return a2.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive = false, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y2, z2) {
    this.radius = Math.sqrt(x * x + y2 * y2 + z2 * z2);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z2);
      this.phi = Math.acos(MathUtils.clamp(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Cylindrical = class {
  constructor(radius = 1, theta = 0, y2 = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  set(radius, theta, y2) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y2, z2) {
    this.radius = Math.sqrt(x * x + z2 * z2);
    this.theta = Math.atan2(x, z2);
    this.y = y2;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$8 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target = new Vector2();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset3) {
    this.min.add(offset3);
    this.max.add(offset3);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line2) {
    this.start.copy(line2.start);
    this.end.copy(line2.end);
    return this;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = MathUtils.clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    if (target === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line2) {
    return line2.start.equals(this.start) && line2.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$9 = /* @__PURE__ */ new Vector3();
var SpotLightHelper = class extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({fog: false, toneMapped: false});
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$9);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix4();
var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors2 = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors2.push(color1.r, color1.g, color1.b);
        colors2.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position2 = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
var PointLightHelper = class extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
};
var _vector$b = /* @__PURE__ */ new Vector3();
var _color1 = /* @__PURE__ */ new Color();
var _color2 = /* @__PURE__ */ new Color();
var HemisphereLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});
    if (this.color === void 0)
      this.material.vertexColors = true;
    const position2 = geometry.getAttribute("position");
    const colors2 = new Float32Array(position2.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors2, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors2 = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors2.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors2.setXYZ(i, color.r, color.g, color.b);
      }
      colors2.needsUpdate = true;
    }
    mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
};
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors2 = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "GridHelper";
  }
};
var PolarGridHelper = class extends LineSegments {
  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors2 = [];
    for (let i = 0; i <= radials; i++) {
      const v = i / radials * (Math.PI * 2);
      const x = Math.sin(v) * radius;
      const z2 = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z2);
      const color = i & 1 ? color1 : color2;
      colors2.push(color.r, color.g, color.b);
      colors2.push(color.r, color.g, color.b);
    }
    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - radius / circles * i;
      for (let j = 0; j < divisions; j++) {
        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z2 = Math.cos(v) * r;
        vertices.push(x, 0, z2);
        colors2.push(color.r, color.g, color.b);
        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z2 = Math.cos(v) * r;
        vertices.push(x, 0, z2);
        colors2.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
};
var _v1$6 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var _v3$1 = /* @__PURE__ */ new Vector3();
var DirectionalLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === void 0)
      size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({fog: false, toneMapped: false});
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    _v1$6.setFromMatrixPosition(this.light.matrixWorld);
    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$1.subVectors(_v2$3, _v1$6);
    this.lightPlane.lookAt(_v2$3);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
  }
};
var _vector$c = /* @__PURE__ */ new Vector3();
var _camera = /* @__PURE__ */ new Camera();
var CameraHelper = class extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({color: 16777215, vertexColors: true, toneMapped: false});
    const vertices = [];
    const colors2 = [];
    const pointMap = {};
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a2, b, color) {
      addPoint(a2, color);
      addPoint(b, color);
    }
    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors2.push(color.r, color.g, color.b);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w3 = 1, h2 = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w3, -h2, -1);
    setPoint("n2", pointMap, geometry, _camera, w3, -h2, -1);
    setPoint("n3", pointMap, geometry, _camera, -w3, h2, -1);
    setPoint("n4", pointMap, geometry, _camera, w3, h2, -1);
    setPoint("f1", pointMap, geometry, _camera, -w3, -h2, 1);
    setPoint("f2", pointMap, geometry, _camera, w3, -h2, 1);
    setPoint("f3", pointMap, geometry, _camera, -w3, h2, 1);
    setPoint("f4", pointMap, geometry, _camera, w3, h2, 1);
    setPoint("u1", pointMap, geometry, _camera, w3 * 0.7, h2 * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w3 * 0.7, h2 * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w3, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w3, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w3, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w3, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
};
function setPoint(point, pointMap, geometry, camera, x, y2, z2) {
  _vector$c.set(x, y2, z2).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position2 = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position2.setXYZ(points[i], _vector$c.x, _vector$c.y, _vector$c.z);
    }
  }
}
var _box$3 = /* @__PURE__ */ new Box3();
var BoxHelper = class extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box$3.setFromObject(this.object);
    }
    if (_box$3.isEmpty())
      return;
    const min = _box$3.min;
    const max = _box$3.max;
    const position2 = this.geometry.attributes.position;
    const array = position2.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position2.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }
};
var Box3Helper = class extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty())
      return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
};
var PlaneHelper = class extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color = hex;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false})));
  }
  updateMatrixWorld(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8)
      scale = 1e-8;
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }
};
var _axis = /* @__PURE__ */ new Vector3();
var _lineGeometry;
var _coneGeometry;
var ArrowHelper = class extends Object3D {
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length2 = 1, color = 16776960, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({color, toneMapped: false}));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({color, toneMapped: false}));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length2, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length2, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length2 - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length2;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
};
var AxesHelper = class extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors2 = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "AxesHelper";
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
var DataUtils = {
  toHalfFloat: function(val) {
    _floatView[0] = val;
    const x = _int32View[0];
    let bits = x >> 16 & 32768;
    let m2 = x >> 12 & 2047;
    const e2 = x >> 23 & 255;
    if (e2 < 103)
      return bits;
    if (e2 > 142) {
      bits |= 31744;
      bits |= (e2 == 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e2 < 113) {
      m2 |= 2048;
      bits |= (m2 >> 114 - e2) + (m2 >> 113 - e2 & 1);
      return bits;
    }
    bits |= e2 - 112 << 10 | m2 >> 1;
    bits += m2 & 1;
    return bits;
  }
};
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var MAX_SAMPLES = 20;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var {_lodPlanes, _sizeLods, _sigmas} = /* @__PURE__ */ _createPlanes();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
function convertLinearToRGBE(color) {
  const maxComponent = Math.max(color.r, color.g, color.b);
  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
  color.multiplyScalar(Math.pow(2, -fExp));
  const alpha = (fExp + 128) / 255;
  return alpha;
}
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background).convertSRGBToLinear();
        scene.background = null;
        const alpha = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = alpha;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const alpha = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = alpha;
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!texture.isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
    uniforms["outputEncoding"].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position2 = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y2,
        0,
        x + 2 / 3,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2 + 1,
        0
      ];
      position2.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position2, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return {_lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2};
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y2, width, height) {
  target.viewport.set(x, y2, width, height);
  target.scissor.set(x, y2, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {n: maxSamples},
    uniforms: {
      envMap: {value: null},
      samples: {value: 1},
      weights: {value: weights},
      latitudinal: {value: false},
      dTheta: {value: 0},
      mipInt: {value: 0},
      poleAxis: {value: poleAxis},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {value: null},
      texelSize: {value: texelSize},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {value: null},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
var LineStrip = 0;
var LinePieces = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
function MeshFaceMaterial(materials) {
  console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
  return materials;
}
function MultiMaterial(materials = []) {
  console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
  materials.isMultiMaterial = true;
  materials.materials = materials;
  materials.clone = function() {
    return materials.slice();
  };
  return materials;
}
function PointCloud(geometry, material) {
  console.warn("THREE.PointCloud has been renamed to THREE.Points.");
  return new Points(geometry, material);
}
function Particle(material) {
  console.warn("THREE.Particle has been renamed to THREE.Sprite.");
  return new Sprite(material);
}
function ParticleSystem(geometry, material) {
  console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
  return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
  console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
  console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
  console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function Vertex(x, y2, z2) {
  console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
  return new Vector3(x, y2, z2);
}
function DynamicBufferAttribute(array, itemSize) {
  console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
  console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
  return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
  console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
  return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
  console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
  return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
  console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
  return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
  console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
  return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
  console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
  return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
  console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
  return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
  console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
  return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
  console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
  return new Float64BufferAttribute(array, itemSize);
}
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
function AxisHelper(size) {
  console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
  return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
  console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
  return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
  console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(object, hex) {
  console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));
}
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(manager) {
  console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
  return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
  console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
  return new DataTextureLoader(manager);
}
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset3) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset3);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset3) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset3);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line2) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line2);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b, c, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b, c, target);
};
Triangle.normal = function(a2, b, c, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b, c, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options2) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options2);
};
Shape.prototype.makeGeometry = function(options2) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options2);
};
Vector2.prototype.fromAttribute = function(attribute, index4, offset3) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset3);
};
Vector2.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index4, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index4);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index4, offset3) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset3);
};
Vector3.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index4, offset3) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset3);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name2) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name2);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index4) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index4);
};
BufferGeometry.prototype.addAttribute = function(name2, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name2, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name2 === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name2, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name2) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name2);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(width, height, options2) {
  console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
  return new WebGLCubeRenderTarget(width, options2);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(Audio.prototype, {
  load: {
    value: function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping3, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping3)
    texture.mapping = mapping3;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping3, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping3)
    texture.mapping = mapping3;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
var SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/react-three-fiber/web.js
var import_react_reconciler = __toModule(require_react_reconciler());
var import_scheduler = __toModule(require_scheduler());
var import_react2 = __toModule(require("react"));
var import_tiny_emitter = __toModule(require_tiny_emitter());

// node_modules/use-asset/dist/index.js
var import_react = __toModule(require("react"));
var import_fast_deep_equal = __toModule(require_fast_deep_equal());
var globalCache = [];
function handleAsset(fn, cache3, args, lifespan = 0, preload = false) {
  for (const entry2 of cache3) {
    if ((0, import_fast_deep_equal.default)(args, entry2.args)) {
      if (preload)
        return;
      if (entry2.error)
        throw entry2.error;
      if (entry2.response)
        return entry2.response;
      throw entry2.promise;
    }
  }
  const entry = {
    args,
    promise: fn(...args).then((response) => entry.response = response != null ? response : true).catch((e2) => entry.error = e2 != null ? e2 : "unknown error").then(() => {
      if (lifespan > 0) {
        setTimeout(() => {
          const index4 = cache3.indexOf(entry);
          if (index4 !== -1)
            cache3.splice(index4, 1);
        }, lifespan);
      }
    })
  };
  cache3.push(entry);
  if (!preload)
    throw entry.promise;
}
function clear(cache3, ...args) {
  if (args === void 0)
    cache3.splice(0, cache3.length);
  else {
    const entry = cache3.find((entry2) => (0, import_fast_deep_equal.default)(args, entry2.args));
    if (entry) {
      const index4 = cache3.indexOf(entry);
      if (index4 !== -1)
        cache3.splice(index4, 1);
    }
  }
}
function useAsset(fn, ...args) {
  return (0, import_react.useMemo)(() => handleAsset(fn, globalCache, args, useAsset.lifespan), args);
}
useAsset.lifespan = 0;
useAsset.clear = (...args) => clear(globalCache, ...args);
useAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);
useAsset.peek = (...args) => {
  var _globalCache$find;
  return (_globalCache$find = globalCache.find((entry) => (0, import_fast_deep_equal.default)(args, entry.args))) == null ? void 0 : _globalCache$find.response;
};

// node_modules/react-three-fiber/web.js
var import_react_use_measure = __toModule(require_web());

// node_modules/react-merge-refs/dist/react-merge-refs.esm.js
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var react_merge_refs_esm_default = mergeRefs;

// node_modules/react-three-fiber/web.js
var name = "react-three-fiber";
var version = "5.3.19";
var roots = new Map();
var emptyObject = {};
var is = {
  obj: (a2) => a2 === Object(a2) && !is.arr(a2),
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0,
  arr: (a2) => Array.isArray(a2),
  equ(a2, b) {
    if (typeof a2 !== typeof b || !!a2 !== !!b)
      return false;
    if (is.str(a2) || is.num(a2) || is.obj(a2))
      return a2 === b;
    if (is.arr(a2) && a2 == b)
      return true;
    let i;
    for (i in a2)
      if (!(i in b))
        return false;
    for (i in b)
      if (a2[i] !== b[i])
        return false;
    return is.und(i) ? a2 === b : true;
  }
};
var globalEffects = [];
var globalAfterEffects = [];
var globalTailEffects = [];
function renderGl(state, timestamp, repeat = 0, runGlobalEffects = false) {
  let i;
  if (runGlobalEffects) {
    for (i = 0; i < globalEffects.length; i++) {
      globalEffects[i](timestamp);
      repeat++;
    }
  }
  const delta = state.current.clock.getDelta();
  for (i = 0; i < state.current.subscribers.length; i++) {
    state.current.subscribers[i].ref.current(state.current, delta);
  }
  state.current.frames = Math.max(0, state.current.frames - 1);
  repeat += !state.current.invalidateFrameloop ? 1 : state.current.frames;
  if (!state.current.manual && state.current.gl.render)
    state.current.gl.render(state.current.scene, state.current.camera);
  if (runGlobalEffects) {
    for (i = 0; i < globalAfterEffects.length; i++) {
      globalAfterEffects[i](timestamp);
    }
  }
  return repeat;
}
var running = false;
function renderLoop(timestamp) {
  running = true;
  let repeat = 0;
  let i;
  for (i = 0; i < globalEffects.length; i++) {
    globalEffects[i](timestamp);
    repeat++;
  }
  roots.forEach((root) => {
    const state = root.containerInfo.__state;
    if (state.current.active && state.current.ready && (!state.current.invalidateFrameloop || state.current.frames > 0)) {
      repeat = renderGl(state, timestamp, repeat);
    } else {
      repeat = 0;
    }
  });
  for (i = 0; i < globalAfterEffects.length; i++) {
    globalAfterEffects[i](timestamp);
  }
  if (repeat !== 0) {
    return requestAnimationFrame(renderLoop);
  } else {
    for (i = 0; i < globalTailEffects.length; i++) {
      globalTailEffects[i](timestamp);
    }
  }
  running = false;
}
function invalidate(state = true, frames = 1) {
  if (state === true) {
    roots.forEach((root) => {
      const state2 = root.containerInfo.__state;
      state2.current.frames = state2.current.ready ? state2.current.frames + frames : frames;
    });
  } else if (state && state.current) {
    if (state.current.vr)
      return;
    state.current.frames = state.current.ready ? state.current.frames + frames : frames;
  }
  if (!running) {
    running = true;
    requestAnimationFrame(renderLoop);
  }
}
var catalogue = {};
function applyProps(instance, newProps, oldProps = {}, accumulative = false) {
  const container = instance.__container;
  const sameProps = [];
  const handlers = [];
  let i;
  let keys = Object.keys(newProps);
  for (i = 0; i < keys.length; i++) {
    if (is.equ(newProps[keys[i]], oldProps[keys[i]])) {
      sameProps.push(keys[i]);
    }
    if (is.fun(newProps[keys[i]]) && keys[i].startsWith("on")) {
      if (keys[i].includes("Pointer") || keys[i].includes("Click") || keys[i].includes("ContextMenu") || keys[i].includes("Wheel")) {
        handlers.push(keys[i]);
      }
    }
  }
  const leftOvers = [];
  keys = Object.keys(oldProps);
  if (accumulative) {
    for (i = 0; i < keys.length; i++) {
      if (newProps[keys[i]] === void 0) {
        leftOvers.push(keys[i]);
      }
    }
  }
  const toFilter = [...sameProps, "children", "key", "ref"];
  if (instance.__instance)
    toFilter.push("object");
  const filteredProps = {
    ...newProps
  };
  keys = Object.keys(filteredProps);
  for (i = 0; i < keys.length; i++) {
    if (toFilter.indexOf(keys[i]) > -1) {
      delete filteredProps[keys[i]];
    }
  }
  keys = Object.keys(leftOvers);
  for (i = 0; i < keys.length; i++) {
    if (keys[i] !== "children") {
      filteredProps[keys[i]] = void 0;
    }
  }
  const filteredPropsEntries = Object.entries(filteredProps);
  if (filteredPropsEntries.length > 0) {
    filteredPropsEntries.forEach(([key, value]) => {
      if (!handlers.includes(key)) {
        var _instance$__container, _instance$__container2;
        let root = instance;
        let target = root[key];
        if (key.includes("-")) {
          const entries = key.split("-");
          target = entries.reduce((acc, key2) => acc[key2], instance);
          if (!(target && target.set)) {
            const [name2, ...reverseEntries] = entries.reverse();
            root = reverseEntries.reverse().reduce((acc, key2) => acc[key2], instance);
            key = name2;
          }
        }
        const isColorManagement = (_instance$__container = instance.__container) == null ? void 0 : (_instance$__container2 = _instance$__container.__state) == null ? void 0 : _instance$__container2.current.colorManagement;
        if (target && target.set && (target.copy || target instanceof Layers)) {
          if (Array.isArray(value)) {
            target.set(...value);
          } else if (target.copy && value && value.constructor && target.constructor.name === value.constructor.name) {
            target.copy(value);
          } else if (value !== void 0) {
            target.set(value);
            if (isColorManagement && target instanceof Color) {
              target.convertSRGBToLinear();
            }
          }
        } else {
          root[key] = value;
          if (isColorManagement && root[key] instanceof Texture) {
            root[key].encoding = sRGBEncoding;
          }
        }
        invalidateInstance(instance);
      }
    });
    if (accumulative && container && instance.raycast && instance.__handlers) {
      instance.__handlers = void 0;
      const index4 = container.__interaction.indexOf(instance);
      if (index4 > -1)
        container.__interaction.splice(index4, 1);
    }
    if (handlers.length) {
      if (accumulative && container && instance.raycast)
        container.__interaction.push(instance);
      instance.__handlers = handlers.reduce((acc, key) => {
        acc[key.charAt(2).toLowerCase() + key.substr(3)] = newProps[key];
        return acc;
      }, {});
    }
    if (instance.parent)
      updateInstance(instance);
  }
}
function invalidateInstance(instance) {
  if (instance.__container && instance.__container.__state)
    invalidate(instance.__container.__state);
}
function updateInstance(instance) {
  if (instance.onUpdate)
    instance.onUpdate(instance);
}
function createInstance(type, {
  args = [],
  ...props
}, container, hostContext, internalInstanceHandle) {
  let name2 = `${type[0].toUpperCase()}${type.slice(1)}`;
  let instance;
  if (type === "primitive") {
    props = {
      dispose: null,
      ...props
    };
    instance = props.object;
    instance.__instance = true;
    instance.__dispose = instance.dispose;
  } else {
    const target = catalogue[name2] || three_module_exports[name2];
    if (!target) {
      throw `"${name2}" is not part of the THREE namespace! Did you forget to extend it? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;
    }
    instance = is.arr(args) ? new target(...args) : new target(args);
  }
  while (container.__container) {
    container = container.__container;
  }
  if (!roots.has(container)) {
    const fn = (node2) => {
      if (!node2.return)
        return node2.stateNode && node2.stateNode.containerInfo;
      else
        return fn(node2.return);
    };
    container = fn(internalInstanceHandle);
  }
  instance.__objects = [];
  instance.__container = container;
  if (name2.endsWith("Geometry")) {
    props = {
      attach: "geometry",
      ...props
    };
  } else if (name2.endsWith("Material")) {
    props = {
      attach: "material",
      ...props
    };
  }
  applyProps(instance, props, {});
  return instance;
}
function appendChild(parentInstance, child) {
  if (child) {
    if (child.isObject3D) {
      parentInstance.add(child);
    } else {
      parentInstance.__objects.push(child);
      child.parent = parentInstance;
      if (child.attachArray) {
        if (!is.arr(parentInstance[child.attachArray]))
          parentInstance[child.attachArray] = [];
        parentInstance[child.attachArray].push(child);
      } else if (child.attachObject) {
        if (!is.obj(parentInstance[child.attachObject[0]]))
          parentInstance[child.attachObject[0]] = {};
        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;
      } else if (child.attach) {
        parentInstance[child.attach] = child;
      }
    }
    updateInstance(child);
    invalidateInstance(child);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  if (child) {
    if (child.isObject3D) {
      child.parent = parentInstance;
      child.dispatchEvent({
        type: "added"
      });
      const restSiblings = parentInstance.children.filter((sibling) => sibling !== child);
      const index4 = restSiblings.indexOf(beforeChild);
      parentInstance.children = [...restSiblings.slice(0, index4), child, ...restSiblings.slice(index4)];
      updateInstance(child);
    } else {
      appendChild(parentInstance, child);
    }
    invalidateInstance(child);
  }
}
function removeRecursive(array, parent, clone = false) {
  if (array) {
    const target = clone ? [...array] : array;
    target.forEach((child) => removeChild(parent, child));
  }
}
function removeChild(parentInstance, child) {
  if (child) {
    if (child.isObject3D) {
      parentInstance.remove(child);
    } else {
      child.parent = null;
      if (parentInstance.__objects)
        parentInstance.__objects = parentInstance.__objects.filter((x) => x !== child);
      if (child.attachArray) {
        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter((x) => x !== child);
      } else if (child.attachObject) {
        delete parentInstance[child.attachObject[0]][child.attachObject[1]];
      } else if (child.attach) {
        parentInstance[child.attach] = null;
      }
    }
    if (child.__container)
      child.__container.__interaction = child.__container.__interaction.filter((x) => x !== child);
    invalidateInstance(child);
    if (child.dispose !== null) {
      (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_IdlePriority, () => {
        removeRecursive(child.__objects, child);
        removeRecursive(child.children, child, true);
        if (child.dispose && child.type !== "Scene")
          child.dispose();
        else if (child.__dispose)
          child.__dispose();
        delete child.__container;
        delete child.__objects;
      });
    }
  }
}
function switchInstance(instance, type, newProps, fiber) {
  const parent = instance.parent;
  const newInstance = createInstance(type, newProps, instance.__container, null, fiber);
  removeChild(parent, instance);
  appendChild(parent, newInstance);
  [fiber, fiber.alternate].forEach((fiber2) => {
    if (fiber2 !== null) {
      fiber2.stateNode = newInstance;
      if (fiber2.ref) {
        if (is.fun(fiber2.ref))
          fiber2.ref(newInstance);
        else
          fiber2.ref.current = newInstance;
      }
    }
  });
}
var Renderer = (0, import_react_reconciler.default)({
  now: import_scheduler.unstable_now,
  createInstance,
  removeChild,
  appendChild,
  insertBefore,
  warnsIfNotActing: true,
  supportsMutation: true,
  isPrimaryRenderer: false,
  scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
  cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
  setTimeout: is.fun(setTimeout) ? setTimeout : void 0,
  clearTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
  noTimeout: -1,
  appendInitialChild: appendChild,
  appendChildToContainer: appendChild,
  removeChildFromContainer: removeChild,
  insertInContainerBefore: insertBefore,
  commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {
    if (instance.__instance && newProps.object && newProps.object !== instance) {
      switchInstance(instance, type, newProps, fiber);
    } else {
      const {
        args: argsNew = [],
        ...restNew
      } = newProps;
      const {
        args: argsOld = [],
        ...restOld
      } = oldProps;
      const hasNewArgs = argsNew.some((value, index4) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index4][key]) : value !== argsOld[index4]);
      if (hasNewArgs) {
        switchInstance(instance, type, newProps, fiber);
      } else {
        applyProps(instance, restNew, restOld, true);
      }
    }
  },
  hideInstance(instance) {
    if (instance.isObject3D) {
      instance.visible = false;
      invalidateInstance(instance);
    }
  },
  unhideInstance(instance, props) {
    if (instance.isObject3D && props.visible == null || props.visible) {
      instance.visible = true;
      invalidateInstance(instance);
    }
  },
  hideTextInstance() {
    throw new Error("Text is not allowed in the react-three-fibre tree. You may have extraneous whitespace between components.");
  },
  getPublicInstance(instance) {
    return instance;
  },
  getRootHostContext() {
    return emptyObject;
  },
  getChildHostContext() {
    return emptyObject;
  },
  createTextInstance() {
  },
  finalizeInitialChildren(instance) {
    return instance.__handlers;
  },
  commitMount(instance) {
    const container = instance.__container;
    if (container && instance.raycast && instance.__handlers)
      container.__interaction.push(instance);
  },
  prepareUpdate() {
    return emptyObject;
  },
  shouldDeprioritizeSubtree() {
    return false;
  },
  prepareForCommit() {
    return null;
  },
  preparePortalMount() {
    return null;
  },
  resetAfterCommit() {
  },
  shouldSetTextContent() {
    return false;
  },
  clearContainer() {
    return false;
  }
});
var hasSymbol = is.fun(Symbol) && Symbol.for;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
function render(element, container, state) {
  let root = roots.get(container);
  if (!root) {
    container.__state = state;
    let newRoot = root = Renderer.createContainer(container, state !== void 0 && state.current.concurrent ? 2 : 0, false, null);
    roots.set(container, newRoot);
  }
  Renderer.updateContainer(element, root, null, () => void 0);
  return Renderer.getPublicRootInstance(root);
}
function unmountComponentAtNode(container, callback) {
  const root = roots.get(container);
  if (root) {
    Renderer.updateContainer(null, root, null, () => {
      roots.delete(container);
      if (callback)
        callback(container);
    });
  }
}
Renderer.injectIntoDevTools({
  bundleType: true ? 0 : 1,
  findHostInstanceByFiber: () => null,
  version,
  rendererPackageName: name
});
function isOrthographicCamera(def) {
  return def.isOrthographicCamera;
}
function makeId(event) {
  return (event.eventObject || event.object).uuid + "/" + event.index;
}
var stateContext = /* @__PURE__ */ (0, import_react2.createContext)({});
var useCanvas = (props) => {
  const {
    children,
    gl,
    camera,
    orthographic,
    raycaster,
    size,
    pixelRatio,
    vr = false,
    concurrent = false,
    shadowMap = false,
    colorManagement = true,
    invalidateFrameloop = false,
    updateDefaultCamera = true,
    noEvents = false,
    onCreated,
    onPointerMissed,
    forceResize
  } = props;
  const [ready, setReady] = (0, import_react2.useState)(false);
  const [mouse] = (0, import_react2.useState)(() => new Vector2());
  const [defaultRaycaster] = (0, import_react2.useState)(() => {
    const ray = new Raycaster();
    if (raycaster) {
      const {
        filter,
        computeOffsets,
        ...raycasterProps
      } = raycaster;
      applyProps(ray, raycasterProps, {});
    }
    return ray;
  });
  const [defaultScene] = (0, import_react2.useState)(() => {
    const scene = new Scene();
    scene.__interaction = [];
    scene.__objects = [];
    return scene;
  });
  const [defaultCam, setDefaultCamera] = (0, import_react2.useState)(() => {
    const cam = orthographic ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3) : new PerspectiveCamera(75, 0, 0.1, 1e3);
    cam.position.z = 5;
    if (camera)
      applyProps(cam, camera, {});
    cam.lookAt(0, 0, 0);
    return cam;
  });
  const [clock] = (0, import_react2.useState)(() => new Clock());
  const state = (0, import_react2.useRef)({
    ready: false,
    active: true,
    manual: 0,
    colorManagement,
    vr,
    concurrent,
    noEvents,
    invalidateFrameloop: false,
    frames: 0,
    aspect: 0,
    subscribers: [],
    camera: defaultCam,
    scene: defaultScene,
    raycaster: defaultRaycaster,
    mouse,
    clock,
    gl,
    size,
    viewport: null,
    initialClick: [0, 0],
    initialHits: [],
    pointer: new import_tiny_emitter.TinyEmitter(),
    captured: void 0,
    events: void 0,
    subscribe: (ref, priority = 0) => {
      if (priority)
        state.current.manual++;
      state.current.subscribers.push({
        ref,
        priority
      });
      state.current.subscribers = state.current.subscribers.sort((a2, b) => a2.priority - b.priority);
      return () => {
        var _state$current;
        if ((_state$current = state.current) == null ? void 0 : _state$current.subscribers) {
          if (priority)
            state.current.manual--;
          state.current.subscribers = state.current.subscribers.filter((s2) => s2.ref !== ref);
        }
      };
    },
    setDefaultCamera: (camera2) => setDefaultCamera(camera2),
    invalidate: () => invalidate(state),
    intersect: (event = {}, prepare = true) => handlePointerMove(event, prepare),
    forceResize
  });
  const position2 = new Vector3();
  const getCurrentViewport = (0, import_react2.useCallback)((camera2 = state.current.camera, target = new Vector3(0, 0, 0)) => {
    const {
      width,
      height
    } = state.current.size;
    const distance = camera2.getWorldPosition(position2).distanceTo(target);
    if (isOrthographicCamera(camera2)) {
      return {
        width: width / camera2.zoom,
        height: height / camera2.zoom,
        factor: 1,
        distance
      };
    } else {
      const fov2 = camera2.fov * Math.PI / 180;
      const h2 = 2 * Math.tan(fov2 / 2) * distance;
      const w3 = h2 * (width / height);
      return {
        width: w3,
        height: h2,
        factor: width / w3,
        distance
      };
    }
  }, []);
  (0, import_react2.useMemo)(() => {
    state.current.ready = ready;
    state.current.size = size;
    state.current.camera = defaultCam;
    state.current.invalidateFrameloop = invalidateFrameloop;
    state.current.vr = vr;
    state.current.gl = gl;
    state.current.concurrent = concurrent;
    state.current.noEvents = noEvents;
    state.current.viewport = getCurrentViewport;
  }, [invalidateFrameloop, vr, concurrent, noEvents, ready, size, defaultCam, gl]);
  (0, import_react2.useMemo)(() => {
    state.current.aspect = size.width / size.height;
    Object.assign(state.current.viewport, getCurrentViewport());
    if (updateDefaultCamera) {
      if (isOrthographicCamera(defaultCam)) {
        defaultCam.left = size.width / -2;
        defaultCam.right = size.width / 2;
        defaultCam.top = size.height / 2;
        defaultCam.bottom = size.height / -2;
      } else {
        defaultCam.aspect = state.current.aspect;
      }
      defaultCam.updateProjectionMatrix();
      defaultCam.updateMatrixWorld();
    }
    gl.setSize(size.width, size.height);
    if (ready)
      invalidate(state);
  }, [defaultCam, gl, size, updateDefaultCamera, ready]);
  const sharedState = (0, import_react2.useRef)(null);
  (0, import_react2.useMemo)(() => {
    const {
      ready: ready2,
      manual,
      vr: vr2,
      noEvents: noEvents2,
      invalidateFrameloop: invalidateFrameloop2,
      frames,
      subscribers,
      captured,
      initialClick,
      initialHits,
      ...props2
    } = state.current;
    sharedState.current = props2;
  }, [size, defaultCam]);
  (0, import_react2.useLayoutEffect)(() => {
    if (pixelRatio) {
      if (Array.isArray(pixelRatio))
        gl.setPixelRatio(Math.max(Math.min(pixelRatio[0], window.devicePixelRatio), pixelRatio[1]));
      else
        gl.setPixelRatio(pixelRatio);
    }
  }, [gl, pixelRatio]);
  (0, import_react2.useLayoutEffect)(() => {
    if (shadowMap) {
      gl.shadowMap.enabled = true;
      if (typeof shadowMap === "object")
        Object.assign(gl.shadowMap, shadowMap);
      else
        gl.shadowMap.type = PCFSoftShadowMap;
    }
    if (colorManagement) {
      gl.toneMapping = ACESFilmicToneMapping;
      gl.outputEncoding = sRGBEncoding;
    }
  }, [shadowMap, colorManagement]);
  const hovered = (0, import_react2.useMemo)(() => new Map(), []);
  const temp = new Vector3();
  const prepareRay = (0, import_react2.useCallback)((event) => {
    const offsets = (raycaster == null ? void 0 : raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, sharedState.current)) || event.nativeEvent;
    if (offsets) {
      const {
        offsetX,
        offsetY
      } = offsets;
      const {
        width,
        height
      } = state.current.size;
      mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
      defaultRaycaster.setFromCamera(mouse, state.current.camera);
    }
  }, []);
  const intersect = (0, import_react2.useCallback)((filter) => {
    if (state.current.noEvents)
      return [];
    const seen = new Set();
    const hits = [];
    const eventsObjects = filter ? filter(state.current.scene.__interaction) : state.current.scene.__interaction;
    let intersects2 = defaultRaycaster.intersectObjects(eventsObjects, true).filter((item) => {
      const id = makeId(item);
      if (seen.has(id))
        return false;
      seen.add(id);
      return true;
    });
    if (raycaster && raycaster.filter && sharedState.current) {
      intersects2 = raycaster.filter(intersects2, sharedState.current);
    }
    for (const intersect2 of intersects2) {
      let eventObject = intersect2.object;
      while (eventObject) {
        const handlers = eventObject.__handlers;
        if (handlers)
          hits.push({
            ...intersect2,
            eventObject
          });
        eventObject = eventObject.parent;
      }
    }
    return hits;
  }, []);
  const calculateDistance = (0, import_react2.useCallback)((event) => {
    const dx = event.nativeEvent.offsetX - state.current.initialClick[0];
    const dy = event.nativeEvent.offsetY - state.current.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }, []);
  const handlePointerCancel = (0, import_react2.useCallback)((event, hits, prepare = true) => {
    state.current.pointer.emit("pointerCancel", event);
    if (prepare)
      prepareRay(event);
    Array.from(hovered.values()).forEach((hoveredObj) => {
      if (hits && (!hits.length || !hits.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index))) {
        const eventObject = hoveredObj.eventObject;
        const handlers = eventObject.__handlers;
        hovered.delete(makeId(hoveredObj));
        if (handlers) {
          const data3 = {
            ...hoveredObj,
            intersections: hits || []
          };
          if (handlers.pointerOut)
            handlers.pointerOut({
              ...data3,
              type: "pointerout"
            });
          if (handlers.pointerLeave)
            handlers.pointerLeave({
              ...data3,
              type: "pointerleave"
            });
        }
      }
    });
  }, []);
  const getIntersects = (0, import_react2.useCallback)((event, filter) => {
    const intersections = intersect(filter);
    if (state.current.captured && event.type !== "click" && event.type !== "wheel") {
      state.current.captured.forEach((captured) => {
        if (!intersections.find((hit) => hit.eventObject === captured.eventObject))
          intersections.push(captured);
      });
    }
    return intersections;
  }, []);
  const handleIntersects = (0, import_react2.useCallback)((intersections, event, fn) => {
    if (intersections.length) {
      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(state.current.camera);
      const delta = event.type === "click" ? calculateDistance(event) : 0;
      const releasePointerCapture = (id) => event.target.releasePointerCapture(id);
      const localState = {
        stopped: false,
        captured: false
      };
      for (const hit of intersections) {
        const setPointerCapture = (id) => {
          if (!localState.captured) {
            localState.captured = true;
            state.current.captured = [];
          }
          if (state.current.captured) {
            state.current.captured.push(hit);
          }
          event.target.setPointerCapture(id);
        };
        const raycastEvent = {
          ...event,
          ...hit,
          intersections,
          stopped: localState.stopped,
          delta,
          unprojectedPoint,
          ray: defaultRaycaster.ray,
          camera: state.current.camera,
          stopPropagation: () => {
            const cap = state.current.captured;
            if (!cap || cap.find((h2) => h2.eventObject.id === hit.eventObject.id)) {
              raycastEvent.stopped = localState.stopped = true;
              if (hovered.size && Array.from(hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                const higher = intersections.slice(0, intersections.indexOf(hit));
                handlePointerCancel(raycastEvent, [...higher, hit]);
              }
            }
          },
          target: {
            ...event.target,
            setPointerCapture,
            releasePointerCapture
          },
          currentTarget: {
            ...event.currentTarget,
            setPointerCapture,
            releasePointerCapture
          },
          sourceEvent: event
        };
        fn(raycastEvent);
        if (localState.stopped === true)
          break;
      }
    }
    return intersections;
  }, []);
  const handlePointerMove = (0, import_react2.useCallback)((event, prepare = true) => {
    state.current.pointer.emit("pointerMove", event);
    if (prepare)
      prepareRay(event);
    const hits = getIntersects(event, (objects) => objects.filter((obj) => ["Move", "Over", "Enter", "Out", "Leave"].some((name2) => obj.__handlers["pointer" + name2])));
    handlePointerCancel(event, hits);
    handleIntersects(hits, event, (data3) => {
      const eventObject = data3.eventObject;
      const handlers = eventObject.__handlers;
      if (!handlers)
        return;
      if (handlers.pointerOver || handlers.pointerEnter || handlers.pointerOut || handlers.pointerLeave) {
        const id = makeId(data3);
        const hoveredItem = hovered.get(id);
        if (!hoveredItem) {
          hovered.set(id, data3);
          if (handlers.pointerOver)
            handlers.pointerOver({
              ...data3,
              type: "pointerover"
            });
          if (handlers.pointerEnter)
            handlers.pointerEnter({
              ...data3,
              type: "pointerenter"
            });
        } else if (hoveredItem.stopped) {
          data3.stopPropagation();
        }
      }
      if (handlers.pointerMove)
        handlers.pointerMove(data3);
    });
    return hits;
  }, []);
  const handlePointer = (0, import_react2.useCallback)((name2) => (event, prepare = true) => {
    state.current.pointer.emit(name2, event);
    if (prepare)
      prepareRay(event);
    const hits = getIntersects(event);
    handleIntersects(hits, event, (data3) => {
      const eventObject = data3.eventObject;
      const handlers = eventObject.__handlers;
      if (handlers && handlers[name2]) {
        if (name2 !== "click" && name2 !== "contextMenu" && name2 !== "doubleClick" || state.current.initialHits.includes(eventObject)) {
          handlers[name2](data3);
          pointerMissed(event, defaultScene.__interaction, (object) => object !== eventObject);
        }
      }
    });
    if (name2 === "pointerDown") {
      state.current.initialClick = [event.nativeEvent.offsetX, event.nativeEvent.offsetY];
      state.current.initialHits = hits.map((hit) => hit.eventObject);
    }
    if ((name2 === "click" || name2 === "contextMenu" || name2 === "doubleClick") && !hits.length) {
      if (calculateDistance(event) <= 2) {
        pointerMissed(event, defaultScene.__interaction);
        if (onPointerMissed)
          onPointerMissed();
      }
    }
  }, [onPointerMissed, calculateDistance, getIntersects, handleIntersects, prepareRay]);
  (0, import_react2.useMemo)(() => {
    state.current.events = {
      onClick: handlePointer("click"),
      onContextMenu: handlePointer("contextMenu"),
      onDoubleClick: handlePointer("doubleClick"),
      onWheel: handlePointer("wheel"),
      onPointerDown: handlePointer("pointerDown"),
      onPointerUp: handlePointer("pointerUp"),
      onPointerLeave: (e2) => handlePointerCancel(e2, []),
      onPointerMove: handlePointerMove,
      onGotPointerCaptureLegacy: (e2) => state.current.captured = intersect(),
      onLostPointerCapture: (e2) => (state.current.captured = void 0, handlePointerCancel(e2))
    };
  }, [handlePointer, intersect, handlePointerCancel, handlePointerMove]);
  const Canvas3 = (0, import_react2.useCallback)(function Canvas4(props2) {
    const activate = () => setReady(true);
    (0, import_react2.useLayoutEffect)(() => void gl.compile(defaultScene, defaultCam), []);
    (0, import_react2.useEffect)(() => {
      const result = onCreated && onCreated(state.current);
      if (result && result.then)
        result.then(activate);
      else
        activate();
    }, []);
    return props2.children;
  }, []);
  (0, import_react2.useLayoutEffect)(() => {
    render(/* @__PURE__ */ (0, import_react2.createElement)(Canvas3, null, /* @__PURE__ */ (0, import_react2.createElement)(stateContext.Provider, {
      value: sharedState.current
    }, typeof children === "function" ? children(state.current) : children)), defaultScene, state);
  }, [ready, children, sharedState.current]);
  (0, import_react2.useLayoutEffect)(() => {
    if (ready) {
      if (!state.current.vr) {
        if (state.current.frames === 0)
          invalidate(state);
      } else if ((gl.xr || gl.vr) && gl.setAnimationLoop) {
        (gl.xr || gl.vr).enabled = true;
        gl.setAnimationLoop((t) => renderGl(state, t, 0, true));
      } else {
        console.warn("the gl instance does not support VR!");
      }
    }
  }, [gl, ready, invalidateFrameloop]);
  (0, import_react2.useEffect)(() => () => {
    if (state.current.gl) {
      if (state.current.gl.renderLists)
        state.current.gl.renderLists.dispose();
      if (state.current.gl.forceContextLoss)
        state.current.gl.forceContextLoss();
      dispose(state.current.gl);
    }
    unmountComponentAtNode(state.current.scene, () => {
      dispose(state.current.raycaster);
      dispose(state.current.camera);
      dispose(state.current);
    });
  }, []);
  return state.current.events;
};
function pointerMissed(event, objects, filter = (object) => true) {
  objects.filter(filter).forEach((object) => {
    var _handlers$pointerMis, _handlers;
    return (_handlers$pointerMis = (_handlers = object.__handlers).pointerMissed) == null ? void 0 : _handlers$pointerMis.call(_handlers, event);
  });
}
function dispose(obj) {
  if (obj.dispose && obj.type !== "Scene")
    obj.dispose();
  for (const p in obj) {
    if (typeof p === "object" && p.dispose)
      p.dispose();
    delete obj[p];
  }
}
function useContext(context) {
  let result = (0, import_react2.useContext)(context);
  if (!("subscribe" in result)) {
    throw new Error(`\u26A1\uFE0F react-three-fiber hooks can only be used within the Canvas component! https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#hooks`);
  }
  return result;
}
function useFrame(callback, renderPriority = 0) {
  const {
    subscribe
  } = useContext(stateContext);
  const ref = (0, import_react2.useRef)(callback);
  (0, import_react2.useLayoutEffect)(() => void (ref.current = callback), [callback]);
  (0, import_react2.useEffect)(() => {
    const unsubscribe = subscribe(ref, renderPriority);
    return () => unsubscribe();
  }, [renderPriority, subscribe]);
  return null;
}
function buildGraph(object) {
  const data3 = {
    nodes: {},
    materials: {}
  };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data3.nodes[obj.name] = obj;
      if (obj.material && !data3.materials[obj.material.name])
        data3.materials[obj.material.name] = obj.material;
    });
  }
  return data3;
}
function loadingFn(extensions, onProgress) {
  return function(Proto, ...input2) {
    const loader = new Proto();
    if (extensions)
      extensions(loader);
    return Promise.all(input2.map((input3) => new Promise((res, reject) => loader.load(input3, (data3) => {
      if (data3.scene)
        Object.assign(data3, buildGraph(data3.scene));
      res(data3);
    }, onProgress, (error) => {
      var _error$message;
      return reject((_error$message = error.message) != null ? _error$message : `failure loading ${input3}`);
    }))));
  };
}
function useLoader(Proto, input2, extensions, onProgress) {
  const keys = Array.isArray(input2) ? input2 : [input2];
  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys);
  return Array.isArray(input2) ? results : results[0];
}
useLoader.preload = function(Proto, input2, extensions) {
  const keys = Array.isArray(input2) ? input2 : [input2];
  return useAsset.preload(loadingFn(extensions), Proto, ...keys);
};
var defaultStyles = {
  position: "relative",
  width: "100%",
  height: "100%",
  overflow: "hidden"
};
function Content({
  children,
  setEvents,
  container,
  renderer,
  effects,
  ...props
}) {
  const [gl] = (0, import_react2.useState)(renderer);
  if (!gl)
    console.warn("No renderer created!");
  (0, import_react2.useEffect)(() => {
    if (effects)
      effects(gl, container);
  }, [container, effects, gl]);
  const events = useCanvas({
    ...props,
    children,
    gl
  });
  (0, import_react2.useEffect)(() => {
    setEvents(events);
  }, [events, setEvents]);
  return null;
}
var ResizeContainer = /* @__PURE__ */ import_react2.default.memo(function ResizeContainer2(props) {
  const {
    renderer,
    effects,
    children,
    vr,
    webgl1,
    concurrent,
    shadowMap,
    colorManagement,
    orthographic,
    invalidateFrameloop,
    updateDefaultCamera,
    noEvents,
    gl,
    camera,
    raycaster,
    pixelRatio,
    onCreated,
    onPointerMissed,
    preRender,
    resize,
    style,
    ...restSpread
  } = props;
  const containerRef = (0, import_react2.useRef)();
  const [{
    onGotPointerCaptureLegacy,
    ...events
  }, setEvents] = (0, import_react2.useState)({});
  const [bind, size, forceResize] = (0, import_react_use_measure.default)({
    scroll: true,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...resize
  });
  const readyFlag = (0, import_react2.useRef)(false);
  const ready = (0, import_react2.useMemo)(() => readyFlag.current = readyFlag.current || !!size.width && !!size.height, [size]);
  const state = (0, import_react2.useMemo)(() => ({
    size,
    forceResize,
    setEvents,
    container: containerRef.current
  }), [forceResize, size]);
  if (typeof window === "undefined")
    return /* @__PURE__ */ import_react2.default.createElement("div", _extends({
      style: {
        ...defaultStyles,
        ...style
      }
    }, restSpread), preRender);
  return /* @__PURE__ */ import_react2.default.createElement("div", _extends({
    ref: react_merge_refs_esm_default([bind, containerRef]),
    style: {
      ...defaultStyles,
      ...style
    }
  }, events, restSpread), preRender, ready && /* @__PURE__ */ import_react2.default.createElement(Content, _extends({}, props, state)));
});
var Canvas = /* @__PURE__ */ import_react2.default.memo(function Canvas2({
  children,
  ...props
}) {
  const canvasRef = (0, import_react2.useRef)();
  const renderer = props.webgl1 ? WebGL1Renderer : WebGLRenderer;
  return /* @__PURE__ */ import_react2.default.createElement(ResizeContainer, _extends({}, props, {
    renderer: () => {
      if (canvasRef.current) {
        const params = {
          antialias: true,
          alpha: true,
          ...props.gl
        };
        const temp = new renderer({
          powerPreference: "high-performance",
          canvas: canvasRef.current,
          ...params
        });
        return temp;
      }
    },
    preRender: /* @__PURE__ */ import_react2.default.createElement("canvas", {
      ref: canvasRef,
      style: {
        display: "block"
      }
    })
  }), children);
});

// src/r3f.tsx
function Three(props) {
  const preserveDrawingBuffer = props.componentObject.project.designMode;
  return /* @__PURE__ */ import_react3.default.createElement(Canvas, {
    gl: {preserveDrawingBuffer}
  }, /* @__PURE__ */ import_react3.default.createElement("ambientLight", null), /* @__PURE__ */ import_react3.default.createElement("pointLight", {
    position: [10, 10, 10]
  }), /* @__PURE__ */ import_react3.default.createElement(Box, {
    position: [-2.2, 0, 0]
  }), /* @__PURE__ */ import_react3.default.createElement(Box, {
    position: [2.2, 0, 0]
  }));
}
var ThreeDescription = {
  name: "Three",
  description: "The Three Component ...",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: Three,
  extends: "Play Kit/View",
  properties: {
    width: {type: "number", title: "Width", default: 400},
    height: {type: "number", title: "Height", default: 200}
  }
};
var Box = (props) => {
  const mesh = (0, import_react3.useRef)();
  const [hovered, setHover] = (0, import_react3.useState)(false);
  const [active, setActive] = (0, import_react3.useState)(false);
  useFrame(() => {
    if (mesh.current)
      mesh.current.rotation.x = mesh.current.rotation.y += 0.01;
  });
  return /* @__PURE__ */ import_react3.default.createElement("mesh", {
    ...props,
    ref: mesh,
    scale: active ? [2.5, 2.5, 2.5] : [2, 2, 2],
    onClick: (event) => setActive(!active),
    onPointerOver: (event) => setHover(true),
    onPointerOut: (event) => setHover(false)
  }, /* @__PURE__ */ import_react3.default.createElement("boxBufferGeometry", {
    args: [1, 1, 1]
  }), /* @__PURE__ */ import_react3.default.createElement("meshStandardMaterial", {
    color: hovered ? "hotpink" : "orange"
  }));
};

// src/xkcd.tsx
var import_react4 = __toModule(require("react"));
function XKCD(props) {
  const {comic, componentObject} = props;
  const [source, setSource] = (0, import_react4.useState)();
  const [error, setError] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    fetch(`/cors?url=https://xkcd.com/${comic}/info.0.json`).then((response) => response.json()).then((json3) => {
      setSource(json3.img);
      componentObject.response = json3;
    }).catch((err) => {
      setSource(void 0);
      setError(err.toString());
    });
  }, [comic]);
  return /* @__PURE__ */ import_react4.default.createElement("div", {
    style: {width: "100%", height: "100%", position: "relative"}
  }, source && /* @__PURE__ */ import_react4.default.createElement("img", {
    src: `/cors?url=${source}`,
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      objectFit: "contain"
    }
  }), error && /* @__PURE__ */ import_react4.default.createElement("div", {
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      display: "flex",
      alignContent: "center",
      alignItems: "center"
    }
  }, error));
}
var XKCDDescription = {
  name: "XKCD",
  description: "The XKCD Component .... Content copyright",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: XKCD,
  extends: "Play Kit/View",
  properties: {
    comic: {type: "number", default: 2293},
    width: {type: "number", default: 400},
    height: {type: "number", default: 400}
  }
};

// src/index.ts
var import_chart_xkcd = require_chart_xkcd();

// src/clock/clock.tsx
var import_react18 = __toModule(require("react"));

// node_modules/react-clock/dist/esm/Clock.js
var import_react7 = __toModule(require("react"));
var import_prop_types3 = __toModule(require_prop_types());

// node_modules/merge-class-names/dist/esm/index.js
function mergeClassNames() {
  return Array.prototype.slice.call(arguments).reduce(function(classList, arg) {
    return typeof arg === "string" || Array.isArray(arg) ? classList.concat(arg) : classList;
  }, []).filter(Boolean).join(" ");
}

// node_modules/@wojtekmaj/date-utils/dist/esm/index.js
function makeGetEdgeOfNeighbor(getPeriod, getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborInternal(date4) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var previousPeriod = getPeriod(date4) + offset3;
    return getEdgeOfPeriod(previousPeriod);
  };
}
function makeGetEnd(getBeginOfNextPeriod) {
  return function makeGetEndInternal(date4) {
    return new Date(getBeginOfNextPeriod(date4).getTime() - 1);
  };
}
function makeGetRange(functions) {
  return function makeGetRangeInternal(date4) {
    return functions.map(function(fn) {
      return fn(date4);
    });
  };
}
function getYear(date4) {
  if (date4 instanceof Date) {
    return date4.getFullYear();
  }
  if (typeof date4 === "number") {
    return date4;
  }
  var year6 = parseInt(date4, 10);
  if (typeof date4 === "string" && !isNaN(year6)) {
    return year6;
  }
  throw new Error("Failed to get year from date: ".concat(date4, "."));
}
function getMonth(date4) {
  if (date4 instanceof Date) {
    return date4.getMonth();
  }
  throw new Error("Failed to get month from date: ".concat(date4, "."));
}
function getDate(date4) {
  if (date4 instanceof Date) {
    return date4.getDate();
  }
  throw new Error("Failed to get year from date: ".concat(date4, "."));
}
function getHours(date4) {
  if (date4 instanceof Date) {
    return date4.getHours();
  }
  if (typeof date4 === "string") {
    var datePieces = date4.split(":");
    if (datePieces.length >= 2) {
      var hoursString = datePieces[0];
      var hours2 = parseInt(hoursString, 10);
      if (!isNaN(hours2)) {
        return hours2;
      }
    }
  }
  throw new Error("Failed to get hours from date: ".concat(date4, "."));
}
function getMinutes(date4) {
  if (date4 instanceof Date) {
    return date4.getMinutes();
  }
  if (typeof date4 === "string") {
    var datePieces = date4.split(":");
    if (datePieces.length >= 2) {
      var minutesString = datePieces[1] || 0;
      var minutes2 = parseInt(minutesString, 10);
      if (!isNaN(minutes2)) {
        return minutes2;
      }
    }
  }
  throw new Error("Failed to get minutes from date: ".concat(date4, "."));
}
function getSeconds(date4) {
  if (date4 instanceof Date) {
    return date4.getSeconds();
  }
  if (typeof date4 === "string") {
    var datePieces = date4.split(":");
    if (datePieces.length >= 2) {
      var secondsString = datePieces[2] || 0;
      var seconds2 = parseInt(secondsString, 10);
      if (!isNaN(seconds2)) {
        return seconds2;
      }
    }
  }
  throw new Error("Failed to get seconds from date: ".concat(date4, "."));
}
function getCenturyStart(date4) {
  var year6 = getYear(date4);
  var centuryStartYear = year6 + (-year6 + 1) % 100;
  var centuryStartDate = new Date();
  centuryStartDate.setFullYear(centuryStartYear, 0, 1);
  centuryStartDate.setHours(0, 0, 0, 0);
  return centuryStartDate;
}
var getPreviousCenturyStart = makeGetEdgeOfNeighbor(getYear, getCenturyStart, -100);
var getNextCenturyStart = makeGetEdgeOfNeighbor(getYear, getCenturyStart, 100);
var getCenturyEnd = makeGetEnd(getNextCenturyStart);
var getPreviousCenturyEnd = makeGetEdgeOfNeighbor(getYear, getCenturyEnd, -100);
var getNextCenturyEnd = makeGetEdgeOfNeighbor(getYear, getCenturyEnd, 100);
var getCenturyRange = makeGetRange([getCenturyStart, getCenturyEnd]);
function getDecadeStart(date4) {
  var year6 = getYear(date4);
  var decadeStartYear = year6 + (-year6 + 1) % 10;
  var decadeStartDate = new Date();
  decadeStartDate.setFullYear(decadeStartYear, 0, 1);
  decadeStartDate.setHours(0, 0, 0, 0);
  return decadeStartDate;
}
var getPreviousDecadeStart = makeGetEdgeOfNeighbor(getYear, getDecadeStart, -10);
var getNextDecadeStart = makeGetEdgeOfNeighbor(getYear, getDecadeStart, 10);
var getDecadeEnd = makeGetEnd(getNextDecadeStart);
var getPreviousDecadeEnd = makeGetEdgeOfNeighbor(getYear, getDecadeEnd, -10);
var getNextDecadeEnd = makeGetEdgeOfNeighbor(getYear, getDecadeEnd, 10);
var getDecadeRange = makeGetRange([getDecadeStart, getDecadeEnd]);
function getYearStart(date4) {
  var year6 = getYear(date4);
  var yearStartDate = new Date();
  yearStartDate.setFullYear(year6, 0, 1);
  yearStartDate.setHours(0, 0, 0, 0);
  return yearStartDate;
}
var getPreviousYearStart = makeGetEdgeOfNeighbor(getYear, getYearStart, -1);
var getNextYearStart = makeGetEdgeOfNeighbor(getYear, getYearStart, 1);
var getYearEnd = makeGetEnd(getNextYearStart);
var getPreviousYearEnd = makeGetEdgeOfNeighbor(getYear, getYearEnd, -1);
var getNextYearEnd = makeGetEdgeOfNeighbor(getYear, getYearEnd, 1);
var getYearRange = makeGetRange([getYearStart, getYearEnd]);
function makeGetEdgeOfNeighborMonth(getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborMonthInternal(date4) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var year6 = getYear(date4);
    var month6 = getMonth(date4) + offset3;
    var previousPeriod = new Date();
    previousPeriod.setFullYear(year6, month6, 1);
    previousPeriod.setHours(0, 0, 0, 0);
    return getEdgeOfPeriod(previousPeriod);
  };
}
function getMonthStart(date4) {
  var year6 = getYear(date4);
  var month6 = getMonth(date4);
  var monthStartDate = new Date();
  monthStartDate.setFullYear(year6, month6, 1);
  monthStartDate.setHours(0, 0, 0, 0);
  return monthStartDate;
}
var getPreviousMonthStart = makeGetEdgeOfNeighborMonth(getMonthStart, -1);
var getNextMonthStart = makeGetEdgeOfNeighborMonth(getMonthStart, 1);
var getMonthEnd = makeGetEnd(getNextMonthStart);
var getPreviousMonthEnd = makeGetEdgeOfNeighborMonth(getMonthEnd, -1);
var getNextMonthEnd = makeGetEdgeOfNeighborMonth(getMonthEnd, 1);
var getMonthRange = makeGetRange([getMonthStart, getMonthEnd]);
function makeGetEdgeOfNeighborDay(getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborDayInternal(date4) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var year6 = getYear(date4);
    var month6 = getMonth(date4);
    var day5 = getDate(date4) + offset3;
    var previousPeriod = new Date();
    previousPeriod.setFullYear(year6, month6, day5);
    previousPeriod.setHours(0, 0, 0, 0);
    return getEdgeOfPeriod(previousPeriod);
  };
}
function getDayStart(date4) {
  var year6 = getYear(date4);
  var month6 = getMonth(date4);
  var day5 = getDate(date4);
  var dayStartDate = new Date();
  dayStartDate.setFullYear(year6, month6, day5);
  dayStartDate.setHours(0, 0, 0, 0);
  return dayStartDate;
}
var getPreviousDayStart = makeGetEdgeOfNeighborDay(getDayStart, -1);
var getNextDayStart = makeGetEdgeOfNeighborDay(getDayStart, 1);
var getDayEnd = makeGetEnd(getNextDayStart);
var getPreviousDayEnd = makeGetEdgeOfNeighborDay(getDayEnd, -1);
var getNextDayEnd = makeGetEdgeOfNeighborDay(getDayEnd, 1);
var getDayRange = makeGetRange([getDayStart, getDayEnd]);

// node_modules/react-clock/dist/esm/Hand.js
var import_react5 = __toModule(require("react"));
var import_prop_types = __toModule(require_prop_types());

// node_modules/react-clock/dist/esm/shared/utils.js
var isDefined = function isDefined2(variable) {
  return typeof variable !== "undefined";
};

// node_modules/react-clock/dist/esm/shared/propTypes.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var isNumberBetween = function isNumberBetween2(min, max) {
  return function(props, propName, componentName) {
    var value = props[propName];
    if (isDefined(value)) {
      if (typeof value !== "number") {
        return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(value), "` supplied to `").concat(componentName, "`, expected `number`."));
      }
      if (value < min || value > max) {
        return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(value), "` supplied to `").concat(componentName, "`, length must be between ").concat(min, " and ").concat(max, "."));
      }
    }
    return null;
  };
};
var isHandLength = isNumberBetween(0, 100);
var isOppositeHandLength = isNumberBetween(-100, 100);
var isHandWidth = function isHandWidth2(props, propName, componentName) {
  var width = props[propName];
  if (isDefined(width)) {
    if (typeof width !== "number") {
      return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(width), "` supplied to `").concat(componentName, "`, expected `number`."));
    }
    if (width < 0) {
      return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(width), "` supplied to `").concat(componentName, "`, width must be greater or equal to 0."));
    }
  }
  return null;
};
var isMarkLength = isHandLength;
var isMarkWidth = isHandWidth;

// node_modules/react-clock/dist/esm/Hand.js
function Hand(_ref3) {
  var _ref$angle = _ref3.angle, angle = _ref$angle === void 0 ? 0 : _ref$angle, name2 = _ref3.name, _ref$length = _ref3.length, length2 = _ref$length === void 0 ? 100 : _ref$length, _ref$oppositeLength = _ref3.oppositeLength, oppositeLength = _ref$oppositeLength === void 0 ? 10 : _ref$oppositeLength, _ref$width = _ref3.width, width = _ref$width === void 0 ? 1 : _ref$width;
  return /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "react-clock__hand react-clock__".concat(name2, "-hand"),
    style: {
      transform: "rotate(".concat(angle, "deg)")
    }
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "react-clock__hand__body react-clock__".concat(name2, "-hand__body"),
    style: {
      width: "".concat(width, "px"),
      top: "".concat(50 - length2 / 2, "%"),
      bottom: "".concat(50 - oppositeLength / 2, "%")
    }
  }));
}
Hand.propTypes = {
  angle: import_prop_types.default.number,
  length: isHandLength,
  name: import_prop_types.default.string.isRequired,
  oppositeLength: isHandLength,
  width: import_prop_types.default.number
};

// node_modules/react-clock/dist/esm/Mark.js
var import_react6 = __toModule(require("react"));
var import_prop_types2 = __toModule(require_prop_types());
function Mark(_ref3) {
  var _ref$angle = _ref3.angle, angle = _ref$angle === void 0 ? 0 : _ref$angle, _ref$length = _ref3.length, length2 = _ref$length === void 0 ? 10 : _ref$length, name2 = _ref3.name, _ref$width = _ref3.width, width = _ref$width === void 0 ? 1 : _ref$width, number = _ref3.number;
  return /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark react-clock__".concat(name2, "-mark"),
    style: {
      transform: "rotate(".concat(angle, "deg)")
    }
  }, /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark__body react-clock__".concat(name2, "-mark__body"),
    style: {
      width: "".concat(width, "px"),
      top: 0,
      bottom: "".concat(100 - length2 / 2, "%")
    }
  }), number && /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark__number",
    style: {
      transform: "rotate(-".concat(angle, "deg)"),
      top: "".concat(length2 / 2, "%")
    }
  }, number));
}
Mark.propTypes = {
  angle: import_prop_types2.default.number,
  length: isMarkLength,
  name: import_prop_types2.default.string.isRequired,
  number: import_prop_types2.default.number,
  width: isMarkWidth
};

// node_modules/react-clock/dist/esm/Clock.js
function Clock2(_ref3) {
  var className = _ref3.className, _ref$hourHandLength = _ref3.hourHandLength, hourHandLength = _ref$hourHandLength === void 0 ? 50 : _ref$hourHandLength, hourHandOppositeLength = _ref3.hourHandOppositeLength, _ref$hourHandWidth = _ref3.hourHandWidth, hourHandWidth = _ref$hourHandWidth === void 0 ? 4 : _ref$hourHandWidth, _ref$hourMarksLength = _ref3.hourMarksLength, hourMarksLength = _ref$hourMarksLength === void 0 ? 10 : _ref$hourMarksLength, _ref$hourMarksWidth = _ref3.hourMarksWidth, hourMarksWidth = _ref$hourMarksWidth === void 0 ? 3 : _ref$hourMarksWidth, _ref$minuteHandLength = _ref3.minuteHandLength, minuteHandLength = _ref$minuteHandLength === void 0 ? 70 : _ref$minuteHandLength, minuteHandOppositeLength = _ref3.minuteHandOppositeLength, _ref$minuteHandWidth = _ref3.minuteHandWidth, minuteHandWidth = _ref$minuteHandWidth === void 0 ? 2 : _ref$minuteHandWidth, _ref$minuteMarksLengt = _ref3.minuteMarksLength, minuteMarksLength = _ref$minuteMarksLengt === void 0 ? 6 : _ref$minuteMarksLengt, _ref$minuteMarksWidth = _ref3.minuteMarksWidth, minuteMarksWidth = _ref$minuteMarksWidth === void 0 ? 1 : _ref$minuteMarksWidth, _ref$renderHourMarks = _ref3.renderHourMarks, renderHourMarks = _ref$renderHourMarks === void 0 ? true : _ref$renderHourMarks, _ref$renderMinuteHand = _ref3.renderMinuteHand, renderMinuteHand = _ref$renderMinuteHand === void 0 ? true : _ref$renderMinuteHand, _ref$renderMinuteMark = _ref3.renderMinuteMarks, renderMinuteMarks = _ref$renderMinuteMark === void 0 ? true : _ref$renderMinuteMark, renderNumbers = _ref3.renderNumbers, _ref$renderSecondHand = _ref3.renderSecondHand, renderSecondHand = _ref$renderSecondHand === void 0 ? true : _ref$renderSecondHand, _ref$secondHandLength = _ref3.secondHandLength, secondHandLength = _ref$secondHandLength === void 0 ? 90 : _ref$secondHandLength, secondHandOppositeLength = _ref3.secondHandOppositeLength, _ref$secondHandWidth = _ref3.secondHandWidth, secondHandWidth = _ref$secondHandWidth === void 0 ? 1 : _ref$secondHandWidth, _ref$size = _ref3.size, size = _ref$size === void 0 ? 150 : _ref$size, value = _ref3.value;
  function renderMinuteMarksFn() {
    if (!renderMinuteMarks) {
      return null;
    }
    var minuteMarks = [];
    for (var i = 1; i <= 60; i += 1) {
      var isHourMark = renderHourMarks && !(i % 5);
      if (!isHourMark) {
        minuteMarks.push(/* @__PURE__ */ import_react7.default.createElement(Mark, {
          key: "minute_".concat(i),
          angle: i * 6,
          length: minuteMarksLength,
          name: "minute",
          width: minuteMarksWidth
        }));
      }
    }
    return minuteMarks;
  }
  function renderHourMarksFn() {
    if (!renderHourMarks) {
      return null;
    }
    var hourMarks = [];
    for (var i = 1; i <= 12; i += 1) {
      hourMarks.push(/* @__PURE__ */ import_react7.default.createElement(Mark, {
        key: "hour_".concat(i),
        angle: i * 30,
        length: hourMarksLength,
        name: "hour",
        number: renderNumbers ? i : null,
        width: hourMarksWidth
      }));
    }
    return hourMarks;
  }
  function renderFace() {
    return /* @__PURE__ */ import_react7.default.createElement("div", {
      className: "react-clock__face"
    }, renderMinuteMarksFn(), renderHourMarksFn());
  }
  function renderHourHandFn() {
    var angle = value ? getHours(value) * 30 + getMinutes(value) / 2 + getSeconds(value) / 600 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: hourHandLength,
      name: "hour",
      oppositeLength: hourHandOppositeLength,
      width: hourHandWidth
    });
  }
  function renderMinuteHandFn() {
    if (!renderMinuteHand) {
      return null;
    }
    var angle = value ? getHours(value) * 360 + getMinutes(value) * 6 + getSeconds(value) / 10 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: minuteHandLength,
      name: "minute",
      oppositeLength: minuteHandOppositeLength,
      width: minuteHandWidth
    });
  }
  function renderSecondHandFn() {
    if (!renderSecondHand) {
      return null;
    }
    var angle = value ? getMinutes(value) * 360 + getSeconds(value) * 6 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: secondHandLength,
      name: "second",
      oppositeLength: secondHandOppositeLength,
      width: secondHandWidth
    });
  }
  return /* @__PURE__ */ import_react7.default.createElement("time", {
    className: mergeClassNames("react-clock", className),
    dateTime: value instanceof Date ? value.toISOString() : value,
    style: {
      width: "".concat(size, "px"),
      height: "".concat(size, "px")
    }
  }, renderFace(), renderHourHandFn(), renderMinuteHandFn(), renderSecondHandFn());
}
Clock2.propTypes = {
  className: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.arrayOf(import_prop_types3.default.string)]),
  hourHandLength: isHandLength,
  hourHandOppositeLength: isOppositeHandLength,
  hourHandWidth: isHandWidth,
  hourMarksLength: isMarkLength,
  hourMarksWidth: isMarkWidth,
  minuteHandLength: isHandLength,
  minuteHandOppositeLength: isOppositeHandLength,
  minuteHandWidth: isHandWidth,
  minuteMarksLength: isMarkLength,
  minuteMarksWidth: isMarkWidth,
  renderHourMarks: import_prop_types3.default.bool,
  renderMinuteHand: import_prop_types3.default.bool,
  renderMinuteMarks: import_prop_types3.default.bool,
  renderNumbers: import_prop_types3.default.bool,
  renderSecondHand: import_prop_types3.default.bool,
  secondHandLength: isHandLength,
  secondHandOppositeLength: isOppositeHandLength,
  secondHandWidth: isHandWidth,
  size: import_prop_types3.default.number,
  value: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.instanceOf(Date)])
};

// node_modules/react-clock/dist/esm/index.js
var esm_default = Clock2;

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p2) {
    o3.__proto__ = p2;
    return o3;
  };
  return _setPrototypeOf(o2, p);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/react-jss/dist/react-jss.esm.js
var import_react9 = __toModule(require("react"));
var import_hoist_non_react_statics2 = __toModule(require_hoist_non_react_statics_cjs());

// node_modules/theming/dist/theming.esm.js
var import_react8 = __toModule(require("react"));

// node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction = true;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x) {
    }
  }
}
var tiny_warning_esm_default = warning;

// node_modules/theming/dist/theming.esm.js
var import_prop_types4 = __toModule(require_prop_types());
var import_hoist_non_react_statics = __toModule(require_hoist_non_react_statics_cjs());
var import_react_display_name = __toModule(require_getDisplayName());
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function createThemeProvider(context) {
  var ThemeProvider2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(ThemeProvider3, _React$Component);
    function ThemeProvider3() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "cachedTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "lastOuterTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "lastTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderProvider", function(outerTheme) {
        var children = _this.props.children;
        return import_react8.default.createElement(context.Provider, {
          value: _this.getTheme(outerTheme)
        }, children);
      });
      return _this;
    }
    var _proto = ThemeProvider3.prototype;
    _proto.getTheme = function getTheme(outerTheme) {
      if (this.props.theme !== this.lastTheme || outerTheme !== this.lastOuterTheme || !this.cachedTheme) {
        this.lastOuterTheme = outerTheme;
        this.lastTheme = this.props.theme;
        if (typeof this.lastTheme === "function") {
          var theme = this.props.theme;
          this.cachedTheme = theme(outerTheme);
          false ? tiny_warning_esm_default(isObject(this.cachedTheme), "[ThemeProvider] Please return an object from your theme function") : void 0;
        } else {
          var _theme = this.props.theme;
          false ? tiny_warning_esm_default(isObject(_theme), "[ThemeProvider] Please make your theme prop a plain object") : void 0;
          this.cachedTheme = outerTheme ? _extends2({}, outerTheme, _theme) : _theme;
        }
      }
      return this.cachedTheme;
    };
    _proto.render = function render2() {
      var children = this.props.children;
      if (!children) {
        return null;
      }
      return import_react8.default.createElement(context.Consumer, null, this.renderProvider);
    };
    return ThemeProvider3;
  }(import_react8.default.Component);
  if (false) {
    ThemeProvider2.propTypes = {
      children: import_prop_types4.default.node,
      theme: import_prop_types4.default.oneOfType([import_prop_types4.default.shape({}), import_prop_types4.default.func]).isRequired
    };
  }
  return ThemeProvider2;
}
function createWithTheme(context) {
  return function hoc(Component6) {
    var withTheme2 = import_react8.default.forwardRef(function(props, ref) {
      return import_react8.default.createElement(context.Consumer, null, function(theme) {
        false ? tiny_warning_esm_default(isObject(theme), "[theming] Please use withTheme only with the ThemeProvider") : void 0;
        return import_react8.default.createElement(Component6, _extends2({
          theme,
          ref
        }, props));
      });
    });
    if (false) {
      withTheme2.displayName = "WithTheme(" + (0, import_react_display_name.default)(Component6) + ")";
    }
    (0, import_hoist_non_react_statics.default)(withTheme2, Component6);
    return withTheme2;
  };
}
function createUseTheme(context) {
  var useTheme2 = function useTheme3() {
    var theme = import_react8.default.useContext(context);
    false ? tiny_warning_esm_default(isObject(theme), "[theming] Please use useTheme only with the ThemeProvider") : void 0;
    return theme;
  };
  return useTheme2;
}
function createTheming(context) {
  return {
    context,
    withTheme: createWithTheme(context),
    useTheme: createUseTheme(context),
    ThemeProvider: createThemeProvider(context)
  };
}
var ThemeContext = (0, import_react8.createContext)();
var _createTheming = createTheming(ThemeContext);
var withTheme = _createTheming.withTheme;
var ThemeProvider = _createTheming.ThemeProvider;
var useTheme = _createTheming.useTheme;

// node_modules/is-in-browser/dist/module.js
var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof2(document)) === "object" && document.nodeType === 9;
var module_default = isBrowser;

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/jss/dist/jss.esm.js
var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== "object")
    return style;
  if (Array.isArray(style))
    return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor)
    return style;
  var newStyle = {};
  for (var name2 in style) {
    newStyle[name2] = cloneStyle(style[name2]);
  }
  return newStyle;
}
function createRule(name2, decl, options2) {
  if (name2 === void 0) {
    name2 = "unnamed";
  }
  var jss3 = options2.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss3.plugins.onCreateRule(name2, declCopy, options2);
  if (rule)
    return rule;
  if (name2[0] === "@") {
    false ? tiny_warning_esm_default(false, "[JSS] Unknown rule " + name2) : void 0;
  }
  return null;
}
var join = function join2(value, by) {
  var result = "";
  for (var i = 0; i < value.length; i++) {
    if (value[i] === "!important")
      break;
    if (result)
      result += by;
    result += value[i];
  }
  return result;
};
var toCssValue = function toCssValue2(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }
  if (!Array.isArray(value))
    return value;
  var cssValue = "";
  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === "!important")
        break;
      if (cssValue)
        cssValue += ", ";
      cssValue += join(value[i], " ");
    }
  } else
    cssValue = join(value, ", ");
  if (!ignoreImportant && value[value.length - 1] === "!important") {
    cssValue += " !important";
  }
  return cssValue;
};
function indentStr(str, indent) {
  var result = "";
  for (var index4 = 0; index4 < indent; index4++) {
    result += "  ";
  }
  return result + str;
}
function toCss(selector, style, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var result = "";
  if (!style)
    return result;
  var _options = options2, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector)
    indent++;
  if (fallbacks) {
    if (Array.isArray(fallbacks)) {
      for (var index4 = 0; index4 < fallbacks.length; index4++) {
        var fallback = fallbacks[index4];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            if (result)
              result += "\n";
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];
        if (_value != null) {
          if (result)
            result += "\n";
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }
  for (var _prop2 in style) {
    var _value2 = style[_prop2];
    if (_value2 != null && _prop2 !== "fallbacks") {
      if (result)
        result += "\n";
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  }
  if (!result && !options2.allowEmpty)
    return result;
  if (!selector)
    return result;
  indent--;
  if (result)
    result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr("}", indent);
}
var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== "undefined" && CSS.escape;
var escape2 = function(str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, "\\$1");
};
var BaseStyleRule = /* @__PURE__ */ function() {
  function BaseStyleRule2(key, style, options2) {
    this.type = "style";
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options2.sheet, Renderer2 = options2.Renderer;
    this.key = key;
    this.options = options2;
    this.style = style;
    if (sheet)
      this.renderer = sheet.renderer;
    else if (Renderer2)
      this.renderer = new Renderer2();
  }
  var _proto = BaseStyleRule2.prototype;
  _proto.prop = function prop(name2, value, options2) {
    if (value === void 0)
      return this.style[name2];
    var force = options2 ? options2.force : false;
    if (!force && this.style[name2] === value)
      return this;
    var newValue = value;
    if (!options2 || options2.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name2, this);
    }
    var isEmpty = newValue == null || newValue === false;
    var isDefined3 = name2 in this.style;
    if (isEmpty && !isDefined3 && !force)
      return this;
    var remove = isEmpty && isDefined3;
    if (remove)
      delete this.style[name2];
    else
      this.style[name2] = newValue;
    if (this.renderable && this.renderer) {
      if (remove)
        this.renderer.removeProperty(this.renderable, name2);
      else
        this.renderer.setProperty(this.renderable, name2, newValue);
      return this;
    }
    var sheet = this.options.sheet;
    if (sheet && sheet.attached) {
      false ? tiny_warning_esm_default(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : void 0;
    }
    return this;
  };
  return BaseStyleRule2;
}();
var StyleRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(StyleRule2, _BaseStyleRule);
  function StyleRule2(key, style, options2) {
    var _this;
    _this = _BaseStyleRule.call(this, key, style, options2) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options2.selector, scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized2(_assertThisInitialized2(_this)), sheet);
      _this.selectorText = "." + escape2(_this.id);
    }
    return _this;
  }
  var _proto2 = StyleRule2.prototype;
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;
    if (renderer) {
      var json3 = this.toJSON();
      for (var prop in json3) {
        renderer.setProperty(renderable, prop, json3[prop]);
      }
    }
    return this;
  };
  _proto2.toJSON = function toJSON2() {
    var json3 = {};
    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== "object")
        json3[prop] = value;
      else if (Array.isArray(value))
        json3[prop] = toCssValue(value);
    }
    return json3;
  };
  _proto2.toString = function toString(options2) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.selectorText, this.style, opts);
  };
  _createClass(StyleRule2, [{
    key: "selector",
    set: function set6(selector) {
      if (selector === this.selectorText)
        return;
      this.selectorText = selector;
      var renderer = this.renderer, renderable = this.renderable;
      if (!renderable || !renderer)
        return;
      var hasChanged = renderer.setSelector(renderable, selector);
      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    },
    get: function get() {
      return this.selectorText;
    }
  }]);
  return StyleRule2;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name2, style, options2) {
    if (name2[0] === "@" || options2.parent && options2.parent.type === "keyframes") {
      return null;
    }
    return new StyleRule(name2, style, options2);
  }
};
var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
var ConditionalRule = /* @__PURE__ */ function() {
  function ConditionalRule2(key, styles, options2) {
    this.type = "conditional";
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : "unknown";
    this.query = options2.name || "@" + this.at;
    this.options = options2;
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var name2 in styles) {
      this.rules.add(name2, styles[name2]);
    }
    this.rules.process();
  }
  var _proto = ConditionalRule2.prototype;
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.addRule = function addRule(name2, style, options2) {
    var rule = this.rules.add(name2, style, options2);
    if (!rule)
      return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.toString = function toString(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions;
    }
    if (options2.indent == null)
      options2.indent = defaultToStringOptions.indent;
    if (options2.children == null)
      options2.children = defaultToStringOptions.children;
    if (options2.children === false) {
      return this.query + " {}";
    }
    var children = this.rules.toString(options2);
    return children ? this.query + " {\n" + children + "\n}" : "";
  };
  return ConditionalRule2;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule2(key, styles, options2) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options2) : null;
  }
};
var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
var KeyframesRule = /* @__PURE__ */ function() {
  function KeyframesRule2(key, frames, options2) {
    this.type = "keyframes";
    this.at = "@keyframes";
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);
    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = "noname";
      false ? tiny_warning_esm_default(false, "[JSS] Bad keyframes name " + key) : void 0;
    }
    this.key = this.type + "-" + this.name;
    this.options = options2;
    var scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    this.id = scoped === false ? this.name : escape2(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var name2 in frames) {
      this.rules.add(name2, frames[name2], _extends({}, options2, {
        parent: this
      }));
    }
    this.rules.process();
  }
  var _proto = KeyframesRule2.prototype;
  _proto.toString = function toString(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions$1;
    }
    if (options2.indent == null)
      options2.indent = defaultToStringOptions$1.indent;
    if (options2.children == null)
      options2.children = defaultToStringOptions$1.children;
    if (options2.children === false) {
      return this.at + " " + this.id + " {}";
    }
    var children = this.rules.toString(options2);
    if (children)
      children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };
  return KeyframesRule2;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;
var findReferencedKeyframe = function findReferencedKeyframe2(val, keyframes3) {
  if (typeof val === "string") {
    return val.replace(refRegExp, function(match2, name2) {
      if (name2 in keyframes3) {
        return keyframes3[name2];
      }
      false ? tiny_warning_esm_default(false, '[JSS] Referenced keyframes rule "' + name2 + '" is not defined.') : void 0;
      return match2;
    });
  }
  return val;
};
var replaceRef = function replaceRef2(style, prop, keyframes3) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes3);
  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};
var plugin = {
  onCreateRule: function onCreateRule3(key, frames, options2) {
    return typeof key === "string" && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options2) : null;
  },
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== "style" || !sheet)
      return style;
    if ("animation-name" in style)
      replaceRef(style, "animation-name", sheet.keyframes);
    if ("animation" in style)
      replaceRef(style, "animation", sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;
    if (!sheet) {
      return val;
    }
    switch (prop) {
      case "animation":
        return findReferencedKeyframe(val, sheet.keyframes);
      case "animation-name":
        return findReferencedKeyframe(val, sheet.keyframes);
      default:
        return val;
    }
  }
};
var KeyframeRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(KeyframeRule2, _BaseStyleRule);
  function KeyframeRule2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }
  var _proto = KeyframeRule2.prototype;
  _proto.toString = function toString(options2) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.key, this.style, opts);
  };
  return KeyframeRule2;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule4(key, style, options2) {
    if (options2.parent && options2.parent.type === "keyframes") {
      return new KeyframeRule(key, style, options2);
    }
    return null;
  }
};
var FontFaceRule = /* @__PURE__ */ function() {
  function FontFaceRule2(key, style, options2) {
    this.type = "font-face";
    this.at = "@font-face";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options2;
  }
  var _proto = FontFaceRule2.prototype;
  _proto.toString = function toString(options2) {
    if (Array.isArray(this.style)) {
      var str = "";
      for (var index4 = 0; index4 < this.style.length; index4++) {
        str += toCss(this.at, this.style[index4]);
        if (this.style[index4 + 1])
          str += "\n";
      }
      return str;
    }
    return toCss(this.at, this.style, options2);
  };
  return FontFaceRule2;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule5(key, style, options2) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options2) : null;
  }
};
var ViewportRule = /* @__PURE__ */ function() {
  function ViewportRule2(key, style, options2) {
    this.type = "viewport";
    this.at = "@viewport";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options2;
  }
  var _proto = ViewportRule2.prototype;
  _proto.toString = function toString(options2) {
    return toCss(this.key, this.style, options2);
  };
  return ViewportRule2;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule6(key, style, options2) {
    return key === "@viewport" || key === "@-ms-viewport" ? new ViewportRule(key, style, options2) : null;
  }
};
var SimpleRule = /* @__PURE__ */ function() {
  function SimpleRule2(key, value, options2) {
    this.type = "simple";
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options2;
  }
  var _proto = SimpleRule2.prototype;
  _proto.toString = function toString(options2) {
    if (Array.isArray(this.value)) {
      var str = "";
      for (var index4 = 0; index4 < this.value.length; index4++) {
        str += this.key + " " + this.value[index4] + ";";
        if (this.value[index4 + 1])
          str += "\n";
      }
      return str;
    }
    return this.key + " " + this.value + ";";
  };
  return SimpleRule2;
}();
var keysMap = {
  "@charset": true,
  "@import": true,
  "@namespace": true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule7(key, value, options2) {
    return key in keysMap ? new SimpleRule(key, value, options2) : null;
  }
};
var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
};
var RuleList = /* @__PURE__ */ function() {
  function RuleList2(options2) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options2;
    this.classes = options2.classes;
    this.keyframes = options2.keyframes;
  }
  var _proto = RuleList2.prototype;
  _proto.add = function add2(name2, decl, ruleOptions) {
    var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss3 = _this$options.jss, Renderer2 = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;
    var options2 = _extends({
      classes: this.classes,
      parent,
      sheet,
      jss: jss3,
      Renderer: Renderer2,
      generateId,
      scoped,
      name: name2,
      keyframes: this.keyframes,
      selector: void 0
    }, ruleOptions);
    var key = name2;
    if (name2 in this.raw) {
      key = name2 + "-d" + this.counter++;
    }
    this.raw[key] = decl;
    if (key in this.classes) {
      options2.selector = "." + escape2(this.classes[key]);
    }
    var rule = createRule(key, decl, options2);
    if (!rule)
      return null;
    this.register(rule);
    var index4 = options2.index === void 0 ? this.index.length : options2.index;
    this.index.splice(index4, 0, rule);
    return rule;
  };
  _proto.get = function get(name2) {
    return this.map[name2];
  };
  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  };
  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  };
  _proto.process = function process2() {
    var plugins3 = this.options.jss.plugins;
    this.index.slice(0).forEach(plugins3.onProcessRule, plugins3);
  };
  _proto.register = function register(rule) {
    this.map[rule.key] = rule;
    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id)
        this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  };
  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];
    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  };
  _proto.update = function update() {
    var name2;
    var data3;
    var options2;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "string") {
      name2 = arguments.length <= 0 ? void 0 : arguments[0];
      data3 = arguments.length <= 1 ? void 0 : arguments[1];
      options2 = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      data3 = arguments.length <= 0 ? void 0 : arguments[0];
      options2 = arguments.length <= 1 ? void 0 : arguments[1];
      name2 = null;
    }
    if (name2) {
      this.updateOne(this.map[name2], data3, options2);
    } else {
      for (var index4 = 0; index4 < this.index.length; index4++) {
        this.updateOne(this.index[index4], data3, options2);
      }
    }
  };
  _proto.updateOne = function updateOne(rule, data3, options2) {
    if (options2 === void 0) {
      options2 = defaultUpdateOptions;
    }
    var _this$options2 = this.options, plugins3 = _this$options2.jss.plugins, sheet = _this$options2.sheet;
    if (rule.rules instanceof RuleList2) {
      rule.rules.update(data3, options2);
      return;
    }
    var styleRule = rule;
    var style = styleRule.style;
    plugins3.onUpdate(data3, rule, sheet, options2);
    if (options2.process && style && style !== styleRule.style) {
      plugins3.onProcessStyle(styleRule.style, styleRule, sheet);
      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop];
        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      }
      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop];
        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  };
  _proto.toString = function toString(options2) {
    var str = "";
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    for (var index4 = 0; index4 < this.index.length; index4++) {
      var rule = this.index[index4];
      var css7 = rule.toString(options2);
      if (!css7 && !link)
        continue;
      if (str)
        str += "\n";
      str += css7;
    }
    return str;
  };
  return RuleList2;
}();
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet3(styles, options2) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options2, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });
    if (options2.Renderer) {
      this.renderer = new options2.Renderer(this);
    }
    this.rules = new RuleList(this.options);
    for (var name2 in styles) {
      this.rules.add(name2, styles[name2]);
    }
    this.rules.process();
  }
  var _proto = StyleSheet3.prototype;
  _proto.attach = function attach() {
    if (this.attached)
      return this;
    if (this.renderer)
      this.renderer.attach();
    this.attached = true;
    if (!this.deployed)
      this.deploy();
    return this;
  };
  _proto.detach = function detach() {
    if (!this.attached)
      return this;
    if (this.renderer)
      this.renderer.detach();
    this.attached = false;
    return this;
  };
  _proto.addRule = function addRule(name2, decl, options2) {
    var queue = this.queue;
    if (this.attached && !queue)
      this.queue = [];
    var rule = this.rules.add(name2, decl, options2);
    if (!rule)
      return null;
    this.options.jss.plugins.onProcessRule(rule);
    if (this.attached) {
      if (!this.deployed)
        return rule;
      if (queue)
        queue.push(rule);
      else {
        this.insertRule(rule);
        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = void 0;
        }
      }
      return rule;
    }
    this.deployed = false;
    return rule;
  };
  _proto.insertRule = function insertRule2(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  };
  _proto.addRules = function addRules(styles, options2) {
    var added = [];
    for (var name2 in styles) {
      var rule = this.addRule(name2, styles[name2], options2);
      if (rule)
        added.push(rule);
    }
    return added;
  };
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.deleteRule = function deleteRule(name2) {
    var rule = typeof name2 === "object" ? name2 : this.rules.get(name2);
    if (!rule || this.attached && !rule.renderable) {
      return false;
    }
    this.rules.remove(rule);
    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }
    return true;
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.deploy = function deploy() {
    if (this.renderer)
      this.renderer.deploy();
    this.deployed = true;
    return this;
  };
  _proto.update = function update() {
    var _this$rules;
    (_this$rules = this.rules).update.apply(_this$rules, arguments);
    return this;
  };
  _proto.updateOne = function updateOne(rule, data3, options2) {
    this.rules.updateOne(rule, data3, options2);
    return this;
  };
  _proto.toString = function toString(options2) {
    return this.rules.toString(options2);
  };
  return StyleSheet3;
}();
var PluginsRegistry = /* @__PURE__ */ function() {
  function PluginsRegistry2() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }
  var _proto = PluginsRegistry2.prototype;
  _proto.onCreateRule = function onCreateRule8(name2, decl, options2) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name2, decl, options2);
      if (rule)
        return rule;
    }
    return null;
  };
  _proto.onProcessRule = function onProcessRule3(rule) {
    if (rule.isProcessed)
      return;
    var sheet = rule.options.sheet;
    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }
    if (rule.style)
      this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  };
  _proto.onProcessStyle = function onProcessStyle2(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  };
  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  };
  _proto.onUpdate = function onUpdate(data3, rule, sheet, options2) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data3, rule, sheet, options2);
    }
  };
  _proto.onChangeValue = function onChangeValue2(value, prop, rule) {
    var processedValue = value;
    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }
    return processedValue;
  };
  _proto.use = function use(newPlugin, options2) {
    if (options2 === void 0) {
      options2 = {
        queue: "external"
      };
    }
    var plugins3 = this.plugins[options2.queue];
    if (plugins3.indexOf(newPlugin) !== -1) {
      return;
    }
    plugins3.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry2, plugin2) {
      for (var name2 in plugin2) {
        if (name2 in registry2) {
          registry2[name2].push(plugin2[name2]);
        } else {
          false ? tiny_warning_esm_default(false, '[JSS] Unknown hook "' + name2 + '".') : void 0;
        }
      }
      return registry2;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };
  return PluginsRegistry2;
}();
var SheetsRegistry = /* @__PURE__ */ function() {
  function SheetsRegistry2() {
    this.registry = [];
  }
  var _proto = SheetsRegistry2.prototype;
  _proto.add = function add2(sheet) {
    var registry2 = this.registry;
    var index4 = sheet.options.index;
    if (registry2.indexOf(sheet) !== -1)
      return;
    if (registry2.length === 0 || index4 >= this.index) {
      registry2.push(sheet);
      return;
    }
    for (var i = 0; i < registry2.length; i++) {
      if (registry2[i].options.index > index4) {
        registry2.splice(i, 0, sheet);
        return;
      }
    }
  };
  _proto.reset = function reset() {
    this.registry = [];
  };
  _proto.remove = function remove(sheet) {
    var index4 = this.registry.indexOf(sheet);
    this.registry.splice(index4, 1);
  };
  _proto.toString = function toString(_temp) {
    var _ref3 = _temp === void 0 ? {} : _temp, attached = _ref3.attached, options2 = _objectWithoutPropertiesLoose(_ref3, ["attached"]);
    var css7 = "";
    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];
      if (attached != null && sheet.attached !== attached) {
        continue;
      }
      if (css7)
        css7 += "\n";
      css7 += sheet.toString(options2);
    }
    return css7;
  };
  _createClass(SheetsRegistry2, [{
    key: "index",
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);
  return SheetsRegistry2;
}();
var registry = new SheetsRegistry();
var globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
var ns = "2f1acc6c3a606b082e5eef5e54414ffb";
if (globalThis$1[ns] == null)
  globalThis$1[ns] = 0;
var moduleId = globalThis$1[ns]++;
var maxRules = 1e10;
var createGenerateId = function createGenerateId2(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var ruleCounter = 0;
  return function(rule, sheet) {
    ruleCounter += 1;
    if (ruleCounter > maxRules) {
      false ? tiny_warning_esm_default(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : void 0;
    }
    var jssId = "";
    var prefix3 = "";
    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix3 = sheet.options.classNamePrefix;
      }
      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }
    if (options2.minify) {
      return "" + (prefix3 || "c") + moduleId + jssId + ruleCounter;
    }
    return prefix3 + rule.key + "-" + moduleId + (jssId ? "-" + jssId : "") + "-" + ruleCounter;
  };
};
var memoize = function memoize2(fn) {
  var value;
  return function() {
    if (!value)
      value = fn();
    return value;
  };
};
var getPropertyValue = function getPropertyValue2(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    return "";
  }
};
var setProperty = function setProperty2(cssRule, prop, value) {
  try {
    var cssValue = value;
    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);
      if (value[value.length - 1] === "!important") {
        cssRule.style.setProperty(prop, cssValue, "important");
        return true;
      }
    }
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    return false;
  }
  return true;
};
var removeProperty = function removeProperty2(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    false ? tiny_warning_esm_default(false, '[JSS] DOMException "' + err.message + '" was thrown. Tried to remove property "' + prop + '".') : void 0;
  }
};
var setSelector = function setSelector2(cssRule, selectorText) {
  cssRule.selectorText = selectorText;
  return cssRule.selectorText === selectorText;
};
var getHead = memoize(function() {
  return document.querySelector("head");
});
function findHigherSheet(registry2, options2) {
  for (var i = 0; i < registry2.length; i++) {
    var sheet = registry2[i];
    if (sheet.attached && sheet.options.index > options2.index && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findHighestSheet(registry2, options2) {
  for (var i = registry2.length - 1; i >= 0; i--) {
    var sheet = registry2[i];
    if (sheet.attached && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findCommentNode(text) {
  var head = getHead();
  for (var i = 0; i < head.childNodes.length; i++) {
    var node2 = head.childNodes[i];
    if (node2.nodeType === 8 && node2.nodeValue.trim() === text) {
      return node2;
    }
  }
  return null;
}
function findPrevNode(options2) {
  var registry$1 = registry.registry;
  if (registry$1.length > 0) {
    var sheet = findHigherSheet(registry$1, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    }
    sheet = findHighestSheet(registry$1, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  }
  var insertionPoint = options2.insertionPoint;
  if (insertionPoint && typeof insertionPoint === "string") {
    var comment2 = findCommentNode(insertionPoint);
    if (comment2) {
      return {
        parent: comment2.parentNode,
        node: comment2.nextSibling
      };
    }
    false ? tiny_warning_esm_default(false, '[JSS] Insertion point "' + insertionPoint + '" not found.') : void 0;
  }
  return false;
}
function insertStyle(style, options2) {
  var insertionPoint = options2.insertionPoint;
  var nextNode = findPrevNode(options2);
  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  }
  if (insertionPoint && typeof insertionPoint.nodeType === "number") {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode)
      parentNode.insertBefore(style, insertionPointElement.nextSibling);
    else
      false ? tiny_warning_esm_default(false, "[JSS] Insertion point is not in the DOM.") : void 0;
    return;
  }
  getHead().appendChild(style);
}
var getNonce = memoize(function() {
  var node2 = document.querySelector('meta[property="csp-nonce"]');
  return node2 ? node2.getAttribute("content") : null;
});
var _insertRule = function insertRule(container, rule, index4) {
  try {
    if ("insertRule" in container) {
      var c = container;
      c.insertRule(rule, index4);
    } else if ("appendRule" in container) {
      var _c = container;
      _c.appendRule(rule);
    }
  } catch (err) {
    false ? tiny_warning_esm_default(false, "[JSS] " + err.message) : void 0;
    return false;
  }
  return container.cssRules[index4];
};
var getValidRuleInsertionIndex = function getValidRuleInsertionIndex2(container, index4) {
  var maxIndex = container.cssRules.length;
  if (index4 === void 0 || index4 > maxIndex) {
    return maxIndex;
  }
  return index4;
};
var createStyle = function createStyle2() {
  var el2 = document.createElement("style");
  el2.textContent = "\n";
  return el2;
};
var DomRenderer = /* @__PURE__ */ function() {
  function DomRenderer2(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    this.cssRules = [];
    if (sheet)
      registry.add(sheet);
    this.sheet = sheet;
    var _ref3 = this.sheet ? this.sheet.options : {}, media = _ref3.media, meta = _ref3.meta, element = _ref3.element;
    this.element = element || createStyle();
    this.element.setAttribute("data-jss", "");
    if (media)
      this.element.setAttribute("media", media);
    if (meta)
      this.element.setAttribute("data-meta", meta);
    var nonce = getNonce();
    if (nonce)
      this.element.setAttribute("nonce", nonce);
  }
  var _proto = DomRenderer2.prototype;
  _proto.attach = function attach() {
    if (this.element.parentNode || !this.sheet)
      return;
    insertStyle(this.element, this.sheet.options);
    var deployed = Boolean(this.sheet && this.sheet.deployed);
    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  };
  _proto.detach = function detach() {
    if (!this.sheet)
      return;
    var parentNode = this.element.parentNode;
    if (parentNode)
      parentNode.removeChild(this.element);
    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = "\n";
    }
  };
  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet)
      return;
    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }
    this.element.textContent = "\n" + sheet.toString() + "\n";
  };
  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  };
  _proto.insertRule = function insertRule2(rule, index4, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }
    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;
      if (rule.type === "conditional" || rule.type === "keyframes") {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index4);
        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);
        if (latestNativeParent === false) {
          return false;
        }
        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }
      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }
    var ruleStr = rule.toString();
    if (!ruleStr)
      return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index4);
    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);
    if (nativeRule === false) {
      return false;
    }
    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };
  _proto.refCssRule = function refCssRule(rule, index4, cssRule) {
    rule.renderable = cssRule;
    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules[index4] = cssRule;
    }
  };
  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index4 = this.indexOf(cssRule);
    if (index4 === -1)
      return false;
    sheet.deleteRule(index4);
    this.cssRules.splice(index4, 1);
    return true;
  };
  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  };
  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index4 = this.indexOf(cssRule);
    if (index4 === -1)
      return false;
    this.element.sheet.deleteRule(index4);
    this.cssRules.splice(index4, 1);
    return this.insertRule(rule, index4);
  };
  _proto.getRules = function getRules3() {
    return this.element.sheet.cssRules;
  };
  return DomRenderer2;
}();
var instanceCounter = 0;
var Jss = /* @__PURE__ */ function() {
  function Jss2(options2) {
    this.id = instanceCounter++;
    this.version = "10.6.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId,
      Renderer: module_default ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });
    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: "internal"
      });
    }
    this.setup(options2);
  }
  var _proto = Jss2.prototype;
  _proto.setup = function setup(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.createGenerateId) {
      this.options.createGenerateId = options2.createGenerateId;
    }
    if (options2.id) {
      this.options.id = _extends({}, this.options.id, options2.id);
    }
    if (options2.createGenerateId || options2.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }
    if (options2.insertionPoint != null)
      this.options.insertionPoint = options2.insertionPoint;
    if ("Renderer" in options2) {
      this.options.Renderer = options2.Renderer;
    }
    if (options2.plugins)
      this.use.apply(this, options2.plugins);
    return this;
  };
  _proto.createStyleSheet = function createStyleSheet3(styles, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, index4 = _options.index;
    if (typeof index4 !== "number") {
      index4 = registry.index === 0 ? 0 : registry.index + 1;
    }
    var sheet = new StyleSheet(styles, _extends({}, options2, {
      jss: this,
      generateId: options2.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index4
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  };
  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    registry.remove(sheet);
    return this;
  };
  _proto.createRule = function createRule$1(name2, style, options2) {
    if (style === void 0) {
      style = {};
    }
    if (options2 === void 0) {
      options2 = {};
    }
    if (typeof name2 === "object") {
      return this.createRule(void 0, name2, style);
    }
    var ruleOptions = _extends({}, options2, {
      name: name2,
      jss: this,
      Renderer: this.options.Renderer
    });
    if (!ruleOptions.generateId)
      ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes)
      ruleOptions.classes = {};
    if (!ruleOptions.keyframes)
      ruleOptions.keyframes = {};
    var rule = createRule(name2, style, ruleOptions);
    if (rule)
      this.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.use = function use() {
    var _this = this;
    for (var _len = arguments.length, plugins3 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins3[_key] = arguments[_key];
    }
    plugins3.forEach(function(plugin2) {
      _this.plugins.use(plugin2);
    });
    return this;
  };
  return Jss2;
}();
function getDynamicStyles(styles) {
  var to = null;
  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;
    if (type === "function") {
      if (!to)
        to = {};
      to[key] = value;
    } else if (type === "object" && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);
      if (extracted) {
        if (!to)
          to = {};
        to[key] = extracted;
      }
    }
  }
  return to;
}
var SheetsManager = /* @__PURE__ */ function() {
  function SheetsManager2() {
    this.length = 0;
    this.sheets = new WeakMap();
  }
  var _proto = SheetsManager2.prototype;
  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };
  _proto.add = function add2(key, sheet) {
    if (this.sheets.has(key))
      return;
    this.length++;
    this.sheets.set(key, {
      sheet,
      refs: 0
    });
  };
  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);
    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }
      entry.refs++;
      return entry.sheet;
    }
    tiny_warning_esm_default(false, "[JSS] SheetsManager: can't find sheet to manage");
    return void 0;
  };
  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);
    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0)
          entry.sheet.detach();
      }
    } else {
      tiny_warning_esm_default(false, "SheetsManager: can't find sheet to unmanage");
    }
  };
  _createClass(SheetsManager2, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);
  return SheetsManager2;
}();
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var hasCSSTOMSupport = typeof CSS === "object" && CSS != null && "number" in CSS;
var create = function create2(options2) {
  return new Jss(options2);
};
var jss = create();
var jss_esm_default = jss;

// node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js
var now2 = Date.now();
var fnValuesNs = "fnValues" + now2;
var fnRuleNs = "fnStyle" + ++now2;
var functionPlugin = function functionPlugin2() {
  return {
    onCreateRule: function onCreateRule8(name2, decl, options2) {
      if (typeof decl !== "function")
        return null;
      var rule = createRule(name2, {}, options2);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle2(style, rule) {
      if (fnValuesNs in rule || fnRuleNs in rule)
        return style;
      var fnValues = {};
      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== "function")
          continue;
        delete style[prop];
        fnValues[prop] = value;
      }
      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data3, rule, sheet, options2) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs];
      if (fnRule) {
        styleRule.style = fnRule(data3) || {};
        if (false) {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === "function") {
              false ? tiny_warning_esm_default(false, "[JSS] Function values inside function rules are not supported.") : void 0;
              break;
            }
          }
        }
      }
      var fnValues = styleRule[fnValuesNs];
      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data3), options2);
        }
      }
    }
  };
};
var jss_plugin_rule_value_function_esm_default = functionPlugin;

// node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root) {
  var result;
  var Symbol2 = root.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      result = Symbol2("observable");
      Symbol2.observable = result;
    }
  } else {
    result = "@@observable";
  }
  return result;
}

// node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js
var import_symbol_observable = __toModule(require_es());
var isObservable = function isObservable2(value) {
  return value && value[import_symbol_observable.default] && value === value[import_symbol_observable.default]();
};
var observablePlugin = function observablePlugin2(updateOptions) {
  return {
    onCreateRule: function onCreateRule8(name2, decl, options2) {
      if (!isObservable(decl))
        return null;
      var style$ = decl;
      var rule = createRule(name2, {}, options2);
      style$.subscribe(function(style) {
        for (var prop in style) {
          rule.prop(prop, style[prop], updateOptions);
        }
      });
      return rule;
    },
    onProcessRule: function onProcessRule3(rule) {
      if (rule && rule.type !== "style")
        return;
      var styleRule = rule;
      var style = styleRule.style;
      var _loop = function _loop2(prop2) {
        var value = style[prop2];
        if (!isObservable(value))
          return "continue";
        delete style[prop2];
        value.subscribe({
          next: function next3(nextValue) {
            styleRule.prop(prop2, nextValue, updateOptions);
          }
        });
      };
      for (var prop in style) {
        var _ret = _loop(prop);
        if (_ret === "continue")
          continue;
      }
    }
  };
};
var jss_plugin_rule_value_observable_esm_default = observablePlugin;

// node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js
var semiWithNl = /;\n/;
var parse = function parse2(cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);
  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || "").trim();
    if (!decl)
      continue;
    var colonIndex = decl.indexOf(":");
    if (colonIndex === -1) {
      false ? tiny_warning_esm_default(false, '[JSS] Malformed CSS string "' + decl + '"') : void 0;
      continue;
    }
    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }
  return style;
};
var onProcessRule = function onProcessRule2(rule) {
  if (typeof rule.style === "string") {
    rule.style = parse(rule.style);
  }
};
function templatePlugin() {
  return {
    onProcessRule
  };
}
var jss_plugin_template_esm_default = templatePlugin;

// node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js
var at = "@global";
var atPrefix = "@global ";
var GlobalContainerRule = /* @__PURE__ */ function() {
  function GlobalContainerRule2(key, styles, options2) {
    this.type = "global";
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options2;
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }
    this.rules.process();
  }
  var _proto = GlobalContainerRule2.prototype;
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.addRule = function addRule(name2, style, options2) {
    var rule = this.rules.add(name2, style, options2);
    if (rule)
      this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.toString = function toString() {
    return this.rules.toString();
  };
  return GlobalContainerRule2;
}();
var GlobalPrefixedRule = /* @__PURE__ */ function() {
  function GlobalPrefixedRule2(key, style, options2) {
    this.type = "global";
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options2;
    var selector = key.substr(atPrefix.length);
    this.rule = options2.jss.createRule(selector, style, _extends({}, options2, {
      parent: this
    }));
  }
  var _proto2 = GlobalPrefixedRule2.prototype;
  _proto2.toString = function toString(options2) {
    return this.rule ? this.rule.toString(options2) : "";
  };
  return GlobalPrefixedRule2;
}();
var separatorRegExp = /\s*,\s*/g;
function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = "";
  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1])
      scoped += ", ";
  }
  return scoped;
}
function handleNestedGlobalContainerRule(rule, sheet) {
  var options2 = rule.options, style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules)
    return;
  for (var name2 in rules) {
    sheet.addRule(name2, rules[name2], _extends({}, options2, {
      selector: addScope(name2, rule.selector)
    }));
  }
  delete style[at];
}
function handlePrefixedGlobalRule(rule, sheet) {
  var options2 = rule.options, style = rule.style;
  for (var prop in style) {
    if (prop[0] !== "@" || prop.substr(0, at.length) !== at)
      continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], _extends({}, options2, {
      selector
    }));
    delete style[prop];
  }
}
function jssGlobal() {
  function onCreateRule8(name2, styles, options2) {
    if (!name2)
      return null;
    if (name2 === at) {
      return new GlobalContainerRule(name2, styles, options2);
    }
    if (name2[0] === "@" && name2.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name2, styles, options2);
    }
    var parent = options2.parent;
    if (parent) {
      if (parent.type === "global" || parent.options.parent && parent.options.parent.type === "global") {
        options2.scoped = false;
      }
    }
    if (options2.scoped === false) {
      options2.selector = name2;
    }
    return null;
  }
  function onProcessRule3(rule, sheet) {
    if (rule.type !== "style" || !sheet)
      return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }
  return {
    onCreateRule: onCreateRule8,
    onProcessRule: onProcessRule3
  };
}
var jss_plugin_global_esm_default = jssGlobal;

// node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js
var isObject = function isObject2(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
};
var valueNs = "extendCurrValue" + Date.now();
function mergeExtend(style, rule, sheet, newStyle) {
  var extendType = typeof style.extend;
  if (extendType === "string") {
    if (!sheet)
      return;
    var refRule = sheet.getRule(style.extend);
    if (!refRule)
      return;
    if (refRule === rule) {
      false ? tiny_warning_esm_default(false, "[JSS] A rule tries to extend itself \n" + rule.toString()) : void 0;
      return;
    }
    var parent = refRule.options.parent;
    if (parent) {
      var originalStyle = parent.rules.raw[style.extend];
      extend(originalStyle, rule, sheet, newStyle);
    }
    return;
  }
  if (Array.isArray(style.extend)) {
    for (var index4 = 0; index4 < style.extend.length; index4++) {
      var singleExtend = style.extend[index4];
      var singleStyle = typeof singleExtend === "string" ? _extends({}, style, {
        extend: singleExtend
      }) : style.extend[index4];
      extend(singleStyle, rule, sheet, newStyle);
    }
    return;
  }
  for (var prop in style.extend) {
    if (prop === "extend") {
      extend(style.extend.extend, rule, sheet, newStyle);
      continue;
    }
    if (isObject(style.extend[prop])) {
      if (!(prop in newStyle))
        newStyle[prop] = {};
      extend(style.extend[prop], rule, sheet, newStyle[prop]);
      continue;
    }
    newStyle[prop] = style.extend[prop];
  }
}
function mergeRest(style, rule, sheet, newStyle) {
  for (var prop in style) {
    if (prop === "extend")
      continue;
    if (isObject(newStyle[prop]) && isObject(style[prop])) {
      extend(style[prop], rule, sheet, newStyle[prop]);
      continue;
    }
    if (isObject(style[prop])) {
      newStyle[prop] = extend(style[prop], rule, sheet);
      continue;
    }
    newStyle[prop] = style[prop];
  }
}
function extend(style, rule, sheet, newStyle) {
  if (newStyle === void 0) {
    newStyle = {};
  }
  mergeExtend(style, rule, sheet, newStyle);
  mergeRest(style, rule, sheet, newStyle);
  return newStyle;
}
function jssExtend() {
  function onProcessStyle2(style, rule, sheet) {
    if ("extend" in style)
      return extend(style, rule, sheet);
    return style;
  }
  function onChangeValue2(value, prop, rule) {
    if (prop !== "extend")
      return value;
    if (value == null || value === false) {
      for (var key in rule[valueNs]) {
        rule.prop(key, null);
      }
      rule[valueNs] = null;
      return null;
    }
    if (typeof value === "object") {
      for (var _key in value) {
        rule.prop(_key, value[_key]);
      }
      rule[valueNs] = value;
    }
    return null;
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_extend_esm_default = jssExtend;

// node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js
var separatorRegExp2 = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp2 = /\$([\w-]+)/g;
function jssNested() {
  function getReplaceRef(container, sheet) {
    return function(match2, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);
      if (rule) {
        rule = rule;
        return rule.selector;
      }
      false ? tiny_warning_esm_default(false, '[JSS] Could not find the referenced rule "' + key + '" in "' + (container.options.meta || container.toString()) + '".') : void 0;
      return key;
    };
  }
  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp2);
    var nestedSelectors = nestedProp.split(separatorRegExp2);
    var result = "";
    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];
      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result)
          result += ", ";
        result += nested.indexOf("&") !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }
    return result;
  }
  function getOptions(rule, container, prevOptions) {
    if (prevOptions)
      return _extends({}, prevOptions, {
        index: prevOptions.index + 1
      });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === void 0 ? 1 : nestingLevel + 1;
    var options2 = _extends({}, rule.options, {
      nestingLevel,
      index: container.indexOf(rule) + 1
    });
    delete options2.name;
    return options2;
  }
  function onProcessStyle2(style, rule, sheet) {
    if (rule.type !== "style")
      return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options2;
    var replaceRef3;
    for (var prop in style) {
      var isNested = prop.indexOf("&") !== -1;
      var isNestedConditional = prop[0] === "@";
      if (!isNested && !isNestedConditional)
        continue;
      options2 = getOptions(styleRule, container, options2);
      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector);
        if (!replaceRef3)
          replaceRef3 = getReplaceRef(container, sheet);
        selector = selector.replace(refRegExp2, replaceRef3);
        container.addRule(selector, style[prop], _extends({}, options2, {
          selector
        }));
      } else if (isNestedConditional) {
        container.addRule(prop, {}, options2).addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }
      delete style[prop];
    }
    return style;
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_nested_esm_default = jssNested;

// node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js
function registerClass(rule, className) {
  if (!className)
    return true;
  if (Array.isArray(className)) {
    for (var index4 = 0; index4 < className.length; index4++) {
      var isSetted = registerClass(rule, className[index4]);
      if (!isSetted)
        return false;
    }
    return true;
  }
  if (className.indexOf(" ") > -1) {
    return registerClass(rule, className.split(" "));
  }
  var _ref3 = rule.options, parent = _ref3.parent;
  if (className[0] === "$") {
    var refRule = parent.getRule(className.substr(1));
    if (!refRule) {
      false ? tiny_warning_esm_default(false, "[JSS] Referenced rule is not defined. \n" + rule.toString()) : void 0;
      return false;
    }
    if (refRule === rule) {
      false ? tiny_warning_esm_default(false, "[JSS] Cyclic composition detected. \n" + rule.toString()) : void 0;
      return false;
    }
    parent.classes[rule.key] += " " + parent.classes[refRule.key];
    return true;
  }
  parent.classes[rule.key] += " " + className;
  return true;
}
function jssCompose() {
  function onProcessStyle2(style, rule) {
    if (!("composes" in style))
      return style;
    registerClass(rule, style.composes);
    delete style.composes;
    return style;
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_compose_esm_default = jssCompose;

// node_modules/hyphenate-style-name/index.js
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};
function toHyphenLower(match2) {
  return "-" + match2.toLowerCase();
}
function hyphenateStyleName(name2) {
  if (cache.hasOwnProperty(name2)) {
    return cache[name2];
  }
  var hName = name2.replace(uppercasePattern, toHyphenLower);
  return cache[name2] = msPattern.test(hName) ? "-" + hName : hName;
}
var hyphenate_style_name_default = hyphenateStyleName;

// node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js
function convertCase(style) {
  var converted = {};
  for (var prop in style) {
    var key = prop.indexOf("--") === 0 ? prop : hyphenate_style_name_default(prop);
    converted[key] = style[prop];
  }
  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks))
      converted.fallbacks = style.fallbacks.map(convertCase);
    else
      converted.fallbacks = convertCase(style.fallbacks);
  }
  return converted;
}
function camelCase() {
  function onProcessStyle2(style) {
    if (Array.isArray(style)) {
      for (var index4 = 0; index4 < style.length; index4++) {
        style[index4] = convertCase(style[index4]);
      }
      return style;
    }
    return convertCase(style);
  }
  function onChangeValue2(value, prop, rule) {
    if (prop.indexOf("--") === 0) {
      return value;
    }
    var hyphenatedProp = hyphenate_style_name_default(prop);
    if (prop === hyphenatedProp)
      return value;
    rule.prop(hyphenatedProp, value);
    return null;
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_camel_case_esm_default = camelCase;

// node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js
var px2 = hasCSSTOMSupport && CSS ? CSS.px : "px";
var ms = hasCSSTOMSupport && CSS ? CSS.ms : "ms";
var percent = hasCSSTOMSupport && CSS ? CSS.percent : "%";
var defaultUnits = {
  "animation-delay": ms,
  "animation-duration": ms,
  "background-position": px2,
  "background-position-x": px2,
  "background-position-y": px2,
  "background-size": px2,
  border: px2,
  "border-bottom": px2,
  "border-bottom-left-radius": px2,
  "border-bottom-right-radius": px2,
  "border-bottom-width": px2,
  "border-left": px2,
  "border-left-width": px2,
  "border-radius": px2,
  "border-right": px2,
  "border-right-width": px2,
  "border-top": px2,
  "border-top-left-radius": px2,
  "border-top-right-radius": px2,
  "border-top-width": px2,
  "border-width": px2,
  "border-block": px2,
  "border-block-end": px2,
  "border-block-end-width": px2,
  "border-block-start": px2,
  "border-block-start-width": px2,
  "border-block-width": px2,
  "border-inline": px2,
  "border-inline-end": px2,
  "border-inline-end-width": px2,
  "border-inline-start": px2,
  "border-inline-start-width": px2,
  "border-inline-width": px2,
  "border-start-start-radius": px2,
  "border-start-end-radius": px2,
  "border-end-start-radius": px2,
  "border-end-end-radius": px2,
  margin: px2,
  "margin-bottom": px2,
  "margin-left": px2,
  "margin-right": px2,
  "margin-top": px2,
  "margin-block": px2,
  "margin-block-end": px2,
  "margin-block-start": px2,
  "margin-inline": px2,
  "margin-inline-end": px2,
  "margin-inline-start": px2,
  padding: px2,
  "padding-bottom": px2,
  "padding-left": px2,
  "padding-right": px2,
  "padding-top": px2,
  "padding-block": px2,
  "padding-block-end": px2,
  "padding-block-start": px2,
  "padding-inline": px2,
  "padding-inline-end": px2,
  "padding-inline-start": px2,
  "mask-position-x": px2,
  "mask-position-y": px2,
  "mask-size": px2,
  height: px2,
  width: px2,
  "min-height": px2,
  "max-height": px2,
  "min-width": px2,
  "max-width": px2,
  bottom: px2,
  left: px2,
  top: px2,
  right: px2,
  inset: px2,
  "inset-block": px2,
  "inset-block-end": px2,
  "inset-block-start": px2,
  "inset-inline": px2,
  "inset-inline-end": px2,
  "inset-inline-start": px2,
  "box-shadow": px2,
  "text-shadow": px2,
  "column-gap": px2,
  "column-rule": px2,
  "column-rule-width": px2,
  "column-width": px2,
  "font-size": px2,
  "font-size-delta": px2,
  "letter-spacing": px2,
  "text-decoration-thickness": px2,
  "text-indent": px2,
  "text-stroke": px2,
  "text-stroke-width": px2,
  "word-spacing": px2,
  motion: px2,
  "motion-offset": px2,
  outline: px2,
  "outline-offset": px2,
  "outline-width": px2,
  perspective: px2,
  "perspective-origin-x": percent,
  "perspective-origin-y": percent,
  "transform-origin": percent,
  "transform-origin-x": percent,
  "transform-origin-y": percent,
  "transform-origin-z": percent,
  "transition-delay": ms,
  "transition-duration": ms,
  "vertical-align": px2,
  "flex-basis": px2,
  "shape-margin": px2,
  size: px2,
  gap: px2,
  grid: px2,
  "grid-gap": px2,
  "row-gap": px2,
  "grid-row-gap": px2,
  "grid-column-gap": px2,
  "grid-template-rows": px2,
  "grid-template-columns": px2,
  "grid-auto-rows": px2,
  "grid-auto-columns": px2,
  "box-shadow-x": px2,
  "box-shadow-y": px2,
  "box-shadow-blur": px2,
  "box-shadow-spread": px2,
  "font-line-height": px2,
  "text-shadow-x": px2,
  "text-shadow-y": px2,
  "text-shadow-blur": px2
};
function addCamelCasedVersion(obj) {
  var regExp2 = /(-[a-z])/g;
  var replace2 = function replace3(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp2, replace2)] = obj[_key];
  }
  return newObj;
}
var units = addCamelCasedVersion(defaultUnits);
function iterate(prop, value, options2) {
  if (value == null)
    return value;
  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options2);
    }
  } else if (typeof value === "object") {
    if (prop === "fallbacks") {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options2);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options2);
      }
    }
  } else if (typeof value === "number" && isNaN(value) === false) {
    var unit = options2[prop] || units[prop];
    if (unit && !(value === 0 && unit === px2)) {
      return typeof unit === "function" ? unit(value).toString() : "" + value + unit;
    }
    return value.toString();
  }
  return value;
}
function defaultUnit(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var camelCasedOptions = addCamelCasedVersion(options2);
  function onProcessStyle2(style, rule) {
    if (rule.type !== "style")
      return style;
    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }
    return style;
  }
  function onChangeValue2(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_default_unit_esm_default = defaultUnit;

// node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js
var propArray = {
  "background-size": true,
  "background-position": true,
  border: true,
  "border-bottom": true,
  "border-left": true,
  "border-top": true,
  "border-right": true,
  "border-radius": true,
  "border-image": true,
  "border-width": true,
  "border-style": true,
  "border-color": true,
  "box-shadow": true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  "transform-origin": true,
  transform: true,
  transition: true
};
var propArrayInObj = {
  position: true,
  size: true
};
var propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  "border-top": {
    width: null,
    style: null,
    color: null
  },
  "border-right": {
    width: null,
    style: null,
    color: null
  },
  "border-bottom": {
    width: null,
    style: null,
    color: null
  },
  "border-left": {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  "list-style": {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    "timing-function": null,
    timingFunction: null,
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    "timing-function": null,
    timingFunction: null,
    delay: null,
    "iteration-count": null,
    iterationCount: null,
    direction: null,
    "fill-mode": null,
    fillMode: null,
    "play-state": null,
    playState: null
  },
  "box-shadow": {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  "text-shadow": {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }
};
var customPropObj = {
  border: {
    radius: "border-radius",
    image: "border-image",
    width: "border-width",
    style: "border-style",
    color: "border-color"
  },
  "border-bottom": {
    width: "border-bottom-width",
    style: "border-bottom-style",
    color: "border-bottom-color"
  },
  "border-top": {
    width: "border-top-width",
    style: "border-top-style",
    color: "border-top-color"
  },
  "border-left": {
    width: "border-left-width",
    style: "border-left-style",
    color: "border-left-color"
  },
  "border-right": {
    width: "border-right-width",
    style: "border-right-style",
    color: "border-right-color"
  },
  background: {
    size: "background-size",
    image: "background-image"
  },
  font: {
    style: "font-style",
    variant: "font-variant",
    weight: "font-weight",
    stretch: "font-stretch",
    size: "font-size",
    family: "font-family",
    lineHeight: "line-height",
    "line-height": "line-height"
  },
  flex: {
    grow: "flex-grow",
    basis: "flex-basis",
    direction: "flex-direction",
    wrap: "flex-wrap",
    flow: "flex-flow",
    shrink: "flex-shrink"
  },
  align: {
    self: "align-self",
    items: "align-items",
    content: "align-content"
  },
  grid: {
    "template-columns": "grid-template-columns",
    templateColumns: "grid-template-columns",
    "template-rows": "grid-template-rows",
    templateRows: "grid-template-rows",
    "template-areas": "grid-template-areas",
    templateAreas: "grid-template-areas",
    template: "grid-template",
    "auto-columns": "grid-auto-columns",
    autoColumns: "grid-auto-columns",
    "auto-rows": "grid-auto-rows",
    autoRows: "grid-auto-rows",
    "auto-flow": "grid-auto-flow",
    autoFlow: "grid-auto-flow",
    row: "grid-row",
    column: "grid-column",
    "row-start": "grid-row-start",
    rowStart: "grid-row-start",
    "row-end": "grid-row-end",
    rowEnd: "grid-row-end",
    "column-start": "grid-column-start",
    columnStart: "grid-column-start",
    "column-end": "grid-column-end",
    columnEnd: "grid-column-end",
    area: "grid-area",
    gap: "grid-gap",
    "row-gap": "grid-row-gap",
    rowGap: "grid-row-gap",
    "column-gap": "grid-column-gap",
    columnGap: "grid-column-gap"
  }
};
function mapValuesByProp(value, prop, rule) {
  return value.map(function(item) {
    return objectToArray(item, prop, rule, false, true);
  });
}
function processArray(value, prop, scheme, rule) {
  if (scheme[prop] == null)
    return value;
  if (value.length === 0)
    return [];
  if (Array.isArray(value[0]))
    return processArray(value[0], prop, scheme, rule);
  if (typeof value[0] === "object") {
    return mapValuesByProp(value, prop, rule);
  }
  return [value];
}
function objectToArray(value, prop, rule, isFallback, isInArray) {
  if (!(propObj[prop] || customPropObj[prop]))
    return [];
  var result = [];
  if (customPropObj[prop]) {
    value = customPropsToStyle(value, rule, customPropObj[prop], isFallback);
  }
  if (Object.keys(value).length) {
    for (var baseProp in propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(" "));
        } else
          result.push(value[baseProp]);
        continue;
      }
      if (propObj[prop][baseProp] != null) {
        result.push(propObj[prop][baseProp]);
      }
    }
  }
  if (!result.length || isInArray)
    return result;
  return [result];
}
function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop];
    if (typeof value[prop] !== "undefined" && (isFallback || !rule.prop(propName))) {
      var _styleDetector;
      var appendedValue = styleDetector((_styleDetector = {}, _styleDetector[propName] = value[prop], _styleDetector), rule)[propName];
      if (isFallback)
        rule.style.fallbacks[propName] = appendedValue;
      else
        rule.style[propName] = appendedValue;
    }
    delete value[prop];
  }
  return value;
}
function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];
    if (Array.isArray(value)) {
      if (!Array.isArray(value[0])) {
        if (prop === "fallbacks") {
          for (var index4 = 0; index4 < style.fallbacks.length; index4++) {
            style.fallbacks[index4] = styleDetector(style.fallbacks[index4], rule, true);
          }
          continue;
        }
        style[prop] = processArray(value, prop, propArray, rule);
        if (!style[prop].length)
          delete style[prop];
      }
    } else if (typeof value === "object") {
      if (prop === "fallbacks") {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }
      style[prop] = objectToArray(value, prop, rule, isFallback);
      if (!style[prop].length)
        delete style[prop];
    } else if (style[prop] === "")
      delete style[prop];
  }
  return style;
}
function jssExpand() {
  function onProcessStyle2(style, rule) {
    if (!style || rule.type !== "style")
      return style;
    if (Array.isArray(style)) {
      for (var index4 = 0; index4 < style.length; index4++) {
        style[index4] = styleDetector(style[index4], rule);
      }
      return style;
    }
    return styleDetector(style, rule);
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_expand_esm_default = jssExpand;

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n = Object.prototype.toString.call(o2).slice(8, -1);
  if (n === "Object" && o2.constructor)
    n = o2.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o2);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/css-vendor/dist/css-vendor.esm.js
var js = "";
var css = "";
var vendor = "";
var browser = "";
var isTouch = module_default && "ontouchstart" in document.documentElement;
if (module_default) {
  jsCssMap = {
    Moz: "-moz-",
    ms: "-ms-",
    O: "-o-",
    Webkit: "-webkit-"
  };
  _document$createEleme = document.createElement("p"), style = _document$createEleme.style;
  testProp = "Transform";
  for (key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
  if (js === "Webkit" && "msHyphens" in style) {
    js = "ms";
    css = jsCssMap.ms;
    browser = "edge";
  }
  if (js === "Webkit" && "-apple-trailing-word" in style) {
    vendor = "apple";
  }
}
var jsCssMap;
var _document$createEleme;
var style;
var testProp;
var key;
var prefix = {
  js,
  css,
  vendor,
  browser,
  isTouch
};
function supportedKeyframes(key) {
  if (key[1] === "-")
    return key;
  if (prefix.js === "ms")
    return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
}
var appearence = {
  noPrefill: ["appearance"],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== "appearance")
      return false;
    if (prefix.js === "ms")
      return "-webkit-" + prop;
    return prefix.css + prop;
  }
};
var colorAdjust = {
  noPrefill: ["color-adjust"],
  supportedProperty: function supportedProperty2(prop) {
    if (prop !== "color-adjust")
      return false;
    if (prefix.js === "Webkit")
      return prefix.css + "print-" + prop;
    return prop;
  }
};
var regExp = /[-\s]+(.)?/g;
function toUpper(match2, c) {
  return c ? c.toUpperCase() : "";
}
function camelize(str) {
  return str.replace(regExp, toUpper);
}
function pascalize(str) {
  return camelize("-" + str);
}
var mask = {
  noPrefill: ["mask"],
  supportedProperty: function supportedProperty3(prop, style) {
    if (!/^mask/.test(prop))
      return false;
    if (prefix.js === "Webkit") {
      var longhand = "mask-image";
      if (camelize(longhand) in style) {
        return prop;
      }
      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }
    return prop;
  }
};
var textOrientation = {
  noPrefill: ["text-orientation"],
  supportedProperty: function supportedProperty4(prop) {
    if (prop !== "text-orientation")
      return false;
    if (prefix.vendor === "apple" && !prefix.isTouch) {
      return prefix.css + prop;
    }
    return prop;
  }
};
var transform = {
  noPrefill: ["transform"],
  supportedProperty: function supportedProperty5(prop, style, options2) {
    if (prop !== "transform")
      return false;
    if (options2.transform) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var transition = {
  noPrefill: ["transition"],
  supportedProperty: function supportedProperty6(prop, style, options2) {
    if (prop !== "transition")
      return false;
    if (options2.transition) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var writingMode = {
  noPrefill: ["writing-mode"],
  supportedProperty: function supportedProperty7(prop) {
    if (prop !== "writing-mode")
      return false;
    if (prefix.js === "Webkit" || prefix.js === "ms" && prefix.browser !== "edge") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var userSelect = {
  noPrefill: ["user-select"],
  supportedProperty: function supportedProperty8(prop) {
    if (prop !== "user-select")
      return false;
    if (prefix.js === "Moz" || prefix.js === "ms" || prefix.vendor === "apple") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var breakPropsOld = {
  supportedProperty: function supportedProperty9(prop, style) {
    if (!/^break-/.test(prop))
      return false;
    if (prefix.js === "Webkit") {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }
    if (prefix.js === "Moz") {
      var _jsProp = "page" + pascalize(prop);
      return _jsProp in style ? "page-" + prop : false;
    }
    return false;
  }
};
var inlineLogicalOld = {
  supportedProperty: function supportedProperty10(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop))
      return false;
    if (prefix.js === "Moz")
      return prop;
    var newProp = prop.replace("-inline", "");
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var unprefixed = {
  supportedProperty: function supportedProperty11(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};
var prefixed = {
  supportedProperty: function supportedProperty12(prop, style) {
    var pascalized = pascalize(prop);
    if (prop[0] === "-")
      return prop;
    if (prop[0] === "-" && prop[1] === "-")
      return prop;
    if (prefix.js + pascalized in style)
      return prefix.css + prop;
    if (prefix.js !== "Webkit" && "Webkit" + pascalized in style)
      return "-webkit-" + prop;
    return false;
  }
};
var scrollSnap = {
  supportedProperty: function supportedProperty13(prop) {
    if (prop.substring(0, 11) !== "scroll-snap")
      return false;
    if (prefix.js === "ms") {
      return "" + prefix.css + prop;
    }
    return prop;
  }
};
var overscrollBehavior = {
  supportedProperty: function supportedProperty14(prop) {
    if (prop !== "overscroll-behavior")
      return false;
    if (prefix.js === "ms") {
      return prefix.css + "scroll-chaining";
    }
    return prop;
  }
};
var propMap = {
  "flex-grow": "flex-positive",
  "flex-shrink": "flex-negative",
  "flex-basis": "flex-preferred-size",
  "justify-content": "flex-pack",
  order: "flex-order",
  "align-items": "flex-align",
  "align-content": "flex-line-pack"
};
var flex2012 = {
  supportedProperty: function supportedProperty15(prop, style) {
    var newProp = propMap[prop];
    if (!newProp)
      return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var propMap$1 = {
  flex: "box-flex",
  "flex-grow": "box-flex",
  "flex-direction": ["box-orient", "box-direction"],
  order: "box-ordinal-group",
  "align-items": "box-align",
  "flex-flow": ["box-orient", "box-direction"],
  "justify-content": "box-pack"
};
var propKeys = Object.keys(propMap$1);
var prefixCss = function prefixCss2(p) {
  return prefix.css + p;
};
var flex2009 = {
  supportedProperty: function supportedProperty16(prop, style, _ref3) {
    var multiple = _ref3.multiple;
    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];
      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }
      if (!multiple)
        return false;
      for (var i = 0; i < newProp.length; i++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }
      return newProp.map(prefixCss);
    }
    return false;
  }
};
var plugins2 = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins2.filter(function(p) {
  return p.supportedProperty;
}).map(function(p) {
  return p.supportedProperty;
});
var noPrefill = plugins2.filter(function(p) {
  return p.noPrefill;
}).reduce(function(a2, p) {
  a2.push.apply(a2, _toConsumableArray(p.noPrefill));
  return a2;
}, []);
var el;
var cache2 = {};
if (module_default) {
  el = document.createElement("p");
  computed = window.getComputedStyle(document.documentElement, "");
  for (key$1 in computed) {
    if (!isNaN(key$1))
      cache2[computed[key$1]] = computed[key$1];
  }
  noPrefill.forEach(function(x) {
    return delete cache2[x];
  });
}
var computed;
var key$1;
function supportedProperty17(prop, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (!el)
    return prop;
  if (cache2[prop] != null) {
    return cache2[prop];
  }
  if (prop === "transition" || prop === "transform") {
    options2[prop] = prop in el.style;
  }
  for (var i = 0; i < propertyDetectors.length; i++) {
    cache2[prop] = propertyDetectors[i](prop, el.style, options2);
    if (cache2[prop])
      break;
  }
  try {
    el.style[prop] = "";
  } catch (err) {
    return false;
  }
  return cache2[prop];
}
var cache$1 = {};
var transitionProperties = {
  transition: 1,
  "transition-property": 1,
  "-webkit-transition": 1,
  "-webkit-transition-property": 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
function prefixTransitionCallback(match2, p1, p2) {
  if (p1 === "var")
    return "var";
  if (p1 === "all")
    return "all";
  if (p2 === "all")
    return ", all";
  var prefixedValue = p1 ? supportedProperty17(p1) : ", " + supportedProperty17(p2);
  if (!prefixedValue)
    return p1 || p2;
  return prefixedValue;
}
if (module_default)
  el$1 = document.createElement("p");
function supportedValue(property, value) {
  var prefixedValue = value;
  if (!el$1 || property === "content")
    return value;
  if (typeof prefixedValue !== "string" || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  }
  var cacheKey = property + prefixedValue;
  if (cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  }
  try {
    el$1.style[property] = prefixedValue;
  } catch (err) {
    cache$1[cacheKey] = false;
    return false;
  }
  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === "") {
    prefixedValue = prefix.css + prefixedValue;
    if (prefixedValue === "-ms-flex")
      el$1.style[property] = "-ms-flexbox";
    el$1.style[property] = prefixedValue;
    if (el$1.style[property] === "") {
      cache$1[cacheKey] = false;
      return false;
    }
  }
  el$1.style[property] = "";
  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}

// node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js
function jssVendorPrefixer() {
  function onProcessRule3(rule) {
    if (rule.type === "keyframes") {
      var atRule = rule;
      atRule.at = supportedKeyframes(atRule.at);
    }
  }
  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];
      if (prop === "fallbacks" && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }
      var changeProp = false;
      var supportedProp = supportedProperty17(prop);
      if (supportedProp && supportedProp !== prop)
        changeProp = true;
      var changeValue = false;
      var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));
      if (supportedValue$1 && supportedValue$1 !== value)
        changeValue = true;
      if (changeProp || changeValue) {
        if (changeProp)
          delete style[prop];
        style[supportedProp || prop] = supportedValue$1 || value;
      }
    }
    return style;
  }
  function onProcessStyle2(style, rule) {
    if (rule.type !== "style")
      return style;
    return prefixStyle(style);
  }
  function onChangeValue2(value, prop) {
    return supportedValue(prop, toCssValue(value)) || value;
  }
  return {
    onProcessRule: onProcessRule3,
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_vendor_prefixer_esm_default = jssVendorPrefixer;

// node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js
function jssPropsSort() {
  var sort = function sort2(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }
    return prop0.length - prop1.length;
  };
  return {
    onProcessStyle: function onProcessStyle2(style, rule) {
      if (rule.type !== "style")
        return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);
      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }
      return newStyle;
    }
  };
}
var jss_plugin_props_sort_esm_default = jssPropsSort;

// node_modules/jss-preset-default/dist/jss-preset-default.esm.js
var create3 = function create4(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    plugins: [jss_plugin_rule_value_function_esm_default(), jss_plugin_rule_value_observable_esm_default(options2.observable), jss_plugin_template_esm_default(), jss_plugin_global_esm_default(), jss_plugin_extend_esm_default(), jss_plugin_nested_esm_default(), jss_plugin_compose_esm_default(), jss_plugin_camel_case_esm_default(), jss_plugin_default_unit_esm_default(options2.defaultUnit), jss_plugin_expand_esm_default(), jss_plugin_vendor_prefixer_esm_default(), jss_plugin_props_sort_esm_default()]
  };
};
var jss_preset_default_esm_default = create3;

// node_modules/react-jss/dist/react-jss.esm.js
var import_prop_types5 = __toModule(require_prop_types());

// node_modules/shallow-equal/dist/index.esm.js
function shallowEqualObjects(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/@emotion/is-prop-valid/node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize3(fn) {
  var cache3 = {};
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var memoize_browser_esm_default = memoize3;

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function(prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});

// node_modules/css-jss/dist/css-jss.esm.js
var MAX_RULES_PER_SHEET = 1e4;
var defaultJss = create(jss_preset_default_esm_default());
var createCss = function createCss2(jss3) {
  if (jss3 === void 0) {
    jss3 = defaultJss;
  }
  var cache3 = new Map();
  var ruleIndex = 0;
  var sheet;
  var getSheet = function getSheet2() {
    if (!sheet || sheet.rules.index.length > MAX_RULES_PER_SHEET) {
      sheet = jss3.createStyleSheet().attach();
    }
    return sheet;
  };
  function css7() {
    var args = arguments;
    var argsStr = JSON.stringify(args);
    var cached = cache3.get(argsStr);
    if (cached)
      return cached.className;
    var flatArgs = [];
    for (var argIndex in args) {
      var arg = args[argIndex];
      if (!Array.isArray(arg)) {
        flatArgs.push(arg);
        continue;
      }
      for (var innerArgIndex = 0; innerArgIndex < arg.length; innerArgIndex++) {
        flatArgs.push(arg[innerArgIndex]);
      }
    }
    var mergedStyle = {};
    var labels = [];
    for (var i = 0; i < flatArgs.length; i++) {
      var style = flatArgs[i];
      if (!style)
        continue;
      var styleObject = style;
      if (typeof style === "string") {
        var _cached = cache3.get(style);
        if (_cached) {
          if (_cached.labels.length)
            labels.push.apply(labels, _cached.labels);
          styleObject = _cached.style;
        }
      }
      if (styleObject.label && labels.indexOf(styleObject.label) === -1)
        labels.push(styleObject.label);
      Object.assign(mergedStyle, styleObject);
    }
    delete mergedStyle.label;
    var label = labels.length === 0 ? "css" : labels.join("-");
    var key = label + "-" + ruleIndex++;
    getSheet().addRule(key, mergedStyle);
    var className = getSheet().classes[key];
    var cacheValue = {
      style: mergedStyle,
      labels,
      className
    };
    cache3.set(argsStr, cacheValue);
    cache3.set(className, cacheValue);
    return className;
  }
  css7.getSheet = getSheet;
  return css7;
};
var css2 = createCss();
var css_jss_esm_default = css2;

// node_modules/react-jss/dist/react-jss.esm.js
var JssContext = (0, import_react9.createContext)({
  classNamePrefix: "",
  disableStylesGeneration: false
});
var index2 = Number.MIN_SAFE_INTEGER || -1e9;
var getSheetIndex = function getSheetIndex2() {
  return index2++;
};
var defaultManagers = new Map();
var getManager = function getManager2(context, managerId) {
  if (context.managers) {
    if (!context.managers[managerId]) {
      context.managers[managerId] = new SheetsManager();
    }
    return context.managers[managerId];
  }
  var manager = defaultManagers.get(managerId);
  if (!manager) {
    manager = new SheetsManager();
    defaultManagers.set(managerId, manager);
  }
  return manager;
};
var manageSheet = function manageSheet2(options2) {
  var sheet = options2.sheet, context = options2.context, index4 = options2.index, theme = options2.theme;
  if (!sheet) {
    return;
  }
  var manager = getManager(context, index4);
  manager.manage(theme);
  if (context.registry) {
    context.registry.add(sheet);
  }
};
var unmanageSheet = function unmanageSheet2(options2) {
  if (!options2.sheet) {
    return;
  }
  var manager = getManager(options2.context, options2.index);
  manager.unmanage(options2.theme);
};
var jss2 = create(jss_preset_default_esm_default());
var sheetsMeta = new WeakMap();
var getMeta = function getMeta2(sheet) {
  return sheetsMeta.get(sheet);
};
var addMeta = function addMeta2(sheet, meta) {
  sheetsMeta.set(sheet, meta);
};
var getStyles = function getStyles2(options2) {
  var styles = options2.styles;
  if (typeof styles !== "function") {
    return styles;
  }
  false ? tiny_warning_esm_default(styles.length !== 0, "[JSS] <" + (options2.name || "Hook") + ` />'s styles function doesn't rely on the "theme" argument. We recommend declaring styles as an object instead.`) : void 0;
  return styles(options2.theme);
};
function getSheetOptions(options2, link) {
  var minify;
  if (options2.context.id && options2.context.id.minify != null) {
    minify = options2.context.id.minify;
  }
  var classNamePrefix = options2.context.classNamePrefix || "";
  if (options2.name && !minify) {
    classNamePrefix += options2.name.replace(/\s/g, "-") + "-";
  }
  var meta = "";
  if (options2.name)
    meta = options2.name + ", ";
  meta += typeof options2.styles === "function" ? "Themed" : "Unthemed";
  return _extends({}, options2.sheetOptions, {
    index: options2.index,
    meta,
    classNamePrefix,
    link,
    generateId: options2.sheetOptions.generateId || options2.context.generateId
  });
}
var createStyleSheet = function createStyleSheet2(options2) {
  if (options2.context.disableStylesGeneration) {
    return void 0;
  }
  var manager = getManager(options2.context, options2.index);
  var existingSheet = manager.get(options2.theme);
  if (existingSheet) {
    return existingSheet;
  }
  var jss$1 = options2.context.jss || jss2;
  var styles = getStyles(options2);
  var dynamicStyles = getDynamicStyles(styles);
  var sheet = jss$1.createStyleSheet(styles, getSheetOptions(options2, dynamicStyles !== null));
  addMeta(sheet, {
    dynamicStyles,
    styles
  });
  manager.add(options2.theme, sheet);
  return sheet;
};
var removeDynamicRules = function removeDynamicRules2(sheet, rules) {
  for (var key in rules) {
    sheet.deleteRule(rules[key]);
  }
};
var updateDynamicRules = function updateDynamicRules2(data3, sheet, rules) {
  for (var key in rules) {
    sheet.updateOne(rules[key], data3);
  }
};
var addDynamicRules = function addDynamicRules2(sheet, data3) {
  var meta = getMeta(sheet);
  if (!meta) {
    return void 0;
  }
  var rules = {};
  for (var key in meta.dynamicStyles) {
    var initialRuleCount = sheet.rules.index.length;
    var originalRule = sheet.addRule(key, meta.dynamicStyles[key]);
    for (var i = initialRuleCount; i < sheet.rules.index.length; i++) {
      var rule = sheet.rules.index[i];
      sheet.updateOne(rule, data3);
      rules[originalRule === rule ? key : rule.key] = rule;
    }
  }
  return rules;
};
var getSheetClasses = function getSheetClasses2(sheet, dynamicRules) {
  if (!dynamicRules) {
    return sheet.classes;
  }
  var classes = {};
  var meta = getMeta(sheet);
  if (!meta) {
    return sheet.classes;
  }
  for (var key in meta.styles) {
    classes[key] = sheet.classes[key];
    if (key in dynamicRules) {
      classes[key] += " " + sheet.classes[dynamicRules[key].key];
    }
  }
  return classes;
};
var useEffectOrLayoutEffect = module_default ? import_react9.useLayoutEffect : import_react9.useEffect;
var noTheme$1 = {};
var createUseStyles = function createUseStyles2(styles, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$index = _options.index, index4 = _options$index === void 0 ? getSheetIndex() : _options$index, theming = _options.theming, name2 = _options.name, sheetOptions = _objectWithoutPropertiesLoose(_options, ["index", "theming", "name"]);
  var ThemeContext$1 = theming && theming.context || ThemeContext;
  var useTheme2 = typeof styles === "function" ? function() {
    return (0, import_react9.useContext)(ThemeContext$1) || noTheme$1;
  } : function() {
    return noTheme$1;
  };
  return function useStyles2(data3) {
    var isFirstMount = (0, import_react9.useRef)(true);
    var context = (0, import_react9.useContext)(JssContext);
    var theme = useTheme2();
    var _React$useMemo = (0, import_react9.useMemo)(function() {
      var newSheet = createStyleSheet({
        context,
        styles,
        name: name2,
        theme,
        index: index4,
        sheetOptions
      });
      var newDynamicRules = newSheet ? addDynamicRules(newSheet, data3) : null;
      if (newSheet) {
        manageSheet({
          index: index4,
          context,
          sheet: newSheet,
          theme
        });
      }
      return [newSheet, newDynamicRules];
    }, [context, theme]), sheet = _React$useMemo[0], dynamicRules = _React$useMemo[1];
    useEffectOrLayoutEffect(function() {
      if (sheet && dynamicRules && !isFirstMount.current) {
        updateDynamicRules(data3, sheet, dynamicRules);
      }
    }, [data3]);
    useEffectOrLayoutEffect(function() {
      return function() {
        if (sheet) {
          unmanageSheet({
            index: index4,
            context,
            sheet,
            theme
          });
        }
        if (sheet && dynamicRules) {
          removeDynamicRules(sheet, dynamicRules);
        }
      };
    }, [sheet]);
    var classes = sheet && dynamicRules ? getSheetClasses(sheet, dynamicRules) : {};
    (0, import_react9.useDebugValue)(classes);
    (0, import_react9.useDebugValue)(theme === noTheme$1 ? "No theme" : theme);
    (0, import_react9.useEffect)(function() {
      isFirstMount.current = false;
    });
    return classes;
  };
};
var initialContext = {};
var JssProvider = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(JssProvider2, _React$Component);
  function JssProvider2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.managers = {};
    _this.createContext = function(parentContext, prevContext) {
      if (prevContext === void 0) {
        prevContext = initialContext;
      }
      var _this$props = _this.props, registry2 = _this$props.registry, classNamePrefix = _this$props.classNamePrefix, jss3 = _this$props.jss, generateId = _this$props.generateId, disableStylesGeneration = _this$props.disableStylesGeneration, media = _this$props.media, id = _this$props.id;
      var context = _extends({}, parentContext);
      if (registry2) {
        context.registry = registry2;
        if (registry2 !== _this.registry) {
          _this.managers = {};
          _this.registry = registry2;
        }
      }
      context.managers = _this.managers;
      if (id !== void 0) {
        context.id = id;
      }
      if (generateId !== void 0) {
        context.generateId = generateId;
      } else if (!context.generateId || !prevContext || context.id !== prevContext.id) {
        context.generateId = createGenerateId(context.id);
      }
      if (classNamePrefix) {
        context.classNamePrefix = (context.classNamePrefix || "") + classNamePrefix;
      }
      if (media !== void 0) {
        context.media = media;
      }
      if (jss3) {
        context.jss = jss3;
      }
      if (disableStylesGeneration !== void 0) {
        context.disableStylesGeneration = disableStylesGeneration;
      }
      if (prevContext && shallowEqualObjects(prevContext, context)) {
        return prevContext;
      }
      return context;
    };
    _this.prevContext = void 0;
    _this.generateId = void 0;
    _this.registry = void 0;
    _this.renderProvider = function(parentContext) {
      var children = _this.props.children;
      var context = _this.createContext(parentContext, _this.prevContext);
      _this.prevContext = context;
      return (0, import_react9.createElement)(JssContext.Provider, {
        value: context
      }, children);
    };
    return _this;
  }
  var _proto = JssProvider2.prototype;
  _proto.render = function render2() {
    return (0, import_react9.createElement)(JssContext.Consumer, null, this.renderProvider);
  };
  return JssProvider2;
}(import_react9.Component);
JssProvider.propTypes = {
  registry: import_prop_types5.default.instanceOf(SheetsRegistry),
  jss: import_prop_types5.default.instanceOf(jss_esm_default.constructor),
  generateId: import_prop_types5.default.func,
  classNamePrefix: import_prop_types5.default.string,
  disableStylesGeneration: import_prop_types5.default.bool,
  children: import_prop_types5.default.node.isRequired,
  media: import_prop_types5.default.string,
  id: import_prop_types5.default.shape({
    minify: import_prop_types5.default.bool
  })
};
var shouldForwardPropSymbol = Symbol("react-jss-styled");
var create5 = function create6(css7) {
  if (css7 === void 0) {
    css7 = css_jss_esm_default;
  }
  return function createElement6(type, props) {
    var args = arguments;
    if (props && props.css) {
      var className = css7(props.css);
      var newProps = Object.assign({}, props);
      newProps.className = props.className ? props.className + " " + className : className;
      delete newProps.css;
      args[1] = newProps;
    }
    return import_react9.createElement.apply(void 0, args);
  };
};
var createElement2 = create5();

// node_modules/react-timezone-select/dist/index.js
var React11 = __toModule(require("react"));

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_react11 = __toModule(require("react"));

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet2 = /* @__PURE__ */ function() {
  function StyleSheet3(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        before = _this.prepend ? _this.container.firstChild : _this.before;
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.before = null;
  }
  var _proto = StyleSheet3.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (false) {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
        if (false) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (false) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet3;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
function hash(value, length2) {
  return (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index4) {
  return value.charCodeAt(index4) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return {value, root, parent, type, props, children, line, column, length: length2, return: ""};
}
function copy(value, root, type) {
  return node(value, root.root, root.parent, type, root.props, root.children, 0);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        return delimiter(type === 34 || type === 39 ? type : character);
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index4) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index4, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index4) {
  while (!token(peek()))
    next();
  return slice(index4, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse3(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index4 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 34:
      case 39:
      case 91:
      case 40:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index4++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index4, offset3, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse3(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse3(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse3(characters2, reference, reference, reference, [""], children, length2, points, children);
                }
        }
        index4 = offset3 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123) {
            --variable;
          } else if (character2 == 125 && variable++ == 0 && prev() == 125) {
            continue;
          }
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index4++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index4, offset3, rules, points, type, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index4; ++i)
    for (var x = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x < size; ++x)
      if (z2 = trim(j > 0 ? rule[x] + " " + y2 : replace(y2, /&\f/g, rule[x])))
        props[k++] = z2;
  return node(value, root, parent, offset3 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Prefixer.js
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index4, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index4, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index4, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index4, children, callback) {
  if (!element.return)
    switch (element.type) {
      case DECLARATION:
        element.return = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(replace(element.value, "@", "@" + WEBKIT), element, "")], callback);
      case RULESET:
        if (element.length)
          return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy(replace(value, /:(read-\w+)/, ":" + MOZ + "$1"), element, "")], callback);
              case "::placeholder":
                return serialize([
                  copy(replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1"), element, ""),
                  copy(replace(value, /:(plac\w+)/, ":" + MOZ + "$1"), element, ""),
                  copy(replace(value, /:(plac\w+)/, MS + "input-$1"), element, "")
                ], callback);
            }
            return "";
          });
    }
}

// node_modules/@emotion/memoize/dist/emotion-memoize.browser.esm.js
function memoize4(fn) {
  var cache3 = Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var emotion_memoize_browser_esm_default = memoize4;

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var toRules = function toRules2(parsed, points) {
  var index4 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index4] = 1;
        }
        parsed[index4] += identifier(position - 1);
        break;
      case 2:
        parsed[index4] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index4] = peek() === 58 ? "&\f" : "";
          points[index4] = parsed[index4].length;
          break;
        }
      default:
        parsed[index4] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || !element.length) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (false) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  if (false) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion]"), function(node2) {
      var attrib = node2.getAttribute("data-emotion").split(" ");
      if (attrib[0] !== key) {
        return;
      }
      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }
      nodesToHydrate.push(node2);
    });
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (false) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache3.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, false ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (false) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache3.inserted[serialized.name] = true;
      }
    };
  }
  var cache3 = {
    key,
    sheet: new StyleSheet2({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache3.sheet.hydrate(nodesToHydrate);
  return cache3;
};
var emotion_cache_browser_esm_default = createCache;

// node_modules/@emotion/react/dist/emotion-element-4fbd89c5.browser.esm.js
var import_react10 = __toModule(require("react"));

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles2(cache3, serialized, isStringTag) {
  var className = cache3.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser2 === false) && cache3.registered[className] === void 0) {
    cache3.registered[className] = serialized.styles;
  }
  if (cache3.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      var maybeStyles = cache3.insert(serialized === current ? "." + className : "", current, cache3.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h2 = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= k >>> 24;
    h2 = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ emotion_memoize_browser_esm_default(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitless_browser_esm_default[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (false) {
  contentValuePattern = /(attr|calc|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(/;
  contentValues = ["normal", "none", "counter", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern2 = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern2, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern2;
var hyphenPattern;
var hyphenatedCache;
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (false) {
      throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next3 = interpolation.next;
        if (next3 !== void 0) {
          while (next3 !== void 0) {
            cursor = {
              name: next3.name,
              styles: next3.styles,
              next: cursor
            };
            next3 = next3.next;
          }
        }
        var styles = interpolation.styles + ";";
        if (false) {
          styles += interpolation.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (false) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (false) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (false) {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;
var sourceMapPattern;
if (false) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if (false) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i];
    }
  }
  var sourceMap;
  if (false) {
    styles = styles.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = hash_browser_esm_default(styles) + identifierName;
  if (false) {
    return {
      name: name2,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name2,
    styles,
    next: cursor
  };
};

// node_modules/@emotion/react/dist/emotion-element-4fbd89c5.browser.esm.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ (0, import_react10.createContext)(typeof HTMLElement !== "undefined" ? /* @__PURE__ */ emotion_cache_browser_esm_default({
  key: "css"
}) : null);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ (0, import_react10.forwardRef)(function(props, ref) {
    var cache3 = (0, import_react10.useContext)(EmotionCacheContext);
    return func(props, cache3, ref);
  });
};
var ThemeContext2 = /* @__PURE__ */ (0, import_react10.createContext)({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (false) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  if (false) {
    var error = new Error();
    if (error.stack) {
      var match2 = error.stack.match(/at (?:Object\.|Module\.|)(?:jsx|createEmotionProps).*\n\s+at (?:Object\.|)([A-Z][A-Za-z0-9$]+) /);
      if (!match2) {
        match2 = error.stack.match(/.*\n([A-Z][A-Za-z0-9$]+)@/);
      }
      if (match2) {
        newProps[labelPropName] = sanitizeIdentifier(match2[1]);
      }
    }
  }
  return newProps;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache3, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache3.registered[cssProp] !== void 0) {
    cssProp = cache3.registered[cssProp];
  }
  var type = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache3.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, typeof cssProp === "function" || Array.isArray(cssProp) ? (0, import_react10.useContext)(ThemeContext2) : void 0);
  if (false) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  var rules = insertStyles(cache3, serialized, typeof type === "string");
  className += cache3.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  var ele = /* @__PURE__ */ (0, import_react10.createElement)(type, newProps);
  return ele;
});
if (false) {
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_hoist_non_react_statics3 = __toModule(require_hoist_non_react_statics_cjs());
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return import_react11.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return import_react11.createElement.apply(null, createElementArgArray);
};
if (false) {
  Global.displayName = "EmotionGlobal";
}
function css3() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css3.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (false) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css7, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css7(registeredStyles);
}
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache3) {
  var hasRendered = false;
  var css7 = function css8() {
    if (hasRendered && false) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache3.registered);
    {
      insertStyles(cache3, serialized, false);
    }
    return cache3.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && false) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache3.registered, css7, classnames(args));
  };
  var content = {
    css: css7,
    cx,
    theme: (0, import_react11.useContext)(ThemeContext2)
  };
  var ele = props.children(content);
  hasRendered = true;
  return ele;
});
if (false) {
  ClassNames.displayName = "EmotionClassNames";
}
if (false) {
  isBrowser3 = true;
  isJest = typeof jest !== "undefined";
  if (isBrowser3 && !isJest) {
    globalContext = isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isJest;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}

// node_modules/react-select/dist/index-4bd03571.esm.js
var import_react_input_autosize = __toModule(require_AutosizeInput());

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/react-select/dist/index-4bd03571.esm.js
var import_react13 = __toModule(require("react"));
var import_react_dom = __toModule(require("react-dom"));
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized3(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var noop = function noop2() {
};
function applyPrefixToName(prefix3, name2) {
  if (!name2) {
    return prefix3;
  } else if (name2[0] === "-") {
    return prefix3 + name2;
  } else {
    return prefix3 + "__" + name2;
  }
}
function classNames(prefix3, state, className) {
  var arr = [className];
  if (state && prefix3) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix3, key)));
      }
    }
  }
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (Array.isArray(value))
    return value.filter(Boolean);
  if (_typeof3(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"]);
  return _objectSpread2({}, innerProps);
};
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
function getScrollTop(el2) {
  if (isDocumentElement(el2)) {
    return window.pageYOffset;
  }
  return el2.scrollTop;
}
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  var docEl = document.documentElement;
  if (style.position === "fixed")
    return docEl;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return docEl;
}
function easeOutCubic(t, b, c, d2) {
  return c * ((t = t / d2 - 1) * t * t + 1) + b;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e2) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop, options);
  w.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function getMenuPlacement(_ref3) {
  var maxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, placement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, theme = _ref3.theme;
  var spacing2 = theme.spacing;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = window.innerHeight;
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (placement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (placement === "auto" || isFixedPosition) {
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing2.controlHeight, maxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (placement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(placement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p) {
  return p === "auto" ? "bottom" : p;
};
var menuCSS = function menuCSS2(_ref23) {
  var _ref3;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _ref3 = {
    label: "menu"
  }, _defineProperty2(_ref3, alignToControl(placement), "100%"), _defineProperty2(_ref3, "backgroundColor", colors2.neutral0), _defineProperty2(_ref3, "borderRadius", borderRadius2), _defineProperty2(_ref3, "boxShadow", "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)"), _defineProperty2(_ref3, "marginBottom", spacing2.menuGutter), _defineProperty2(_ref3, "marginTop", spacing2.menuGutter), _defineProperty2(_ref3, "position", "absolute"), _defineProperty2(_ref3, "width", "100%"), _defineProperty2(_ref3, "zIndex", 1), _ref3;
};
var PortalPlacementContext = /* @__PURE__ */ (0, import_react13.createContext)({
  getPortalPlacement: null
});
var MenuPlacer = /* @__PURE__ */ function(_Component) {
  _inherits(MenuPlacer2, _Component);
  var _super = _createSuper(MenuPlacer2);
  function MenuPlacer2() {
    var _this;
    _classCallCheck(this, MenuPlacer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };
    _this.getPlacement = function(ref) {
      var _this$props = _this.props, minMenuHeight = _this$props.minMenuHeight, maxMenuHeight = _this$props.maxMenuHeight, menuPlacement = _this$props.menuPlacement, menuPosition = _this$props.menuPosition, menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView, theme = _this$props.theme;
      if (!ref)
        return;
      var isFixedPosition = menuPosition === "fixed";
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll,
        isFixedPosition,
        theme
      });
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (getPortalPlacement)
        getPortalPlacement(state);
      _this.setState(state);
    };
    _this.getUpdatedProps = function() {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return _objectSpread2(_objectSpread2({}, _this.props), {}, {
        placement,
        maxHeight: _this.state.maxHeight
      });
    };
    return _this;
  }
  _createClass(MenuPlacer2, [{
    key: "render",
    value: function render2() {
      var children = this.props.children;
      return children({
        ref: this.getPlacement,
        placerProps: this.getUpdatedProps()
      });
    }
  }]);
  return MenuPlacer2;
}(import_react13.Component);
MenuPlacer.contextType = PortalPlacementContext;
var Menu = function Menu2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("menu", props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var menuListCSS = function menuListCSS2(_ref4) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight,
    overflowY: "auto",
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2,
    position: "relative",
    WebkitOverflowScrolling: "touch"
  };
};
var MenuList = function MenuList2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({
    css: getStyles3("menuList", props),
    className: cx({
      "menu-list": true,
      "menu-list--is-multi": isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px"),
    textAlign: "center"
  };
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("noOptionsMessage", props),
    className: cx({
      "menu-notice": true,
      "menu-notice--no-options": true
    }, className)
  }, innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: "No options"
};
var LoadingMessage = function LoadingMessage2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("loadingMessage", props),
    className: cx({
      "menu-notice": true,
      "menu-notice--loading": true
    }, className)
  }, innerProps), children);
};
LoadingMessage.defaultProps = {
  children: "Loading..."
};
var menuPortalCSS = function menuPortalCSS2(_ref6) {
  var rect = _ref6.rect, offset3 = _ref6.offset, position2 = _ref6.position;
  return {
    left: rect.left,
    position: position2,
    top: offset3,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = /* @__PURE__ */ function(_Component2) {
  _inherits(MenuPortal2, _Component2);
  var _super2 = _createSuper(MenuPortal2);
  function MenuPortal2() {
    var _this2;
    _classCallCheck(this, MenuPortal2);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.state = {
      placement: null
    };
    _this2.getPortalPlacement = function(_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement);
      if (placement !== initialPlacement) {
        _this2.setState({
          placement
        });
      }
    };
    return _this2;
  }
  _createClass(MenuPortal2, [{
    key: "render",
    value: function render2() {
      var _this$props2 = this.props, appendTo = _this$props2.appendTo, children = _this$props2.children, className = _this$props2.className, controlElement = _this$props2.controlElement, cx = _this$props2.cx, innerProps = _this$props2.innerProps, menuPlacement = _this$props2.menuPlacement, position2 = _this$props2.menuPosition, getStyles3 = _this$props2.getStyles;
      var isFixed = position2 === "fixed";
      if (!appendTo && !isFixed || !controlElement) {
        return null;
      }
      var placement = this.state.placement || coercePlacement(menuPlacement);
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = isFixed ? 0 : window.pageYOffset;
      var offset3 = rect[placement] + scrollDistance;
      var state = {
        offset: offset3,
        position: position2,
        rect
      };
      var menuWrapper = jsx("div", _extends({
        css: getStyles3("menuPortal", state),
        className: cx({
          "menu-portal": true
        }, className)
      }, innerProps), children);
      return jsx(PortalPlacementContext.Provider, {
        value: {
          getPortalPlacement: this.getPortalPlacement
        }
      }, appendTo ? /* @__PURE__ */ (0, import_react_dom.createPortal)(menuWrapper, appendTo) : menuWrapper);
    }
  }]);
  return MenuPortal2;
}(import_react13.Component);
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : null,
    pointerEvents: isDisabled ? "none" : null,
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({
    css: getStyles3("container", props),
    className: cx({
      "--is-disabled": isDisabled,
      "--is-rtl": isRtl
    }, className)
  }, innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23) {
  var spacing2 = _ref23.theme.spacing;
  return {
    alignItems: "center",
    display: "flex",
    flex: 1,
    flexWrap: "wrap",
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px"),
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  };
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, innerProps = props.innerProps, isMulti = props.isMulti, getStyles3 = props.getStyles, hasValue = props.hasValue;
  return jsx("div", _extends({
    css: getStyles3("valueContainer", props),
    className: cx({
      "value-container": true,
      "value-container--is-multi": isMulti,
      "value-container--has-value": hasValue
    }, className)
  }, innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, innerProps = props.innerProps, getStyles3 = props.getStyles;
  return jsx("div", _extends({
    css: getStyles3("indicatorsContainer", props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};
var _templateObject;
var _ref2 = true ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0JJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBDb21tb25Qcm9wcywgVGhlbWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBJY29uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IFN2ZyA9ICh7IHNpemUsIC4uLnByb3BzIH06IHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk0xNC4zNDggMTQuODQ5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwbC0yLjY1MS0zLjAzMC0yLjY1MSAzLjAyOWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMC0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOSAwLTEuNjk3bDIuNzU4LTMuMTUtMi43NTktMy4xNTJjLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI4IDAtMS42OTdzMS4yMjgtMC40NjkgMS42OTcgMGwyLjY1MiAzLjAzMSAyLjY1MS0zLjAzMWMwLjQ2OS0wLjQ2OSAxLjIyOC0wLjQ2OSAxLjY5NyAwczAuNDY5IDEuMjI5IDAgMS42OTdsLTIuNzU4IDMuMTUyIDIuNzU4IDMuMTVjMC40NjkgMC40NjkgMC40NjkgMS4yMjkgMCAxLjY5OHpcIiAvPlxuICA8L1N2Zz5cbik7XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IGFueSkgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIEluZGljYXRvclByb3BzID0gQ29tbW9uUHJvcHMgJiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuOiBOb2RlLFxuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn07XG5cbmNvbnN0IGJhc2VDU1MgPSAoe1xuICBpc0ZvY3VzZWQsXG4gIHRoZW1lOiB7XG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIGNvbG9ycyxcbiAgfSxcbn06IEluZGljYXRvclByb3BzKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG5cbiAgJzpob3Zlcic6IHtcbiAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnY2xlYXJJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudHlwZSBTZXBhcmF0b3JTdGF0ZSA9IHsgaXNEaXNhYmxlZDogYm9vbGVhbiB9O1xuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gKHtcbiAgaXNEaXNhYmxlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogQ29tbW9uUHJvcHMgJiBTZXBhcmF0b3JTdGF0ZSkgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgd2lkdGg6IDEsXG59KTtcblxuZXhwb3J0IGNvbnN0IEluZGljYXRvclNlcGFyYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdpbmRpY2F0b3JTZXBhcmF0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KHsgJ2luZGljYXRvci1zZXBhcmF0b3InOiB0cnVlIH0sIGNsYXNzTmFtZSl9XG4gICAgLz5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTG9hZGluZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGxvYWRpbmdEb3RBbmltYXRpb25zID0ga2V5ZnJhbWVzYFxuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICA0MCUgeyBvcGFjaXR5OiAxOyB9XG5gO1xuXG5leHBvcnQgY29uc3QgbG9hZGluZ0luZGljYXRvckNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgc2l6ZSxcbiAgdGhlbWU6IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICB9LFxufToge1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXG4gIHNpemU6IG51bWJlcixcbiAgdGhlbWU6IFRoZW1lLFxufSkgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgZm9udFNpemU6IHNpemUsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG1hcmdpblJpZ2h0OiBzaXplLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbn0pO1xuXG50eXBlIERvdFByb3BzID0geyBkZWxheTogbnVtYmVyLCBvZmZzZXQ6IGJvb2xlYW4gfTtcbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IERvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiBudWxsLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgdHlwZSBMb2FkaW5nSWNvblByb3BzID0ge1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn0gJiBDb21tb25Qcm9wcyAmIHtcbiAgICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgICBzaXplOiBudW1iZXIsXG4gIH07XG5leHBvcnQgY29uc3QgTG9hZGluZ0luZGljYXRvciA9IChwcm9wczogTG9hZGluZ0ljb25Qcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcywgaXNSdGwgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2xvYWRpbmdJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHsgc2l6ZTogNCB9O1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size = _ref3.size, props = _objectWithoutProperties(_ref3, ["size"]);
  return jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return {
    label: "indicatorContainer",
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    display: "flex",
    padding: baseUnit2 * 2,
    transition: "color 150ms",
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  };
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("dropdownIndicator", props),
    className: cx({
      indicator: true,
      "dropdown-indicator": true
    }, className)
  }, innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("clearIndicator", props),
    className: cx({
      indicator: true,
      "clear-indicator": true
    }, className)
  }, innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return {
    label: "indicatorSeparator",
    alignSelf: "stretch",
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2,
    width: 1
  };
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, {
    css: getStyles3("indicatorSeparator", props),
    className: cx({
      "indicator-separator": true
    }, className)
  }));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5) {
  var isFocused = _ref5.isFocused, size = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return {
    label: "loadingIndicator",
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    display: "flex",
    padding: baseUnit2 * 2,
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: "center",
    verticalAlign: "middle"
  };
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset3 = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css3({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset3 ? "1em" : null,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, true ? "" : ";label:LoadingDot;", true ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0xJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBDb21tb25Qcm9wcywgVGhlbWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBJY29uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IFN2ZyA9ICh7IHNpemUsIC4uLnByb3BzIH06IHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk0xNC4zNDggMTQuODQ5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwbC0yLjY1MS0zLjAzMC0yLjY1MSAzLjAyOWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMC0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOSAwLTEuNjk3bDIuNzU4LTMuMTUtMi43NTktMy4xNTJjLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI4IDAtMS42OTdzMS4yMjgtMC40NjkgMS42OTcgMGwyLjY1MiAzLjAzMSAyLjY1MS0zLjAzMWMwLjQ2OS0wLjQ2OSAxLjIyOC0wLjQ2OSAxLjY5NyAwczAuNDY5IDEuMjI5IDAgMS42OTdsLTIuNzU4IDMuMTUyIDIuNzU4IDMuMTVjMC40NjkgMC40NjkgMC40NjkgMS4yMjkgMCAxLjY5OHpcIiAvPlxuICA8L1N2Zz5cbik7XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IGFueSkgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIEluZGljYXRvclByb3BzID0gQ29tbW9uUHJvcHMgJiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuOiBOb2RlLFxuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn07XG5cbmNvbnN0IGJhc2VDU1MgPSAoe1xuICBpc0ZvY3VzZWQsXG4gIHRoZW1lOiB7XG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIGNvbG9ycyxcbiAgfSxcbn06IEluZGljYXRvclByb3BzKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG5cbiAgJzpob3Zlcic6IHtcbiAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnY2xlYXJJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudHlwZSBTZXBhcmF0b3JTdGF0ZSA9IHsgaXNEaXNhYmxlZDogYm9vbGVhbiB9O1xuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gKHtcbiAgaXNEaXNhYmxlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogQ29tbW9uUHJvcHMgJiBTZXBhcmF0b3JTdGF0ZSkgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgd2lkdGg6IDEsXG59KTtcblxuZXhwb3J0IGNvbnN0IEluZGljYXRvclNlcGFyYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdpbmRpY2F0b3JTZXBhcmF0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KHsgJ2luZGljYXRvci1zZXBhcmF0b3InOiB0cnVlIH0sIGNsYXNzTmFtZSl9XG4gICAgLz5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTG9hZGluZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGxvYWRpbmdEb3RBbmltYXRpb25zID0ga2V5ZnJhbWVzYFxuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICA0MCUgeyBvcGFjaXR5OiAxOyB9XG5gO1xuXG5leHBvcnQgY29uc3QgbG9hZGluZ0luZGljYXRvckNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgc2l6ZSxcbiAgdGhlbWU6IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICB9LFxufToge1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXG4gIHNpemU6IG51bWJlcixcbiAgdGhlbWU6IFRoZW1lLFxufSkgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgZm9udFNpemU6IHNpemUsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG1hcmdpblJpZ2h0OiBzaXplLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbn0pO1xuXG50eXBlIERvdFByb3BzID0geyBkZWxheTogbnVtYmVyLCBvZmZzZXQ6IGJvb2xlYW4gfTtcbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IERvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiBudWxsLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgdHlwZSBMb2FkaW5nSWNvblByb3BzID0ge1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn0gJiBDb21tb25Qcm9wcyAmIHtcbiAgICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgICBzaXplOiBudW1iZXIsXG4gIH07XG5leHBvcnQgY29uc3QgTG9hZGluZ0luZGljYXRvciA9IChwcm9wczogTG9hZGluZ0ljb25Qcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcywgaXNSdGwgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2xvYWRpbmdJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHsgc2l6ZTogNCB9O1xuIl19 */")
  });
};
var LoadingIndicator = function LoadingIndicator2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, isRtl = props.isRtl;
  return jsx("div", _extends({
    css: getStyles3("loadingIndicator", props),
    className: cx({
      indicator: true,
      "loading-indicator": true
    }, className)
  }, innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};
var css4 = function css5(_ref3) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return {
    label: "control",
    alignItems: "center",
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : null,
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms",
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  };
};
var Control = function Control2(props) {
  var children = props.children, cx = props.cx, getStyles3 = props.getStyles, className = props.className, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef,
    css: getStyles3("control", props),
    className: cx({
      control: true,
      "control--is-disabled": isDisabled,
      "control--is-focused": isFocused,
      "control--menu-is-open": menuIsOpen
    }, className)
  }, innerProps), children);
};
var groupCSS = function groupCSS2(_ref3) {
  var spacing2 = _ref3.theme.spacing;
  return {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group2 = function Group3(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({
    css: getStyles3("group", props),
    className: cx({
      group: true
    }, className)
  }, innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles: getStyles3,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23) {
  var spacing2 = _ref23.theme.spacing;
  return {
    label: "group",
    color: "#999",
    cursor: "default",
    display: "block",
    fontSize: "75%",
    fontWeight: "500",
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  };
};
var GroupHeading = function GroupHeading2(props) {
  var getStyles3 = props.getStyles, cx = props.cx, className = props.className;
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, ["data"]);
  return jsx("div", _extends({
    css: getStyles3("groupHeading", props),
    className: cx({
      "group-heading": true
    }, className)
  }, innerProps));
};
var inputCSS = function inputCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    visibility: isDisabled ? "hidden" : "visible",
    color: colors2.neutral80
  };
};
var inputStyle = function inputStyle2(isHidden) {
  return {
    label: "input",
    background: 0,
    border: 0,
    fontSize: "inherit",
    opacity: isHidden ? 0 : 1,
    outline: 0,
    padding: 0,
    color: "inherit"
  };
};
var Input = function Input2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, innerProps = _objectWithoutProperties(_cleanCommonProps, ["innerRef", "isDisabled", "isHidden"]);
  return jsx("div", {
    css: getStyles3("input", props)
  }, jsx(import_react_input_autosize.default, _extends({
    className: cx({
      input: true
    }, className),
    inputRef: innerRef,
    inputStyle: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var multiValueCSS = function multiValueCSS2(_ref3) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return {
    label: "multiValue",
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    display: "flex",
    margin: spacing2.baseUnit / 2,
    minWidth: 0
  };
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    overflow: "hidden",
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis ? "ellipsis" : null,
    whiteSpace: "nowrap"
  };
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return {
    alignItems: "center",
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused && colors2.dangerLight,
    display: "flex",
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  };
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", innerProps, children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, className = props.className, components2 = props.components, cx = props.cx, data3 = props.data, getStyles3 = props.getStyles, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label = components2.Label, Remove = components2.Remove;
  return jsx(ClassNames, null, function(_ref6) {
    var css7 = _ref6.css, emotionCx = _ref6.cx;
    return jsx(Container, {
      data: data3,
      innerProps: _objectSpread2({
        className: emotionCx(css7(getStyles3("multiValue", props)), cx({
          "multi-value": true,
          "multi-value--is-disabled": isDisabled
        }, className))
      }, innerProps),
      selectProps
    }, jsx(Label, {
      data: data3,
      innerProps: {
        className: emotionCx(css7(getStyles3("multiValueLabel", props)), cx({
          "multi-value__label": true
        }, className))
      },
      selectProps
    }, children), jsx(Remove, {
      data: data3,
      innerProps: _objectSpread2({
        className: emotionCx(css7(getStyles3("multiValueRemove", props)), cx({
          "multi-value__remove": true
        }, className))
      }, removeProps),
      selectProps
    }));
  });
};
MultiValue.defaultProps = {
  cropWithEllipsis: true
};
var optionCSS = function optionCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "option",
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
    ":active": {
      backgroundColor: !isDisabled && (isSelected ? colors2.primary : colors2.primary50)
    }
  };
};
var Option = function Option2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("option", props),
    className: cx({
      option: true,
      "option--is-disabled": isDisabled,
      "option--is-focused": isFocused,
      "option--is-selected": isSelected
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var placeholderCSS = function placeholderCSS2(_ref3) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "placeholder",
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2,
    position: "absolute",
    top: "50%",
    transform: "translateY(-50%)"
  };
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("placeholder", props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};
var css$1 = function css6(_ref3) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "singleValue",
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2,
    maxWidth: "calc(100% - ".concat(spacing2.baseUnit * 2, "px)"),
    overflow: "hidden",
    position: "absolute",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    top: "50%",
    transform: "translateY(-50%)"
  };
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("singleValue", props),
    className: cx({
      "single-value": true,
      "single-value--is-disabled": isDisabled
    }, className)
  }, innerProps), children);
};
var components = {
  ClearIndicator,
  Control,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group2,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input,
  LoadingIndicator,
  Menu,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option,
  Placeholder,
  SelectContainer,
  SingleValue,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/react-select/dist/Select-dbb12e54.esm.js
var import_react14 = __toModule(require("react"));

// node_modules/memoize-one/dist/memoize-one.esm.js
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/react-select/dist/Select-dbb12e54.esm.js
var _ref = true ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFJIiwiZmlsZSI6IkExMXlUZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgdHlwZSBFbGVtZW50Q29uZmlnIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vLyBBc3Npc3RpdmUgdGV4dCB0byBkZXNjcmliZSB2aXN1YWwgZWxlbWVudHMuIEhpZGRlbiBmb3Igc2lnaHRlZCB1c2Vycy5cbmNvbnN0IEExMXlUZXh0ID0gKHByb3BzOiBFbGVtZW50Q29uZmlnPCdzcGFuJz4pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, _props$focused = props.focused, focused = _props$focused === void 0 ? {} : _props$focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = (0, import_react14.useMemo)(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = (0, import_react14.useMemo)(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, removedValue = ariaSelection.removedValue, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var onChangeProps = _objectSpread2({
        isDisabled: selected && isOptionDisabled3(selected),
        label: selected ? getOptionLabel4(selected) : ""
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, isOptionDisabled3, getOptionLabel4, messages]);
  var ariaFocused = (0, import_react14.useMemo)(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused),
        isSelected,
        options: options2,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, options2, selectValue]);
  var ariaResults = (0, import_react14.useMemo)(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = (0, import_react14.useMemo)(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  return jsx(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && jsx(import_react14.default.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext)));
};
var diacritics = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  diacritic = diacritics[i];
  for (j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var diacritic;
var j;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoize_one_esm_default(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input2 = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input2 = input2.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = memoizedStripDiacriticsForInput(input2);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
};
function DummyInput(_ref3) {
  _ref3.in;
  _ref3.out;
  _ref3.onExited;
  _ref3.appear;
  _ref3.enter;
  _ref3.exit;
  var innerRef = _ref3.innerRef;
  _ref3.emotion;
  var props = _objectWithoutProperties(_ref3, ["in", "out", "onExited", "appear", "enter", "exit", "innerRef", "emotion"]);
  return jsx("input", _extends({
    ref: innerRef
  }, props, {
    css: /* @__PURE__ */ css3({
      label: "dummyInput",
      background: 0,
      border: 0,
      fontSize: "inherit",
      outline: 0,
      padding: 0,
      width: 1,
      color: "transparent",
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(0)"
    }, true ? "" : ";label:DummyInput;", true ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbUJNIiwiZmlsZSI6IkR1bW15SW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbjogaW5Qcm9wLFxuICBvdXQsXG4gIG9uRXhpdGVkLFxuICBhcHBlYXIsXG4gIGVudGVyLFxuICBleGl0LFxuICBpbm5lclJlZixcbiAgZW1vdGlvbixcbiAgLi4ucHJvcHNcbn06IGFueSkge1xuICByZXR1cm4gKFxuICAgIDxpbnB1dFxuICAgICAgcmVmPXtpbm5lclJlZn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = (0, import_react14.useRef)(false);
  var isTop = (0, import_react14.useRef)(false);
  var touchStart = (0, import_react14.useRef)(0);
  var scrollTarget = (0, import_react14.useRef)(null);
  var handleEventDelta = (0, import_react14.useCallback)(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, []);
  var onWheel = (0, import_react14.useCallback)(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0, import_react14.useCallback)(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0, import_react14.useCallback)(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0, import_react14.useCallback)(function(el2) {
    if (!el2)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("wheel", onWheel, notPassive);
    }
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("touchstart", onTouchStart, notPassive);
    }
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("touchmove", onTouchMove, notPassive);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0, import_react14.useCallback)(function(el2) {
    if (!el2)
      return;
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("wheel", onWheel, false);
    }
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("touchstart", onTouchStart, false);
    }
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("touchmove", onTouchMove, false);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  (0, import_react14.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  e2.preventDefault();
}
function allowTouchMove(e2) {
  e2.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0, import_react14.useRef)({});
  var scrollTarget = (0, import_react14.useRef)(null);
  var addScrollLock = (0, import_react14.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, []);
  var removeScrollLock = (0, import_react14.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, []);
  (0, import_react14.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref22 = true ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0RVIiwiZmlsZSI6IlNjcm9sbE1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgUmVhY3QsIHsgdHlwZSBFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNjcm9sbENhcHR1cmUgZnJvbSAnLi91c2VTY3JvbGxDYXB0dXJlJztcbmltcG9ydCB1c2VTY3JvbGxMb2NrIGZyb20gJy4vdXNlU2Nyb2xsTG9jayc7XG5cbnR5cGUgUmVmQ2FsbGJhY2s8VD4gPSAoVCB8IG51bGwpID0+IHZvaWQ7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNoaWxkcmVuOiAoUmVmQ2FsbGJhY2s8SFRNTEVsZW1lbnQ+KSA9PiBFbGVtZW50PCo+LFxuICBsb2NrRW5hYmxlZDogYm9vbGVhbixcbiAgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW4sXG4gIG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRWxlbWVudD4pID0+IHZvaWQsXG4gIG9uQm90dG9tTGVhdmU/OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxFbGVtZW50PikgPT4gdm9pZCxcbiAgb25Ub3BBcnJpdmU/OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxFbGVtZW50PikgPT4gdm9pZCxcbiAgb25Ub3BMZWF2ZT86IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB2b2lkLFxufTtcblxuY29uc3QgYmx1clNlbGVjdElucHV0ID0gKCkgPT5cbiAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2Nyb2xsTWFuYWdlcih7XG4gIGNoaWxkcmVuLFxuICBsb2NrRW5hYmxlZCxcbiAgY2FwdHVyZUVuYWJsZWQgPSB0cnVlLFxuICBvbkJvdHRvbUFycml2ZSxcbiAgb25Cb3R0b21MZWF2ZSxcbiAgb25Ub3BBcnJpdmUsXG4gIG9uVG9wTGVhdmUsXG59OiBQcm9wcykge1xuICBjb25zdCBzZXRTY3JvbGxDYXB0dXJlVGFyZ2V0ID0gdXNlU2Nyb2xsQ2FwdHVyZSh7XG4gICAgaXNFbmFibGVkOiBjYXB0dXJlRW5hYmxlZCxcbiAgICBvbkJvdHRvbUFycml2ZSxcbiAgICBvbkJvdHRvbUxlYXZlLFxuICAgIG9uVG9wQXJyaXZlLFxuICAgIG9uVG9wTGVhdmUsXG4gIH0pO1xuICBjb25zdCBzZXRTY3JvbGxMb2NrVGFyZ2V0ID0gdXNlU2Nyb2xsTG9jayh7IGlzRW5hYmxlZDogbG9ja0VuYWJsZWQgfSk7XG5cbiAgY29uc3QgdGFyZ2V0UmVmID0gZWxlbWVudCA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(import_react14.default.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref22
  }), children(targetRef));
}
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel = function getOptionLabel2(option) {
  return option.label;
};
var getOptionValue = function getOptionValue2(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles2 = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css4,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css$1,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel,
  getOptionValue,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: "0",
  tabSelectsValue: true
};
function toCategorizedOption(props, option, selectValue, index4) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel$1(props, option);
  var value = getOptionValue$1(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index4
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if (groupOrOption.options) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(function(categorizedOption) {
    return !!categorizedOption;
  });
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data3 = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data: data3
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel$1 = function getOptionLabel3(props, data3) {
  return props.getOptionLabel(data3);
};
var getOptionValue$1 = function getOptionValue3(props, data3) {
  return props.getOptionValue(data3);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue$1(props, option);
  return selectValue.some(function(i) {
    return getOptionValue$1(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name2 = _this$props.name;
      actionMeta.name = name2;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue) {
      var action = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "set-value";
      var option = arguments.length > 2 ? arguments[2] : void 0;
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti;
      _this.onInputChange("", {
        action: "set-value"
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name2 = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        }), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue([].concat(_toConsumableArray(selectValue), [newValue]), "select-option", newValue);
        } else {
          _this.setValue(newValue, "select-option");
        }
      } else {
        _this.ariaOnChange(newValue, {
          action: "select-option",
          name: name2
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(_this.props.isMulti ? [] : null, {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data3) {
      return getOptionLabel$1(_this.props, data3);
    };
    _this.getOptionValue = function(data3) {
      return getOptionValue$1(_this.props, data3);
    };
    _this.getStyles = function(key, props) {
      var base = defaultStyles2[key](props);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
      event.stopPropagation();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.stopPropagation();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change"
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur"
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close"
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (isFocused && !isDisabled && prevProps.isDisabled || isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close"
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: function getTheme() {
      if (!this.props.theme) {
        return defaultTheme;
      }
      if (typeof this.props.theme === "function") {
        return this.props.theme(defaultTheme);
      }
      return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles3 = this.getStyles, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles: getStyles3,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data3, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var inputValue = this.props.inputValue;
        var selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data3, {
          context,
          inputValue,
          selectValue
        });
      } else {
        return this.getOptionLabel(data3);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data3) {
      return this.props.formatGroupLabel(data3);
    }
  }, {
    key: "startListeningComposition",
    value: function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener("compositionstart", this.onCompositionStart, false);
        document.addEventListener("compositionend", this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener("touchstart", this.onTouchStart, false);
        document.addEventListener("touchmove", this.onTouchMove, false);
        document.addEventListener("touchend", this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: function renderInput() {
      var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form;
      var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
      var inputIsHidden = this.state.inputIsHidden;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId("input");
      var ariaAttributes = {
        "aria-autocomplete": "list",
        "aria-label": this.props["aria-label"],
        "aria-labelledby": this.props["aria-labelledby"]
      };
      if (!isSearchable) {
        return /* @__PURE__ */ import_react14.default.createElement(DummyInput, _extends({
          id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          readOnly: true,
          disabled: isDisabled,
          tabIndex,
          form,
          value: ""
        }, ariaAttributes));
      }
      return /* @__PURE__ */ import_react14.default.createElement(Input3, _extends({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id,
        innerRef: this.getInputRef,
        isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex,
        form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state4 = this.state, selectValue = _this$state4.selectValue, focusedValue = _this$state4.focusedValue, isFocused = _this$state4.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ import_react14.default.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused
        }), placeholder);
      }
      if (isMulti) {
        var selectValues = selectValue.map(function(opt, index4) {
          var isOptionFocused = opt === focusedValue;
          return /* @__PURE__ */ import_react14.default.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key: "".concat(_this3.getOptionValue(opt)).concat(index4),
            index: index4,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e2) {
                e2.preventDefault();
                e2.stopPropagation();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
        return selectValues;
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ import_react14.default.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ import_react14.default.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group4 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal2 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render2 = function render3(props, id) {
        var type = props.type, data3 = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data3;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data3);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data3);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ import_react14.default.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data: data3,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var data3 = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ import_react14.default.createElement(Group4, _extends({}, commonProps, {
              key: groupId,
              data: data3,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render2(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render2(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = /* @__PURE__ */ import_react14.default.createElement(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ import_react14.default.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ import_react14.default.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ import_react14.default.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading,
          placement
        }), /* @__PURE__ */ import_react14.default.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ import_react14.default.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ import_react14.default.createElement(MenuPortal2, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name2 = _this$props13.name;
      var selectValue = this.state.selectValue;
      if (!name2 || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ import_react14.default.createElement("input", {
            name: name2,
            type: "hidden",
            value
          });
        } else {
          var input2 = selectValue.length > 0 ? selectValue.map(function(opt, i) {
            return /* @__PURE__ */ import_react14.default.createElement("input", {
              key: "i-".concat(i),
              name: name2,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ import_react14.default.createElement("input", {
            name: name2,
            type: "hidden"
          });
          return /* @__PURE__ */ import_react14.default.createElement("div", null, input2);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ import_react14.default.createElement("input", {
          name: name2,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state5 = this.state, ariaSelection = _this$state5.ariaSelection, focusedOption = _this$state5.focusedOption, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused, selectValue = _this$state5.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ import_react14.default.createElement(LiveRegion, _extends({}, commonProps, {
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ import_react14.default.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ import_react14.default.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ import_react14.default.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ import_react14.default.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue;
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var selectValue = cleanValue(value);
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props
      });
    }
  }]);
  return Select2;
}(import_react14.Component);
Select.defaultProps = defaultProps;

// node_modules/react-select/dist/stateManager-845a3300.esm.js
var import_react16 = __toModule(require("react"));
var defaultProps2 = {
  defaultInputValue: "",
  defaultMenuIsOpen: false,
  defaultValue: null
};
var manageState = function manageState2(SelectComponent) {
  var _class, _temp;
  return _temp = _class = /* @__PURE__ */ function(_Component) {
    _inherits(StateManager, _Component);
    var _super = _createSuper(StateManager);
    function StateManager() {
      var _this;
      _classCallCheck(this, StateManager);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.select = void 0;
      _this.state = {
        inputValue: _this.props.inputValue !== void 0 ? _this.props.inputValue : _this.props.defaultInputValue,
        menuIsOpen: _this.props.menuIsOpen !== void 0 ? _this.props.menuIsOpen : _this.props.defaultMenuIsOpen,
        value: _this.props.value !== void 0 ? _this.props.value : _this.props.defaultValue
      };
      _this.onChange = function(value, actionMeta) {
        _this.callProp("onChange", value, actionMeta);
        _this.setState({
          value
        });
      };
      _this.onInputChange = function(value, actionMeta) {
        var newValue = _this.callProp("onInputChange", value, actionMeta);
        _this.setState({
          inputValue: newValue !== void 0 ? newValue : value
        });
      };
      _this.onMenuOpen = function() {
        _this.callProp("onMenuOpen");
        _this.setState({
          menuIsOpen: true
        });
      };
      _this.onMenuClose = function() {
        _this.callProp("onMenuClose");
        _this.setState({
          menuIsOpen: false
        });
      };
      return _this;
    }
    _createClass(StateManager, [{
      key: "focus",
      value: function focus() {
        this.select.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.select.blur();
      }
    }, {
      key: "getProp",
      value: function getProp(key) {
        return this.props[key] !== void 0 ? this.props[key] : this.state[key];
      }
    }, {
      key: "callProp",
      value: function callProp(name2) {
        if (typeof this.props[name2] === "function") {
          var _this$props;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return (_this$props = this.props)[name2].apply(_this$props, args);
        }
      }
    }, {
      key: "render",
      value: function render2() {
        var _this2 = this;
        var _this$props2 = this.props;
        _this$props2.defaultInputValue;
        _this$props2.defaultMenuIsOpen;
        _this$props2.defaultValue;
        var props = _objectWithoutProperties(_this$props2, ["defaultInputValue", "defaultMenuIsOpen", "defaultValue"]);
        return /* @__PURE__ */ import_react16.default.createElement(SelectComponent, _extends({}, props, {
          ref: function ref(_ref3) {
            _this2.select = _ref3;
          },
          inputValue: this.getProp("inputValue"),
          menuIsOpen: this.getProp("menuIsOpen"),
          onChange: this.onChange,
          onInputChange: this.onInputChange,
          onMenuClose: this.onMenuClose,
          onMenuOpen: this.onMenuOpen,
          value: this.getProp("value")
        }));
      }
    }]);
    return StateManager;
  }(import_react16.Component), _class.defaultProps = defaultProps2, _temp;
};

// node_modules/react-select/dist/react-select.esm.js
var import_react17 = __toModule(require("react"));
var import_react_input_autosize2 = __toModule(require_AutosizeInput());
var import_react_dom2 = __toModule(require("react-dom"));
var index3 = manageState(Select);
var react_select_esm_default = index3;

// node_modules/spacetime/builds/spacetime.mjs
function _typeof4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n = Object.prototype.toString.call(o2).slice(8, -1);
  if (n === "Object" && o2.constructor)
    n = o2.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o2);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var MSEC_IN_HOUR = 60 * 60 * 1e3;
var toUtc = function toUtc2(dstChange, offset3, year6) {
  var _dstChange$split = dstChange.split("/"), _dstChange$split2 = _slicedToArray(_dstChange$split, 2), month6 = _dstChange$split2[0], rest = _dstChange$split2[1];
  var _rest$split = rest.split(":"), _rest$split2 = _slicedToArray(_rest$split, 2), day5 = _rest$split2[0], hour5 = _rest$split2[1];
  return Date.UTC(year6, month6 - 1, day5, hour5) - offset3 * MSEC_IN_HOUR;
};
var inSummerTime = function inSummerTime2(epoch, start, end, summerOffset, winterOffset) {
  var year6 = new Date(epoch).getUTCFullYear();
  var startUtc = toUtc(start, winterOffset, year6);
  var endUtc = toUtc(end, summerOffset, year6);
  return epoch >= startUtc && epoch < endUtc;
};
var summerTime = inSummerTime;
var quickOffset = function quickOffset2(s2) {
  var zones2 = s2.timezones;
  var obj = zones2[s2.tz];
  if (obj === void 0) {
    console.warn("Warning: couldn't find timezone " + s2.tz);
    return 0;
  }
  if (obj.dst === void 0) {
    return obj.offset;
  }
  var jul = obj.offset;
  var dec = obj.offset + 1;
  if (obj.hem === "n") {
    dec = jul - 1;
  }
  var split = obj.dst.split("->");
  var inSummer = summerTime(s2.epoch, split[0], split[1], jul, dec);
  if (inSummer === true) {
    return jul;
  }
  return dec;
};
var quick = quickOffset;
var _build = {
  "9|s": "2/dili,2/jayapura",
  "9|n": "2/chita,2/khandyga,2/pyongyang,2/seoul,2/tokyo,11/palau",
  "9.5|s|04/04:03->10/03:02": "4/adelaide,4/broken_hill,4/south,4/yancowinna",
  "9.5|s": "4/darwin,4/north",
  "8|s|03/08:01->10/04:00": "12/casey",
  "8|s": "2/kuala_lumpur,2/makassar,2/singapore,4/perth,2/ujung_pandang,4/west",
  "8|n": "2/brunei,2/choibalsan,2/hong_kong,2/irkutsk,2/kuching,2/macau,2/manila,2/shanghai,2/taipei,2/ulaanbaatar,2/chongqing,2/chungking,2/harbin,2/macao,2/ulan_bator",
  "8.75|s": "4/eucla",
  "7|s": "12/davis,2/jakarta,9/christmas",
  "7|n": "2/bangkok,2/barnaul,2/hovd,2/krasnoyarsk,2/novokuznetsk,2/novosibirsk,2/phnom_penh,2/pontianak,2/saigon,2/tomsk,2/vientiane,2/ho_chi_minh",
  "6|s": "12/vostok",
  "6|n": "2/almaty,2/bishkek,2/dhaka,2/omsk,2/qyzylorda,2/qostanay,2/thimphu,2/urumqi,9/chagos,2/dacca,2/kashgar,2/thimbu",
  "6.5|n": "2/rangoon,9/cocos,2/yangon",
  "5|s": "12/mawson,9/kerguelen",
  "5|n": "2/aqtau,2/aqtobe,2/ashgabat,2/atyrau,2/baku,2/dushanbe,2/karachi,2/oral,2/samarkand,2/tashkent,2/yekaterinburg,9/maldives,2/ashkhabad",
  "5.75|n": "2/katmandu,2/kathmandu",
  "5.5|n": "2/calcutta,2/colombo,2/kolkata",
  "4|s": "9/reunion",
  "4|n": "2/dubai,2/muscat,2/tbilisi,2/yerevan,8/astrakhan,8/samara,8/saratov,8/ulyanovsk,8/volgograd,2/volgograd,9/mahe,9/mauritius",
  "4.5|n|03/22:00->09/21:24": "2/tehran",
  "4.5|n": "2/kabul",
  "3|s": "12/syowa,9/antananarivo",
  "3|n|03/28:03->10/31:04": "2/famagusta,2/nicosia,8/athens,8/bucharest,8/helsinki,8/kiev,8/mariehamn,8/riga,8/sofia,8/tallinn,8/uzhgorod,8/vilnius,8/zaporozhye,8/nicosia",
  "3|n|03/28:02->10/31:03": "8/chisinau,8/tiraspol",
  "3|n|03/28:00->10/30:24": "2/beirut",
  "3|n|03/27:00->10/30:01": "2/gaza,2/hebron",
  "3|n|03/26:02->10/31:02": "2/jerusalem,2/tel_aviv",
  "3|n|03/26:00->10/29:01": "2/amman",
  "3|n|03/26:00->10/28:24": "2/damascus",
  "3|n": "0/addis_ababa,0/asmera,0/dar_es_salaam,0/djibouti,0/juba,0/kampala,0/mogadishu,0/nairobi,2/aden,2/baghdad,2/bahrain,2/kuwait,2/qatar,2/riyadh,8/istanbul,8/kirov,8/minsk,8/moscow,8/simferopol,9/comoro,9/mayotte,0/asmara,2/istanbul",
  "2|s|03/28:02->10/31:02": "12/troll",
  "2|s": "0/gaborone,0/harare,0/johannesburg,0/lubumbashi,0/lusaka,0/maputo,0/maseru,0/mbabane",
  "2|n|03/28:02->10/31:03": "0/ceuta,arctic/longyearbyen,8/amsterdam,8/andorra,8/belgrade,8/berlin,8/bratislava,8/brussels,8/budapest,8/busingen,8/copenhagen,8/gibraltar,8/ljubljana,8/luxembourg,8/madrid,8/malta,8/monaco,8/oslo,8/paris,8/podgorica,8/prague,8/rome,8/san_marino,8/sarajevo,8/skopje,8/stockholm,8/tirane,8/vaduz,8/vatican,8/vienna,8/warsaw,8/zagreb,8/zurich,3/jan_mayen",
  "2|n": "0/blantyre,0/bujumbura,0/cairo,0/khartoum,0/kigali,0/tripoli,8/kaliningrad",
  "1|s": "0/brazzaville,0/kinshasa,0/luanda,0/windhoek",
  "1|n|04/11:03->05/16:02": "0/casablanca,0/el_aaiun",
  "1|n|03/28:01->10/31:02": "3/canary,3/faeroe,3/madeira,8/dublin,8/guernsey,8/isle_of_man,8/jersey,8/lisbon,8/london,3/faroe,8/belfast",
  "1|n": "0/algiers,0/bangui,0/douala,0/lagos,0/libreville,0/malabo,0/ndjamena,0/niamey,0/porto-novo,0/tunis",
  "14|n": "11/kiritimati",
  "13|s|04/04:04->09/26:03": "11/apia",
  "13|s|01/15:02->11/05:03": "11/tongatapu",
  "13|n": "11/enderbury,11/fakaofo",
  "12|s|04/04:03->09/26:02": "12/mcmurdo,11/auckland,12/south_pole",
  "12|s|01/17:03->11/14:02": "11/fiji",
  "12|n": "2/anadyr,2/kamchatka,2/srednekolymsk,11/funafuti,11/kwajalein,11/majuro,11/nauru,11/tarawa,11/wake,11/wallis",
  "12.75|s|04/04:03->04/04:02": "11/chatham",
  "11|s|04/04:03->10/03:02": "12/macquarie",
  "11|s": "11/bougainville",
  "11|n": "2/magadan,2/sakhalin,11/efate,11/guadalcanal,11/kosrae,11/noumea,11/ponape,11/pohnpei",
  "11.5|n|04/04:03->10/03:02": "11/norfolk",
  "10|s|04/04:03->10/03:02": "4/currie,4/hobart,4/melbourne,4/sydney,4/act,4/canberra,4/nsw,4/tasmania,4/victoria",
  "10|s": "12/dumontdurville,4/brisbane,4/lindeman,11/port_moresby,4/queensland",
  "10|n": "2/ust-nera,2/vladivostok,2/yakutsk,11/guam,11/saipan,11/truk,11/chuuk,11/yap",
  "10.5|s|04/04:01->10/03:02": "4/lord_howe,4/lhi",
  "0|n|03/28:00->10/31:01": "1/scoresbysund,3/azores",
  "0|n": "0/abidjan,0/accra,0/bamako,0/banjul,0/bissau,0/conakry,0/dakar,0/freetown,0/lome,0/monrovia,0/nouakchott,0/ouagadougou,0/sao_tome,1/danmarkshavn,3/reykjavik,3/st_helena,13/gmt,13/utc,0/timbuktu,13/gmt-0,13/gmt+0,13/gmt0,13/greenwich,13/uct,13/universal,13/zulu",
  "-9|n|03/14:02->11/07:02": "1/adak,1/atka,us/aleutian",
  "-9|n": "11/gambier",
  "-9.5|n": "11/marquesas",
  "-8|n|03/14:02->11/07:02": "1/anchorage,1/juneau,1/metlakatla,1/nome,1/sitka,1/yakutat,us/alaska",
  "-8|n": "11/pitcairn",
  "-7|n|03/14:02->11/07:02": "1/los_angeles,1/santa_isabel,1/tijuana,1/vancouver,1/ensenada,6/pacific,10/bajanorte,us/pacific-new,us/pacific",
  "-7|n|03/08:02->11/01:01": "1/dawson,1/whitehorse,6/yukon",
  "-7|n": "1/creston,1/dawson_creek,1/fort_nelson,1/hermosillo,1/phoenix,us/arizona",
  "-6|s|04/03:22->09/04:22": "11/easter,7/easterisland",
  "-6|n|04/04:02->10/31:02": "1/chihuahua,1/mazatlan,10/bajasur",
  "-6|n|03/14:02->11/07:02": "1/boise,1/cambridge_bay,1/denver,1/edmonton,1/inuvik,1/ojinaga,1/yellowknife,1/shiprock,6/mountain,us/mountain",
  "-6|n": "1/belize,1/costa_rica,1/el_salvador,1/guatemala,1/managua,1/regina,1/swift_current,1/tegucigalpa,11/galapagos,6/east-saskatchewan,6/saskatchewan",
  "-5|s": "1/lima,1/rio_branco,1/porto_acre,5/acre",
  "-5|n|04/04:02->10/31:02": "1/bahia_banderas,1/merida,1/mexico_city,1/monterrey,10/general",
  "-5|n|03/14:02->11/07:02": "1/chicago,1/matamoros,1/menominee,1/rainy_river,1/rankin_inlet,1/resolute,1/winnipeg,1/indiana/knox,1/indiana/tell_city,1/north_dakota/beulah,1/north_dakota/center,1/north_dakota/new_salem,1/knox_in,6/central,us/central,us/indiana-starke",
  "-5|n|03/12:03->11/05:01": "1/north_dakota",
  "-5|n": "1/bogota,1/cancun,1/cayman,1/coral_harbour,1/eirunepe,1/guayaquil,1/jamaica,1/panama,1/atikokan",
  "-4|s|05/13:23->08/13:01": "12/palmer",
  "-4|s|04/03:24->09/05:00": "1/santiago,7/continental",
  "-4|s|03/27:24->10/03:00": "1/asuncion",
  "-4|s|02/16:24->11/03:00": "1/campo_grande,1/cuiaba",
  "-4|s": "1/la_paz,1/manaus,5/west",
  "-4|n|03/14:02->11/07:02": "1/detroit,1/grand_turk,1/indianapolis,1/iqaluit,1/louisville,1/montreal,1/nassau,1/new_york,1/nipigon,1/pangnirtung,1/port-au-prince,1/thunder_bay,1/toronto,1/indiana/marengo,1/indiana/petersburg,1/indiana/vevay,1/indiana/vincennes,1/indiana/winamac,1/kentucky/monticello,1/fort_wayne,1/indiana/indianapolis,1/kentucky/louisville,6/eastern,us/east-indiana,us/eastern,us/michigan",
  "-4|n|03/14:00->11/07:01": "1/havana",
  "-4|n|03/12:03->11/05:01": "1/indiana,1/kentucky",
  "-4|n": "1/anguilla,1/antigua,1/aruba,1/barbados,1/blanc-sablon,1/boa_vista,1/caracas,1/curacao,1/dominica,1/grenada,1/guadeloupe,1/guyana,1/kralendijk,1/lower_princes,1/marigot,1/martinique,1/montserrat,1/port_of_spain,1/porto_velho,1/puerto_rico,1/santo_domingo,1/st_barthelemy,1/st_kitts,1/st_lucia,1/st_thomas,1/st_vincent,1/tortola,1/virgin",
  "-3|s": "1/argentina,1/buenos_aires,1/catamarca,1/cordoba,1/fortaleza,1/jujuy,1/mendoza,1/montevideo,1/punta_arenas,1/sao_paulo,12/rothera,3/stanley,1/argentina/la_rioja,1/argentina/rio_gallegos,1/argentina/salta,1/argentina/san_juan,1/argentina/san_luis,1/argentina/tucuman,1/argentina/ushuaia,1/argentina/buenos_aires,1/argentina/catamarca,1/argentina/comodrivadavia,1/argentina/cordoba,1/argentina/jujuy,1/argentina/mendoza,1/rosario,5/east",
  "-3|n|03/14:02->11/07:02": "1/glace_bay,1/goose_bay,1/halifax,1/moncton,1/thule,3/bermuda,6/atlantic",
  "-3|n": "1/araguaina,1/bahia,1/belem,1/cayenne,1/maceio,1/paramaribo,1/recife,1/santarem",
  "-2|n|03/27:22->10/30:23": "1/godthab,1/nuuk",
  "-2|n|03/14:02->11/07:02": "1/miquelon",
  "-2|n": "1/noronha,3/south_georgia,5/denoronha",
  "-2.5|n|03/14:02->11/07:02": "1/st_johns,6/newfoundland",
  "-1|n": "3/cape_verde",
  "-11|n": "11/midway,11/niue,11/pago_pago,11/samoa,us/samoa",
  "-10|n": "11/honolulu,11/johnston,11/rarotonga,11/tahiti,us/hawaii"
};
var _build$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: _build
});
var _prefixes = ["africa", "america", "asia", "atlantic", "australia", "brazil", "canada", "chile", "europe", "indian", "mexico", "pacific", "antarctica", "etc"];
function createCommonjsModule(fn, module2) {
  return module2 = {exports: {}}, fn(module2, module2.exports), module2.exports;
}
function getCjsExportFromNamespace(n) {
  return n && n["default"] || n;
}
var data = getCjsExportFromNamespace(_build$1);
var all = {};
Object.keys(data).forEach(function(k) {
  var split = k.split("|");
  var obj = {
    offset: Number(split[0]),
    hem: split[1]
  };
  if (split[2]) {
    obj.dst = split[2];
  }
  var names = data[k].split(",");
  names.forEach(function(str) {
    str = str.replace(/(^[0-9]+)\//, function(before, num) {
      num = Number(num);
      return _prefixes[num] + "/";
    });
    all[str] = obj;
  });
});
all["utc"] = {
  offset: 0,
  hem: "n"
};
for (var i = -14; i <= 14; i += 0.5) {
  num = i;
  if (num > 0) {
    num = "+" + num;
  }
  name2 = "etc/gmt" + num;
  all[name2] = {
    offset: i * -1,
    hem: "n"
  };
  name2 = "utc/gmt" + num;
  all[name2] = {
    offset: i * -1,
    hem: "n"
  };
}
var num;
var name2;
var unpack = all;
var fallbackTZ = "utc";
var safeIntl = function safeIntl2() {
  if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
    return null;
  }
  var format3 = Intl.DateTimeFormat();
  if (typeof format3 === "undefined" || typeof format3.resolvedOptions === "undefined") {
    return null;
  }
  var timezone5 = format3.resolvedOptions().timeZone;
  if (!timezone5) {
    return null;
  }
  return timezone5.toLowerCase();
};
var guessTz = function guessTz2() {
  var timezone5 = safeIntl();
  if (timezone5 === null) {
    return fallbackTZ;
  }
  return timezone5;
};
var guessTz_1 = guessTz;
var isOffset = /(\-?[0-9]+)h(rs)?/i;
var isNumber = /(\-?[0-9]+)/;
var utcOffset = /utc([\-+]?[0-9]+)/i;
var gmtOffset = /gmt([\-+]?[0-9]+)/i;
var toIana = function toIana2(num) {
  num = Number(num);
  if (num >= -13 && num <= 13) {
    num = num * -1;
    num = (num > 0 ? "+" : "") + num;
    return "etc/gmt" + num;
  }
  return null;
};
var parseOffset$1 = function parseOffset(tz) {
  var m2 = tz.match(isOffset);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  m2 = tz.match(utcOffset);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  m2 = tz.match(gmtOffset);
  if (m2 !== null) {
    var num = Number(m2[1]) * -1;
    return toIana(num);
  }
  m2 = tz.match(isNumber);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  return null;
};
var parseOffset_1$1 = parseOffset$1;
var local = guessTz_1();
var cities = Object.keys(unpack).reduce(function(h2, k) {
  var city = k.split("/")[1] || "";
  city = city.replace(/_/g, " ");
  h2[city] = k;
  return h2;
}, {});
var normalize = function normalize2(tz) {
  tz = tz.replace(/ time/g, "");
  tz = tz.replace(/ (standard|daylight|summer)/g, "");
  tz = tz.replace(/\b(east|west|north|south)ern/g, "$1");
  tz = tz.replace(/\b(africa|america|australia)n/g, "$1");
  tz = tz.replace(/\beuropean/g, "europe");
  tz = tz.replace(/\islands/g, "island");
  return tz;
};
var lookupTz = function lookupTz2(str, zones2) {
  if (!str) {
    return local;
  }
  if (typeof str !== "string") {
    console.error("Timezone must be a string - recieved: '", str, "'\n");
  }
  var tz = str.trim();
  tz = tz.toLowerCase();
  if (zones2.hasOwnProperty(tz) === true) {
    return tz;
  }
  tz = normalize(tz);
  if (zones2.hasOwnProperty(tz) === true) {
    return tz;
  }
  if (cities.hasOwnProperty(tz) === true) {
    return cities[tz];
  }
  if (/[0-9]/.test(tz) === true) {
    var id = parseOffset_1$1(tz);
    if (id) {
      return id;
    }
  }
  throw new Error("Spacetime: Cannot find timezone named: '" + str + "'. Please enter an IANA timezone id.");
};
var find = lookupTz;
var o = {
  millisecond: 1
};
o.second = 1e3;
o.minute = 6e4;
o.hour = 36e5;
o.day = 864e5;
o.date = o.day;
o.month = 864e5 * 29.5;
o.week = 6048e5;
o.year = 3154e7;
Object.keys(o).forEach(function(k) {
  o[k + "s"] = o[k];
});
var milliseconds = o;
var walk = function walk2(s2, n, fn, unit, previous) {
  var current = s2.d[fn]();
  if (current === n) {
    return;
  }
  var startUnit = previous === null ? null : s2.d[previous]();
  var original = s2.epoch;
  var diff3 = n - current;
  s2.epoch += milliseconds[unit] * diff3;
  if (unit === "day") {
    if (Math.abs(diff3) > 28 && n < 28) {
      s2.epoch += milliseconds.hour;
    }
  }
  if (previous !== null && startUnit !== s2.d[previous]()) {
    s2.epoch = original;
  }
  var halfStep = milliseconds[unit] / 2;
  while (s2.d[fn]() < n) {
    s2.epoch += halfStep;
  }
  while (s2.d[fn]() > n) {
    s2.epoch -= halfStep;
  }
  if (previous !== null && startUnit !== s2.d[previous]()) {
    s2.epoch = original;
  }
};
var units$3 = {
  year: {
    valid: function valid(n) {
      return n > -4e3 && n < 4e3;
    },
    walkTo: function walkTo(s2, n) {
      return walk(s2, n, "getFullYear", "year", null);
    }
  },
  month: {
    valid: function valid2(n) {
      return n >= 0 && n <= 11;
    },
    walkTo: function walkTo2(s2, n) {
      var d2 = s2.d;
      var current = d2.getMonth();
      var original = s2.epoch;
      var startUnit = d2.getFullYear();
      if (current === n) {
        return;
      }
      var diff3 = n - current;
      s2.epoch += milliseconds.day * (diff3 * 28);
      if (startUnit !== s2.d.getFullYear()) {
        s2.epoch = original;
      }
      while (s2.d.getMonth() < n) {
        s2.epoch += milliseconds.day;
      }
      while (s2.d.getMonth() > n) {
        s2.epoch -= milliseconds.day;
      }
    }
  },
  date: {
    valid: function valid3(n) {
      return n > 0 && n <= 31;
    },
    walkTo: function walkTo3(s2, n) {
      return walk(s2, n, "getDate", "day", "getMonth");
    }
  },
  hour: {
    valid: function valid4(n) {
      return n >= 0 && n < 24;
    },
    walkTo: function walkTo4(s2, n) {
      return walk(s2, n, "getHours", "hour", "getDate");
    }
  },
  minute: {
    valid: function valid5(n) {
      return n >= 0 && n < 60;
    },
    walkTo: function walkTo5(s2, n) {
      return walk(s2, n, "getMinutes", "minute", "getHours");
    }
  },
  second: {
    valid: function valid6(n) {
      return n >= 0 && n < 60;
    },
    walkTo: function walkTo6(s2, n) {
      s2.epoch = s2.seconds(n).epoch;
    }
  },
  millisecond: {
    valid: function valid7(n) {
      return n >= 0 && n < 1e3;
    },
    walkTo: function walkTo7(s2, n) {
      s2.epoch = s2.milliseconds(n).epoch;
    }
  }
};
var walkTo8 = function walkTo9(s2, wants) {
  var keys = Object.keys(units$3);
  var old = s2.clone();
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    var n = wants[k];
    if (n === void 0) {
      n = old[k]();
    }
    if (typeof n === "string") {
      n = parseInt(n, 10);
    }
    if (!units$3[k].valid(n)) {
      s2.epoch = null;
      if (s2.silent === false) {
        console.warn("invalid " + k + ": " + n);
      }
      return;
    }
    units$3[k].walkTo(s2, n);
  }
  return;
};
var walk_1 = walkTo8;
var shortMonths = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sept", "oct", "nov", "dec"];
var longMonths = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function buildMapping() {
  var obj = {
    sep: 8
  };
  for (var i = 0; i < shortMonths.length; i++) {
    obj[shortMonths[i]] = i;
  }
  for (var _i = 0; _i < longMonths.length; _i++) {
    obj[longMonths[_i]] = _i;
  }
  return obj;
}
var months$1 = {
  short: function short() {
    return shortMonths;
  },
  long: function long() {
    return longMonths;
  },
  mapping: function mapping() {
    return buildMapping();
  },
  set: function set(i18n2) {
    shortMonths = i18n2["short"] || shortMonths;
    longMonths = i18n2["long"] || longMonths;
  }
};
var parseOffset2 = function parseOffset3(s2, offset3) {
  if (!offset3) {
    return s2;
  }
  if (offset3 === "Z" || offset3 === "z") {
    offset3 = "+0000";
  }
  var num = 0;
  if (/^[\+-]?[0-9]{2}:[0-9]{2}$/.test(offset3)) {
    if (/:00/.test(offset3) === true) {
      offset3 = offset3.replace(/:00/, "");
    }
    if (/:30/.test(offset3) === true) {
      offset3 = offset3.replace(/:30/, ".5");
    }
  }
  if (/^[\+-]?[0-9]{4}$/.test(offset3)) {
    offset3 = offset3.replace(/30$/, ".5");
  }
  num = parseFloat(offset3);
  if (Math.abs(num) > 100) {
    num = num / 100;
  }
  num *= -1;
  if (num >= 0) {
    num = "+" + num;
  }
  var tz = "etc/gmt" + num;
  var zones2 = s2.timezones;
  if (zones2[tz]) {
    s2.tz = tz;
  }
  return s2;
};
var parseOffset_1 = parseOffset2;
var parseTime = function parseTime2(s2) {
  var str = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  str = str.replace(/^\s+/, "").toLowerCase();
  var arr = str.match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:\.]?([0-9]{1,4})?/);
  if (arr !== null) {
    var h2 = Number(arr[1]);
    if (h2 < 0 || h2 > 24) {
      return s2.startOf("day");
    }
    var m2 = Number(arr[2]);
    if (arr[2].length < 2 || m2 < 0 || m2 > 59) {
      return s2.startOf("day");
    }
    if (arr[4] > 999) {
      arr[4] = parseInt("".concat(arr[4]).substring(0, 3), 10);
    }
    s2 = s2.hour(h2);
    s2 = s2.minute(m2);
    s2 = s2.seconds(arr[3] || 0);
    s2 = s2.millisecond(arr[4] || 0);
    var ampm3 = str.match(/[\b0-9](am|pm)\b/);
    if (ampm3 !== null && ampm3[1]) {
      s2 = s2.ampm(ampm3[1]);
    }
    return s2;
  }
  arr = str.match(/([0-9]+) ?(am|pm)/);
  if (arr !== null && arr[1]) {
    var _h = Number(arr[1]);
    if (_h > 12 || _h < 1) {
      return s2.startOf("day");
    }
    s2 = s2.hour(arr[1] || 0);
    s2 = s2.ampm(arr[2]);
    s2 = s2.startOf("hour");
    return s2;
  }
  s2 = s2.startOf("day");
  return s2;
};
var parseTime_1 = parseTime;
var monthLengths = [
  31,
  28,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var monthLengths_1 = monthLengths;
var fns = createCommonjsModule(function(module2, exports2) {
  exports2.isLeapYear = function(year6) {
    return year6 % 4 === 0 && year6 % 100 !== 0 || year6 % 400 === 0;
  };
  exports2.isDate = function(d2) {
    return Object.prototype.toString.call(d2) === "[object Date]" && !isNaN(d2.valueOf());
  };
  exports2.isArray = function(input2) {
    return Object.prototype.toString.call(input2) === "[object Array]";
  };
  exports2.isObject = function(input2) {
    return Object.prototype.toString.call(input2) === "[object Object]";
  };
  exports2.isBoolean = function(input2) {
    return Object.prototype.toString.call(input2) === "[object Boolean]";
  };
  exports2.zeroPad = function(str) {
    var len = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var pad2 = "0";
    str = str + "";
    return str.length >= len ? str : new Array(len - str.length + 1).join(pad2) + str;
  };
  exports2.titleCase = function(str) {
    if (!str) {
      return "";
    }
    return str[0].toUpperCase() + str.substr(1);
  };
  exports2.ordinal = function(i) {
    var j = i % 10;
    var k = i % 100;
    if (j === 1 && k !== 11) {
      return i + "st";
    }
    if (j === 2 && k !== 12) {
      return i + "nd";
    }
    if (j === 3 && k !== 13) {
      return i + "rd";
    }
    return i + "th";
  };
  exports2.toCardinal = function(str) {
    str = String(str);
    str = str.replace(/([0-9])(st|nd|rd|th)$/i, "$1");
    return parseInt(str, 10);
  };
  exports2.normalize = function() {
    var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    str = str.toLowerCase().trim();
    str = str.replace(/ies$/, "y");
    str = str.replace(/s$/, "");
    str = str.replace(/-/g, "");
    if (str === "day" || str === "days") {
      return "date";
    }
    if (str === "min" || str === "mins") {
      return "minute";
    }
    return str;
  };
  exports2.getEpoch = function(tmp2) {
    if (typeof tmp2 === "number") {
      return tmp2;
    }
    if (exports2.isDate(tmp2)) {
      return tmp2.getTime();
    }
    if (tmp2.epoch) {
      return tmp2.epoch;
    }
    return null;
  };
  exports2.beADate = function(d2, s2) {
    if (exports2.isObject(d2) === false) {
      return s2.clone().set(d2);
    }
    return d2;
  };
  exports2.formatTimezone = function(offset3) {
    var delimiter2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var sign2 = offset3 > 0 ? "+" : "-";
    var absOffset = Math.abs(offset3);
    var hours2 = exports2.zeroPad(parseInt("" + absOffset, 10));
    var minutes2 = exports2.zeroPad(absOffset % 1 * 60);
    return "".concat(sign2).concat(hours2).concat(delimiter2).concat(minutes2);
  };
});
fns.isLeapYear;
fns.isDate;
fns.isArray;
fns.isObject;
fns.isBoolean;
fns.zeroPad;
fns.titleCase;
fns.ordinal;
fns.toCardinal;
fns.normalize;
fns.getEpoch;
fns.beADate;
fns.formatTimezone;
var isLeapYear$2 = fns.isLeapYear;
var hasDate = function hasDate2(obj) {
  if (monthLengths_1.hasOwnProperty(obj.month) !== true) {
    return false;
  }
  if (obj.month === 1) {
    if (isLeapYear$2(obj.year) && obj.date <= 29) {
      return true;
    } else {
      return obj.date <= 28;
    }
  }
  var max = monthLengths_1[obj.month] || 0;
  if (obj.date <= max) {
    return true;
  }
  return false;
};
var hasDate_1 = hasDate;
var months = months$1.mapping();
var parseYear = function parseYear2() {
  var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var today2 = arguments.length > 1 ? arguments[1] : void 0;
  var year6 = parseInt(str.trim(), 10);
  if (!year6 && today2) {
    year6 = today2.year;
  }
  year6 = year6 || new Date().getFullYear();
  return year6;
};
var strFmt = [
  {
    reg: /^(\-?0?0?[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-\+:]+)?$/i,
    parse: function parse4(s2, arr, givenTz, options2) {
      var month6 = parseInt(arr[2], 10) - 1;
      var obj = {
        year: arr[1],
        month: month6,
        date: arr[3]
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      parseOffset_1(s2, arr[5]);
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([0-9]{4})[\-\/.]([0-9]{1,2})[\-\/.]([0-9]{1,2}),?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
    parse: function parse5(s2, arr) {
      var obj = {
        year: arr[1],
        month: parseInt(arr[2], 10) - 1,
        date: parseInt(arr[3], 10)
      };
      if (obj.month >= 12) {
        obj.date = parseInt(arr[2], 10);
        obj.month = parseInt(arr[3], 10) - 1;
      }
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([0-9]{1,2})[\-\/.]([0-9]{1,2})[\-\/.]?([0-9]{4})?,?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
    parse: function parse6(s2, arr) {
      var month6 = parseInt(arr[1], 10) - 1;
      var date4 = parseInt(arr[2], 10);
      if (s2.british || month6 >= 12) {
        date4 = parseInt(arr[1], 10);
        month6 = parseInt(arr[2], 10) - 1;
      }
      var year6 = parseYear(arr[3], s2._today) || new Date().getFullYear();
      var obj = {
        year: year6,
        month: month6,
        date: date4
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([0-9]{4})[\-\/]([0-9]{2})$/i,
    parse: function parse7(s2, arr, givenTz, options2) {
      var month6 = parseInt(arr[2], 10) - 1;
      var obj = {
        year: arr[1],
        month: month6,
        date: 1
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      parseOffset_1(s2, arr[5]);
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([0-9]{1,2})[\-\/]([a-z]+)[\-\/]?([0-9]{4})?$/i,
    parse: function parse8(s2, arr) {
      var month6 = months[arr[2].toLowerCase()];
      var year6 = parseYear(arr[3], s2._today);
      var obj = {
        year: year6,
        month: month6,
        date: fns.toCardinal(arr[1] || "")
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([a-z]+)[\-\/]([0-9]{1,2})[\-\/]?([0-9]{4})?$/i,
    parse: function parse9(s2, arr) {
      var month6 = months[arr[1].toLowerCase()];
      var year6 = parseYear(arr[3], s2._today);
      var obj = {
        year: year6,
        month: month6,
        date: fns.toCardinal(arr[2] || "")
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([a-z]+) ([0-9]{1,2}(?:st|nd|rd|th)?),?( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i,
    parse: function parse10(s2, arr) {
      var month6 = months[arr[1].toLowerCase()];
      var year6 = parseYear(arr[3], s2._today);
      var obj = {
        year: year6,
        month: month6,
        date: fns.toCardinal(arr[2] || "")
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([a-z]+) ([0-9]{4})$/i,
    parse: function parse11(s2, arr) {
      var month6 = months[arr[1].toLowerCase()];
      var year6 = parseYear(arr[2], s2._today);
      var obj = {
        year: year6,
        month: month6,
        date: s2._today.date || 1
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^([0-9]{1,2}(?:st|nd|rd|th)?) ([a-z]+),?( [0-9]{4})?,? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i,
    parse: function parse12(s2, arr) {
      var month6 = months[arr[2].toLowerCase()];
      if (!month6) {
        return null;
      }
      var year6 = parseYear(arr[3], s2._today);
      var obj = {
        year: year6,
        month: month6,
        date: fns.toCardinal(arr[1])
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2, arr[4]);
      return s2;
    }
  },
  {
    reg: /^(q[0-9])( of)?( [0-9]{4})?/i,
    parse: function parse13(s2, arr) {
      var quarter5 = arr[1] || "";
      s2 = s2.quarter(quarter5);
      var year6 = arr[3] || "";
      if (year6) {
        year6 = year6.trim();
        s2 = s2.year(year6);
      }
      return s2;
    }
  },
  {
    reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,
    parse: function parse14(s2, arr) {
      var season4 = arr[1] || "";
      s2 = s2.season(season4);
      var year6 = arr[3] || "";
      if (year6) {
        year6 = year6.trim();
        s2 = s2.year(year6);
      }
      return s2;
    }
  },
  {
    reg: /^[0-9,]+ ?b\.?c\.?$/i,
    parse: function parse15(s2, arr) {
      var str = arr[0] || "";
      str = str.replace(/^([0-9,]+) ?b\.?c\.?$/i, "-$1");
      str = str.replace(/,/g, "");
      var year6 = parseInt(str.trim(), 10);
      var d2 = new Date();
      var obj = {
        year: year6,
        month: d2.getMonth(),
        date: d2.getDate()
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2);
      return s2;
    }
  },
  {
    reg: /^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i,
    parse: function parse16(s2, arr) {
      var str = arr[0] || "";
      str = str.replace(/,/g, "");
      var year6 = parseInt(str.trim(), 10);
      var d2 = new Date();
      var obj = {
        year: year6,
        month: d2.getMonth(),
        date: d2.getDate()
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2);
      return s2;
    }
  },
  {
    reg: /^[0-9]{4}( ?a\.?d\.?)?$/i,
    parse: function parse17(s2, arr) {
      var today2 = s2._today;
      var year6 = parseYear(arr[0], today2);
      var d2 = new Date();
      if (today2.month && !today2.date) {
        today2.date = 1;
      }
      var obj = {
        year: year6,
        month: today2.month || d2.getMonth(),
        date: today2.date || d2.getDate()
      };
      if (hasDate_1(obj) === false) {
        s2.epoch = null;
        return s2;
      }
      walk_1(s2, obj);
      s2 = parseTime_1(s2);
      return s2;
    }
  }
];
var strParse = strFmt;
var getNow = function getNow2(s2) {
  s2.epoch = Date.now();
  Object.keys(s2._today || {}).forEach(function(k) {
    if (typeof s2[k] === "function") {
      s2 = s2[k](s2._today[k]);
    }
  });
  return s2;
};
var dates = {
  now: function now3(s2) {
    return getNow(s2);
  },
  today: function today(s2) {
    return getNow(s2);
  },
  tonight: function tonight(s2) {
    s2 = getNow(s2);
    s2 = s2.hour(18);
    return s2;
  },
  tomorrow: function tomorrow(s2) {
    s2 = getNow(s2);
    s2 = s2.add(1, "day");
    s2 = s2.startOf("day");
    return s2;
  },
  yesterday: function yesterday(s2) {
    s2 = getNow(s2);
    s2 = s2.subtract(1, "day");
    s2 = s2.startOf("day");
    return s2;
  },
  christmas: function christmas(s2) {
    var year6 = getNow(s2).year();
    s2 = s2.set([year6, 11, 25, 18, 0, 0]);
    return s2;
  },
  "new years": function newYears(s2) {
    var year6 = getNow(s2).year();
    s2 = s2.set([year6, 11, 31, 18, 0, 0]);
    return s2;
  }
};
dates["new years eve"] = dates["new years"];
var namedDates = dates;
var minimumEpoch = 25e8;
var defaults = {
  year: new Date().getFullYear(),
  month: 0,
  date: 1
};
var handleArray = function handleArray2(s2, arr, today2) {
  if (arr.length === 0) {
    return s2;
  }
  var order2 = ["year", "month", "date", "hour", "minute", "second", "millisecond"];
  for (var i = 0; i < order2.length; i++) {
    var num = arr[i] || today2[order2[i]] || defaults[order2[i]] || 0;
    s2 = s2[order2[i]](num);
  }
  return s2;
};
var handleObject = function handleObject2(s2, obj, today2) {
  if (Object.keys(obj).length === 0) {
    return s2;
  }
  obj = Object.assign({}, defaults, today2, obj);
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    var unit = keys[i];
    if (s2[unit] === void 0 || typeof s2[unit] !== "function") {
      continue;
    }
    if (obj[unit] === null || obj[unit] === void 0 || obj[unit] === "") {
      continue;
    }
    var num = obj[unit] || today2[unit] || defaults[unit] || 0;
    s2 = s2[unit](num);
  }
  return s2;
};
var parseInput = function parseInput2(s2, input2, givenTz) {
  var today2 = s2._today || defaults;
  if (typeof input2 === "number") {
    if (input2 > 0 && input2 < minimumEpoch && s2.silent === false) {
      console.warn("  - Warning: You are setting the date to January 1970.");
      console.warn("       -   did input seconds instead of milliseconds?");
    }
    s2.epoch = input2;
    return s2;
  }
  s2.epoch = Date.now();
  if (s2._today && fns.isObject(s2._today) && Object.keys(s2._today).length > 0) {
    var res = handleObject(s2, today2, defaults);
    if (res.isValid()) {
      s2.epoch = res.epoch;
    }
  }
  if (input2 === null || input2 === void 0 || input2 === "") {
    return s2;
  }
  if (fns.isDate(input2) === true) {
    s2.epoch = input2.getTime();
    return s2;
  }
  if (fns.isArray(input2) === true) {
    s2 = handleArray(s2, input2, today2);
    return s2;
  }
  if (fns.isObject(input2) === true) {
    if (input2.epoch) {
      s2.epoch = input2.epoch;
      s2.tz = input2.tz;
      return s2;
    }
    s2 = handleObject(s2, input2, today2);
    return s2;
  }
  if (typeof input2 !== "string") {
    return s2;
  }
  input2 = input2.replace(/\b(mon|tues|wed|wednes|thu|thurs|fri|sat|satur|sun)(day)?\b/i, "");
  input2 = input2.replace(/,/g, "");
  input2 = input2.replace(/ +/g, " ").trim();
  if (namedDates.hasOwnProperty(input2) === true) {
    s2 = namedDates[input2](s2);
    return s2;
  }
  for (var i = 0; i < strParse.length; i++) {
    var m2 = input2.match(strParse[i].reg);
    if (m2) {
      var _res = strParse[i].parse(s2, m2, givenTz);
      if (_res !== null && _res.isValid()) {
        return _res;
      }
    }
  }
  if (s2.silent === false) {
    console.warn("Warning: couldn't parse date-string: '" + input2 + "'");
  }
  s2.epoch = null;
  return s2;
};
var input = parseInput;
var shortDays = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var longDays = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var days = {
  short: function short2() {
    return shortDays;
  },
  long: function long2() {
    return longDays;
  },
  set: function set2(i18n2) {
    shortDays = i18n2["short"] || shortDays;
    longDays = i18n2["long"] || longDays;
  },
  aliases: {
    mo: 1,
    tu: 2,
    we: 3,
    th: 4,
    fr: 5,
    sa: 6,
    su: 7,
    tues: 2,
    weds: 3,
    wedn: 3,
    thur: 4,
    thurs: 4
  }
};
var titleCaseEnabled = true;
var caseFormat = {
  useTitleCase: function useTitleCase() {
    return titleCaseEnabled;
  },
  set: function set3(useTitleCase2) {
    titleCaseEnabled = useTitleCase2;
  }
};
var isoOffset = function isoOffset2(s2) {
  var offset3 = s2.timezone().current.offset;
  return !offset3 ? "Z" : fns.formatTimezone(offset3, ":");
};
var _offset2 = isoOffset;
var applyCaseFormat = function applyCaseFormat2(str) {
  if (caseFormat.useTitleCase()) {
    return fns.titleCase(str);
  }
  return str;
};
var format = {
  day: function day(s2) {
    return applyCaseFormat(s2.dayName());
  },
  "day-short": function dayShort(s2) {
    return applyCaseFormat(days["short"]()[s2.day()]);
  },
  "day-number": function dayNumber(s2) {
    return s2.day();
  },
  "day-ordinal": function dayOrdinal(s2) {
    return fns.ordinal(s2.day());
  },
  "day-pad": function dayPad(s2) {
    return fns.zeroPad(s2.day());
  },
  date: function date(s2) {
    return s2.date();
  },
  "date-ordinal": function dateOrdinal(s2) {
    return fns.ordinal(s2.date());
  },
  "date-pad": function datePad(s2) {
    return fns.zeroPad(s2.date());
  },
  month: function month(s2) {
    return applyCaseFormat(s2.monthName());
  },
  "month-short": function monthShort(s2) {
    return applyCaseFormat(months$1["short"]()[s2.month()]);
  },
  "month-number": function monthNumber(s2) {
    return s2.month();
  },
  "month-ordinal": function monthOrdinal(s2) {
    return fns.ordinal(s2.month());
  },
  "month-pad": function monthPad(s2) {
    return fns.zeroPad(s2.month());
  },
  "iso-month": function isoMonth(s2) {
    return fns.zeroPad(s2.month() + 1);
  },
  year: function year(s2) {
    var year6 = s2.year();
    if (year6 > 0) {
      return year6;
    }
    year6 = Math.abs(year6);
    return year6 + " BC";
  },
  "year-short": function yearShort(s2) {
    var year6 = s2.year();
    if (year6 > 0) {
      return "'".concat(String(s2.year()).substr(2, 4));
    }
    year6 = Math.abs(year6);
    return year6 + " BC";
  },
  "iso-year": function isoYear(s2) {
    var year6 = s2.year();
    var isNegative = year6 < 0;
    var str = fns.zeroPad(Math.abs(year6), 4);
    if (isNegative) {
      str = fns.zeroPad(str, 6);
      str = "-" + str;
    }
    return str;
  },
  time: function time(s2) {
    return s2.time();
  },
  "time-24": function time24(s2) {
    return "".concat(s2.hour24(), ":").concat(fns.zeroPad(s2.minute()));
  },
  hour: function hour(s2) {
    return s2.hour12();
  },
  "hour-pad": function hourPad(s2) {
    return fns.zeroPad(s2.hour12());
  },
  "hour-24": function hour24(s2) {
    return s2.hour24();
  },
  "hour-24-pad": function hour24Pad(s2) {
    return fns.zeroPad(s2.hour24());
  },
  minute: function minute(s2) {
    return s2.minute();
  },
  "minute-pad": function minutePad(s2) {
    return fns.zeroPad(s2.minute());
  },
  second: function second(s2) {
    return s2.second();
  },
  "second-pad": function secondPad(s2) {
    return fns.zeroPad(s2.second());
  },
  ampm: function ampm(s2) {
    return s2.ampm();
  },
  quarter: function quarter(s2) {
    return "Q" + s2.quarter();
  },
  season: function season(s2) {
    return s2.season();
  },
  era: function era(s2) {
    return s2.era();
  },
  json: function json(s2) {
    return s2.json();
  },
  timezone: function timezone(s2) {
    return s2.timezone().name;
  },
  offset: function offset(s2) {
    return _offset2(s2);
  },
  numeric: function numeric(s2) {
    return "".concat(s2.year(), "/").concat(fns.zeroPad(s2.month() + 1), "/").concat(fns.zeroPad(s2.date()));
  },
  "numeric-us": function numericUs(s2) {
    return "".concat(fns.zeroPad(s2.month() + 1), "/").concat(fns.zeroPad(s2.date()), "/").concat(s2.year());
  },
  "numeric-uk": function numericUk(s2) {
    return "".concat(fns.zeroPad(s2.date()), "/").concat(fns.zeroPad(s2.month() + 1), "/").concat(s2.year());
  },
  "mm/dd": function mmDd(s2) {
    return "".concat(fns.zeroPad(s2.month() + 1), "/").concat(fns.zeroPad(s2.date()));
  },
  iso: function iso(s2) {
    var year6 = s2.format("iso-year");
    var month6 = fns.zeroPad(s2.month() + 1);
    var date4 = fns.zeroPad(s2.date());
    var hour5 = fns.zeroPad(s2.h24());
    var minute5 = fns.zeroPad(s2.minute());
    var second4 = fns.zeroPad(s2.second());
    var ms2 = fns.zeroPad(s2.millisecond(), 3);
    var offset3 = _offset2(s2);
    return "".concat(year6, "-").concat(month6, "-").concat(date4, "T").concat(hour5, ":").concat(minute5, ":").concat(second4, ".").concat(ms2).concat(offset3);
  },
  "iso-short": function isoShort(s2) {
    var month6 = fns.zeroPad(s2.month() + 1);
    var date4 = fns.zeroPad(s2.date());
    return "".concat(s2.year(), "-").concat(month6, "-").concat(date4);
  },
  "iso-utc": function isoUtc(s2) {
    return new Date(s2.epoch).toISOString();
  },
  nice: function nice(s2) {
    return "".concat(months$1["short"]()[s2.month()], " ").concat(fns.ordinal(s2.date()), ", ").concat(s2.time());
  },
  "nice-24": function nice24(s2) {
    return "".concat(months$1["short"]()[s2.month()], " ").concat(fns.ordinal(s2.date()), ", ").concat(s2.hour24(), ":").concat(fns.zeroPad(s2.minute()));
  },
  "nice-year": function niceYear(s2) {
    return "".concat(months$1["short"]()[s2.month()], " ").concat(fns.ordinal(s2.date()), ", ").concat(s2.year());
  },
  "nice-day": function niceDay(s2) {
    return "".concat(days["short"]()[s2.day()], " ").concat(applyCaseFormat(months$1["short"]()[s2.month()]), " ").concat(fns.ordinal(s2.date()));
  },
  "nice-full": function niceFull(s2) {
    return "".concat(s2.dayName(), " ").concat(applyCaseFormat(s2.monthName()), " ").concat(fns.ordinal(s2.date()), ", ").concat(s2.time());
  },
  "nice-full-24": function niceFull24(s2) {
    return "".concat(s2.dayName(), " ").concat(applyCaseFormat(s2.monthName()), " ").concat(fns.ordinal(s2.date()), ", ").concat(s2.hour24(), ":").concat(fns.zeroPad(s2.minute()));
  }
};
var aliases = {
  "day-name": "day",
  "month-name": "month",
  "iso 8601": "iso",
  "time-h24": "time-24",
  "time-12": "time",
  "time-h12": "time",
  tz: "timezone",
  "day-num": "day-number",
  "month-num": "month-number",
  "month-iso": "iso-month",
  "year-iso": "iso-year",
  "nice-short": "nice",
  "nice-short-24": "nice-24",
  mdy: "numeric-us",
  dmy: "numeric-uk",
  ymd: "numeric",
  "yyyy/mm/dd": "numeric",
  "mm/dd/yyyy": "numeric-us",
  "dd/mm/yyyy": "numeric-us",
  "little-endian": "numeric-uk",
  "big-endian": "numeric",
  "day-nice": "nice-day"
};
Object.keys(aliases).forEach(function(k) {
  return format[k] = format[aliases[k]];
});
var printFormat = function printFormat2(s2) {
  var str = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (s2.isValid() !== true) {
    return "";
  }
  if (format.hasOwnProperty(str)) {
    var out = format[str](s2) || "";
    if (str !== "json") {
      out = String(out);
      if (str !== "ampm") {
        out = applyCaseFormat(out);
      }
    }
    return out;
  }
  if (str.indexOf("{") !== -1) {
    var sections = /\{(.+?)\}/g;
    str = str.replace(sections, function(_, fmt) {
      fmt = fmt.toLowerCase().trim();
      if (format.hasOwnProperty(fmt)) {
        var _out = String(format[fmt](s2));
        if (fmt !== "ampm") {
          return applyCaseFormat(_out);
        }
        return _out;
      }
      return "";
    });
    return str;
  }
  return s2.format("iso-short");
};
var format_1 = printFormat;
var pad = fns.zeroPad;
var formatTimezone = fns.formatTimezone;
var mapping2 = {
  G: function G(s2) {
    return s2.era();
  },
  GG: function GG(s2) {
    return s2.era();
  },
  GGG: function GGG(s2) {
    return s2.era();
  },
  GGGG: function GGGG(s2) {
    return s2.era() === "AD" ? "Anno Domini" : "Before Christ";
  },
  y: function y(s2) {
    return s2.year();
  },
  yy: function yy(s2) {
    return parseInt(String(s2.year()).substr(2, 4), 10);
  },
  yyy: function yyy(s2) {
    return s2.year();
  },
  yyyy: function yyyy(s2) {
    return s2.year();
  },
  yyyyy: function yyyyy(s2) {
    return "0" + s2.year();
  },
  Q: function Q(s2) {
    return s2.quarter();
  },
  QQ: function QQ(s2) {
    return s2.quarter();
  },
  QQQ: function QQQ(s2) {
    return s2.quarter();
  },
  QQQQ: function QQQQ(s2) {
    return s2.quarter();
  },
  M: function M(s2) {
    return s2.month() + 1;
  },
  MM: function MM(s2) {
    return pad(s2.month() + 1);
  },
  MMM: function MMM(s2) {
    return s2.format("month-short");
  },
  MMMM: function MMMM(s2) {
    return s2.format("month");
  },
  w: function w2(s2) {
    return s2.week();
  },
  ww: function ww(s2) {
    return pad(s2.week());
  },
  d: function d(s2) {
    return s2.date();
  },
  dd: function dd(s2) {
    return pad(s2.date());
  },
  D: function D(s2) {
    return s2.dayOfYear();
  },
  DD: function DD(s2) {
    return pad(s2.dayOfYear());
  },
  DDD: function DDD(s2) {
    return pad(s2.dayOfYear(), 3);
  },
  E: function E(s2) {
    return s2.format("day-short");
  },
  EE: function EE(s2) {
    return s2.format("day-short");
  },
  EEE: function EEE(s2) {
    return s2.format("day-short");
  },
  EEEE: function EEEE(s2) {
    return s2.format("day");
  },
  EEEEE: function EEEEE(s2) {
    return s2.format("day")[0];
  },
  e: function e(s2) {
    return s2.day();
  },
  ee: function ee(s2) {
    return s2.day();
  },
  eee: function eee(s2) {
    return s2.format("day-short");
  },
  eeee: function eeee(s2) {
    return s2.format("day");
  },
  eeeee: function eeeee(s2) {
    return s2.format("day")[0];
  },
  a: function a(s2) {
    return s2.ampm().toUpperCase();
  },
  aa: function aa(s2) {
    return s2.ampm().toUpperCase();
  },
  aaa: function aaa(s2) {
    return s2.ampm().toUpperCase();
  },
  aaaa: function aaaa(s2) {
    return s2.ampm().toUpperCase();
  },
  h: function h(s2) {
    return s2.h12();
  },
  hh: function hh(s2) {
    return pad(s2.h12());
  },
  H: function H(s2) {
    return s2.hour();
  },
  HH: function HH(s2) {
    return pad(s2.hour());
  },
  m: function m(s2) {
    return s2.minute();
  },
  mm: function mm(s2) {
    return pad(s2.minute());
  },
  s: function s(_s) {
    return _s.second();
  },
  ss: function ss(s2) {
    return pad(s2.second());
  },
  A: function A(s2) {
    return s2.epoch - s2.startOf("day").epoch;
  },
  z: function z(s2) {
    return s2.timezone().name;
  },
  zz: function zz(s2) {
    return s2.timezone().name;
  },
  zzz: function zzz(s2) {
    return s2.timezone().name;
  },
  zzzz: function zzzz(s2) {
    return s2.timezone().name;
  },
  Z: function Z(s2) {
    return formatTimezone(s2.timezone().current.offset);
  },
  ZZ: function ZZ(s2) {
    return formatTimezone(s2.timezone().current.offset);
  },
  ZZZ: function ZZZ(s2) {
    return formatTimezone(s2.timezone().current.offset);
  },
  ZZZZ: function ZZZZ(s2) {
    return formatTimezone(s2.timezone().current.offset, ":");
  }
};
var addAlias = function addAlias2(_char, to, n) {
  var name2 = _char;
  var toName = to;
  for (var i = 0; i < n; i += 1) {
    mapping2[name2] = mapping2[toName];
    name2 += _char;
    toName += to;
  }
};
addAlias("q", "Q", 4);
addAlias("L", "M", 4);
addAlias("Y", "y", 4);
addAlias("c", "e", 4);
addAlias("k", "H", 2);
addAlias("K", "h", 2);
addAlias("S", "s", 2);
addAlias("v", "z", 4);
addAlias("V", "Z", 4);
var escapeChars = function escapeChars2(arr) {
  for (var i = 0; i < arr.length; i += 1) {
    if (arr[i] === "'") {
      for (var o2 = i + 1; o2 < arr.length; o2 += 1) {
        if (arr[o2]) {
          arr[i] += arr[o2];
        }
        if (arr[o2] === "'") {
          arr[o2] = null;
          break;
        }
        arr[o2] = null;
      }
    }
  }
  return arr.filter(function(ch) {
    return ch;
  });
};
var combineRepeated = function combineRepeated2(arr) {
  for (var i = 0; i < arr.length; i += 1) {
    var c = arr[i];
    for (var o2 = i + 1; o2 < arr.length; o2 += 1) {
      if (arr[o2] === c) {
        arr[i] += arr[o2];
        arr[o2] = null;
      } else {
        break;
      }
    }
  }
  arr = arr.filter(function(ch) {
    return ch;
  });
  arr = arr.map(function(str) {
    if (str === "''") {
      str = "'";
    }
    return str;
  });
  return arr;
};
var unixFmt = function unixFmt2(s2, str) {
  var arr = str.split("");
  arr = escapeChars(arr);
  arr = combineRepeated(arr);
  return arr.reduce(function(txt, c) {
    if (mapping2[c] !== void 0) {
      txt += mapping2[c](s2) || "";
    } else {
      if (/^'.{1,}'$/.test(c)) {
        c = c.replace(/'/g, "");
      }
      txt += c;
    }
    return txt;
  }, "");
};
var unixFmt_1 = unixFmt;
var units$2 = ["year", "season", "quarter", "month", "week", "day", "quarterHour", "hour", "minute"];
var doUnit = function doUnit2(s2, k) {
  var start = s2.clone().startOf(k);
  var end = s2.clone().endOf(k);
  var duration = end.epoch - start.epoch;
  var percent2 = (s2.epoch - start.epoch) / duration;
  return parseFloat(percent2.toFixed(2));
};
var progress = function progress2(s2, unit) {
  if (unit) {
    unit = fns.normalize(unit);
    return doUnit(s2, unit);
  }
  var obj = {};
  units$2.forEach(function(k) {
    obj[k] = doUnit(s2, k);
  });
  return obj;
};
var progress_1 = progress;
var nearest = function nearest2(s2, unit) {
  var prog = s2.progress();
  unit = fns.normalize(unit);
  if (unit === "quarterhour") {
    unit = "quarterHour";
  }
  if (prog[unit] !== void 0) {
    if (prog[unit] > 0.5) {
      s2 = s2.add(1, unit);
    }
    s2 = s2.startOf(unit);
  } else if (s2.silent === false) {
    console.warn("no known unit '" + unit + "'");
  }
  return s2;
};
var nearest_1 = nearest;
var climb = function climb2(a2, b, unit) {
  var i = 0;
  a2 = a2.clone();
  while (a2.isBefore(b)) {
    a2 = a2.add(1, unit);
    i += 1;
  }
  if (a2.isAfter(b, unit)) {
    i -= 1;
  }
  return i;
};
var diffOne = function diffOne2(a2, b, unit) {
  if (a2.isBefore(b)) {
    return climb(a2, b, unit);
  } else {
    return climb(b, a2, unit) * -1;
  }
};
var one = diffOne;
var fastYear = function fastYear2(a2, b) {
  var years = b.year() - a2.year();
  a2 = a2.year(b.year());
  if (a2.isAfter(b)) {
    years -= 1;
  }
  return years;
};
var diff$1 = function diff(a2, b) {
  var msDiff = b.epoch - a2.epoch;
  var obj = {
    milliseconds: msDiff,
    seconds: parseInt(msDiff / 1e3, 10)
  };
  obj.minutes = parseInt(obj.seconds / 60, 10);
  obj.hours = parseInt(obj.minutes / 60, 10);
  var tmp2 = a2.clone();
  obj.years = fastYear(tmp2, b);
  tmp2 = a2.add(obj.years, "year");
  obj.months = obj.years * 12;
  tmp2 = a2.add(obj.months, "month");
  obj.months += one(tmp2, b, "month");
  obj.weeks = obj.years * 52;
  tmp2 = a2.add(obj.weeks, "week");
  obj.weeks += one(tmp2, b, "week");
  obj.days = obj.weeks * 7;
  tmp2 = a2.add(obj.days, "day");
  obj.days += one(tmp2, b, "day");
  return obj;
};
var waterfall = diff$1;
var reverseDiff = function reverseDiff2(obj) {
  Object.keys(obj).forEach(function(k) {
    obj[k] *= -1;
  });
  return obj;
};
var main$1 = function main(a2, b, unit) {
  b = fns.beADate(b, a2);
  var reversed = false;
  if (a2.isAfter(b)) {
    var tmp2 = a2;
    a2 = b;
    b = tmp2;
    reversed = true;
  }
  var obj = waterfall(a2, b);
  if (reversed) {
    obj = reverseDiff(obj);
  }
  if (unit) {
    unit = fns.normalize(unit);
    if (/s$/.test(unit) !== true) {
      unit += "s";
    }
    if (unit === "dates") {
      unit = "days";
    }
    return obj[unit];
  }
  return obj;
};
var diff2 = main$1;
var qualifiers = {
  months: {
    almost: 10,
    over: 4
  },
  days: {
    almost: 25,
    over: 10
  },
  hours: {
    almost: 20,
    over: 8
  },
  minutes: {
    almost: 50,
    over: 20
  },
  seconds: {
    almost: 50,
    over: 20
  }
};
function getDiff(a2, b) {
  var isBefore = a2.isBefore(b);
  var later = isBefore ? b : a2;
  var earlier = isBefore ? a2 : b;
  earlier = earlier.clone();
  var diff3 = {
    years: 0,
    months: 0,
    days: 0,
    hours: 0,
    minutes: 0,
    seconds: 0
  };
  Object.keys(diff3).forEach(function(unit) {
    if (earlier.isSame(later, unit)) {
      return;
    }
    var max = earlier.diff(later, unit);
    earlier = earlier.add(max, unit);
    diff3[unit] = max;
  });
  if (isBefore) {
    Object.keys(diff3).forEach(function(u) {
      if (diff3[u] !== 0) {
        diff3[u] *= -1;
      }
    });
  }
  return diff3;
}
function pluralize(value, unit) {
  if (value === 1) {
    unit = unit.slice(0, -1);
  }
  return value + " " + unit;
}
var since = function since2(start, end) {
  end = fns.beADate(end, start);
  var diff3 = getDiff(start, end);
  var isNow = Object.keys(diff3).every(function(u) {
    return !diff3[u];
  });
  if (isNow === true) {
    return {
      diff: diff3,
      rounded: "now",
      qualified: "now",
      precise: "now"
    };
  }
  var rounded;
  var qualified;
  var precise;
  var englishValues = [];
  Object.keys(diff3).forEach(function(unit, i, units3) {
    var value = Math.abs(diff3[unit]);
    if (value === 0) {
      return;
    }
    var englishValue = pluralize(value, unit);
    englishValues.push(englishValue);
    if (!rounded) {
      rounded = qualified = englishValue;
      if (i > 4) {
        return;
      }
      var nextUnit = units3[i + 1];
      var nextValue = Math.abs(diff3[nextUnit]);
      if (nextValue > qualifiers[nextUnit].almost) {
        rounded = pluralize(value + 1, unit);
        qualified = "almost " + rounded;
      } else if (nextValue > qualifiers[nextUnit].over)
        qualified = "over " + englishValue;
    }
  });
  precise = englishValues.splice(0, 2).join(", ");
  if (start.isAfter(end) === true) {
    rounded += " ago";
    qualified += " ago";
    precise += " ago";
  } else {
    rounded = "in " + rounded;
    qualified = "in " + qualified;
    precise = "in " + precise;
  }
  return {
    diff: diff3,
    rounded,
    qualified,
    precise
  };
};
var since_1 = since;
var seasons = {
  north: [
    ["spring", 2, 1],
    ["summer", 5, 1],
    ["fall", 8, 1],
    ["autumn", 8, 1],
    ["winter", 11, 1]
  ],
  south: [
    ["fall", 2, 1],
    ["autumn", 2, 1],
    ["winter", 5, 1],
    ["spring", 8, 1],
    ["summer", 11, 1]
  ]
};
var quarters = [
  null,
  [0, 1],
  [3, 1],
  [6, 1],
  [9, 1]
];
var units$1 = {
  minute: function minute2(s2) {
    walk_1(s2, {
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  quarterhour: function quarterhour(s2) {
    var minute5 = s2.minutes();
    if (minute5 >= 45) {
      s2 = s2.minutes(45);
    } else if (minute5 >= 30) {
      s2 = s2.minutes(30);
    } else if (minute5 >= 15) {
      s2 = s2.minutes(15);
    } else {
      s2 = s2.minutes(0);
    }
    walk_1(s2, {
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  hour: function hour2(s2) {
    walk_1(s2, {
      minute: 0,
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  day: function day2(s2) {
    walk_1(s2, {
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  week: function week(s2) {
    var original = s2.clone();
    s2 = s2.day(s2._weekStart);
    if (s2.isAfter(original)) {
      s2 = s2.subtract(1, "week");
    }
    walk_1(s2, {
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  month: function month2(s2) {
    walk_1(s2, {
      date: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  quarter: function quarter2(s2) {
    var q = s2.quarter();
    if (quarters[q]) {
      walk_1(s2, {
        month: quarters[q][0],
        date: quarters[q][1],
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      });
    }
    return s2;
  },
  season: function season2(s2) {
    var current = s2.season();
    var hem = "north";
    if (s2.hemisphere() === "South") {
      hem = "south";
    }
    for (var i = 0; i < seasons[hem].length; i++) {
      if (seasons[hem][i][0] === current) {
        var year6 = s2.year();
        if (current === "winter" && s2.month() < 3) {
          year6 -= 1;
        }
        walk_1(s2, {
          year: year6,
          month: seasons[hem][i][1],
          date: seasons[hem][i][2],
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0
        });
        return s2;
      }
    }
    return s2;
  },
  year: function year2(s2) {
    walk_1(s2, {
      month: 0,
      date: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    });
    return s2;
  },
  decade: function decade(s2) {
    s2 = s2.startOf("year");
    var year6 = s2.year();
    var decade3 = parseInt(year6 / 10, 10) * 10;
    s2 = s2.year(decade3);
    return s2;
  },
  century: function century(s2) {
    s2 = s2.startOf("year");
    var year6 = s2.year();
    var decade3 = parseInt(year6 / 100, 10) * 100;
    s2 = s2.year(decade3);
    return s2;
  }
};
units$1.date = units$1.day;
var startOf = function startOf2(a2, unit) {
  var s2 = a2.clone();
  unit = fns.normalize(unit);
  if (units$1[unit]) {
    return units$1[unit](s2);
  }
  if (unit === "summer" || unit === "winter") {
    s2 = s2.season(unit);
    return units$1.season(s2);
  }
  return s2;
};
var endOf = function endOf2(a2, unit) {
  var s2 = a2.clone();
  unit = fns.normalize(unit);
  if (units$1[unit]) {
    s2 = units$1[unit](s2);
    s2 = s2.add(1, unit);
    s2 = s2.subtract(1, "millisecond");
    return s2;
  }
  return s2;
};
var startOf_1 = {
  startOf,
  endOf
};
var isDay = function isDay2(unit) {
  if (days["short"]().find(function(s2) {
    return s2 === unit;
  })) {
    return true;
  }
  if (days["long"]().find(function(s2) {
    return s2 === unit;
  })) {
    return true;
  }
  return false;
};
var every = function every2(start) {
  var unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var end = arguments.length > 2 ? arguments[2] : void 0;
  if (!unit || !end) {
    return [];
  }
  unit = fns.normalize(unit);
  end = start.clone().set(end);
  if (start.isAfter(end)) {
    var tmp2 = start;
    start = end;
    end = tmp2;
  }
  var d2 = start.clone();
  if (isDay(unit)) {
    d2 = d2.next(unit);
    unit = "week";
  } else {
    d2 = d2.next(unit);
  }
  var result = [];
  while (d2.isBefore(end)) {
    result.push(d2);
    d2 = d2.add(1, unit);
  }
  return result;
};
var every_1 = every;
var parseDst = function parseDst2(dst) {
  if (!dst) {
    return [];
  }
  return dst.split("->");
};
var titleCase = function titleCase2(str) {
  str = str[0].toUpperCase() + str.substr(1);
  str = str.replace(/\/gmt/, "/GMT");
  str = str.replace(/[\/_]([a-z])/gi, function(s2) {
    return s2.toUpperCase();
  });
  return str;
};
var timezone2 = function timezone3(s2) {
  var zones2 = s2.timezones;
  var tz = s2.tz;
  if (zones2.hasOwnProperty(tz) === false) {
    tz = find(s2.tz, zones2);
  }
  if (tz === null) {
    if (s2.silent === false) {
      console.warn("Warn: could not find given or local timezone - '" + s2.tz + "'");
    }
    return {
      current: {
        epochShift: 0
      }
    };
  }
  var found = zones2[tz];
  var result = {
    name: titleCase(tz),
    hasDst: Boolean(found.dst),
    default_offset: found.offset,
    hemisphere: found.hem === "s" ? "South" : "North",
    current: {}
  };
  if (result.hasDst) {
    var arr = parseDst(found.dst);
    result.change = {
      start: arr[0],
      back: arr[1]
    };
  }
  var summer = found.offset;
  var winter = summer;
  if (result.hasDst === true) {
    if (result.hemisphere === "North") {
      winter = summer - 1;
    } else {
      winter = found.offset + 1;
    }
  }
  if (result.hasDst === false) {
    result.current.offset = summer;
    result.current.isDST = false;
  } else if (summerTime(s2.epoch, result.change.start, result.change.back, summer, winter) === true) {
    result.current.offset = summer;
    result.current.isDST = result.hemisphere === "North";
  } else {
    result.current.offset = winter;
    result.current.isDST = result.hemisphere === "South";
  }
  return result;
};
var timezone_1 = timezone2;
var units2 = ["century", "decade", "year", "month", "date", "day", "hour", "minute", "second", "millisecond"];
var methods$4 = {
  set: function set4(input$1, tz) {
    var s2 = this.clone();
    s2 = input(s2, input$1, null);
    if (tz) {
      this.tz = find(tz);
    }
    return s2;
  },
  timezone: function timezone4() {
    return timezone_1(this);
  },
  isDST: function isDST() {
    return timezone_1(this).current.isDST;
  },
  hasDST: function hasDST() {
    return timezone_1(this).hasDst;
  },
  offset: function offset2() {
    return timezone_1(this).current.offset * 60;
  },
  hemisphere: function hemisphere() {
    return timezone_1(this).hemisphere;
  },
  format: function format2(fmt) {
    return format_1(this, fmt);
  },
  unixFmt: function unixFmt3(fmt) {
    return unixFmt_1(this, fmt);
  },
  startOf: function startOf3(unit) {
    return startOf_1.startOf(this, unit);
  },
  endOf: function endOf3(unit) {
    return startOf_1.endOf(this, unit);
  },
  leapYear: function leapYear() {
    var year6 = this.year();
    return fns.isLeapYear(year6);
  },
  progress: function progress3(unit) {
    return progress_1(this, unit);
  },
  nearest: function nearest3(unit) {
    return nearest_1(this, unit);
  },
  diff: function diff$12(d2, unit) {
    return diff2(this, d2, unit);
  },
  since: function since3(d2) {
    if (!d2) {
      d2 = this.clone().set();
    }
    return since_1(this, d2);
  },
  next: function next2(unit) {
    var s2 = this.add(1, unit);
    return s2.startOf(unit);
  },
  last: function last(unit) {
    var s2 = this.subtract(1, unit);
    return s2.startOf(unit);
  },
  isValid: function isValid() {
    if (!this.epoch && this.epoch !== 0) {
      return false;
    }
    return !isNaN(this.d.getTime());
  },
  goto: function goto(tz) {
    var s2 = this.clone();
    s2.tz = find(tz, s2.timezones);
    return s2;
  },
  every: function every3(unit, to) {
    if (_typeof4(unit) === "object" && typeof to === "string") {
      var tmp2 = to;
      to = unit;
      unit = tmp2;
    }
    return every_1(this, unit, to);
  },
  isAwake: function isAwake() {
    var hour5 = this.hour();
    if (hour5 < 8 || hour5 > 22) {
      return false;
    }
    return true;
  },
  isAsleep: function isAsleep() {
    return !this.isAwake();
  },
  log: function log() {
    console.log("");
    console.log(format_1(this, "nice-short"));
    return this;
  },
  logYear: function logYear() {
    console.log("");
    console.log(format_1(this, "full-short"));
    return this;
  },
  json: function json2() {
    var _this = this;
    return units2.reduce(function(h2, unit) {
      h2[unit] = _this[unit]();
      return h2;
    }, {});
  },
  debug: function debug() {
    var tz = this.timezone();
    var date4 = this.format("MM") + " " + this.format("date-ordinal") + " " + this.year();
    date4 += "\n     - " + this.format("time");
    console.log("\n\n", date4 + "\n     - " + tz.name + " (" + tz.current.offset + ")");
    return this;
  },
  from: function from2(d2) {
    d2 = this.clone().set(d2);
    return d2.since(this);
  },
  fromNow: function fromNow() {
    var d2 = this.clone().set(Date.now());
    return d2.since(this);
  },
  weekStart: function weekStart(input2) {
    if (typeof input2 === "number") {
      this._weekStart = input2;
      return this;
    }
    if (typeof input2 === "string") {
      input2 = input2.toLowerCase().trim();
      var num = days["short"]().indexOf(input2);
      if (num === -1) {
        num = days["long"]().indexOf(input2);
      }
      if (num === -1) {
        num = 1;
      }
      this._weekStart = num;
    } else {
      console.warn("Spacetime Error: Cannot understand .weekStart() input:", input2);
    }
    return this;
  }
};
methods$4.inDST = methods$4.isDST;
methods$4.round = methods$4.nearest;
methods$4.each = methods$4.every;
var methods_1 = methods$4;
var isLeapYear$1 = fns.isLeapYear;
var validate = function validate2(n) {
  if (typeof n === "string") {
    n = parseInt(n, 10);
  }
  return n;
};
var order$1 = ["year", "month", "date", "hour", "minute", "second", "millisecond"];
var confirm = function confirm2(s2, tmp2, unit) {
  var n = order$1.indexOf(unit);
  var arr = order$1.slice(n, order$1.length);
  for (var i = 0; i < arr.length; i++) {
    var want = tmp2[arr[i]]();
    s2[arr[i]](want);
  }
  return s2;
};
var set5 = {
  milliseconds: function milliseconds2(s2, n) {
    n = validate(n);
    var current = s2.millisecond();
    var diff3 = current - n;
    return s2.epoch - diff3;
  },
  seconds: function seconds(s2, n) {
    n = validate(n);
    var diff3 = s2.second() - n;
    var shift = diff3 * milliseconds.second;
    return s2.epoch - shift;
  },
  minutes: function minutes(s2, n) {
    n = validate(n);
    var old = s2.clone();
    var diff3 = s2.minute() - n;
    var shift = diff3 * milliseconds.minute;
    s2.epoch -= shift;
    confirm(s2, old, "second");
    return s2.epoch;
  },
  hours: function hours(s2, n) {
    n = validate(n);
    if (n >= 24) {
      n = 24;
    } else if (n < 0) {
      n = 0;
    }
    var old = s2.clone();
    var diff3 = s2.hour() - n;
    var shift = diff3 * milliseconds.hour;
    s2.epoch -= shift;
    if (s2.date() !== old.date()) {
      s2 = old.clone();
      if (diff3 > 1) {
        diff3 -= 1;
      }
      if (diff3 < 1) {
        diff3 += 1;
      }
      shift = diff3 * milliseconds.hour;
      s2.epoch -= shift;
    }
    walk_1(s2, {
      hour: n
    });
    confirm(s2, old, "minute");
    return s2.epoch;
  },
  time: function time2(s2, str) {
    var m2 = str.match(/([0-9]{1,2})[:h]([0-9]{1,2})(:[0-9]{1,2})? ?(am|pm)?/);
    if (!m2) {
      m2 = str.match(/([0-9]{1,2}) ?(am|pm)/);
      if (!m2) {
        return s2.epoch;
      }
      m2.splice(2, 0, "0");
      m2.splice(3, 0, "");
    }
    var h24 = false;
    var hour5 = parseInt(m2[1], 10);
    var minute5 = parseInt(m2[2], 10);
    if (hour5 > 12) {
      h24 = true;
    }
    if (h24 === false) {
      if (m2[4] === "am" && hour5 === 12) {
        hour5 = 0;
      }
      if (m2[4] === "pm" && hour5 < 12) {
        hour5 += 12;
      }
    }
    m2[3] = m2[3] || "";
    m2[3] = m2[3].replace(/:/, "");
    var sec = parseInt(m2[3], 10) || 0;
    s2 = s2.hour(hour5);
    s2 = s2.minute(minute5);
    s2 = s2.second(sec);
    s2 = s2.millisecond(0);
    return s2.epoch;
  },
  date: function date2(s2, n) {
    n = validate(n);
    if (n > 28) {
      var month6 = s2.month();
      var max = monthLengths_1[month6];
      if (month6 === 1 && n === 29 && isLeapYear$1(s2.year())) {
        max = 29;
      }
      if (n > max) {
        n = max;
      }
    }
    if (n <= 0) {
      n = 1;
    }
    walk_1(s2, {
      date: n
    });
    return s2.epoch;
  },
  month: function month3(s2, n) {
    if (typeof n === "string") {
      n = months$1.mapping()[n.toLowerCase()];
    }
    n = validate(n);
    if (n >= 12) {
      n = 11;
    }
    if (n <= 0) {
      n = 0;
    }
    var date4 = s2.date();
    if (date4 > monthLengths_1[n]) {
      date4 = monthLengths_1[n];
    }
    walk_1(s2, {
      month: n,
      date: date4
    });
    return s2.epoch;
  },
  year: function year3(s2, n) {
    if (typeof n === "string" && /^'[0-9]{2}$/.test(n)) {
      n = n.replace(/'/, "").trim();
      n = Number(n);
      if (n > 30) {
        n = 1900 + n;
      } else {
        n = 2e3 + n;
      }
    }
    n = validate(n);
    walk_1(s2, {
      year: n
    });
    return s2.epoch;
  },
  dayOfYear: function dayOfYear(s2, n) {
    n = validate(n);
    var old = s2.clone();
    n -= 1;
    if (n <= 0) {
      n = 0;
    } else if (n >= 365) {
      n = 364;
    }
    s2 = s2.startOf("year");
    s2 = s2.add(n, "day");
    confirm(s2, old, "hour");
    return s2.epoch;
  }
};
var methods$3 = {
  millisecond: function millisecond(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.milliseconds(s2, num);
      return s2;
    }
    return this.d.getMilliseconds();
  },
  second: function second2(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.seconds(s2, num);
      return s2;
    }
    return this.d.getSeconds();
  },
  minute: function minute3(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.minutes(s2, num);
      return s2;
    }
    return this.d.getMinutes();
  },
  hour: function hour3(num) {
    var d2 = this.d;
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.hours(s2, num);
      return s2;
    }
    return d2.getHours();
  },
  hourFloat: function hourFloat(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      var _minute = num % 1;
      _minute = _minute * 60;
      var _hour = parseInt(num, 10);
      s2.epoch = set5.hours(s2, _hour);
      s2.epoch = set5.minutes(s2, _minute);
      return s2;
    }
    var d2 = this.d;
    var hour5 = d2.getHours();
    var minute5 = d2.getMinutes();
    minute5 = minute5 / 60;
    return hour5 + minute5;
  },
  hour12: function hour12(str) {
    var d2 = this.d;
    if (str !== void 0) {
      var s2 = this.clone();
      str = "" + str;
      var m2 = str.match(/^([0-9]+)(am|pm)$/);
      if (m2) {
        var hour5 = parseInt(m2[1], 10);
        if (m2[2] === "pm") {
          hour5 += 12;
        }
        s2.epoch = set5.hours(s2, hour5);
      }
      return s2;
    }
    var hour122 = d2.getHours();
    if (hour122 > 12) {
      hour122 = hour122 - 12;
    }
    if (hour122 === 0) {
      hour122 = 12;
    }
    return hour122;
  },
  time: function time3(str) {
    if (str !== void 0) {
      var s2 = this.clone();
      str = str.toLowerCase().trim();
      s2.epoch = set5.time(s2, str);
      return s2;
    }
    return "".concat(this.h12(), ":").concat(fns.zeroPad(this.minute())).concat(this.ampm());
  },
  ampm: function ampm2(input2) {
    var which = "am";
    var hour5 = this.hour();
    if (hour5 >= 12) {
      which = "pm";
    }
    if (typeof input2 !== "string") {
      return which;
    }
    var s2 = this.clone();
    input2 = input2.toLowerCase().trim();
    if (hour5 >= 12 && input2 === "am") {
      hour5 -= 12;
      return s2.hour(hour5);
    }
    if (hour5 < 12 && input2 === "pm") {
      hour5 += 12;
      return s2.hour(hour5);
    }
    return s2;
  },
  dayTime: function dayTime(str) {
    if (str !== void 0) {
      var times = {
        morning: "7:00am",
        breakfast: "7:00am",
        noon: "12:00am",
        lunch: "12:00pm",
        afternoon: "2:00pm",
        evening: "6:00pm",
        dinner: "6:00pm",
        night: "11:00pm",
        midnight: "23:59pm"
      };
      var s2 = this.clone();
      str = str || "";
      str = str.toLowerCase();
      if (times.hasOwnProperty(str) === true) {
        s2 = s2.time(times[str]);
      }
      return s2;
    }
    var h2 = this.hour();
    if (h2 < 6) {
      return "night";
    }
    if (h2 < 12) {
      return "morning";
    }
    if (h2 < 17) {
      return "afternoon";
    }
    if (h2 < 22) {
      return "evening";
    }
    return "night";
  },
  iso: function iso2(num) {
    if (num !== void 0) {
      return this.set(num);
    }
    return this.format("iso");
  }
};
var _01Time = methods$3;
var methods$2 = {
  date: function date3(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      num = parseInt(num, 10);
      if (num) {
        s2.epoch = set5.date(s2, num);
      }
      return s2;
    }
    return this.d.getDate();
  },
  day: function day3(input2) {
    if (input2 === void 0) {
      return this.d.getDay();
    }
    var original = this.clone();
    var want = input2;
    if (typeof input2 === "string") {
      input2 = input2.toLowerCase();
      if (days.aliases.hasOwnProperty(input2)) {
        want = days.aliases[input2];
      } else {
        want = days["short"]().indexOf(input2);
        if (want === -1) {
          want = days["long"]().indexOf(input2);
        }
      }
    }
    var day5 = this.d.getDay();
    var diff3 = day5 - want;
    var s2 = this.subtract(diff3, "days");
    walk_1(s2, {
      hour: original.hour(),
      minute: original.minute(),
      second: original.second()
    });
    return s2;
  },
  dayName: function dayName(input2) {
    if (input2 === void 0) {
      return days["long"]()[this.day()];
    }
    var s2 = this.clone();
    s2 = s2.day(input2);
    return s2;
  },
  month: function month4(input2) {
    if (input2 !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.month(s2, input2);
      return s2;
    }
    return this.d.getMonth();
  }
};
var _02Date = methods$2;
var clearMinutes = function clearMinutes2(s2) {
  s2 = s2.minute(0);
  s2 = s2.second(0);
  s2 = s2.millisecond(1);
  return s2;
};
var methods$1 = {
  dayOfYear: function dayOfYear2(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.dayOfYear(s2, num);
      return s2;
    }
    var sum = 0;
    var month6 = this.d.getMonth();
    var tmp2;
    for (var i = 1; i <= month6; i++) {
      tmp2 = new Date();
      tmp2.setDate(1);
      tmp2.setFullYear(this.d.getFullYear());
      tmp2.setHours(1);
      tmp2.setMinutes(1);
      tmp2.setMonth(i);
      tmp2.setHours(-2);
      sum += tmp2.getDate();
    }
    return sum + this.d.getDate();
  },
  week: function week2(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2 = s2.month(0);
      s2 = s2.date(1);
      s2 = s2.day("monday");
      s2 = clearMinutes(s2);
      if (s2.monthName() === "december" && s2.date() >= 28) {
        s2 = s2.add(1, "week");
      }
      num -= 1;
      s2 = s2.add(num, "weeks");
      return s2;
    }
    var tmp2 = this.clone();
    tmp2 = tmp2.month(0);
    tmp2 = tmp2.date(1);
    tmp2 = clearMinutes(tmp2);
    tmp2 = tmp2.day("monday");
    if (tmp2.monthName() === "december" && tmp2.date() >= 28) {
      tmp2 = tmp2.add(1, "week");
    }
    var toAdd = 1;
    if (tmp2.date() === 1) {
      toAdd = 0;
    }
    tmp2 = tmp2.minus(1, "second");
    var thisOne = this.epoch;
    if (tmp2.epoch > thisOne) {
      return 1;
    }
    var i = 0;
    var skipWeeks = this.month() * 4;
    tmp2.epoch += milliseconds.week * skipWeeks;
    i += skipWeeks;
    for (; i <= 52; i++) {
      if (tmp2.epoch > thisOne) {
        return i + toAdd;
      }
      tmp2 = tmp2.add(1, "week");
    }
    return 52;
  },
  monthName: function monthName(input2) {
    if (input2 === void 0) {
      return months$1["long"]()[this.month()];
    }
    var s2 = this.clone();
    s2 = s2.month(input2);
    return s2;
  },
  quarter: function quarter3(num) {
    if (num !== void 0) {
      if (typeof num === "string") {
        num = num.replace(/^q/i, "");
        num = parseInt(num, 10);
      }
      if (quarters[num]) {
        var s2 = this.clone();
        var _month = quarters[num][0];
        s2 = s2.month(_month);
        s2 = s2.date(1);
        s2 = s2.startOf("day");
        return s2;
      }
    }
    var month6 = this.d.getMonth();
    for (var i = 1; i < quarters.length; i++) {
      if (month6 < quarters[i][0]) {
        return i - 1;
      }
    }
    return 4;
  },
  season: function season3(input2) {
    var hem = "north";
    if (this.hemisphere() === "South") {
      hem = "south";
    }
    if (input2 !== void 0) {
      var s2 = this.clone();
      for (var i = 0; i < seasons[hem].length; i++) {
        if (input2 === seasons[hem][i][0]) {
          s2 = s2.month(seasons[hem][i][1]);
          s2 = s2.date(1);
          s2 = s2.startOf("day");
        }
      }
      return s2;
    }
    var month6 = this.d.getMonth();
    for (var _i = 0; _i < seasons[hem].length - 1; _i++) {
      if (month6 >= seasons[hem][_i][1] && month6 < seasons[hem][_i + 1][1]) {
        return seasons[hem][_i][0];
      }
    }
    return "winter";
  },
  year: function year4(num) {
    if (num !== void 0) {
      var s2 = this.clone();
      s2.epoch = set5.year(s2, num);
      return s2;
    }
    return this.d.getFullYear();
  },
  era: function era2(str) {
    if (str !== void 0) {
      var s2 = this.clone();
      str = str.toLowerCase();
      var year6 = s2.d.getFullYear();
      if (str === "bc" && year6 > 0) {
        s2.epoch = set5.year(s2, year6 * -1);
      }
      if (str === "ad" && year6 < 0) {
        s2.epoch = set5.year(s2, year6 * -1);
      }
      return s2;
    }
    if (this.d.getFullYear() < 0) {
      return "BC";
    }
    return "AD";
  },
  decade: function decade2(input2) {
    if (input2 !== void 0) {
      input2 = String(input2);
      input2 = input2.replace(/([0-9])'?s$/, "$1");
      input2 = input2.replace(/([0-9])(th|rd|st|nd)/, "$1");
      if (!input2) {
        console.warn("Spacetime: Invalid decade input");
        return this;
      }
      if (input2.length === 2 && /[0-9][0-9]/.test(input2)) {
        input2 = "19" + input2;
      }
      var year6 = Number(input2);
      if (isNaN(year6)) {
        return this;
      }
      year6 = Math.floor(year6 / 10) * 10;
      return this.year(year6);
    }
    return this.startOf("decade").year();
  },
  century: function century2(input2) {
    if (input2 !== void 0) {
      if (typeof input2 === "string") {
        input2 = input2.replace(/([0-9])(th|rd|st|nd)/, "$1");
        input2 = input2.replace(/([0-9]+) ?(b\.?c\.?|a\.?d\.?)/i, function(a2, b, c) {
          if (c.match(/b\.?c\.?/i)) {
            b = "-" + b;
          }
          return b;
        });
        input2 = input2.replace(/c$/, "");
      }
      var year6 = Number(input2);
      if (isNaN(input2)) {
        console.warn("Spacetime: Invalid century input");
        return this;
      }
      if (year6 === 0) {
        year6 = 1;
      }
      if (year6 >= 0) {
        year6 = (year6 - 1) * 100;
      } else {
        year6 = (year6 + 1) * 100;
      }
      return this.year(year6);
    }
    var num = this.startOf("century").year();
    num = Math.floor(num / 100);
    if (num < 0) {
      return num - 1;
    }
    return num + 1;
  },
  millenium: function millenium(input2) {
    if (input2 !== void 0) {
      if (typeof input2 === "string") {
        input2 = input2.replace(/([0-9])(th|rd|st|nd)/, "$1");
        input2 = Number(input2);
        if (isNaN(input2)) {
          console.warn("Spacetime: Invalid millenium input");
          return this;
        }
      }
      if (input2 > 0) {
        input2 -= 1;
      }
      var year6 = input2 * 1e3;
      if (year6 === 0) {
        year6 = 1;
      }
      return this.year(year6);
    }
    var num = Math.floor(this.year() / 1e3);
    if (num >= 0) {
      num += 1;
    }
    return num;
  }
};
var _03Year = methods$1;
var methods = Object.assign({}, _01Time, _02Date, _03Year);
methods.milliseconds = methods.millisecond;
methods.seconds = methods.second;
methods.minutes = methods.minute;
methods.hours = methods.hour;
methods.hour24 = methods.hour;
methods.h12 = methods.hour12;
methods.h24 = methods.hour24;
methods.days = methods.day;
var addMethods$4 = function addMethods(Space) {
  Object.keys(methods).forEach(function(k) {
    Space.prototype[k] = methods[k];
  });
};
var query = addMethods$4;
var isLeapYear = fns.isLeapYear;
var getMonthLength = function getMonthLength2(month6, year6) {
  if (month6 === 1 && isLeapYear(year6)) {
    return 29;
  }
  return monthLengths_1[month6];
};
var rollMonth = function rollMonth2(want, old) {
  if (want.month > 0) {
    var years = parseInt(want.month / 12, 10);
    want.year = old.year() + years;
    want.month = want.month % 12;
  } else if (want.month < 0) {
    var _years = Math.floor(Math.abs(want.month) / 13, 10);
    _years = Math.abs(_years) + 1;
    want.year = old.year() - _years;
    want.month = want.month % 12;
    want.month = want.month + 12;
    if (want.month === 12) {
      want.month = 0;
    }
  }
  return want;
};
var rollDaysDown = function rollDaysDown2(want, old, sum) {
  want.year = old.year();
  want.month = old.month();
  var date4 = old.date();
  want.date = date4 - Math.abs(sum);
  while (want.date < 1) {
    want.month -= 1;
    if (want.month < 0) {
      want.month = 11;
      want.year -= 1;
    }
    var max = getMonthLength(want.month, want.year);
    want.date += max;
  }
  return want;
};
var rollDaysUp = function rollDaysUp2(want, old, sum) {
  var year6 = old.year();
  var month6 = old.month();
  var max = getMonthLength(month6, year6);
  while (sum > max) {
    sum -= max;
    month6 += 1;
    if (month6 >= 12) {
      month6 -= 12;
      year6 += 1;
    }
    max = getMonthLength(month6, year6);
  }
  want.month = month6;
  want.date = sum;
  return want;
};
var _model = {
  months: rollMonth,
  days: rollDaysUp,
  daysBack: rollDaysDown
};
var order = ["millisecond", "second", "minute", "hour", "date", "month"];
var keep = {
  second: order.slice(0, 1),
  minute: order.slice(0, 2),
  quarterhour: order.slice(0, 2),
  hour: order.slice(0, 3),
  date: order.slice(0, 4),
  month: order.slice(0, 4),
  quarter: order.slice(0, 4),
  season: order.slice(0, 4),
  year: order,
  decade: order,
  century: order
};
keep.week = keep.hour;
keep.season = keep.date;
keep.quarter = keep.date;
var dstAwareUnits = {
  year: true,
  quarter: true,
  season: true,
  month: true,
  week: true,
  day: true
};
var keepDate = {
  month: true,
  quarter: true,
  season: true,
  year: true
};
var addMethods$3 = function addMethods2(SpaceTime3) {
  SpaceTime3.prototype.add = function(num, unit) {
    var s2 = this.clone();
    if (!unit || num === 0) {
      return s2;
    }
    var old = this.clone();
    unit = fns.normalize(unit);
    if (unit === "millisecond") {
      s2.epoch += num;
      return s2;
    }
    if (unit === "fortnight") {
      num *= 2;
      unit = "week";
    }
    if (milliseconds[unit]) {
      s2.epoch += milliseconds[unit] * num;
    } else if (unit === "week") {
      s2.epoch += milliseconds.day * (num * 7);
    } else if (unit === "quarter" || unit === "season") {
      s2.epoch += milliseconds.month * (num * 3);
    } else if (unit === "quarterhour") {
      s2.epoch += milliseconds.minute * 15 * num;
    }
    var want = {};
    if (keep[unit]) {
      keep[unit].forEach(function(u) {
        want[u] = old[u]();
      });
    }
    if (dstAwareUnits[unit]) {
      var diff3 = old.timezone().current.offset - s2.timezone().current.offset;
      s2.epoch += diff3 * 3600 * 1e3;
    }
    if (unit === "month") {
      want.month = old.month() + num;
      want = _model.months(want, old);
    }
    if (unit === "week") {
      var sum = old.date() + num * 7;
      if (sum <= 28 && sum > 1) {
        want.date = sum;
      }
    } else if (unit === "date") {
      if (num < 0) {
        want = _model.daysBack(want, old, num);
      } else {
        var _sum = old.date() + num;
        want = _model.days(want, old, _sum);
      }
      if (num !== 0 && old.isSame(s2, "day")) {
        want.date = old.date() + num;
      }
    } else if (unit === "quarter") {
      want.month = old.month() + num * 3;
      want.year = old.year();
      if (want.month < 0) {
        var years = Math.floor(want.month / 12);
        var remainder = want.month + Math.abs(years) * 12;
        want.month = remainder;
        want.year += years;
      } else if (want.month >= 12) {
        var _years = Math.floor(want.month / 12);
        want.month = want.month % 12;
        want.year += _years;
      }
      want.date = old.date();
    } else if (unit === "year") {
      var wantYear = old.year() + num;
      var haveYear = s2.year();
      if (haveYear < wantYear) {
        s2.epoch += milliseconds.day;
      } else if (haveYear > wantYear) {
        s2.epoch += milliseconds.day;
      }
    } else if (unit === "decade") {
      want.year = s2.year() + 10;
    } else if (unit === "century") {
      want.year = s2.year() + 100;
    }
    if (keepDate[unit]) {
      var max = monthLengths_1[want.month];
      want.date = old.date();
      if (want.date > max) {
        want.date = max;
      }
    }
    if (Object.keys(want).length > 1) {
      walk_1(s2, want);
    }
    return s2;
  };
  SpaceTime3.prototype.subtract = function(num, unit) {
    var s2 = this.clone();
    return s2.add(num * -1, unit);
  };
  SpaceTime3.prototype.minus = SpaceTime3.prototype.subtract;
  SpaceTime3.prototype.plus = SpaceTime3.prototype.add;
};
var add = addMethods$3;
var print = {
  millisecond: function millisecond2(s2) {
    return s2.epoch;
  },
  second: function second3(s2) {
    return [s2.year(), s2.month(), s2.date(), s2.hour(), s2.minute(), s2.second()].join("-");
  },
  minute: function minute4(s2) {
    return [s2.year(), s2.month(), s2.date(), s2.hour(), s2.minute()].join("-");
  },
  hour: function hour4(s2) {
    return [s2.year(), s2.month(), s2.date(), s2.hour()].join("-");
  },
  day: function day4(s2) {
    return [s2.year(), s2.month(), s2.date()].join("-");
  },
  week: function week3(s2) {
    return [s2.year(), s2.week()].join("-");
  },
  month: function month5(s2) {
    return [s2.year(), s2.month()].join("-");
  },
  quarter: function quarter4(s2) {
    return [s2.year(), s2.quarter()].join("-");
  },
  year: function year5(s2) {
    return s2.year();
  }
};
print.date = print.day;
var addMethods$2 = function addMethods3(SpaceTime3) {
  SpaceTime3.prototype.isSame = function(b, unit) {
    var tzAware = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var a2 = this;
    if (!unit) {
      return null;
    }
    if (typeof b === "string" && _typeof4(unit) === "object") {
      var tmp2 = b;
      b = unit;
      unit = tmp2;
    }
    if (typeof b === "string" || typeof b === "number") {
      b = new SpaceTime3(b, this.timezone.name);
    }
    unit = unit.replace(/s$/, "");
    if (tzAware === true && a2.tz !== b.tz) {
      b = b.clone();
      b.tz = a2.tz;
    }
    if (print[unit]) {
      return print[unit](a2) === print[unit](b);
    }
    return null;
  };
};
var same = addMethods$2;
var addMethods$1 = function addMethods4(SpaceTime3) {
  var methods2 = {
    isAfter: function isAfter(d2) {
      d2 = fns.beADate(d2, this);
      var epoch = fns.getEpoch(d2);
      if (epoch === null) {
        return null;
      }
      return this.epoch > epoch;
    },
    isBefore: function isBefore(d2) {
      d2 = fns.beADate(d2, this);
      var epoch = fns.getEpoch(d2);
      if (epoch === null) {
        return null;
      }
      return this.epoch < epoch;
    },
    isEqual: function isEqual(d2) {
      d2 = fns.beADate(d2, this);
      var epoch = fns.getEpoch(d2);
      if (epoch === null) {
        return null;
      }
      return this.epoch === epoch;
    },
    isBetween: function isBetween(start, end) {
      var isInclusive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      start = fns.beADate(start, this);
      end = fns.beADate(end, this);
      var startEpoch = fns.getEpoch(start);
      if (startEpoch === null) {
        return null;
      }
      var endEpoch = fns.getEpoch(end);
      if (endEpoch === null) {
        return null;
      }
      if (isInclusive) {
        return this.isBetween(start, end) || this.isEqual(start) || this.isEqual(end);
      }
      return startEpoch < this.epoch && this.epoch < endEpoch;
    }
  };
  Object.keys(methods2).forEach(function(k) {
    SpaceTime3.prototype[k] = methods2[k];
  });
};
var compare = addMethods$1;
var addMethods5 = function addMethods6(SpaceTime3) {
  var methods2 = {
    i18n: function i18n2(data3) {
      if (fns.isObject(data3.days)) {
        days.set(data3.days);
      }
      if (fns.isObject(data3.months)) {
        months$1.set(data3.months);
      }
      if (fns.isBoolean(data3.useTitleCase)) {
        caseFormat.set(data3.useTitleCase);
      }
    }
  };
  Object.keys(methods2).forEach(function(k) {
    SpaceTime3.prototype[k] = methods2[k];
  });
};
var i18n = addMethods5;
var timezones = unpack;
var SpaceTime = function SpaceTime2(input$1, tz) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  this.epoch = null;
  this.tz = find(tz, timezones);
  this.silent = options2.silent || true;
  this.british = options2.dmy || options2.british;
  this._weekStart = 1;
  if (options2.weekStart !== void 0) {
    this._weekStart = options2.weekStart;
  }
  this._today = {};
  if (options2.today !== void 0) {
    this._today = options2.today;
  }
  Object.defineProperty(this, "d", {
    get: function get() {
      var offset3 = quick(this);
      var bias = new Date(this.epoch).getTimezoneOffset() || 0;
      var shift = bias + offset3 * 60;
      shift = shift * 60 * 1e3;
      var epoch = this.epoch + shift;
      var d2 = new Date(epoch);
      return d2;
    }
  });
  Object.defineProperty(this, "timezones", {
    get: function get() {
      return timezones;
    },
    set: function set6(obj) {
      timezones = obj;
      return obj;
    }
  });
  var tmp2 = input(this, input$1, tz);
  this.epoch = tmp2.epoch;
};
Object.keys(methods_1).forEach(function(k) {
  SpaceTime.prototype[k] = methods_1[k];
});
SpaceTime.prototype.clone = function() {
  return new SpaceTime(this.epoch, this.tz, {
    silent: this.silent,
    weekStart: this._weekStart,
    today: this._today
  });
};
SpaceTime.prototype.toLocalDate = function() {
  return new Date(this.epoch);
};
query(SpaceTime);
add(SpaceTime);
same(SpaceTime);
compare(SpaceTime);
i18n(SpaceTime);
var spacetime = SpaceTime;
var whereIts = function whereIts2(a2, b) {
  var start = new spacetime(null);
  var end = new spacetime(null);
  start = start.time(a2);
  if (b) {
    end = end.time(b);
  } else {
    end = start.add(59, "minutes");
  }
  var startHour = start.hour();
  var endHour = end.hour();
  var tzs = Object.keys(start.timezones).filter(function(tz) {
    if (tz.indexOf("/") === -1) {
      return false;
    }
    var m2 = new spacetime(null, tz);
    var hour5 = m2.hour();
    if (hour5 >= startHour && hour5 <= endHour) {
      if (hour5 === startHour && m2.minute() < start.minute()) {
        return false;
      }
      if (hour5 === endHour && m2.minute() > end.minute()) {
        return false;
      }
      return true;
    }
    return false;
  });
  return tzs;
};
var whereIts_1 = whereIts;
var _version = "6.14.0";
var main2 = function main3(input2, tz, options2) {
  return new spacetime(input2, tz, options2);
};
var setToday = function setToday2(s2) {
  var today2 = s2._today || {};
  Object.keys(today2).forEach(function(k) {
    s2 = s2[k](today2[k]);
  });
  return s2;
};
main2.now = function(tz, options2) {
  var s2 = new spacetime(new Date().getTime(), tz, options2);
  s2 = setToday(s2);
  return s2;
};
main2.today = function(tz, options2) {
  var s2 = new spacetime(new Date().getTime(), tz, options2);
  s2 = setToday(s2);
  return s2.startOf("day");
};
main2.tomorrow = function(tz, options2) {
  var s2 = new spacetime(new Date().getTime(), tz, options2);
  s2 = setToday(s2);
  return s2.add(1, "day").startOf("day");
};
main2.yesterday = function(tz, options2) {
  var s2 = new spacetime(new Date().getTime(), tz, options2);
  s2 = setToday(s2);
  return s2.subtract(1, "day").startOf("day");
};
main2.extend = function(obj) {
  Object.keys(obj).forEach(function(k) {
    spacetime.prototype[k] = obj[k];
  });
  return this;
};
main2.timezones = function() {
  var s2 = new spacetime();
  return s2.timezones;
};
main2.max = function(tz, options2) {
  var s2 = new spacetime(null, tz, options2);
  s2.epoch = 864e13;
  return s2;
};
main2.min = function(tz, options2) {
  var s2 = new spacetime(null, tz, options2);
  s2.epoch = -864e13;
  return s2;
};
main2.whereIts = whereIts_1;
main2.version = _version;
main2.plugin = main2.extend;
var src = main2;
var spacetime_default = src;

// node_modules/spacetime-informal/builds/spacetime-informal.mjs
var iana = {
  Africa: ["Abidjan", "Accra", "Addis_Ababa", "Algiers", "Asmara", "Asmera", "Bamako", "Bangui", "Banjul", "Bissau", "Blantyre", "Brazzaville", "Bujumbura", "Cairo", "Casablanca", "Ceuta", "Conakry", "Dakar", "Dar_Es_Salaam", "Djibouti", "Douala", "El_Aaiun", "Freetown", "Gaborone", "Harare", "Johannesburg", "Juba", "Kampala", "Khartoum", "Kigali", "Kinshasa", "Lagos", "Libreville", "Lome", "Luanda", "Lubumbashi", "Lusaka", "Malabo", "Maputo", "Maseru", "Mbabane", "Mogadishu", "Monrovia", "Nairobi", "Ndjamena", "Niamey", "Nouakchott", "Ouagadougou", "Porto-novo", "Sao_Tome", "Timbuktu", "Tripoli", "Tunis", "Windhoek"],
  America: ["Adak", "Anchorage", "Anguilla", "Antigua", "Araguaina", "Argentina", "Aruba", "Asuncion", "Atikokan", "Atka", "Bahia", "Bahia_Banderas", "Barbados", "Belem", "Belize", "Blanc-sablon", "Boa_Vista", "Bogota", "Boise", "Buenos_Aires", "Cambridge_Bay", "Campo_Grande", "Cancun", "Caracas", "Catamarca", "Cayenne", "Cayman", "Chicago", "Chihuahua", "Coral_Harbour", "Cordoba", "Costa_Rica", "Creston", "Cuiaba", "Curacao", "Danmarkshavn", "Dawson", "Dawson_Creek", "Denver", "Detroit", "Dominica", "Edmonton", "Eirunepe", "El_Salvador", "Ensenada", "Fort_Wayne", "Fortaleza", "Glace_Bay", "Godthab", "Goose_Bay", "Grand_Turk", "Grenada", "Guadeloupe", "Guatemala", "Guayaquil", "Guyana", "Halifax", "Havana", "Hermosillo", "Indiana", "Indianapolis", "Inuvik", "Iqaluit", "Jamaica", "Jujuy", "Juneau", "Kentucky", "Knox_In", "Kralendijk", "La_Paz", "Lima", "Los_Angeles", "Louisville", "Lower_Princes", "Maceio", "Managua", "Manaus", "Marigot", "Martinique", "Matamoros", "Mazatlan", "Mendoza", "Menominee", "Merida", "Metlakatla", "Mexico_City", "Miquelon", "Moncton", "Monterrey", "Montevideo", "Montreal", "Montserrat", "Nassau", "New_York", "Nipigon", "Nome", "Noronha", "North_Dakota", "Ojinaga", "Panama", "Pangnirtung", "Paramaribo", "Phoenix", "Port-au-prince", "Port_Of_Spain", "Porto_Acre", "Porto_Velho", "Puerto_Rico", "Punta_Arenas", "Rainy_River", "Rankin_Inlet", "Recife", "Regina", "Resolute", "Rio_Branco", "Rosario", "Santa_Isabel", "Santarem", "Santiago", "Santo_Domingo", "Sao_Paulo", "Scoresbysund", "Shiprock", "Sitka", "St_Barthelemy", "St_Johns", "St_Kitts", "St_Lucia", "St_Thomas", "St_Vincent", "Swift_Current", "Tegucigalpa", "Thule", "Thunder_Bay", "Tijuana", "Toronto", "Tortola", "Vancouver", "Virgin", "Whitehorse", "Winnipeg", "Yakutat", "Yellowknife"],
  Antarctica: ["Casey", "Davis", "Dumontdurville", "Macquarie", "Mawson", "Mcmurdo", "Palmer", "Rothera", "South_Pole", "Syowa", "Troll", "Vostok"],
  Arctic: ["Longyearbyen"],
  Asia: ["Aden", "Almaty", "Amman", "Anadyr", "Aqtau", "Aqtobe", "Ashgabat", "Ashkhabad", "Atyrau", "Baghdad", "Bahrain", "Baku", "Bangkok", "Barnaul", "Beirut", "Bishkek", "Brunei", "Calcutta", "Chita", "Choibalsan", "Chongqing", "Chungking", "Colombo", "Dacca", "Damascus", "Dhaka", "Dili", "Dubai", "Dushanbe", "Gaza", "Harbin", "Hebron", "Ho_Chi_Minh", "Hong_Kong", "Hovd", "Irkutsk", "Istanbul", "Jakarta", "Jayapura", "Jerusalem", "Kabul", "Kamchatka", "Karachi", "Kashgar", "Kathmandu", "Katmandu", "Khandyga", "Kolkata", "Krasnoyarsk", "Kuala_Lumpur", "Kuching", "Kuwait", "Macao", "Macau", "Magadan", "Makassar", "Manila", "Muscat", "Nicosia", "Novokuznetsk", "Novosibirsk", "Omsk", "Oral", "Phnom_Penh", "Pontianak", "Pyongyang", "Qatar", "Qyzylorda", "Rangoon", "Riyadh", "Saigon", "Sakhalin", "Samarkand", "Seoul", "Shanghai", "Singapore", "Srednekolymsk", "Taipei", "Tashkent", "Tbilisi", "Tehran", "Tel_Aviv", "Thimbu", "Thimphu", "Tokyo", "Tomsk", "Ujung_Pandang", "Ulaanbaatar", "Ulan_Bator", "Urumqi", "Ust-nera", "Vientiane", "Vladivostok", "Yakutsk", "Yekaterinburg", "Yerevan", "Volgograd"],
  Atlantic: ["Azores", "Bermuda", "Canary", "Cape_Verde", "Faeroe", "Faroe", "Jan_Mayen", "Madeira", "Reykjavik", "South_Georgia", "St_Helena", "Stanley"],
  Australia: ["Act", "Adelaide", "Brisbane", "Broken_Hill", "Canberra", "Currie", "Darwin", "Eucla", "Hobart", "Lhi", "Lindeman", "Lord_Howe", "Melbourne", "Nsw", "North", "Perth", "Queensland", "South", "Sydney", "Tasmania", "Victoria", "West", "Yancowinna"],
  Brazil: ["Acre", "Denoronha", "East", "West"],
  Canada: ["Atlantic", "Central", "East-saskatchewan", "Eastern", "Mountain", "Newfoundland", "Pacific", "Saskatchewan", "Yukon"],
  Chile: ["Continental", "EasterIsland"],
  Europe: ["Amsterdam", "Andorra", "Astrakhan", "Athens", "Belfast", "Belgrade", "Berlin", "Bratislava", "Brussels", "Bucharest", "Budapest", "Busingen", "Chisinau", "Copenhagen", "Dublin", "Gibraltar", "Guernsey", "Helsinki", "Isle_Of_Man", "Istanbul", "Jersey", "Kaliningrad", "Kirov", "Kiev", "Lisbon", "Ljubljana", "London", "Luxembourg", "Madrid", "Malta", "Mariehamn", "Minsk", "Monaco", "Moscow", "Nicosia", "Oslo", "Paris", "Podgorica", "Prague", "Riga", "Rome", "Samara", "Saratov", "San_Marino", "Sarajevo", "Simferopol", "Skopje", "Sofia", "Stockholm", "Tallinn", "Tirane", "Tiraspol", "Ulyanovsk", "Uzhgorod", "Vaduz", "Vatican", "Vienna", "Vilnius", "Volgograd", "Warsaw", "Zagreb", "Zaporozhye", "Zurich"],
  Indian: ["Antananarivo", "Chagos", "Christmas", "Cocos", "Comoro", "Kerguelen", "Mahe", "Maldives", "Mauritius", "Mayotte", "Reunion"],
  Mexico: ["Bajanorte", "Bajasur", "General"],
  Pacific: ["Apia", "Auckland", "Bougainville", "Chatham", "Chuuk", "Easter", "Efate", "Enderbury", "Fakaofo", "Fiji", "Funafuti", "Galapagos", "Gambier", "Guadalcanal", "Guam", "Honolulu", "Johnston", "Kiritimati", "Kosrae", "Kwajalein", "Majuro", "Marquesas", "Midway", "Nauru", "Niue", "Norfolk", "Noumea", "Pago_Pago", "Palau", "Pitcairn", "Pohnpei", "Ponape", "Port_Moresby", "Rarotonga", "Saipan", "Samoa", "Tahiti", "Tarawa", "Tongatapu", "Truk", "Wake", "Wallis", "Yap"],
  ETC: ["GMT", "GMT+0", "GMT-0", "GMT0", "Greenwich", "UTC", "Universal", "Zulu"]
};
var ignore = {
  east: true,
  west: true
};
var zones = {};
Object.keys(iana).forEach(function(k) {
  iana[k].forEach(function(str) {
    var id = k + "/" + str;
    zones[id.toLowerCase()] = id;
    if (!ignore[str]) {
      str = str.toLowerCase();
      str = str.replace(/[_-]/g, " ");
      zones[str] = id;
    }
  });
});
var _01Iana = zones;
var _02ByCity = {
  "san fransisco": "America/Los_Angeles",
  ottawa: "America/Toronto",
  montreal: "America/Toronto",
  chongqing: "Asia/Shanghai",
  beijing: "Asia/Shanghai",
  chengdu: "Asia/Shanghai",
  guangzhou: "Asia/Shanghai",
  tianjin: "Asia/Shanghai",
  baoding: "Asia/Shanghai",
  wenzhou: "Asia/Shanghai",
  xian: "Asia/Shanghai",
  shenzhen: "Asia/Shanghai",
  suzhou: "Asia/Shanghai",
  nanjing: "Asia/Shanghai",
  dongguan: "Asia/Shanghai",
  quanzhou: "Asia/Shanghai",
  "hong kong": "Asia/Shanghai",
  mumbai: "Asia/Kolkata",
  bombay: "Asia/Kolkata",
  madras: "Asia/Kolkata",
  calcutta: "Asia/Kolkata",
  "port blair": "Asia/Kolkata",
  delhi: "Asia/Kolkata",
  chennai: "Asia/Kolkata",
  bangalore: "Asia/Kolkata",
  hyderabad: "Asia/Kolkata",
  lahore: "Asia/Karachi",
  islamabad: "Asia/Karachi",
  peshawar: "Asia/Karachi",
  multan: "Asia/Karachi"
};
var _04OldZones = {
  "africa/asmera": "Africa/Nairobi",
  "africa/timbuktu": "Africa/Abidjan",
  "america/argentina/comodrivadavia": "America/Argentina",
  "america/atka": "America/Adak",
  "america/buenos_aires": "America/Argentina",
  "america/argentina/buenos_aires": "America/Argentina",
  "america/catamarca": "America/Argentina",
  "america/argentina/catamarca": "America/Argentina",
  "america/coral_harbour": "America/Atikokan",
  "america/cordoba": "America/Argentina",
  "america/argentina/cordoba": "America/Argentina",
  "america/ensenada": "America/Tijuana",
  "america/fort_wayne": "America/Indiana",
  "america/indiana/indianapolis": "America/Indiana",
  "america/indianapolis": "America/Indiana",
  "america/jujuy": "America/Argentina",
  "america/knox_in": "America/Indiana",
  "america/louisville": "America/Kentucky",
  "america/kentucky/louisville": "America/Kentucky",
  "america/mendoza": "America/Argentina",
  "america/montreal": "America/Toronto",
  "america/porto_acre": "America/Rio_Branco",
  "america/rosario": "America/Argentina",
  "america/santa_isabel": "America/Tijuana",
  "america/shiprock": "America/Denver",
  "america/virgin": "America/Port_Of_Spain",
  "antarctica/south_pole": "Pacific/Auckland",
  "asia/ashkhabad": "Asia/Ashgabat",
  "asia/calcutta": "Asia/Kolkata",
  "asia/chongqing": "Asia/Shanghai",
  "asia/chungking": "Asia/Shanghai",
  "asia/dacca": "Asia/Dhaka",
  "asia/harbin": "Asia/Shanghai",
  "asia/kashgar": "Asia/Urumqi",
  "asia/katmandu": "Asia/Kathmandu",
  "asia/macao": "Asia/Macau",
  "asia/rangoon": "Asia/Yangon",
  "asia/saigon": "Asia/Ho_Chi_Minh",
  "asia/tel_aviv": "Asia/Jerusalem",
  "asia/thimbu": "Asia/Thimphu",
  "asia/ujung_pandang": "Asia/Makassar",
  "asia/ulan_bator": "Asia/Ulaanbaatar",
  "atlantic/faeroe": "atlantic/Faroe",
  "atlantic/jan_mayen": "Europe/Oslo",
  "australia/act": "Australia/Sydney",
  "australia/canberra": "Australia/Sydney",
  "australia/lhi": "Australia/Lord_Howe",
  "australia/nsw": "Australia/Sydney",
  "australia/north": "Australia/Darwin",
  "australia/queensland": "Australia/Brisbane",
  "australia/south": "Australia/Adelaide",
  "australia/tasmania": "Australia/Hobart",
  "australia/victoria": "Australia/Melbourne",
  "australia/west": "Australia/Perth",
  "australia/yancowinna": "Australia/Broken_Hill",
  "brazil/acre": "America/Rio_Branco",
  "brazil/denoronha": "America/Noronha",
  "brazil/east": "America/Sao_Paulo",
  "brazil/west": "America/Manaus",
  "canada/atlantic": "America/Halifax",
  "canada/central": "America/Winnipeg",
  "canada/east-saskatchewan": "America/Regina",
  "canada/eastern": "America/Toronto",
  "canada/mountain": "America/Edmonton",
  "canada/newfoundland": "America/St_Johns",
  "canada/pacific": "America/Vancouver",
  "canada/saskatchewan": "America/Regina",
  "canada/yukon": "America/Whitehorse",
  "chile/continental": "America/Santiago",
  "chile/easterisland": "Pacific/Easter",
  cuba: "America/Havana",
  egypt: "Africa/Cairo",
  eire: "Europe/Dublin",
  "europe/belfast": "Europe/London",
  "europe/tiraspol": "Europe/Chisinau",
  gb: "Europe/London",
  "gb-eire": "Europe/London",
  "gmt+0": "etc/Gmt",
  "gmt-0": "etc/Gmt",
  gmt0: "etc/Gmt",
  greenwich: "etc/Gmt",
  hongkong: "Asia/Hong_Kong",
  iceland: "atlantic/Reykjavik",
  iran: "Asia/Tehran",
  israel: "Asia/Jerusalem",
  jamaica: "America/Jamaica",
  japan: "Asia/Tokyo",
  kwajalein: "Pacific/Kwajalein",
  libya: "Africa/Tripoli",
  "mexico/bajanorte": "America/Tijuana",
  "mexico/bajasur": "America/Mazatlan",
  "mexico/general": "America/Mexico_City",
  nz: "Pacific/Auckland",
  "nz-chat": "Pacific/Chatham",
  navajo: "America/Denver",
  prc: "Asia/Shanghai",
  "pacific/johnston": "Pacific/Honolulu",
  "pacific/ponape": "Pacific/Pohnpei",
  "pacific/samoa": "Pacific/Pago_Pago",
  "pacific/truk": "Pacific/Chuuk",
  "pacific/yap": "Pacific/Chuuk",
  poland: "Europe/Warsaw",
  portugal: "Europe/Lisbon",
  roc: "Asia/Taipei",
  rok: "Asia/Seoul",
  "us/alaska": "America/Anchorage",
  "us/aleutian": "America/Adak",
  "us/arizona": "America/Phoenix",
  "us/central": "America/Chicago",
  "us/east-indiana": "America/Indiana",
  "us/eastern": "America/New_York",
  "us/hawaii": "Pacific/Honolulu",
  "us/indiana-starke": "America/Indiana",
  "america/indiana/knox": "America/Indiana",
  "us/michigan": "America/Detroit",
  "us/mountain": "America/Denver",
  "us/pacific": "America/Los_Angeles",
  "us/samoa": "Pacific/Pago_Pago",
  universal: "etc/Utc",
  "w-su": "Europe/Moscow",
  zulu: "Etc/Utc",
  z: "Etc/Utc",
  "america/argentina/jujuy": "America/Jujuy",
  "america/argentina/mendoza": "America/Mendoza",
  "america/atikokan": "America/Coral_Harbour",
  "europe/nicosia": "Asia/Nicosia",
  "africa/asmara": "Africa/Asmera",
  "pacific/pohnpei": "Pacific/Ponape",
  "pacific/chuuk": "Pacific/Truk",
  "atlantic/faroe": "atlantic/Faeroe",
  "asia/kolkata": "Asia/Calcutta",
  "asia/yangon": "Asia/Rangoon",
  "asia/kathmandu": "Asia/Katmandu",
  "asia/ho_chi_minh": "Asia/Saigon",
  "asia/istanbul": "Europe/Istanbul",
  "etc/gmt+0": "Etc/Gmt",
  "etc/gmt-0": "Etc/Gmt",
  "etc/gmt0": "Etc/Gmt",
  "etc/greenwich": "etc/Gmt",
  "etc/uct": "Etc/Utc",
  "etc/universal": "Etc/Utc",
  "etc/zulu": "Etc/Utc",
  gmt: "etc/Gmt",
  singapore: "Asia/Singapore",
  "easter island": "Chile/EasterIsland",
  "us/pacific-new": "America/Los_Angeles",
  uct: "Etc/Utc",
  utc: "Etc/Utc",
  est: "Etc/Gmt+5",
  mst: "Etc/Gmt+7",
  hst: "Etc/Gmt+10"
};
var _07Parentheses = {
  "west africa time": "Africa/Lagos",
  casey: "Antarctica/Casey",
  davis: "Antarctica/Davis",
  "dumont-d'urville": "Antarctica/DumontDUrville",
  mawson: "Antarctica/Mawson",
  palmer: "Antarctica/Palmer",
  rothera: "Antarctica/Rothera",
  syowa: "Antarctica/Syowa",
  troll: "Antarctica/Troll",
  vostok: "Antarctica/Vostok",
  "new zealand time": "Pacific/Auckland",
  "buenos aires (ba, cf)": "America/Argentina",
  "argentina (most areas: cb, cc, cn, er, fm, mn, se, sf)": "America/Argentina",
  "salta (sa, lp, nq, rn)": "America/Argentina",
  "jujuy (jy)": "America/Argentina",
  "tucum\xE1n (tm)": "America/Argentina",
  "catamarca (ct); chubut (ch)": "America/Argentina",
  "la rioja (lr)": "America/Argentina",
  "san juan (sj)": "America/Argentina",
  "mendoza (mz)": "America/Argentina",
  "san luis (sl)": "America/Argentina",
  "santa cruz (sc)": "America/Argentina",
  "tierra del fuego (tf)": "America/Argentina",
  "samoa, midway": "Pacific/Pago_Pago",
  "lord howe island": "Australia/Lord_Howe",
  "macquarie island": "Antarctica/Macquarie",
  "tasmania (most areas)": "Australia/Hobart",
  "tasmania (king island)": "Australia/Currie",
  victoria: "Australia/Melbourne",
  "new south wales (most areas)": "Australia/Sydney",
  "new south wales (yancowinna)": "Australia/Broken_Hill",
  "queensland (most areas)": "Australia/Brisbane",
  "queensland (whitsunday islands)": "Australia/Lindeman",
  "south australia": "Australia/Adelaide",
  "northern territory": "Australia/Darwin",
  "western australia (most areas)": "Australia/Perth",
  "western australia (eucla)": "Australia/Eucla",
  "central africa time": "Africa/Maputo",
  "atlantic islands": "America/Noronha",
  "par\xE1 (east); amap\xE1": "America/Belem",
  "brazil (northeast: ma, pi, ce, rn, pb)": "America/Fortaleza",
  pernambuco: "America/Recife",
  tocantins: "America/Araguaina",
  "alagoas, sergipe": "America/Maceio",
  bahia: "America/Bahia",
  "brazil (southeast: go, df, mg, es, rj, sp, pr, sc, rs)": "America/Sao_Paulo",
  "mato grosso do sul": "America/Campo_Grande",
  "mato grosso": "America/Cuiaba",
  "par\xE1 (west)": "America/Santarem",
  rond\u00F4nia: "America/Porto_Velho",
  roraima: "America/Boa_Vista",
  "amazonas (east)": "America/Manaus",
  "amazonas (west)": "America/Eirunepe",
  acre: "America/Rio_Branco",
  "newfoundland; labrador (southeast)": "America/St_Johns",
  "atlantic - ns (most areas); pe": "America/Halifax",
  "atlantic - ns (cape breton)": "America/Glace_Bay",
  "atlantic - new brunswick": "America/Moncton",
  "atlantic - labrador (most areas)": "America/Goose_Bay",
  "ast - qc (lower north shore)": "America/Blanc-Sablon",
  "eastern - on, qc (most areas)": "America/Toronto",
  "eastern - on, qc (no dst 1967-73)": "America/Nipigon",
  "eastern - on (thunder bay)": "America/Thunder_Bay",
  "eastern - nu (most east areas)": "America/Iqaluit",
  "eastern - nu (pangnirtung)": "America/Pangnirtung",
  "est - on (atikokan); nu (coral h)": "America/Atikokan",
  "central - on (west); manitoba": "America/Winnipeg",
  "central - on (rainy r, ft frances)": "America/Rainy_River",
  "central - nu (resolute)": "America/Resolute",
  "central - nu (central)": "America/Rankin_Inlet",
  "cst - sk (most areas)": "America/Regina",
  "cst - sk (midwest)": "America/Swift_Current",
  "mountain - ab; bc (e); sk (w)": "America/Edmonton",
  "mountain - nu (west)": "America/Cambridge_Bay",
  "mountain - nt (central)": "America/Yellowknife",
  "mountain - nt (west)": "America/Inuvik",
  "mst - bc (creston)": "America/Creston",
  "mst - bc (dawson cr, ft st john)": "America/Dawson_Creek",
  "mst - bc (ft nelson)": "America/Fort_Nelson",
  "pacific - bc (most areas)": "America/Vancouver",
  "pacific - yukon (south)": "America/Whitehorse",
  "pacific - yukon (north)": "America/Dawson",
  "swiss time": "Europe/Zurich",
  "chile (most areas)": "America/Santiago",
  "region of magallanes": "America/Punta_Arenas",
  "easter island": "Chile/EasterIsland",
  "beijing time": "Asia/Shanghai",
  "xinjiang time": "Asia/Urumqi",
  "cyprus (most areas)": "Asia/Nicosia",
  "northern cyprus": "Asia/Famagusta",
  "germany (most areas)": "Europe/Berlin",
  "ecuador (mainland)": "America/Guayaquil",
  "gal\xE1pagos islands": "Pacific/Galapagos",
  "spain (mainland)": "Europe/Madrid",
  "ceuta, melilla": "Africa/Ceuta",
  "canary islands": "Atlantic/Canary",
  "chuuk/truk, yap": "Pacific/Chuuk",
  "pohnpei/ponape": "Pacific/Pohnpei",
  kosrae: "Pacific/Kosrae",
  "greenland (most areas)": "America/Godthab",
  "national park (east coast)": "America/Danmarkshavn",
  "scoresbysund/ittoqqortoormiit": "America/Scoresbysund",
  "thule/pituffik": "America/Thule",
  "java, sumatra": "Asia/Jakarta",
  "borneo (west, central)": "Asia/Pontianak",
  "borneo (east, south); sulawesi/celebes, bali, nusa tengarra; timor (west)": "Asia/Makassar",
  "new guinea (west papua / irian jaya); malukus/moluccas": "Asia/Jayapura",
  "indochina (most areas)": "Asia/Bangkok",
  "gilbert islands": "Pacific/Tarawa",
  "phoenix islands": "Pacific/Enderbury",
  "line islands": "Pacific/Kiritimati",
  "kazakhstan (most areas)": "Asia/Almaty",
  "qyzylorda/kyzylorda/kzyl-orda": "Asia/Qyzylorda",
  "aqt\xF6be/aktobe": "Asia/Aqtobe",
  "mangghysta\u016B/mankistau": "Asia/Aqtau",
  "atyra\u016B/atirau/gur'yev": "Asia/Atyrau",
  "west kazakhstan": "Asia/Oral",
  "marshall islands (most areas)": "Pacific/Majuro",
  kwajalein: "Pacific/Kwajalein",
  "mongolia (most areas)": "Asia/Ulaanbaatar",
  "bayan-\xF6lgii, govi-altai, hovd, uvs, zavkhan": "Asia/Hovd",
  "dornod, s\xFCkhbaatar": "Asia/Choibalsan",
  "central time": "America/Mexico_City",
  "eastern standard time - quintana roo": "America/Cancun",
  "central time - campeche, yucat\xE1n": "America/Merida",
  "central time - durango; coahuila, nuevo le\xF3n, tamaulipas (most areas)": "America/Monterrey",
  "central time us - coahuila, nuevo le\xF3n, tamaulipas (us border)": "America/Matamoros",
  "mountain time - baja california sur, nayarit, sinaloa": "America/Mazatlan",
  "mountain time - chihuahua (most areas)": "America/Chihuahua",
  "mountain time us - chihuahua (us border)": "America/Ojinaga",
  "mountain standard time - sonora": "America/Hermosillo",
  "pacific time us - baja california": "America/Tijuana",
  "central time - bah\xEDa de banderas": "America/Bahia_Banderas",
  "malaysia (peninsula)": "Asia/Kuala_Lumpur",
  "sabah, sarawak": "Asia/Kuching",
  "chatham islands": "Pacific/Chatham",
  "society islands": "Pacific/Tahiti",
  "marquesas islands": "Pacific/Marquesas",
  "gambier islands": "Pacific/Gambier",
  "papua new guinea (most areas)": "Pacific/Port_Moresby",
  bougainville: "Pacific/Bougainville",
  "gaza strip": "Asia/Gaza",
  "west bank": "Asia/Hebron",
  "portugal (mainland)": "Europe/Lisbon",
  "madeira islands": "Atlantic/Madeira",
  azores: "Atlantic/Azores",
  "r\xE9union, crozet, scattered islands": "Indian/Reunion",
  "msk-01 - kaliningrad": "Europe/Kaliningrad",
  "msk+00 - moscow area": "Europe/Moscow",
  "msk+00 - crimea": "Europe/Simferopol",
  "msk+00 - volgograd": "Europe/Volgograd",
  "msk+00 - kirov": "Europe/Kirov",
  "msk+01 - astrakhan": "Europe/Astrakhan",
  "msk+01 - saratov": "Europe/Saratov",
  "msk+01 - ulyanovsk": "Europe/Ulyanovsk",
  "msk+01 - samara, udmurtia": "Europe/Samara",
  "msk+02 - urals": "Asia/Yekaterinburg",
  "msk+03 - omsk": "Asia/Omsk",
  "msk+04 - novosibirsk": "Asia/Novosibirsk",
  "msk+04 - altai": "Asia/Barnaul",
  "msk+04 - tomsk": "Asia/Tomsk",
  "msk+04 - kemerovo": "Asia/Novokuznetsk",
  "msk+04 - krasnoyarsk area": "Asia/Krasnoyarsk",
  "msk+05 - irkutsk, buryatia": "Asia/Irkutsk",
  "msk+06 - zabaykalsky": "Asia/Chita",
  "msk+06 - lena river": "Asia/Yakutsk",
  "msk+06 - tomponsky, ust-maysky": "Asia/Khandyga",
  "msk+07 - amur river": "Asia/Vladivostok",
  "msk+07 - oymyakonsky": "Asia/Ust-Nera",
  "msk+08 - magadan": "Asia/Magadan",
  "msk+08 - sakhalin island": "Asia/Sakhalin",
  "msk+08 - sakha (e); north kuril is": "Asia/Srednekolymsk",
  "msk+09 - kamchatka": "Asia/Kamchatka",
  "msk+09 - bering sea": "Asia/Anadyr",
  "kerguelen, st paul island, amsterdam island": "Indian/Kerguelen",
  "ukraine (most areas)": "Europe/Kiev",
  ruthenia: "Europe/Uzhgorod",
  "zaporozh'ye/zaporizhia; lugansk/luhansk (east)": "Europe/Zaporozhye",
  "wake island": "Pacific/Wake",
  "eastern (most areas)": "America/New_York",
  "eastern - mi (most areas)": "America/Detroit",
  "eastern - ky (louisville area)": "America/Kentucky",
  "eastern - ky (wayne)": "America/Kentucky",
  "eastern - in (most areas)": "America/Indiana",
  "eastern - in (da, du, k, mn)": "America/Indiana",
  "eastern - in (pulaski)": "America/Indiana",
  "eastern - in (crawford)": "America/Indiana",
  "eastern - in (pike)": "America/Indiana",
  "eastern - in (switzerland)": "America/Indiana",
  "central (most areas)": "America/Chicago",
  "central - in (perry)": "America/Indiana",
  "central - in (starke)": "America/Indiana",
  "central - mi (wisconsin border)": "America/Menominee",
  "central - nd (oliver)": "America/North_Dakota",
  "central - nd (morton rural)": "America/North_Dakota",
  "central - nd (mercer)": "America/North_Dakota",
  "mountain (most areas)": "America/Denver",
  "mountain - id (south); or (east)": "America/Boise",
  "mst - arizona (except navajo)": "America/Phoenix",
  "alaska (most areas)": "America/Anchorage",
  "alaska - juneau area": "America/Juneau",
  "alaska - sitka area": "America/Sitka",
  "alaska - annette island": "America/Metlakatla",
  "alaska - yakutat": "America/Yakutat",
  "alaska (west)": "America/Nome",
  "aleutian islands": "America/Adak",
  "uzbekistan (west)": "Asia/Samarkand",
  "uzbekistan (east)": "Asia/Tashkent",
  "vietnam (south)": "Asia/Ho_Chi_Minh"
};
var informal = {
  "America/Halifax": ["ast", "adt", "atlantic"],
  "America/New_York": ["est", "edt", "eastern"],
  "America/Chicago": ["cst", "cdt", "central"],
  "America/Denver": ["mst", "mdt", "mountain"],
  "America/Los_Angeles": ["pst", "pdt", "pacific"],
  "America/Anchorage": ["ahst", "ahdt", "akst", "akdt", "alaska"],
  "America/St_Johns": ["nst", "ndt", "nt", "newfoundland", "nddt"],
  "America/Caracas": ["vet", null, "venezuela"],
  "America/Bogota": ["cot", null, "colombia"],
  "America/Cayenne": ["gft", null, "french guiana"],
  "America/Paramaribo": ["srt", null, "suriname"],
  "America/Guyana": ["gyt"],
  "America/Buenos_Aires": ["art", null, "argentina"],
  "America/La_Paz": ["bot", null, "bolivia"],
  "America/Asuncion": ["pyt", "pyst", "paraguay"],
  "America/Santiago": ["clt", "clst", "chile"],
  "America/Lima": ["pet", null, "peru"],
  "America/Montevideo": ["uyt", null, "uruguay"],
  "Atlantic/Stanley": ["fkst", null, "falkland island"],
  "America/Manaus": ["amt"],
  "America/Sao_Paulo": ["brt", "brst"],
  "Brazil/Acre": ["act"],
  "Europe/London": ["gmt", "bst", "british"],
  "ETC/GMT": ["gmt", null, "greenwich"],
  "Europe/Lisbon": ["wet", "west", "west europe"],
  "Europe/Berlin": ["cet", "cest", "central europe", "middle european", "met", "mest"],
  "Europe/Riga": ["eet", "eest", "east europe", "kalt"],
  "Europe/Moscow": ["msk", null, "fet", "mdst", "msd"],
  "Europe/Samara": ["samt"],
  "Asia/Yekaterinburg": ["yekt"],
  "Asia/Omsk": ["omst"],
  "Asia/Krasnoyarsk": ["krat"],
  "Asia/Novosibirsk": ["novt"],
  "Asia/Irkutsk": ["irkt"],
  "Asia/Yakutsk": ["yakt"],
  "Asia/Cladivostok": ["vlat"],
  "Asia/Magadan": ["magt"],
  "Asia/Sakhalin": ["sakt"],
  "Asia/Srednekolymsk": ["sret"],
  "Asia/Anadyr": ["anat"],
  "Asia/Kamchatka": ["pett"],
  "Asia/Tashkent": ["uzt", "uzbekistan"],
  "Asia/Bishkek": ["kgt", "kyrgyzstan"],
  "Antarctica/Vostok": ["vost"],
  "Asia/Hovd": ["hovt"],
  "Asia/Ashgabat": ["tmt", null, "turkmenistan"],
  "Africa/Lagos": ["wat", "wast", "west africa"],
  "Africa/Khartoum": ["cat", null, "central africa"],
  "Africa/Nairobi": ["eat", null, "east africa"],
  "Atlantic/Cape_Verde": ["cvt"],
  "Indian/Mauritius": ["mut"],
  "Indian/Reunion": ["ret"],
  "Africa/Johannesburg": ["sast", null, "south africa"],
  "Atlantic/Azores": ["azot", "azost", "hmt"],
  "America/Godthab": ["wgt", "wgst", "west greenland"],
  "America/Scoresbysund": ["egt", "egst", "east greenland"],
  "Europe/Istanbul": ["trt", null, "turkey"],
  "Asia/Tbilisi": ["get", null, "georgia"],
  "Asia/Baku": ["azt", null, "azerbaijan"],
  "Asia/Jerusalem": [null, "idt", "israel", "jmt", "iddt"],
  "Asia/Tehran": ["irst", "irdt", "iran"],
  "Asia/Karachi": ["pkt", null, "pakistan"],
  "Asia/Kabul": ["aft", null, "afghanistan"],
  "Asia/Dushanbe": ["tjt", null, "tajikistan"],
  "Asia/Almaty": ["almt", null, "alma ata"],
  "Asia/Dubai": ["gst", null, "gulf"],
  "Asia/Kolkata": ["ist", null, "india", "slst"],
  "Asia/Thimbu": ["btt", null, "bhutan"],
  "Indian/Maldives": ["mvt"],
  "Asia/Kathmandu": ["npt", null, "nepal"],
  "Indian/Cocos": ["cct", null, "cocos island"],
  "Indian/Chagos": ["iot", null, "indian chagos"],
  "Indian/Kerguelen": ["tft", null, "french southern and antarctic"],
  "Asia/Shanghai": ["ct", null, "china", "hkt"],
  "Asia/Ulaanbaatar": ["ulat"],
  "Asia/Seoul": ["kst", null, "korea"],
  "Asia/Tokyo": ["jst", null, "japan"],
  "Asia/Phnom_Penh": ["ict", null],
  "Asia/Manila": ["pht", null, "philippines"],
  "Asia/Singapore": ["sgt"],
  "Australia/Brisbane": ["aest", "aedt", "australian east"],
  "Australia/Adelaide": ["acst", "acdt", "australian central"],
  "Australia/Eucla": ["acwst", null, "cwst", "australian central western"],
  "Australia/Perth": ["awst", "awdt", "australian west"],
  "Pacific/Auckland": ["nzst", "nzdt", "nzmt"],
  "Australia/Lord_Howe": ["lhst", "lhdt"],
  "Pacific/Guam": ["chst"],
  "Pacific/Chatham": ["chast", "chadt"],
  "Pacific/Honolulu": ["hst"],
  "Asia/Brunei": ["bnt", null, "bdt"],
  "Pacific/Midway": ["sst", null, "samoa", "sdt"],
  "Pacific/Niue": ["nut"],
  "Pacific/Fakaofo": ["tkt"],
  "Pacific/Rarotonga": ["ckt", null, "cook islands"],
  "Chile/EasterIsland": ["east", "easst", "easter island", "emt"],
  "Asia/Jayapura": ["wit", null, "east indonesia"],
  "Asia/Jakarta": ["wib", null, "west indonesia"],
  "Asia/Makassar": ["wita", null, "central indonesia"],
  "Pacific/Galapagos": ["galt"],
  "Pacific/Fiji": ["fjt", "fjst"],
  "Asia/Dili": ["tlt", null, "east timor"],
  "Indian/Christmas": ["cxt"]
};
var _06Abbreviations = informal;
var _05Metazones = [
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    daylight: {
      name: "British Summer Time",
      abbrev: "BST"
    },
    alias: ["british", "britain"],
    pick: "Europe/London",
    zones: ["Europe/Guernsey", "Europe/Isle_Of_Man", "Europe/Jersey", "Europe/London"]
  },
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    daylight: {
      name: "Irish Summer Time",
      abbrev: "IST"
    },
    alias: ["ireland"],
    zones: ["Europe/Dublin"]
  },
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    pick: "Africa/Freetown",
    alias: ["etc", "utc"],
    zones: ["Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "America/Danmarkshavn", "Antarctica/Troll", "Atlantic/Reykjavik", "Atlantic/St_Helena", "ETC/GMT"]
  },
  {
    standard: {
      name: "Central Standard Time",
      abbrev: "CST"
    },
    daylight: {
      name: "Central Daylight Time",
      abbrev: "CDT"
    },
    pick: "America/Chicago",
    zones: ["America/Bahia_Banderas", "America/Belize", "America/Chicago", "America/Costa_Rica", "America/El_Salvador", "America/Guatemala", "America/Indiana", "America/Managua", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/Monterrey", "America/North_Dakota", "America/North_Dakota", "America/North_Dakota", "America/Rainy_River", "America/Rankin_Inlet", "America/Regina", "America/Resolute", "America/Swift_Current", "America/Tegucigalpa", "America/Winnipeg"]
  },
  {
    standard: {
      name: "Mountain Standard Time",
      abbrev: "MST"
    },
    daylight: {
      name: "Mountain Daylight Time",
      abbrev: "MDT"
    },
    pick: "America/Denver",
    zones: [
      "America/Boise",
      "America/Cambridge_Bay",
      "America/Creston",
      "America/Dawson_Creek",
      "America/Denver",
      "America/Edmonton",
      "America/Fort_Nelson",
      "America/Inuvik",
      "America/Ojinaga",
      "America/Phoenix",
      "America/Yellowknife",
      "America/Chihuahua",
      "America/Hermosillo",
      "America/Mazatlan"
    ]
  },
  {
    standard: {
      name: "Atlantic Standard Time",
      abbrev: "AST"
    },
    daylight: {
      name: "Atlantic Daylight Time",
      abbrev: "ADT"
    },
    pick: "America/Halifax",
    zones: ["America/Anguilla", "America/Antigua", "America/Aruba", "America/Barbados", "America/Blanc-sablon", "America/Curacao", "America/Dominica", "America/Glace_Bay", "America/Goose_Bay", "America/Grenada", "America/Guadeloupe", "America/Halifax", "America/Kralendijk", "America/Lower_Princes", "America/Marigot", "America/Martinique", "America/Moncton", "America/Montserrat", "America/Port_Of_Spain", "America/Puerto_Rico", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thule", "America/Tortola", "Atlantic/Bermuda"]
  },
  {
    standard: {
      name: "Eastern Standard Time",
      abbrev: "EST"
    },
    daylight: {
      name: "Eastern Daylight Time",
      abbrev: "EDT"
    },
    pick: "America/New_York",
    zones: ["America/Cancun", "America/Cayman", "America/Coral_Harbour", "America/Detroit", "America/Grand_Turk", "America/Indiana", "America/Indianapolis", "America/Iqaluit", "America/Jamaica", "America/Kentucky", "America/Louisville", "America/Nassau", "America/New_York", "America/Nipigon", "America/Panama", "America/Pangnirtung", "America/Port-au-prince", "America/Thunder_Bay", "America/Toronto", "America/Montreal"]
  },
  {
    standard: {
      name: "Pacific Standard Time",
      abbrev: "PST"
    },
    daylight: {
      name: "Pacific Daylight Time",
      abbrev: "PDT"
    },
    pick: "America/Los_Angeles",
    zones: ["America/Dawson", "America/Los_Angeles", "America/Tijuana", "America/Vancouver", "America/Whitehorse"]
  },
  {
    standard: {
      name: "Alaskan Standard Time",
      abbrev: "AHST"
    },
    daylight: {
      name: "Alaskan Daylight Time",
      abbrev: "AHDT"
    },
    pick: "America/Anchorage",
    zones: ["America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat"]
  },
  {
    standard: {
      name: "Hawaiian Standard Time",
      abbrev: "HST"
    },
    alias: ["aleutian", "hawaii"],
    pick: "Pacific/Honolulu",
    zones: ["America/Adak", "Pacific/Honolulu", "Pacific/Johnston"]
  },
  {
    standard: {
      name: "Newfoundland Standard Time",
      abbrev: "NST"
    },
    daylight: {
      name: "Newfoundland Daylight Time",
      abbrev: "NDT"
    },
    pick: "America/St_Johns",
    zones: ["America/St_Johns"]
  },
  {
    standard: {
      name: "Central European Time",
      abbrev: "CET"
    },
    daylight: {
      name: "Central European Summer Time",
      abbrev: "CEST"
    },
    alias: ["romance", "central europe"],
    pick: "Europe/Berlin",
    zones: ["Africa/Algiers", "Africa/Ceuta", "Africa/Tunis", "arctic/Longyearbyen", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich"]
  },
  {
    standard: {
      name: "Eastern European Time",
      abbrev: "EET"
    },
    daylight: {
      name: "Eastern European Summer Time",
      abbrev: "EEST"
    },
    alias: ["eastern europe"],
    pick: "Europe/Riga",
    zones: ["Africa/Cairo", "Africa/Tripoli", "Asia/Amman", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Nicosia", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Kaliningrad", "Europe/Kiev", "Europe/Mariehamn", "Europe/Riga", "Europe/Sofia", "Europe/Tallinn", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye"]
  },
  {
    standard: {
      name: "Western European Time",
      abbrev: "WET"
    },
    daylight: {
      name: "Western European Summer Time",
      abbrev: "WEST"
    },
    alias: ["western europe"],
    pick: "Europe/Lisbon",
    zones: ["Africa/Casablanca", "Africa/El_Aaiun", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Madeira", "Europe/Lisbon"]
  },
  {
    standard: {
      name: "Turkey Standard Time",
      abbrev: "TRT"
    },
    alias: ["turkish"],
    pick: "Europe/Istanbul",
    zones: ["Europe/Istanbul"]
  },
  {
    standard: {
      name: "East Africa Time",
      abbrev: "EAT"
    },
    alias: ["east african", "eastern africa"],
    pick: "Africa/Nairobi",
    zones: ["Africa/Addis_Ababa", "Africa/Asmera", "Africa/Dar_Es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte"]
  },
  {
    standard: {
      name: "Central Africa Time",
      abbrev: "CAT"
    },
    pick: "Africa/Khartoum",
    alias: ["central africa"],
    zones: ["Africa/Blantyre", "Africa/Bujumbura", "Africa/Gaborone", "Africa/Harare", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Windhoek"]
  },
  {
    standard: {
      name: "South Africa Standard Time",
      abbrev: "SAST"
    },
    alias: ["southern africa", "south african"],
    pick: "Africa/Johannesburg",
    zones: ["Africa/Johannesburg", "Africa/Maseru", "Africa/Mbabane"]
  },
  {
    standard: {
      name: "West Africa Standard Time",
      abbrev: "WAT"
    },
    alias: ["western africa", "west african"],
    pick: "Africa/Lagos",
    zones: ["Africa/Bangui", "Africa/Brazzaville", "Africa/Douala", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-novo"]
  },
  {
    standard: {
      name: "Australian Central Standard Time",
      abbrev: "ACST"
    },
    daylight: {
      name: "Australian Central Daylight Time",
      abbrev: "ACDT"
    },
    alias: ["australia central"],
    pick: "Australia/Adelaide",
    zones: ["Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin"]
  },
  {
    standard: {
      name: "Australian Eastern Standard Time",
      abbrev: "AEST"
    },
    daylight: {
      name: "Australian Eastern Daylight Time",
      abbrev: "AEDT"
    },
    alias: ["australia east"],
    pick: "Australia/Brisbane",
    zones: ["Australia/Brisbane", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/Sydney"]
  },
  {
    standard: {
      name: "Australian Western Standard Time",
      abbrev: "AWST"
    },
    daylight: {
      name: "Australian Western Daylight Time",
      abbrev: "AWDT"
    },
    alias: ["australia west"],
    pick: "Australia/Perth",
    zones: ["Antarctica/Casey", "Australia/Perth"]
  },
  {
    standard: {
      name: "Australian Central Western Standard Time",
      abbrev: "ACWST"
    },
    alias: ["australia central west"],
    pick: "Australia/Eucla",
    zones: ["Australia/Eucla"]
  },
  {
    standard: {
      name: "Lord Howe Standard Time",
      abbrev: "LHST"
    },
    daylight: {
      name: "Lord Howe Daylight Time",
      abbrev: "LHDT"
    },
    pick: "Australia/Lord_Howe",
    zones: ["Australia/Lord_Howe"]
  },
  {
    standard: {
      name: "New Zealand Standard Time",
      abbrev: "NZST"
    },
    daylight: {
      name: "New Zealand Daylight Time",
      abbrev: "NZDT"
    },
    pick: "Pacific/Auckland",
    zones: ["Antarctica/Mcmurdo", "Pacific/Auckland"]
  },
  {
    standard: {
      name: "Chatham Island Standard Time",
      abbrev: "CHAST"
    },
    daylight: {
      name: "Chatham Island Daylight Time",
      abbrev: "CHADT"
    },
    pick: "Pacific/Chatham",
    zones: ["Pacific/Chatham"]
  },
  {
    standard: {
      name: "Russian Standard Time",
      abbrev: "MSK"
    },
    alias: ["russian"],
    pick: "Europe/Moscow",
    zones: ["Europe/Astrakhan", "Europe/Minsk", "Europe/Moscow", "Europe/Simferopol", "Europe/Ulyanovsk", "Europe/Kirov"]
  },
  {
    standard: {
      name: "Volgograd Time",
      abbrev: "VOLT"
    },
    zones: ["Europe/Volgograd"]
  },
  {
    standard: {
      name: "Brazil Time",
      abbrev: "BRT"
    },
    alias: ["bras\xEDlia", "brasilia", "brazilian"],
    pick: "America/Sao_Paulo",
    zones: ["America/Araguaina", "America/Bahia", "America/Belem", "America/Fortaleza", "America/Maceio", "America/Recife", "America/Santarem", "America/Sao_Paulo"]
  },
  {
    standard: {
      name: "Argentina Time",
      abbrev: "ART"
    },
    alias: ["argentinian"],
    pick: "America/Buenos_Aires",
    zones: ["America/Argentina", "America/Buenos_Aires", "America/Catamarca", "America/Cordoba", "America/Jujuy", "America/Mendoza"]
  },
  {
    standard: {
      name: "Amazon Time",
      abbrev: "AMT"
    },
    alias: ["amazonian"],
    pick: "America/Manaus",
    zones: [
      "America/Boa_Vista",
      "America/Campo_Grande",
      "America/Cuiaba",
      "America/Manaus",
      "America/Porto_Velho"
    ]
  },
  {
    standard: {
      name: "Easter Island Standard Time",
      abbrev: "EAST"
    },
    daylight: {
      name: "Easter Island Summer Time",
      abbrev: "EASST"
    },
    zones: ["Chile/EasterIsland"]
  },
  {
    standard: {
      name: "Venezuelan Standard Time",
      abbrev: "VET"
    },
    alias: ["venezuela"],
    zones: ["America/Caracas"]
  },
  {
    standard: {
      name: "Paraguay Time",
      abbrev: "PYT"
    },
    daylight: {
      name: "Paraguay Summer Time",
      abbrev: "PYST"
    },
    zones: ["America/Asuncion"]
  },
  {
    standard: {
      name: "Cuba Standard Time",
      abbrev: "CST"
    },
    daylight: {
      name: "Cuba Daylight Time",
      abbrev: "CDT"
    },
    alias: ["cuban"],
    zones: ["America/Havana"]
  },
  {
    standard: {
      name: "Bolivia Time",
      abbrev: "BOT"
    },
    alias: ["bolivian"],
    zones: ["America/La_Paz"]
  },
  {
    standard: {
      name: "Colombia Time",
      abbrev: "COT"
    },
    alias: ["colombian"],
    zones: ["America/Bogota"]
  },
  {
    standard: {
      name: "Acre Time",
      abbrev: "ACT"
    },
    pick: null,
    zones: ["America/Eirunepe", "America/Rio_Branco"]
  },
  {
    standard: {
      name: "Peru Time",
      abbrev: "PET"
    },
    zones: ["America/Lima"]
  },
  {
    standard: {
      name: "Chile Standard Time",
      abbrev: "CLST"
    },
    daylight: {
      name: "Chile Summer Time",
      abbrev: "CLDT"
    },
    pick: null,
    zones: ["America/Punta_Arenas", "America/Santiago", "Antarctica/Palmer"]
  },
  {
    standard: {
      name: "Uruguay Time",
      abbrev: "UYT"
    },
    zones: ["America/Montevideo"]
  },
  {
    standard: {
      name: "Arabic Standard Time",
      abbrev: "AST"
    },
    pick: "Asia/Baghdad",
    alias: ["arabic", "arab"],
    zones: ["Asia/Aden", "Asia/Baghdad", "Asia/Bahrain", "Asia/Kuwait", "Asia/Qatar", "Asia/Riyadh"]
  },
  {
    standard: {
      name: "Iran Standard Time",
      abbrev: "IRST"
    },
    daylight: {
      name: "Iran Daylight Time",
      abbrev: "IRDT"
    },
    alias: ["iranian"],
    pick: "Asia/Tehran",
    zones: ["Asia/Tehran"]
  },
  {
    standard: {
      name: "Pakistan Standard Time",
      abbrev: "PKT"
    },
    pick: "Asia/Karachi",
    zones: ["Asia/Karachi"]
  },
  {
    standard: {
      name: "India Standard Time",
      abbrev: "IST"
    },
    alias: ["indian"],
    pick: "Asia/Kolkata",
    zones: ["Asia/Kolkata", "Asia/Colombo"]
  },
  {
    standard: {
      name: "Indochina Time",
      abbrev: "ICT"
    },
    alias: ["South East Asia"],
    pick: "Asia/Bangkok",
    zones: ["Asia/Bangkok", "Asia/Phnom_Penh", "Asia/Saigon", "Asia/Vientiane"]
  },
  {
    standard: {
      name: "China Standard Time",
      abbrev: "CT"
    },
    alias: ["chinese"],
    pick: "Asia/Shanghai",
    zones: ["Asia/Macau", "Asia/Shanghai", "Asia/Taipei"]
  },
  {
    standard: {
      name: "Alma-Ata Time",
      abbrev: "ALMT"
    },
    pick: "Asia/Almaty",
    zones: ["Asia/Almaty", "Asia/Qostanay"]
  },
  {
    standard: {
      name: "Oral Time",
      abbrev: "ORAT"
    },
    pick: "Asia/Oral",
    zones: ["Asia/Aqtau", "Asia/Aqtobe", "Asia/Atyrau", "Asia/Oral", "Asia/Qyzylorda"]
  },
  {
    standard: {
      name: "Yakutsk Time",
      abbrev: "YAKT"
    },
    pick: "Asia/Yakutsk",
    zones: ["Asia/Chita", "Asia/Khandyga", "Asia/Yakutsk"]
  },
  {
    standard: {
      name: "Gulf Standard Time",
      abbrev: "GST"
    },
    pick: "Asia/Dubai",
    alias: ["uae"],
    zones: ["Asia/Dubai", "Asia/Muscat"]
  },
  {
    standard: {
      name: "Hong Kong Time",
      abbrev: "HKT"
    },
    zones: ["Asia/Hong_Kong"]
  },
  {
    standard: {
      name: "Western Indonesian Time",
      abbrev: "WIB"
    },
    alias: ["indonesia"],
    zones: ["Asia/Jakarta", "Asia/Pontianak", "Asia/Jayapura"]
  },
  {
    standard: {
      name: "Central Indonesian Time",
      abbrev: "WITA"
    },
    zones: ["Asia/Makassar"]
  },
  {
    standard: {
      name: "Israel Daylight Time",
      abbrev: "IDT"
    },
    daylight: {
      name: "Israel Standard Time",
      abbrev: "IST"
    },
    alias: ["israeli"],
    zones: ["Asia/Jerusalem"]
  },
  {
    standard: {
      name: "Krasnoyarsk Time",
      abbrev: "KRAT"
    },
    zones: ["Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Barnaul"]
  },
  {
    standard: {
      name: "Malaysia Time",
      abbrev: "MYT"
    },
    zones: ["Asia/Kuala_Lumpur", "Asia/Kuching"]
  },
  {
    standard: {
      name: "Singapore Time",
      abbrev: "SGT"
    },
    zones: ["Asia/Singapore"]
  },
  {
    standard: {
      name: "Korea Standard Time",
      abbrev: "KST"
    },
    pick: "Asia/Seoul",
    alias: ["korean"],
    zones: ["Asia/Pyongyang", "Asia/Seoul"]
  },
  {
    standard: {
      name: "Uzbekistan Time",
      abbrev: "UZT"
    },
    zones: ["Asia/Samarkand", "Asia/Tashkent"]
  },
  {
    standard: {
      name: "Vladivostok Time",
      abbrev: "VLAT"
    },
    pick: "Asia/Vladivostok",
    zones: ["Asia/Ust-nera", "Asia/Vladivostok"]
  },
  {
    standard: {
      name: "Anadyr Time",
      abbrev: "ANAT"
    },
    zones: ["Asia/Anadyr"]
  },
  {
    standard: {
      name: "Turkmenistan Time",
      abbrev: "TMT"
    },
    zones: ["Asia/Ashgabat"]
  },
  {
    standard: {
      name: "Azerbaijan Time",
      abbrev: "AZT"
    },
    zones: ["Asia/Baku"]
  },
  {
    standard: {
      name: "Kyrgyzstan Time",
      abbrev: "KGT"
    },
    zones: ["Asia/Bishkek"]
  },
  {
    standard: {
      name: "Brunei Darussalam Time",
      abbrev: "BNT"
    },
    zones: ["Asia/Brunei"]
  },
  {
    standard: {
      name: "Afghanistan Time",
      abbrev: "AFT"
    },
    zones: ["Asia/Kabul"]
  },
  {
    standard: {
      name: "Kamchatka Time",
      abbrev: "PETT"
    },
    zones: ["Asia/Kamchatka"]
  },
  {
    standard: {
      name: "Nepal Time",
      abbrev: "NPT"
    },
    zones: ["Asia/Katmandu"]
  },
  {
    standard: {
      name: "Philippine Time",
      abbrev: "PHT"
    },
    zones: ["Asia/Manila"]
  },
  {
    standard: {
      name: "Myanmar Time",
      abbrev: "MMT"
    },
    zones: ["Asia/Rangoon"]
  },
  {
    standard: {
      name: "Georgia Standard Time",
      abbrev: "GET"
    },
    zones: ["Asia/Tbilisi"]
  },
  {
    standard: {
      name: "Japan Standard Time",
      abbrev: "JST"
    },
    zones: ["Asia/Tokyo"]
  },
  {
    standard: {
      name: "Ulaanbaatar Time",
      abbrev: "ULAT"
    },
    zones: ["Asia/Ulaanbaatar"]
  },
  {
    standard: {
      name: "Maldives Time",
      abbrev: "MVT"
    },
    zones: ["Indian/Maldives"]
  },
  {
    standard: {
      name: "Mauritius Time",
      abbrev: "MUT"
    },
    zones: ["Indian/Mauritius"]
  },
  {
    standard: {
      name: "Marshall Islands Time",
      abbrev: "MHT"
    },
    zones: ["Pacific/Kwajalein", "Pacific/Majuro"]
  },
  {
    standard: {
      name: "Samoa Standard Time",
      abbrev: "SST"
    },
    alias: ["somoan"],
    zones: ["Pacific/Midway", "Pacific/Pago_Pago"]
  },
  {
    standard: {
      name: "Chamorro Standard Time",
      abbrev: "CHST"
    },
    zones: ["Pacific/Guam", "Pacific/Saipan"]
  },
  {
    standard: {
      name: "Papua New Guinea Time",
      abbrev: "PGT"
    },
    zones: ["Pacific/Bougainville", "Pacific/Port_Moresby"]
  }
];
var _03ByCountry = {
  andorra: {
    code: "ad",
    choice: "Europe/Andorra"
  },
  oman: {
    code: "om",
    choice: "Asia/Dubai"
  },
  afghanistan: {
    code: "af",
    choice: "Asia/Kabul"
  },
  "virgin islands": {
    code: "vi",
    choice: "America/Port_Of_Spain"
  },
  albania: {
    code: "al",
    choice: "Europe/Tirane"
  },
  armenia: {
    code: "am",
    choice: "Asia/Yerevan"
  },
  nigeria: {
    code: "ng",
    choice: "Africa/Lagos"
  },
  austria: {
    code: "at",
    choice: "Europe/Vienna"
  },
  "st maarten": {
    code: "sx",
    choice: "America/Curacao"
  },
  finland: {
    code: "fi",
    choice: "Europe/Helsinki"
  },
  azerbaijan: {
    code: "az",
    choice: "Asia/Baku"
  },
  slovenia: {
    code: "si",
    choice: "Europe/Belgrade"
  },
  barbados: {
    code: "bb",
    choice: "America/Barbados"
  },
  bangladesh: {
    code: "bd",
    choice: "Asia/Dhaka"
  },
  belgium: {
    code: "be",
    choice: "Europe/Brussels"
  },
  togo: {
    code: "tg",
    choice: "Africa/Abidjan"
  },
  bulgaria: {
    code: "bg",
    choice: "Europe/Sofia"
  },
  qatar: {
    code: "qa",
    choice: "Asia/Qatar"
  },
  zimbabwe: {
    code: "zw",
    choice: "Africa/Maputo"
  },
  bermuda: {
    code: "bm",
    choice: "Atlantic/Bermuda"
  },
  brunei: {
    code: "bn",
    choice: "Asia/Brunei"
  },
  bolivia: {
    code: "bo",
    choice: "America/La_Paz"
  },
  bahamas: {
    code: "bs",
    choice: "America/Nassau"
  },
  bhutan: {
    code: "bt",
    choice: "Asia/Thimphu"
  },
  belarus: {
    code: "by",
    choice: "Europe/Minsk"
  },
  belize: {
    code: "bz",
    choice: "America/Belize"
  },
  "cocos islands": {
    code: "cc",
    choice: "Indian/Cocos"
  },
  liechtenstein: {
    code: "li",
    choice: "Europe/Zurich"
  },
  "cook islands": {
    code: "ck",
    choice: "Pacific/Rarotonga"
  },
  colombia: {
    code: "co",
    choice: "America/Bogota"
  },
  "costa rica": {
    code: "cr",
    choice: "America/Costa_Rica"
  },
  cuba: {
    code: "cu",
    choice: "America/Havana"
  },
  "cape verde": {
    code: "cv",
    choice: "Atlantic/Cape_Verde"
  },
  "christmas island": {
    code: "cx",
    choice: "Indian/Christmas"
  },
  slovakia: {
    code: "sk",
    choice: "Europe/Prague"
  },
  mayotte: {
    code: "yt",
    choice: "Africa/Nairobi"
  },
  denmark: {
    code: "dk",
    choice: "Europe/Copenhagen"
  },
  "dominican republic": {
    code: "do",
    choice: "America/Santo_Domingo"
  },
  algeria: {
    code: "dz",
    choice: "Africa/Algiers"
  },
  estonia: {
    code: "ee",
    choice: "Europe/Tallinn"
  },
  egypt: {
    code: "eg",
    choice: "Africa/Cairo"
  },
  "western sahara": {
    code: "eh",
    choice: "Africa/El_Aaiun"
  },
  fiji: {
    code: "fj",
    choice: "Pacific/Fiji"
  },
  "falkland islands": {
    code: "fk",
    choice: "Atlantic/Stanley"
  },
  "faroe islands": {
    code: "fo",
    choice: "Atlantic/Faroe"
  },
  france: {
    code: "fr",
    choice: "Europe/Paris"
  },
  jersey: {
    code: "je",
    choice: "Europe/London"
  },
  georgia: {
    code: "ge",
    choice: "Asia/Tbilisi"
  },
  "french guiana": {
    code: "gf",
    choice: "America/Cayenne"
  },
  ghana: {
    code: "gh",
    choice: "Africa/Accra"
  },
  gibraltar: {
    code: "gi",
    choice: "Europe/Gibraltar"
  },
  greece: {
    code: "gr",
    choice: "Europe/Athens"
  },
  "south georgia": {
    code: "gs",
    choice: "Atlantic/South_Georgia"
  },
  guatemala: {
    code: "gt",
    choice: "America/Guatemala"
  },
  "northern mariana islands": {
    code: "mp",
    choice: "Pacific/Guam"
  },
  "guinea bissau": {
    code: "gw",
    choice: "Africa/Bissau"
  },
  guyana: {
    code: "gy",
    choice: "America/Guyana"
  },
  "hong kong": {
    code: "hk",
    choice: "Asia/Hong_Kong"
  },
  honduras: {
    code: "hn",
    choice: "America/Tegucigalpa"
  },
  haiti: {
    code: "ht",
    choice: "America/Port-au-prince"
  },
  hungary: {
    code: "hu",
    choice: "Europe/Budapest"
  },
  ireland: {
    code: "ie",
    choice: "Europe/Dublin"
  },
  israel: {
    code: "il",
    choice: "Asia/Jerusalem"
  },
  india: {
    code: "in",
    choice: "Asia/Kolkata"
  },
  "british indian ocean territory": {
    code: "io",
    choice: "Indian/Chagos"
  },
  iraq: {
    code: "iq",
    choice: "Asia/Baghdad"
  },
  iran: {
    code: "ir",
    choice: "Asia/Tehran"
  },
  iceland: {
    code: "is",
    choice: "Atlantic/Reykjavik"
  },
  "vatican city": {
    code: "va",
    choice: "Europe/Rome"
  },
  jamaica: {
    code: "jm",
    choice: "America/Jamaica"
  },
  jordan: {
    code: "jo",
    choice: "Asia/Amman"
  },
  japan: {
    code: "jp",
    choice: "Asia/Tokyo"
  },
  kyrgyzstan: {
    code: "kg",
    choice: "Asia/Bishkek"
  },
  "north korea": {
    code: "kp",
    choice: "Asia/Pyongyang"
  },
  "south korea": {
    code: "kr",
    choice: "Asia/Seoul"
  },
  yemen: {
    code: "ye",
    choice: "Asia/Riyadh"
  },
  panama: {
    code: "pa",
    choice: "America/Panama"
  },
  lebanon: {
    code: "lb",
    choice: "Asia/Beirut"
  },
  "sri lanka": {
    code: "lk",
    choice: "Asia/Colombo"
  },
  liberia: {
    code: "lr",
    choice: "Africa/Monrovia"
  },
  "south africa": {
    code: "za",
    choice: "Africa/Johannesburg"
  },
  lithuania: {
    code: "lt",
    choice: "Europe/Vilnius"
  },
  luxembourg: {
    code: "lu",
    choice: "Europe/Luxembourg"
  },
  latvia: {
    code: "lv",
    choice: "Europe/Riga"
  },
  libya: {
    code: "ly",
    choice: "Africa/Tripoli"
  },
  morocco: {
    code: "ma",
    choice: "Africa/Casablanca"
  },
  monaco: {
    code: "mc",
    choice: "Europe/Monaco"
  },
  moldova: {
    code: "md",
    choice: "Europe/Chisinau"
  },
  myanmar: {
    code: "mm",
    choice: "Asia/Yangon"
  },
  burma: {
    code: "mm",
    choice: "Asia/Yangon"
  },
  macau: {
    code: "mo",
    choice: "Asia/Macau"
  },
  martinique: {
    code: "mq",
    choice: "America/Martinique"
  },
  malta: {
    code: "mt",
    choice: "Europe/Malta"
  },
  mauritius: {
    code: "mu",
    choice: "Indian/Mauritius"
  },
  maldives: {
    code: "mv",
    choice: "Indian/Maldives"
  },
  namibia: {
    code: "na",
    choice: "Africa/Windhoek"
  },
  "new caledonia": {
    code: "nc",
    choice: "Pacific/Noumea"
  },
  "norfolk island": {
    code: "nf",
    choice: "Pacific/Norfolk"
  },
  nicaragua: {
    code: "ni",
    choice: "America/Managua"
  },
  netherlands: {
    code: "nl",
    choice: "Europe/Amsterdam"
  },
  "svalbard and jan mayen": {
    code: "sj",
    choice: "Europe/Oslo"
  },
  nepal: {
    code: "np",
    choice: "Asia/Kathmandu"
  },
  nauru: {
    code: "nr",
    choice: "Pacific/Nauru"
  },
  niue: {
    code: "nu",
    choice: "Pacific/Niue"
  },
  peru: {
    code: "pe",
    choice: "America/Lima"
  },
  philippines: {
    code: "ph",
    choice: "Asia/Manila"
  },
  pakistan: {
    code: "pk",
    choice: "Asia/Karachi"
  },
  poland: {
    code: "pl",
    choice: "Europe/Warsaw"
  },
  "st pierre and miquelon": {
    code: "pm",
    choice: "America/Miquelon"
  },
  pitcairn: {
    code: "pn",
    choice: "Pacific/Pitcairn"
  },
  "puerto rico": {
    code: "pr",
    choice: "America/Puerto_Rico"
  },
  palau: {
    code: "pw",
    choice: "Pacific/Palau"
  },
  paraguay: {
    code: "py",
    choice: "America/Asuncion"
  },
  romania: {
    code: "ro",
    choice: "Europe/Bucharest"
  },
  "solomon islands": {
    code: "sb",
    choice: "Pacific/Guadalcanal"
  },
  seychelles: {
    code: "sc",
    choice: "Indian/Mahe"
  },
  sudan: {
    code: "sd",
    choice: "Africa/Khartoum"
  },
  sweden: {
    code: "se",
    choice: "Europe/Stockholm"
  },
  singapore: {
    code: "sg",
    choice: "Asia/Singapore"
  },
  suriname: {
    code: "sr",
    choice: "America/Paramaribo"
  },
  "south sudan": {
    code: "ss",
    choice: "Africa/Juba"
  },
  "sao tome": {
    code: "st",
    choice: "Africa/Sao_Tome"
  },
  "el salvador": {
    code: "sv",
    choice: "America/El_Salvador"
  },
  syria: {
    code: "sy",
    choice: "Asia/Damascus"
  },
  "turks and caicos": {
    code: "tc",
    choice: "America/Grand_Turk"
  },
  chad: {
    code: "td",
    choice: "Africa/Ndjamena"
  },
  tajikistan: {
    code: "tj",
    choice: "Asia/Dushanbe"
  },
  tokelau: {
    code: "tk",
    choice: "Pacific/Fakaofo"
  },
  "east timor": {
    code: "tl",
    choice: "Asia/Dili"
  },
  turkmenistan: {
    code: "tm",
    choice: "Asia/Ashgabat"
  },
  tunisia: {
    code: "tn",
    choice: "Africa/Tunis"
  },
  tonga: {
    code: "to",
    choice: "Pacific/Tongatapu"
  },
  turkey: {
    code: "tr",
    choice: "Europe/Istanbul"
  },
  tuvalu: {
    code: "tv",
    choice: "Pacific/Funafuti"
  },
  taiwan: {
    code: "tw",
    choice: "Asia/Taipei"
  },
  uruguay: {
    code: "uy",
    choice: "America/Montevideo"
  },
  venezuela: {
    code: "ve",
    choice: "America/Caracas"
  },
  vanuatu: {
    code: "vu",
    choice: "Pacific/Efate"
  },
  "wallis and futuna": {
    code: "wf",
    choice: "Pacific/Wallis"
  },
  "western samoa": {
    code: "ws",
    choice: "Pacific/Apia"
  },
  samoa: {
    code: "ws",
    choice: "Pacific/Apia"
  },
  antarctica: {
    code: "aq",
    choice: "Antarctica/Davis"
  },
  argentina: {
    code: "ar",
    choice: "America/Argentina"
  },
  australia: {
    code: "au",
    choice: "Australia/Sydney"
  },
  brazil: {
    code: "br",
    choice: "America/Sao_Paulo"
  },
  canada: {
    code: "ca",
    choice: "America/Toronto"
  },
  congo: {
    code: "cd",
    choice: "Africa/Kinshasa"
  },
  chile: {
    code: "cl",
    choice: "America/Santiago"
  },
  china: {
    code: "cn",
    choice: "Asia/Shanghai"
  },
  cyprus: {
    code: "cy",
    choice: "Asia/Nicosia"
  },
  germany: {
    code: "de",
    choice: "Europe/Berlin"
  },
  ecuador: {
    code: "ec",
    choice: "America/Guayaquil"
  },
  spain: {
    code: "es",
    choice: "Europe/Madrid"
  },
  micronesia: {
    code: "fm",
    choice: "Pacific/Pohnpei"
  },
  greenland: {
    code: "gl",
    choice: "America/Godthab"
  },
  indonesia: {
    code: "id",
    choice: "Asia/Jakarta"
  },
  kiribati: {
    code: "ki",
    choice: "Pacific/Kiritimati"
  },
  kazakhstan: {
    code: "kz",
    choice: "Asia/Almaty"
  },
  "marshall islands": {
    code: "mh",
    choice: "Pacific/Majuro"
  },
  mongolia: {
    code: "mn",
    choice: "Asia/Ulaanbaatar"
  },
  mexico: {
    code: "mx",
    choice: "America/Mexico_City"
  },
  malaysia: {
    code: "my",
    choice: "Asia/Kuala_Lumpur"
  },
  "new zealand": {
    code: "nz",
    choice: "Pacific/Auckland"
  },
  "french polynesia": {
    code: "pf",
    choice: "Pacific/Pohnpei"
  },
  "papua new guinea": {
    code: "pg",
    choice: "Pacific/Port_Moresby"
  },
  palestine: {
    code: "ps",
    choice: "Asia/Gaza"
  },
  portugal: {
    code: "pt",
    choice: "Europe/Lisbon"
  },
  russia: {
    code: "ru",
    choice: "Europe/Moscow"
  },
  "french southern and antarctic lands": {
    code: "tf",
    choice: "Indian/Kerguelen"
  },
  ukraine: {
    code: "ua",
    choice: "Europe/Kiev"
  },
  "us minor outlying islands": {
    code: "um",
    choice: "Pacific/Wake"
  },
  "united states": {
    code: "us",
    choice: "America/New_York"
  },
  uzbekistan: {
    code: "uz",
    choice: "Asia/Tashkent"
  },
  vietnam: {
    code: "vn",
    choice: "Asia/Ho_Chi_Minh"
  }
};
var all2 = Object.assign({}, _01Iana, _02ByCity, _04OldZones, _07Parentheses);
Object.keys(_03ByCountry).forEach(function(key) {
  all2[key] = _03ByCountry[key].choice;
  all2[_03ByCountry[key].code] = _03ByCountry[key].choice;
});
_05Metazones.forEach(function(obj) {
  var zone = obj.pick || obj.zones[0];
  all2[obj.standard.name.toLowerCase()] = zone;
  if (obj.standard.abbrev) {
    all2[obj.standard.abbrev.toLowerCase()] = zone;
  }
  if (obj.daylight) {
    if (obj.daylight.name) {
      all2[obj.daylight.name.toLowerCase()] = zone;
    }
    if (obj.daylight.abbrev) {
      all2[obj.daylight.abbrev.toLowerCase()] = zone;
    }
  }
  if (obj.alias) {
    obj.alias.forEach(function(str) {
      return all2[str.toLowerCase()] = zone;
    });
  }
});
Object.keys(_06Abbreviations).forEach(function(k) {
  var arr = (_06Abbreviations[k] || []).filter(function(a2) {
    return a2;
  });
  arr.forEach(function(abbr) {
    if (all2.hasOwnProperty(abbr) === false) {
      all2[abbr] = k;
    }
  });
});
var data2 = all2;
var isOffset2 = /(\-?[0-9]+)h(rs)?/i;
var isNumber2 = /(\-?[0-9]+)/;
var utcOffset2 = /utc([\-+]?[0-9]+)/i;
var gmtOffset2 = /gmt([\-+]?[0-9]+)/i;
var toIana3 = function toIana4(num) {
  num = Number(num);
  if (num > -13 && num < 13) {
    num = num * -1;
    num = (num > 0 ? "+" : "") + num;
    return "Etc/GMT" + num;
  }
  return null;
};
var parseOffset4 = function parseOffset5(tz) {
  var m2 = tz.match(isOffset2);
  if (m2 !== null) {
    return toIana3(m2[1]);
  }
  m2 = tz.match(utcOffset2);
  if (m2 !== null) {
    return toIana3(m2[1]);
  }
  m2 = tz.match(gmtOffset2);
  if (m2 !== null) {
    var num = Number(m2[1]) * -1;
    return toIana3(num);
  }
  m2 = tz.match(isNumber2);
  if (m2 !== null) {
    return toIana3(m2[1]);
  }
  return null;
};
var parseOffset_12 = parseOffset4;
var normalizeOne = function normalizeOne2(tz) {
  tz = tz.replace(/ time/g, "");
  tz = tz.replace(/ (standard|daylight|summer)/g, "");
  tz = tz.replace(/ - .*/g, "");
  tz = tz.replace(/, .*/g, "");
  return tz.trim();
};
var normalizeTwo = function normalizeTwo2(tz) {
  tz = tz.replace(/\b(east|west|north|south)ern/g, "$1");
  tz = tz.replace(/\b(africa|america|australia)n/g, "$1");
  tz = tz.replace(/\beuropean/g, "europe");
  tz = tz.replace(/\islands/g, "island");
  tz = tz.replace(/.*\//g, "");
  return tz.trim();
};
var normalizeThree = function normalizeThree2(tz) {
  tz = tz.replace(/\(.*\)/, "");
  return tz.trim();
};
var find2 = function find3(str) {
  if (!str) {
    return null;
  }
  str = str.toLowerCase().trim();
  if (data2.hasOwnProperty(str)) {
    return data2[str];
  }
  if (/[0-9]/.test(str)) {
    var etc = parseOffset_12(str);
    if (etc) {
      return etc;
    }
  }
  str = normalizeOne(str);
  if (data2.hasOwnProperty(str)) {
    return data2[str];
  }
  var tmp2 = str + " time";
  if (data2.hasOwnProperty(tmp2)) {
    return data2[tmp2];
  }
  tmp2 = str + " standard time";
  if (data2.hasOwnProperty(tmp2)) {
    return data2[tmp2];
  }
  str = normalizeTwo(str);
  if (data2.hasOwnProperty(str)) {
    return data2[str];
  }
  str = normalizeThree(str);
  if (data2.hasOwnProperty(str)) {
    return data2[str];
  }
  tmp2 = str + " time";
  if (data2.hasOwnProperty(tmp2)) {
    return data2[tmp2];
  }
  tmp2 = str + " standard time";
  if (data2.hasOwnProperty(tmp2)) {
    return data2[tmp2];
  }
  return null;
};
var find_1 = find2;
var display = function display2(str) {
  var id = find_1(str);
  if (!id) {
    return null;
  }
  var meta = _05Metazones.find(function(obj) {
    return obj.zones.find(function(tz) {
      return tz === id;
    });
  });
  meta = meta || {};
  return {
    iana: id,
    standard: meta.standard,
    daylight: meta.daylight
  };
};
var display_1 = display;
var _version2 = "0.5.0";
var src2 = {
  find: find_1,
  display: display_1,
  version: _version2
};
var src_1 = src2.find;
var src_2 = src2.display;
var src_3 = src2.version;

// node_modules/react-timezone-select/dist/index.js
var i18nTimezones = {
  "Pacific/Midway": "Midway Island, Samoa",
  "Pacific/Honolulu": "Hawaii",
  "America/Juneau": "Alaska",
  "America/Boise": "Mountain Time",
  "America/Dawson": "Dawson, Yukon",
  "America/Chihuahua": "Chihuahua, La Paz, Mazatlan",
  "America/Phoenix": "Arizona",
  "America/Chicago": "Central Time",
  "America/Regina": "Saskatchewan",
  "America/Mexico_City": "Guadalajara, Mexico City, Monterrey",
  "America/Belize": "Central America",
  "America/Detroit": "Eastern Time",
  "America/Bogota": "Bogota, Lima, Quito",
  "America/Caracas": "Caracas, La Paz",
  "America/Santiago": "Santiago",
  "America/St_Johns": "Newfoundland and Labrador",
  "America/Sao_Paulo": "Brasilia",
  "America/Tijuana": "Tijuana, Pacific Time",
  "America/Argentina/Buenos_Aires": "Buenos Aires, Georgetown",
  "America/Godthab": "Greenland",
  "Atlantic/Azores": "Azores",
  "Atlantic/Cape_Verde": "Cape Verde Islands",
  GMT: "Dublin, Edinburgh, Lisbon, London",
  "Africa/Casablanca": "Casablanca, Monrovia",
  "Atlantic/Canary": "Canary Islands",
  "Europe/Belgrade": "Belgrade, Bratislava, Budapest, Ljubljana, Prague",
  "Europe/Sarajevo": "Sarajevo, Skopje, Warsaw, Zagreb",
  "Europe/Brussels": "Brussels, Copenhagen, Madrid, Paris",
  "Europe/Amsterdam": "Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
  "Africa/Algiers": "West Central Africa",
  "Europe/Bucharest": "Bucharest",
  "Africa/Cairo": "Cairo",
  "Europe/Helsinki": "Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius",
  "Europe/Athens": "Athens, Istanbul, Minsk",
  "Asia/Jerusalem": "Jerusalem",
  "Africa/Harare": "Harare, Pretoria",
  "Europe/Moscow": "Moscow, St. Petersburg, Volgograd",
  "Asia/Kuwait": "Kuwait, Riyadh",
  "Africa/Nairobi": "Nairobi",
  "Asia/Baghdad": "Baghdad",
  "Asia/Tehran": "Tehran",
  "Asia/Dubai": "Abu Dhabi, Muscat",
  "Asia/Baku": "Baku, Tbilisi, Yerevan",
  "Asia/Kabul": "Kabul",
  "Asia/Yekaterinburg": "Ekaterinburg",
  "Asia/Karachi": "Islamabad, Karachi, Tashkent",
  "Asia/Kolkata": "Chennai, Kolkata, Mumbai, New Delhi",
  "Asia/Kathmandu": "Kathmandu",
  "Asia/Dhaka": "Astana, Dhaka",
  "Asia/Colombo": "Sri Jayawardenepura",
  "Asia/Almaty": "Almaty, Novosibirsk",
  "Asia/Rangoon": "Yangon Rangoon",
  "Asia/Bangkok": "Bangkok, Hanoi, Jakarta",
  "Asia/Krasnoyarsk": "Krasnoyarsk",
  "Asia/Shanghai": "Beijing, Chongqing, Hong Kong SAR, Urumqi",
  "Asia/Kuala_Lumpur": "Kuala Lumpur, Singapore",
  "Asia/Taipei": "Taipei",
  "Australia/Perth": "Perth",
  "Asia/Irkutsk": "Irkutsk, Ulaanbaatar",
  "Asia/Seoul": "Seoul",
  "Asia/Tokyo": "Osaka, Sapporo, Tokyo",
  "Asia/Yakutsk": "Yakutsk",
  "Australia/Darwin": "Darwin",
  "Australia/Adelaide": "Adelaide",
  "Australia/Sydney": "Canberra, Melbourne, Sydney",
  "Australia/Brisbane": "Brisbane",
  "Australia/Hobart": "Hobart",
  "Asia/Vladivostok": "Vladivostok",
  "Pacific/Guam": "Guam, Port Moresby",
  "Asia/Magadan": "Magadan, Solomon Islands, New Caledonia",
  "Asia/Kamchatka": "Kamchatka, Marshall Islands",
  "Pacific/Fiji": "Fiji Islands",
  "Pacific/Auckland": "Auckland, Wellington",
  "Pacific/Tongatapu": "Nuku'alofa"
};
var TimezoneSelect = ({value, onBlur, onChange: onChange2, labelStyle = "original", timezones: timezones2 = i18nTimezones, ...props}) => {
  const getOptions = React11.useMemo(() => {
    const options2 = [];
    Object.entries(timezones2).reduce((obj, entry) => {
      const a2 = spacetime_default.now().goto(entry[0]);
      const tz = a2.timezone();
      const tzDisplay = src_2(entry[0]);
      let abbrev = entry[0];
      let altName = entry[0];
      if (tzDisplay && tzDisplay.daylight && tzDisplay.standard) {
        abbrev = a2.isDST() ? tzDisplay.daylight.abbrev : tzDisplay.standard.abbrev;
        altName = a2.isDST() ? tzDisplay.daylight.name : tzDisplay.standard.name;
      }
      obj.push({
        name: entry[0],
        label: entry[1],
        offset: tz.current.offset,
        abbrev,
        altName
      });
      return obj;
    }, []).sort((a2, b) => {
      return a2.offset - b.offset;
    }).map((tz) => {
      if (tz.offset === void 0)
        return false;
      let label = "";
      const min = tz.offset * 60;
      const hr = `${min / 60 ^ 0}:` + (min % 60 === 0 ? "00" : Math.abs(min % 60));
      const prefix3 = `(GMT${hr.includes("-") ? hr : `+${hr}`}) ${tz.label}`;
      switch (labelStyle) {
        case "original":
          label = prefix3;
          break;
        case "altName":
          label = `${prefix3} ${!tz.altName.includes("/") ? `(${tz.altName})` : ""}`;
          break;
        case "abbrev":
          label = `${prefix3} 
            ${tz.abbrev.length < 5 ? `(${tz.abbrev})` : ""}`;
          break;
        default:
          label = `${prefix3}`;
      }
      options2.push({
        value: tz.name,
        label,
        abbrev: tz.abbrev,
        altName: tz.altName
      });
    });
    return options2;
  }, [labelStyle, timezones2]);
  const handleChange = (tz) => {
    onChange2 && onChange2(tz);
  };
  const normalizeTz = (value2) => {
    let returnTz;
    if (typeof value2 === "string") {
      returnTz = getOptions.find((tz) => tz.value === value2);
    } else if (value2.value && !value2.label) {
      returnTz = getOptions.find((tz) => tz.value === value2.value);
    } else {
      returnTz = value2;
    }
    return returnTz;
  };
  return React11.createElement(react_select_esm_default, Object.assign({value: normalizeTz(value), onChange: handleChange, options: getOptions, onBlur}, props));
};
var dist_default = TimezoneSelect;

// src/clock/clock.tsx
var useStyles = createUseStyles({
  react_clock: {
    MozBoxSizing: "border-box",
    WebkitBoxSizing: "border-box",
    boxSizing: "border-box",
    "&:before": {
      MozBoxSizing: "border-box",
      WebkitBoxSizing: "border-box",
      boxSizing: "border-box"
    },
    "&:after": {
      MozBoxSizing: "border-box",
      WebkitBoxSizing: "border-box",
      boxSizing: "border-box"
    },
    "& .react-clock__face": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "0",
      right: "0",
      border: (props) => `1px solid ${props.borderColor}`,
      borderRadius: "50%"
    },
    "& .react-clock__hand": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "50%",
      right: "50%"
    },
    "& .react-clock__hand__body": {
      position: "absolute",
      backgroundColor: (props) => props.handColor,
      transform: "translateX(-50%)"
    },
    "& .react-clock__mark": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "50%",
      right: "50%"
    },
    "& .react-clock__mark__body": {
      position: "absolute",
      backgroundColor: (props) => props.faceColor,
      transform: "translateX(-50%)"
    },
    "& .react-clock__mark__number": {
      position: "absolute",
      left: "-40px",
      width: "80px",
      textAlign: "center",
      color: (props) => props.numberColor
    }
  }
});
function ClockRenderer(props) {
  const [value, setValue] = (0, import_react18.useState)(new Date());
  const intervalRef = (0, import_react18.useRef)(null);
  const classes = useStyles(props);
  const {
    timezone: timezone5,
    showNumbers,
    showMinuteMarks,
    showHourMarks,
    showSecondHand,
    showMinuteHand
  } = props;
  (0, import_react18.useEffect)(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    intervalRef.current = setInterval(() => {
      let newDate = new Date();
      if (timezone5) {
        newDate = changeTimezone(newDate, timezone5);
      }
      setValue(newDate);
    }, 1e3);
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [timezone5]);
  return /* @__PURE__ */ import_react18.default.createElement("div", null, /* @__PURE__ */ import_react18.default.createElement(esm_default, {
    value,
    className: classes.react_clock,
    renderHourMarks: showHourMarks,
    renderMinuteMarks: showMinuteMarks,
    renderNumbers: showNumbers,
    renderSecondHand: showSecondHand,
    renderMinuteHand: showMinuteHand
  }));
}
function changeTimezone(date4, ianatz) {
  let st = spacetime_default(date4);
  st = st.goto(ianatz);
  return new Date(st.year(), st.month(), st.day(), st.hour(), st.minute(), st.second(), st.millisecond());
}
var ClockPrototype = {
  _proportionalSizing: true
};
var ClockDescription = {
  name: "Clock",
  title: "Clock",
  description: "The Clock Component ...",
  author: "Playful Software",
  renderer: ClockRenderer,
  extends: "Play Kit/View",
  prototype: ClockPrototype,
  properties: {
    width: {type: "number", title: "Width", default: 100},
    height: {type: "number", title: "Height", default: 100},
    handColor: {type: "string", title: "Hand Color", default: "white", editor: "Color"},
    faceColor: {type: "string", title: "Face Color", default: "white", editor: "Color"},
    numberColor: {type: "string", title: "Number Color", default: "white", editor: "Color"},
    borderColor: {type: "string", title: "Border Color", default: "white", editor: "Color"},
    showNumbers: {type: "boolean", title: "Show Numbers", default: false},
    showMinuteMarks: {type: "boolean", title: "Show Minute Marks", default: true},
    showHourMarks: {type: "boolean", title: "Show Hour Marks", default: true},
    showSecondHand: {type: "boolean", title: "Show Second Hand", default: true},
    showMinuteHand: {type: "boolean", title: "Show Minute Hand", default: true},
    timezone: {
      type: "string",
      title: "Time Zone",
      editor: {
        type: "String",
        component: ({value, onValueChange}) => {
          const handleChange = (timezone5) => {
            onValueChange(timezone5.value);
          };
          return /* @__PURE__ */ import_react18.default.createElement(dist_default, {
            value,
            onChange: handleChange,
            styles: {
              option: (provided) => ({
                ...provided,
                color: "black"
              })
            }
          });
        }
      }
    }
  }
};

// src/warpspeed/WarpSpeedComponent.tsx
var import_react19 = __toModule(require("react"));
var import_WarpSpeed = __toModule(require_WarpSpeed());
function WarpSpeedComponent(props) {
  const {
    componentObject,
    speed,
    speedAdjustmentFactor,
    density,
    shape,
    warpEffect,
    warpEffectLength,
    depthFade,
    starSize,
    backgroundColor,
    color,
    pause,
    preset
  } = props;
  const [warpspeed, setWarpspeed] = (0, import_react19.useState)();
  const [canvas, setCanvas] = (0, import_react19.useState)();
  function createWarpSpeed(id) {
    if (warpspeed) {
      warpspeed.destroy();
    }
    const ws = new import_WarpSpeed.default(id, {
      speed,
      speedAdjFactor: speedAdjustmentFactor,
      density,
      shape,
      warpEffect,
      warpEffectLength,
      depthFade,
      starSize,
      backgroundColor,
      starColor: color
    });
    if (pause) {
      ws.pause();
    }
    setWarpspeed(ws);
  }
  const canvasCallback = (0, import_react19.useCallback)((canvas2) => setCanvas(canvas2), []);
  (0, import_react19.useEffect)(() => {
    if (canvas) {
      createWarpSpeed(componentObject.id.toString());
    }
    return () => warpspeed == null ? void 0 : warpspeed.destroy();
  }, [canvas, density]);
  (0, import_react19.useEffect)(() => {
    if (warpspeed) {
      warpspeed.TARGET_SPEED = speed;
      warpspeed.USE_CIRCLES = shape === "circle";
      warpspeed.WARP_EFFECT = warpEffect;
      warpspeed.WARP_EFFECT_LENGTH = warpEffectLength;
      warpspeed.DEPTH_ALPHA = depthFade;
      warpspeed.STAR_SCALE = starSize;
      warpspeed.BACKGROUND_COLOR = backgroundColor;
      warpspeed.STAR_R = parseInt(color.slice(1, 3), 16);
      warpspeed.STAR_G = parseInt(color.slice(3, 5), 16);
      warpspeed.STAR_B = parseInt(color.slice(5, 7), 16);
    }
  }, [
    speed,
    speedAdjustmentFactor,
    density,
    shape,
    warpEffect,
    warpEffectLength,
    depthFade,
    starSize,
    backgroundColor,
    color
  ]);
  (0, import_react19.useEffect)(() => {
    if (!warpspeed) {
      return;
    }
    if (pause) {
      warpspeed.pause();
    } else {
      warpspeed.resume();
    }
  }, [pause]);
  return /* @__PURE__ */ import_react19.default.createElement("canvas", {
    style: {width: "100%", height: "100%"},
    id: componentObject.id.toString(),
    ref: canvasCallback
  });
}
var WarpSpeedDescription = {
  name: "WarpSpeed",
  description: "The WarpSpeed Component ...",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: WarpSpeedComponent,
  extends: "Play Kit/View",
  properties: {
    speed: {
      type: "number",
      default: 0.7,
      editor: {type: "Number", min: 0, max: 50, step: 0.1},
      description: `The speed at which we're moving through the starfield.`
    },
    warpEffect: {
      type: "boolean",
      default: true,
      description: `Draws lines instead of just the stars. Slower.`
    },
    warpEffectLength: {
      type: "number",
      default: 5,
      editor: {type: "Number", min: 0, max: 30, step: 0.1},
      description: `How long the warp strikes are in depth units.`
    },
    density: {
      type: "number",
      default: 0.7,
      editor: {type: "Number", min: 0, max: 30, step: 0.01},
      description: `Star density. Number of stars = density * drawDistance.`
    },
    depthFade: {
      type: "boolean",
      default: true,
      description: `Stars that are further from the camera are less opaque. Slower.`
    },
    starSize: {
      type: "number",
      default: 3,
      editor: {type: "Number", min: 1, max: 20},
      description: `Size of stars.`
    },
    shape: {
      type: "string",
      default: "circle",
      editor: {type: "Option", options: ["circle", "square"]},
      description: `Drawing squares instead of circles is faster, but looks less pretty.`
    },
    speedAdjustmentFactor: {
      type: "number",
      default: 0.03,
      editor: {type: "Number", min: 0, max: 1, step: 0.01},
      description: `How fast the speed changes from the current speed to target speed. 0 = no change, 1 = instant change.`
    },
    backgroundColor: {
      type: "string",
      default: "hsl(263,45%,7%)",
      editor: "Color",
      description: `Background color. Alpha not recommended.`
    },
    color: {
      type: "string",
      title: "Star Color",
      default: "#ffffff",
      editor: "Color",
      description: `Star color. Alpha not recommended.`
    },
    pause: {type: "boolean", default: false},
    credits: {
      type: "string",
      default: `WarpSpeed.js by Federico Dossena (https://github.com/adolfintel/warpspeed)`,
      readonly: true
    },
    width: {type: "number", title: "Width", default: 400},
    height: {type: "number", title: "Height", default: 400}
  }
};

// src/index.ts
var kit = {
  title: "React Test Kit",
  description: "React Test Kit contains React components used to test Play.",
  author: "Playful Software",
  components: [
    ThreeDescription,
    XKCDDescription,
    import_chart_xkcd.LineChartDescription,
    import_chart_xkcd.BarChartDescription,
    import_chart_xkcd.PieChartDescription,
    import_chart_xkcd.XYChartDescription,
    import_chart_xkcd.StackedBarChartDescription,
    import_chart_xkcd.RadarChartDescription,
    ClockDescription,
    WarpSpeedDescription
  ]
};
//# sourceMappingURL=index.js.map
