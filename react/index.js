var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, {get: all2[name2], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports2, module2) => {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  "use strict";
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from2 = Object(arguments[s2]);
      for (var key in from2) {
        if (hasOwnProperty2.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from2, symbols[i2])) {
            to[symbols[i2]] = from2[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
});

// node_modules/react-reconciler/node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS((exports2) => {
  /** @license React v0.20.2
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var f2;
  var g2;
  var h2;
  var k2;
  if (typeof performance === "object" && typeof performance.now === "function") {
    l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var l2;
  var p2;
  var q2;
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    t2 = null, u2 = null, w3 = function() {
      if (t2 !== null)
        try {
          var a2 = exports2.unstable_now();
          t2(true, a2);
          t2 = null;
        } catch (b2) {
          throw setTimeout(w3, 0), b2;
        }
    };
    f2 = function(a2) {
      t2 !== null ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w3, 0));
    };
    g2 = function(a2, b2) {
      u2 = setTimeout(a2, b2);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    x2 = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E2;
    };
    k2 = function() {
    };
    exports2.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a2 = exports2.unstable_now();
        E2 = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b2) {
          throw G2.postMessage(null), b2;
        }
      } else
        A2 = false;
    };
    f2 = function(a2) {
      B2 = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a2, b2) {
      C2 = x2(function() {
        a2(exports2.unstable_now());
      }, b2);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  var t2;
  var u2;
  var w3;
  var x2;
  var y2;
  var z2;
  var A2;
  var B2;
  var C2;
  var D2;
  var E2;
  var F2;
  var G2;
  function H2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (e2 !== void 0 && 0 < I2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function J2(a2) {
    a2 = a2[0];
    return a2 === void 0 ? null : a2;
  }
  function K2(a2) {
    var b2 = a2[0];
    if (b2 !== void 0) {
      var c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
            if (n2 !== void 0 && 0 > I2(n2, c2))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c2))
              a2[d2] = r2, a2[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b2;
    }
    return null;
  }
  function I2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a2.id - b2.id;
  }
  var L4 = [];
  var M2 = [];
  var N2 = 1;
  var O2 = null;
  var P2 = 3;
  var Q2 = false;
  var R2 = false;
  var S2 = false;
  function T2(a2) {
    for (var b2 = J2(M2); b2 !== null; ) {
      if (b2.callback === null)
        K2(M2);
      else if (b2.startTime <= a2)
        K2(M2), b2.sortIndex = b2.expirationTime, H2(L4, b2);
      else
        break;
      b2 = J2(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (J2(L4) !== null)
        R2 = true, f2(V2);
      else {
        var b2 = J2(M2);
        b2 !== null && g2(U2, b2.startTime - a2);
      }
  }
  function V2(a2, b2) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c2 = P2;
    try {
      T2(b2);
      for (O2 = J2(L4); O2 !== null && (!(O2.expirationTime > b2) || a2 && !exports2.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if (typeof d2 === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d2(O2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          typeof e2 === "function" ? O2.callback = e2 : O2 === J2(L4) && K2(L4);
          T2(b2);
        } else
          K2(L4);
        O2 = J2(L4);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J2(M2);
        n2 !== null && g2(U2, n2.startTime - b2);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q2 = false;
    }
  }
  var W2 = k2;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J2(L4);
  };
  exports2.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = P2;
    }
    var c2 = P2;
    P2 = b2;
    try {
      return a2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W2;
  exports2.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = P2;
    P2 = a2;
    try {
      return b2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports2.unstable_now();
    typeof c2 === "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 === "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = {id: N2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1};
    c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), J2(L4) === null && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e2, H2(L4, a2), R2 || Q2 || (R2 = true, f2(V2)));
    return a2;
  };
  exports2.unstable_wrapCallback = function(a2) {
    var b2 = P2;
    return function() {
      var c2 = P2;
      P2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
});

// node_modules/react-reconciler/node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_scheduler_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/react-reconciler/cjs/react-reconciler.production.min.js
var require_react_reconciler_production_min = __commonJS((exports2, module2) => {
  /** @license React v0.26.1
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  module2.exports = function $$$reconciler($$$hostConfig) {
    var exports3 = {};
    "use strict";
    var aa = require_object_assign(), ba = require("react"), m2 = require_scheduler();
    function q2(a2) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var ca = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, da = 60103, ea = 60106, fa = 60107, ha = 60108, ia = 60114, ja = 60109, ka = 60110, la = 60112, ma = 60113, na = 60120, oa = 60115, pa = 60116, qa = 60121, ra = 60129, sa = 60130, ta = 60131;
    if (typeof Symbol === "function" && Symbol.for) {
      var r2 = Symbol.for;
      da = r2("react.element");
      ea = r2("react.portal");
      fa = r2("react.fragment");
      ha = r2("react.strict_mode");
      ia = r2("react.profiler");
      ja = r2("react.provider");
      ka = r2("react.context");
      la = r2("react.forward_ref");
      ma = r2("react.suspense");
      na = r2("react.suspense_list");
      oa = r2("react.memo");
      pa = r2("react.lazy");
      qa = r2("react.block");
      r2("react.scope");
      ra = r2("react.debug_trace_mode");
      sa = r2("react.offscreen");
      ta = r2("react.legacy_hidden");
    }
    var ua = typeof Symbol === "function" && Symbol.iterator;
    function va(a2) {
      if (a2 === null || typeof a2 !== "object")
        return null;
      a2 = ua && a2[ua] || a2["@@iterator"];
      return typeof a2 === "function" ? a2 : null;
    }
    function wa(a2) {
      if (a2 == null)
        return null;
      if (typeof a2 === "function")
        return a2.displayName || a2.name || null;
      if (typeof a2 === "string")
        return a2;
      switch (a2) {
        case fa:
          return "Fragment";
        case ea:
          return "Portal";
        case ia:
          return "Profiler";
        case ha:
          return "StrictMode";
        case ma:
          return "Suspense";
        case na:
          return "SuspenseList";
      }
      if (typeof a2 === "object")
        switch (a2.$$typeof) {
          case ka:
            return (a2.displayName || "Context") + ".Consumer";
          case ja:
            return (a2._context.displayName || "Context") + ".Provider";
          case la:
            var b2 = a2.render;
            b2 = b2.displayName || b2.name || "";
            return a2.displayName || (b2 !== "" ? "ForwardRef(" + b2 + ")" : "ForwardRef");
          case oa:
            return wa(a2.type);
          case qa:
            return wa(a2._render);
          case pa:
            b2 = a2._payload;
            a2 = a2._init;
            try {
              return wa(a2(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function xa(a2) {
      var b2 = a2, c2 = a2;
      if (a2.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a2 = b2;
        do
          b2 = a2, (b2.flags & 1026) !== 0 && (c2 = b2.return), a2 = b2.return;
        while (a2);
      }
      return b2.tag === 3 ? c2 : null;
    }
    function ya(a2) {
      if (xa(a2) !== a2)
        throw Error(q2(188));
    }
    function za(a2) {
      var b2 = a2.alternate;
      if (!b2) {
        b2 = xa(a2);
        if (b2 === null)
          throw Error(q2(188));
        return b2 !== a2 ? null : a2;
      }
      for (var c2 = a2, d2 = b2; ; ) {
        var e2 = c2.return;
        if (e2 === null)
          break;
        var f2 = e2.alternate;
        if (f2 === null) {
          d2 = e2.return;
          if (d2 !== null) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return ya(e2), a2;
            if (f2 === d2)
              return ya(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(q2(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(q2(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(q2(190));
      }
      if (c2.tag !== 3)
        throw Error(q2(188));
      return c2.stateNode.current === c2 ? a2 : b2;
    }
    function Aa(a2) {
      a2 = za(a2);
      if (!a2)
        return null;
      for (var b2 = a2; ; ) {
        if (b2.tag === 5 || b2.tag === 6)
          return b2;
        if (b2.child)
          b2.child.return = b2, b2 = b2.child;
        else {
          if (b2 === a2)
            break;
          for (; !b2.sibling; ) {
            if (!b2.return || b2.return === a2)
              return null;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return null;
    }
    function Ba(a2) {
      a2 = za(a2);
      if (!a2)
        return null;
      for (var b2 = a2; ; ) {
        if (b2.tag === 5 || b2.tag === 6)
          return b2;
        if (b2.child && b2.tag !== 4)
          b2.child.return = b2, b2 = b2.child;
        else {
          if (b2 === a2)
            break;
          for (; !b2.sibling; ) {
            if (!b2.return || b2.return === a2)
              return null;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return null;
    }
    function Ca(a2, b2) {
      for (var c2 = a2.alternate; b2 !== null; ) {
        if (b2 === a2 || b2 === c2)
          return true;
        b2 = b2.return;
      }
      return false;
    }
    var Da = $$$hostConfig.getPublicInstance, Ea = $$$hostConfig.getRootHostContext, Fa = $$$hostConfig.getChildHostContext, Ga = $$$hostConfig.prepareForCommit, Ha = $$$hostConfig.resetAfterCommit, Ia = $$$hostConfig.createInstance, Ja = $$$hostConfig.appendInitialChild, Ka = $$$hostConfig.finalizeInitialChildren, La = $$$hostConfig.prepareUpdate, Ma = $$$hostConfig.shouldSetTextContent, Na = $$$hostConfig.createTextInstance, Pa = $$$hostConfig.scheduleTimeout, Qa = $$$hostConfig.cancelTimeout, Ra = $$$hostConfig.noTimeout, Sa = $$$hostConfig.isPrimaryRenderer, Ta = $$$hostConfig.supportsMutation, Ua = $$$hostConfig.supportsPersistence, Va = $$$hostConfig.supportsHydration, Wa = $$$hostConfig.getInstanceFromNode, Xa = $$$hostConfig.makeOpaqueHydratingObject, Ya = $$$hostConfig.makeClientId, Za = $$$hostConfig.beforeActiveInstanceBlur, $a = $$$hostConfig.afterActiveInstanceBlur, ab = $$$hostConfig.preparePortalMount, bb = $$$hostConfig.supportsTestSelectors, cb = $$$hostConfig.findFiberRoot, db = $$$hostConfig.getBoundingRect, eb = $$$hostConfig.getTextContent, fb = $$$hostConfig.isHiddenSubtree, gb = $$$hostConfig.matchAccessibilityRole, hb = $$$hostConfig.setFocusIfFocusable, ib = $$$hostConfig.setupIntersectionObserver, jb = $$$hostConfig.appendChild, kb = $$$hostConfig.appendChildToContainer, lb = $$$hostConfig.commitTextUpdate, mb = $$$hostConfig.commitMount, nb = $$$hostConfig.commitUpdate, ob = $$$hostConfig.insertBefore, pb = $$$hostConfig.insertInContainerBefore, qb = $$$hostConfig.removeChild, rb = $$$hostConfig.removeChildFromContainer, sb = $$$hostConfig.resetTextContent, tb = $$$hostConfig.hideInstance, ub = $$$hostConfig.hideTextInstance, vb = $$$hostConfig.unhideInstance, wb = $$$hostConfig.unhideTextInstance, xb = $$$hostConfig.clearContainer, yb = $$$hostConfig.cloneInstance, zb = $$$hostConfig.createContainerChildSet, Ab = $$$hostConfig.appendChildToContainerChildSet, Bb = $$$hostConfig.finalizeContainerChildren, Cb = $$$hostConfig.replaceContainerChildren, Db = $$$hostConfig.cloneHiddenInstance, Eb = $$$hostConfig.cloneHiddenTextInstance, Fb = $$$hostConfig.canHydrateInstance, Gb = $$$hostConfig.canHydrateTextInstance, Hb = $$$hostConfig.isSuspenseInstancePending, Ib = $$$hostConfig.isSuspenseInstanceFallback, Jb = $$$hostConfig.getNextHydratableSibling, Kb = $$$hostConfig.getFirstHydratableChild, Lb = $$$hostConfig.hydrateInstance, Mb = $$$hostConfig.hydrateTextInstance, Nb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, Ob = $$$hostConfig.commitHydratedContainer, Pb = $$$hostConfig.commitHydratedSuspenseInstance, Qb;
    function Rb(a2) {
      if (Qb === void 0)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          Qb = b2 && b2[1] || "";
        }
      return "\n" + Qb + a2;
    }
    var Sb = false;
    function Tb(a2, b2) {
      if (!a2 || Sb)
        return "";
      Sb = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", {set: function() {
            throw Error();
          }}), typeof Reflect === "object" && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (k2) {
              var d2 = k2;
            }
            Reflect.construct(a2, [], b2);
          } else {
            try {
              b2.call();
            } catch (k2) {
              d2 = k2;
            }
            a2.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k2) {
            d2 = k2;
          }
          a2();
        }
      } catch (k2) {
        if (k2 && d2 && typeof k2.stack === "string") {
          for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (g2 !== 1 || h2 !== 1) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                    return "\n" + e2[g2].replace(" at new ", " at ");
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Sb = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Rb(a2) : "";
    }
    var Ub = [], Vb = -1;
    function Wb(a2) {
      return {current: a2};
    }
    function z2(a2) {
      0 > Vb || (a2.current = Ub[Vb], Ub[Vb] = null, Vb--);
    }
    function A2(a2, b2) {
      Vb++;
      Ub[Vb] = a2.current;
      a2.current = b2;
    }
    var Xb = {}, B2 = Wb(Xb), D2 = Wb(false), Yb = Xb;
    function Zb(a2, b2) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Xb;
      var d2 = a2.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function E2(a2) {
      a2 = a2.childContextTypes;
      return a2 !== null && a2 !== void 0;
    }
    function $b() {
      z2(D2);
      z2(B2);
    }
    function ac(a2, b2, c2) {
      if (B2.current !== Xb)
        throw Error(q2(168));
      A2(B2, b2);
      A2(D2, c2);
    }
    function bc(a2, b2, c2) {
      var d2 = a2.stateNode;
      a2 = b2.childContextTypes;
      if (typeof d2.getChildContext !== "function")
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in a2))
          throw Error(q2(108, wa(b2) || "Unknown", e2));
      return aa({}, c2, d2);
    }
    function cc(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Xb;
      Yb = B2.current;
      A2(B2, a2);
      A2(D2, D2.current);
      return true;
    }
    function dc(a2, b2, c2) {
      var d2 = a2.stateNode;
      if (!d2)
        throw Error(q2(169));
      c2 ? (a2 = bc(a2, b2, Yb), d2.__reactInternalMemoizedMergedChildContext = a2, z2(D2), z2(B2), A2(B2, a2)) : z2(D2);
      A2(D2, c2);
    }
    var ec = null, fc = null, gc = m2.unstable_now;
    gc();
    var hc = 0, F2 = 8;
    function ic(a2) {
      if ((1 & a2) !== 0)
        return F2 = 15, 1;
      if ((2 & a2) !== 0)
        return F2 = 14, 2;
      if ((4 & a2) !== 0)
        return F2 = 13, 4;
      var b2 = 24 & a2;
      if (b2 !== 0)
        return F2 = 12, b2;
      if ((a2 & 32) !== 0)
        return F2 = 11, 32;
      b2 = 192 & a2;
      if (b2 !== 0)
        return F2 = 10, b2;
      if ((a2 & 256) !== 0)
        return F2 = 9, 256;
      b2 = 3584 & a2;
      if (b2 !== 0)
        return F2 = 8, b2;
      if ((a2 & 4096) !== 0)
        return F2 = 7, 4096;
      b2 = 4186112 & a2;
      if (b2 !== 0)
        return F2 = 6, b2;
      b2 = 62914560 & a2;
      if (b2 !== 0)
        return F2 = 5, b2;
      if (a2 & 67108864)
        return F2 = 4, 67108864;
      if ((a2 & 134217728) !== 0)
        return F2 = 3, 134217728;
      b2 = 805306368 & a2;
      if (b2 !== 0)
        return F2 = 2, b2;
      if ((1073741824 & a2) !== 0)
        return F2 = 1, 1073741824;
      F2 = 8;
      return a2;
    }
    function jc(a2) {
      switch (a2) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function kc(a2) {
      switch (a2) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(q2(358, a2));
      }
    }
    function lc(a2, b2) {
      var c2 = a2.pendingLanes;
      if (c2 === 0)
        return F2 = 0;
      var d2 = 0, e2 = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
      if (f2 !== 0)
        d2 = f2, e2 = F2 = 15;
      else if (f2 = c2 & 134217727, f2 !== 0) {
        var k2 = f2 & ~g2;
        k2 !== 0 ? (d2 = ic(k2), e2 = F2) : (h2 &= f2, h2 !== 0 && (d2 = ic(h2), e2 = F2));
      } else
        f2 = c2 & ~g2, f2 !== 0 ? (d2 = ic(f2), e2 = F2) : h2 !== 0 && (d2 = ic(h2), e2 = F2);
      if (d2 === 0)
        return 0;
      d2 = 31 - mc(d2);
      d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
      if (b2 !== 0 && b2 !== d2 && (b2 & g2) === 0) {
        ic(b2);
        if (e2 <= F2)
          return b2;
        F2 = e2;
      }
      b2 = a2.entangledLanes;
      if (b2 !== 0)
        for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - mc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
      return d2;
    }
    function nc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function oc(a2, b2) {
      switch (a2) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a2 = pc(24 & ~b2), a2 === 0 ? oc(10, b2) : a2;
        case 10:
          return a2 = pc(192 & ~b2), a2 === 0 ? oc(8, b2) : a2;
        case 8:
          return a2 = pc(3584 & ~b2), a2 === 0 && (a2 = pc(4186112 & ~b2), a2 === 0 && (a2 = 512)), a2;
        case 2:
          return b2 = pc(805306368 & ~b2), b2 === 0 && (b2 = 268435456), b2;
      }
      throw Error(q2(358, a2));
    }
    function pc(a2) {
      return a2 & -a2;
    }
    function qc(a2) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a2);
      return b2;
    }
    function rc(a2, b2, c2) {
      a2.pendingLanes |= b2;
      var d2 = b2 - 1;
      a2.suspendedLanes &= d2;
      a2.pingedLanes &= d2;
      a2 = a2.eventTimes;
      b2 = 31 - mc(b2);
      a2[b2] = c2;
    }
    var mc = Math.clz32 ? Math.clz32 : sc, tc = Math.log, uc = Math.LN2;
    function sc(a2) {
      return a2 === 0 ? 32 : 31 - (tc(a2) / uc | 0) | 0;
    }
    var vc = m2.unstable_runWithPriority, wc = m2.unstable_scheduleCallback, xc = m2.unstable_cancelCallback, yc = m2.unstable_shouldYield, zc = m2.unstable_requestPaint, Ac = m2.unstable_now, Bc = m2.unstable_getCurrentPriorityLevel, Cc = m2.unstable_ImmediatePriority, Dc = m2.unstable_UserBlockingPriority, Ec = m2.unstable_NormalPriority, Fc = m2.unstable_LowPriority, Gc = m2.unstable_IdlePriority, Hc = {}, Ic = zc !== void 0 ? zc : function() {
    }, Jc = null, Kc = null, Lc = false, Mc = Ac(), G2 = 1e4 > Mc ? Ac : function() {
      return Ac() - Mc;
    };
    function Nc() {
      switch (Bc()) {
        case Cc:
          return 99;
        case Dc:
          return 98;
        case Ec:
          return 97;
        case Fc:
          return 96;
        case Gc:
          return 95;
        default:
          throw Error(q2(332));
      }
    }
    function Oc(a2) {
      switch (a2) {
        case 99:
          return Cc;
        case 98:
          return Dc;
        case 97:
          return Ec;
        case 96:
          return Fc;
        case 95:
          return Gc;
        default:
          throw Error(q2(332));
      }
    }
    function Pc(a2, b2) {
      a2 = Oc(a2);
      return vc(a2, b2);
    }
    function Qc(a2, b2, c2) {
      a2 = Oc(a2);
      return wc(a2, b2, c2);
    }
    function H2() {
      if (Kc !== null) {
        var a2 = Kc;
        Kc = null;
        xc(a2);
      }
      Rc();
    }
    function Rc() {
      if (!Lc && Jc !== null) {
        Lc = true;
        var a2 = 0;
        try {
          var b2 = Jc;
          Pc(99, function() {
            for (; a2 < b2.length; a2++) {
              var c2 = b2[a2];
              do
                c2 = c2(true);
              while (c2 !== null);
            }
          });
          Jc = null;
        } catch (c2) {
          throw Jc !== null && (Jc = Jc.slice(a2 + 1)), wc(Cc, H2), c2;
        } finally {
          Lc = false;
        }
      }
    }
    var Sc = ca.ReactCurrentBatchConfig;
    function Tc(a2, b2) {
      return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var I2 = typeof Object.is === "function" ? Object.is : Tc, Uc = Object.prototype.hasOwnProperty;
    function Vc(a2, b2) {
      if (I2(a2, b2))
        return true;
      if (typeof a2 !== "object" || a2 === null || typeof b2 !== "object" || b2 === null)
        return false;
      var c2 = Object.keys(a2), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++)
        if (!Uc.call(b2, c2[d2]) || !I2(a2[c2[d2]], b2[c2[d2]]))
          return false;
      return true;
    }
    function Wc(a2) {
      switch (a2.tag) {
        case 5:
          return Rb(a2.type);
        case 16:
          return Rb("Lazy");
        case 13:
          return Rb("Suspense");
        case 19:
          return Rb("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Tb(a2.type, false), a2;
        case 11:
          return a2 = Tb(a2.type.render, false), a2;
        case 22:
          return a2 = Tb(a2.type._render, false), a2;
        case 1:
          return a2 = Tb(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Xc(a2, b2) {
      if (a2 && a2.defaultProps) {
        b2 = aa({}, b2);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          b2[c2] === void 0 && (b2[c2] = a2[c2]);
        return b2;
      }
      return b2;
    }
    var Yc = Wb(null), Zc = null, $c = null, ad = null;
    function bd() {
      ad = $c = Zc = null;
    }
    function cd(a2, b2) {
      a2 = a2.type._context;
      Sa ? (A2(Yc, a2._currentValue), a2._currentValue = b2) : (A2(Yc, a2._currentValue2), a2._currentValue2 = b2);
    }
    function dd(a2) {
      var b2 = Yc.current;
      z2(Yc);
      a2 = a2.type._context;
      Sa ? a2._currentValue = b2 : a2._currentValue2 = b2;
    }
    function ed(a2, b2) {
      for (; a2 !== null; ) {
        var c2 = a2.alternate;
        if ((a2.childLanes & b2) === b2)
          if (c2 === null || (c2.childLanes & b2) === b2)
            break;
          else
            c2.childLanes |= b2;
        else
          a2.childLanes |= b2, c2 !== null && (c2.childLanes |= b2);
        a2 = a2.return;
      }
    }
    function fd(a2, b2) {
      Zc = a2;
      ad = $c = null;
      a2 = a2.dependencies;
      a2 !== null && a2.firstContext !== null && ((a2.lanes & b2) !== 0 && (gd = true), a2.firstContext = null);
    }
    function J2(a2, b2) {
      if (ad !== a2 && b2 !== false && b2 !== 0) {
        if (typeof b2 !== "number" || b2 === 1073741823)
          ad = a2, b2 = 1073741823;
        b2 = {context: a2, observedBits: b2, next: null};
        if ($c === null) {
          if (Zc === null)
            throw Error(q2(308));
          $c = b2;
          Zc.dependencies = {lanes: 0, firstContext: b2, responders: null};
        } else
          $c = $c.next = b2;
      }
      return Sa ? a2._currentValue : a2._currentValue2;
    }
    var hd = false;
    function id(a2) {
      a2.updateQueue = {baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: {pending: null}, effects: null};
    }
    function jd(a2, b2) {
      a2 = a2.updateQueue;
      b2.updateQueue === a2 && (b2.updateQueue = {baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects});
    }
    function kd(a2, b2) {
      return {eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null};
    }
    function md(a2, b2) {
      a2 = a2.updateQueue;
      if (a2 !== null) {
        a2 = a2.shared;
        var c2 = a2.pending;
        c2 === null ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
        a2.pending = b2;
      }
    }
    function nd(a2, b2) {
      var c2 = a2.updateQueue, d2 = a2.alternate;
      if (d2 !== null && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (c2 !== null) {
          do {
            var g2 = {eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null};
            f2 === null ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (c2 !== null);
          f2 === null ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = {baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects};
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      a2 === null ? c2.firstBaseUpdate = b2 : a2.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function od(a2, b2, c2, d2) {
      var e2 = a2.updateQueue;
      hd = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (h2 !== null) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        g2 === null ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var n2 = a2.alternate;
        if (n2 !== null) {
          n2 = n2.updateQueue;
          var t2 = n2.lastBaseUpdate;
          t2 !== g2 && (t2 === null ? n2.firstBaseUpdate = l2 : t2.next = l2, n2.lastBaseUpdate = k2);
        }
      }
      if (f2 !== null) {
        t2 = e2.baseState;
        g2 = 0;
        n2 = l2 = k2 = null;
        do {
          h2 = f2.lane;
          var p2 = f2.eventTime;
          if ((d2 & h2) === h2) {
            n2 !== null && (n2 = n2.next = {
              eventTime: p2,
              lane: 0,
              tag: f2.tag,
              payload: f2.payload,
              callback: f2.callback,
              next: null
            });
            a: {
              var y2 = a2, x2 = f2;
              h2 = b2;
              p2 = c2;
              switch (x2.tag) {
                case 1:
                  y2 = x2.payload;
                  if (typeof y2 === "function") {
                    t2 = y2.call(p2, t2, h2);
                    break a;
                  }
                  t2 = y2;
                  break a;
                case 3:
                  y2.flags = y2.flags & -4097 | 64;
                case 0:
                  y2 = x2.payload;
                  h2 = typeof y2 === "function" ? y2.call(p2, t2, h2) : y2;
                  if (h2 === null || h2 === void 0)
                    break a;
                  t2 = aa({}, t2, h2);
                  break a;
                case 2:
                  hd = true;
              }
            }
            f2.callback !== null && (a2.flags |= 32, h2 = e2.effects, h2 === null ? e2.effects = [f2] : h2.push(f2));
          } else
            p2 = {eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null}, n2 === null ? (l2 = n2 = p2, k2 = t2) : n2 = n2.next = p2, g2 |= h2;
          f2 = f2.next;
          if (f2 === null)
            if (h2 = e2.shared.pending, h2 === null)
              break;
            else
              f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
        } while (1);
        n2 === null && (k2 = t2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = n2;
        pd |= g2;
        a2.lanes = g2;
        a2.memoizedState = t2;
      }
    }
    function qd(a2, b2, c2) {
      a2 = b2.effects;
      b2.effects = null;
      if (a2 !== null)
        for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = a2[b2], e2 = d2.callback;
          if (e2 !== null) {
            d2.callback = null;
            d2 = c2;
            if (typeof e2 !== "function")
              throw Error(q2(191, e2));
            e2.call(d2);
          }
        }
    }
    var rd = new ba.Component().refs;
    function sd(a2, b2, c2, d2) {
      b2 = a2.memoizedState;
      c2 = c2(d2, b2);
      c2 = c2 === null || c2 === void 0 ? b2 : aa({}, b2, c2);
      a2.memoizedState = c2;
      a2.lanes === 0 && (a2.updateQueue.baseState = c2);
    }
    var vd = {isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? xa(a2) === a2 : false;
    }, enqueueSetState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = K2(), e2 = td(a2), f2 = kd(d2, e2);
      f2.payload = b2;
      c2 !== void 0 && c2 !== null && (f2.callback = c2);
      md(a2, f2);
      ud(a2, e2, d2);
    }, enqueueReplaceState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = K2(), e2 = td(a2), f2 = kd(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      c2 !== void 0 && c2 !== null && (f2.callback = c2);
      md(a2, f2);
      ud(a2, e2, d2);
    }, enqueueForceUpdate: function(a2, b2) {
      a2 = a2._reactInternals;
      var c2 = K2(), d2 = td(a2), e2 = kd(c2, d2);
      e2.tag = 2;
      b2 !== void 0 && b2 !== null && (e2.callback = b2);
      md(a2, e2);
      ud(a2, d2, c2);
    }};
    function wd(a2, b2, c2, d2, e2, f2, g2) {
      a2 = a2.stateNode;
      return typeof a2.shouldComponentUpdate === "function" ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Vc(c2, d2) || !Vc(e2, f2) : true;
    }
    function xd(a2, b2, c2) {
      var d2 = false, e2 = Xb;
      var f2 = b2.contextType;
      typeof f2 === "object" && f2 !== null ? f2 = J2(f2) : (e2 = E2(b2) ? Yb : B2.current, d2 = b2.contextTypes, f2 = (d2 = d2 !== null && d2 !== void 0) ? Zb(a2, e2) : Xb);
      b2 = new b2(c2, f2);
      a2.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null;
      b2.updater = vd;
      a2.stateNode = b2;
      b2._reactInternals = a2;
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function yd(a2, b2, c2, d2) {
      a2 = b2.state;
      typeof b2.componentWillReceiveProps === "function" && b2.componentWillReceiveProps(c2, d2);
      typeof b2.UNSAFE_componentWillReceiveProps === "function" && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a2 && vd.enqueueReplaceState(b2, b2.state, null);
    }
    function zd(a2, b2, c2, d2) {
      var e2 = a2.stateNode;
      e2.props = c2;
      e2.state = a2.memoizedState;
      e2.refs = rd;
      id(a2);
      var f2 = b2.contextType;
      typeof f2 === "object" && f2 !== null ? e2.context = J2(f2) : (f2 = E2(b2) ? Yb : B2.current, e2.context = Zb(a2, f2));
      od(a2, c2, e2, d2);
      e2.state = a2.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      typeof f2 === "function" && (sd(a2, b2, f2, c2), e2.state = a2.memoizedState);
      typeof b2.getDerivedStateFromProps === "function" || typeof e2.getSnapshotBeforeUpdate === "function" || typeof e2.UNSAFE_componentWillMount !== "function" && typeof e2.componentWillMount !== "function" || (b2 = e2.state, typeof e2.componentWillMount === "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount === "function" && e2.UNSAFE_componentWillMount(), b2 !== e2.state && vd.enqueueReplaceState(e2, e2.state, null), od(a2, c2, e2, d2), e2.state = a2.memoizedState);
      typeof e2.componentDidMount === "function" && (a2.flags |= 4);
    }
    var Ad = Array.isArray;
    function Bd(a2, b2, c2) {
      a2 = c2.ref;
      if (a2 !== null && typeof a2 !== "function" && typeof a2 !== "object") {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (c2.tag !== 1)
              throw Error(q2(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(q2(147, a2));
          var e2 = "" + a2;
          if (b2 !== null && b2.ref !== null && typeof b2.ref === "function" && b2.ref._stringRef === e2)
            return b2.ref;
          b2 = function(a3) {
            var b3 = d2.refs;
            b3 === rd && (b3 = d2.refs = {});
            a3 === null ? delete b3[e2] : b3[e2] = a3;
          };
          b2._stringRef = e2;
          return b2;
        }
        if (typeof a2 !== "string")
          throw Error(q2(284));
        if (!c2._owner)
          throw Error(q2(290, a2));
      }
      return a2;
    }
    function Cd(a2, b2) {
      if (a2.type !== "textarea")
        throw Error(q2(31, Object.prototype.toString.call(b2) === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
    }
    function Dd(a2) {
      function b2(b3, c3) {
        if (a2) {
          var d3 = b3.lastEffect;
          d3 !== null ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
          c3.nextEffect = null;
          c3.flags = 8;
        }
      }
      function c2(c3, d3) {
        if (!a2)
          return null;
        for (; d3 !== null; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a3, b3) {
        for (a3 = new Map(); b3 !== null; )
          b3.key !== null ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
        return a3;
      }
      function e2(a3, b3) {
        a3 = Ed(a3, b3);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a2)
          return c3;
        d3 = b3.alternate;
        if (d3 !== null)
          return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
        b3.flags = 2;
        return c3;
      }
      function g2(b3) {
        a2 && b3.alternate === null && (b3.flags = 2);
        return b3;
      }
      function h2(a3, b3, c3, d3) {
        if (b3 === null || b3.tag !== 6)
          return b3 = Fd(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function k2(a3, b3, c3, d3) {
        if (b3 !== null && b3.elementType === c3.type)
          return d3 = e2(b3, c3.props), d3.ref = Bd(a3, b3, c3), d3.return = a3, d3;
        d3 = Gd(c3.type, c3.key, c3.props, null, a3.mode, d3);
        d3.ref = Bd(a3, b3, c3);
        d3.return = a3;
        return d3;
      }
      function l2(a3, b3, c3, d3) {
        if (b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = Hd(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a3;
        return b3;
      }
      function n2(a3, b3, c3, d3, f3) {
        if (b3 === null || b3.tag !== 7)
          return b3 = Id(c3, a3.mode, d3, f3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function t2(a3, b3, c3) {
        if (typeof b3 === "string" || typeof b3 === "number")
          return b3 = Fd("" + b3, a3.mode, c3), b3.return = a3, b3;
        if (typeof b3 === "object" && b3 !== null) {
          switch (b3.$$typeof) {
            case da:
              return c3 = Gd(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Bd(a3, null, b3), c3.return = a3, c3;
            case ea:
              return b3 = Hd(b3, a3.mode, c3), b3.return = a3, b3;
          }
          if (Ad(b3) || va(b3))
            return b3 = Id(b3, a3.mode, c3, null), b3.return = a3, b3;
          Cd(a3, b3);
        }
        return null;
      }
      function p2(a3, b3, c3, d3) {
        var e3 = b3 !== null ? b3.key : null;
        if (typeof c3 === "string" || typeof c3 === "number")
          return e3 !== null ? null : h2(a3, b3, "" + c3, d3);
        if (typeof c3 === "object" && c3 !== null) {
          switch (c3.$$typeof) {
            case da:
              return c3.key === e3 ? c3.type === fa ? n2(a3, b3, c3.props.children, d3, e3) : k2(a3, b3, c3, d3) : null;
            case ea:
              return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
          }
          if (Ad(c3) || va(c3))
            return e3 !== null ? null : n2(a3, b3, c3, d3, null);
          Cd(a3, c3);
        }
        return null;
      }
      function y2(a3, b3, c3, d3, e3) {
        if (typeof d3 === "string" || typeof d3 === "number")
          return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
        if (typeof d3 === "object" && d3 !== null) {
          switch (d3.$$typeof) {
            case da:
              return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, d3.type === fa ? n2(b3, a3, d3.props.children, e3, d3.key) : k2(b3, a3, d3, e3);
            case ea:
              return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
          }
          if (Ad(d3) || va(d3))
            return a3 = a3.get(c3) || null, n2(b3, a3, d3, e3, null);
          Cd(b3, d3);
        }
        return null;
      }
      function x2(e3, g3, h3, k3) {
        for (var l3 = null, v2 = null, u2 = g3, C2 = g3 = 0, n3 = null; u2 !== null && C2 < h3.length; C2++) {
          u2.index > C2 ? (n3 = u2, u2 = null) : n3 = u2.sibling;
          var w3 = p2(e3, u2, h3[C2], k3);
          if (w3 === null) {
            u2 === null && (u2 = n3);
            break;
          }
          a2 && u2 && w3.alternate === null && b2(e3, u2);
          g3 = f2(w3, g3, C2);
          v2 === null ? l3 = w3 : v2.sibling = w3;
          v2 = w3;
          u2 = n3;
        }
        if (C2 === h3.length)
          return c2(e3, u2), l3;
        if (u2 === null) {
          for (; C2 < h3.length; C2++)
            u2 = t2(e3, h3[C2], k3), u2 !== null && (g3 = f2(u2, g3, C2), v2 === null ? l3 = u2 : v2.sibling = u2, v2 = u2);
          return l3;
        }
        for (u2 = d2(e3, u2); C2 < h3.length; C2++)
          n3 = y2(u2, e3, C2, h3[C2], k3), n3 !== null && (a2 && n3.alternate !== null && u2.delete(n3.key === null ? C2 : n3.key), g3 = f2(n3, g3, C2), v2 === null ? l3 = n3 : v2.sibling = n3, v2 = n3);
        a2 && u2.forEach(function(a3) {
          return b2(e3, a3);
        });
        return l3;
      }
      function Y2(e3, g3, h3, k3) {
        var l3 = va(h3);
        if (typeof l3 !== "function")
          throw Error(q2(150));
        h3 = l3.call(h3);
        if (h3 == null)
          throw Error(q2(151));
        for (var u2 = l3 = null, v2 = g3, n3 = g3 = 0, C2 = null, w3 = h3.next(); v2 !== null && !w3.done; n3++, w3 = h3.next()) {
          v2.index > n3 ? (C2 = v2, v2 = null) : C2 = v2.sibling;
          var x3 = p2(e3, v2, w3.value, k3);
          if (x3 === null) {
            v2 === null && (v2 = C2);
            break;
          }
          a2 && v2 && x3.alternate === null && b2(e3, v2);
          g3 = f2(x3, g3, n3);
          u2 === null ? l3 = x3 : u2.sibling = x3;
          u2 = x3;
          v2 = C2;
        }
        if (w3.done)
          return c2(e3, v2), l3;
        if (v2 === null) {
          for (; !w3.done; n3++, w3 = h3.next())
            w3 = t2(e3, w3.value, k3), w3 !== null && (g3 = f2(w3, g3, n3), u2 === null ? l3 = w3 : u2.sibling = w3, u2 = w3);
          return l3;
        }
        for (v2 = d2(e3, v2); !w3.done; n3++, w3 = h3.next())
          w3 = y2(v2, e3, n3, w3.value, k3), w3 !== null && (a2 && w3.alternate !== null && v2.delete(w3.key === null ? n3 : w3.key), g3 = f2(w3, g3, n3), u2 === null ? l3 = w3 : u2.sibling = w3, u2 = w3);
        a2 && v2.forEach(function(a3) {
          return b2(e3, a3);
        });
        return l3;
      }
      return function(a3, d3, f3, h3) {
        var k3 = typeof f3 === "object" && f3 !== null && f3.type === fa && f3.key === null;
        k3 && (f3 = f3.props.children);
        var l3 = typeof f3 === "object" && f3 !== null;
        if (l3)
          switch (f3.$$typeof) {
            case da:
              a: {
                l3 = f3.key;
                for (k3 = d3; k3 !== null; ) {
                  if (k3.key === l3) {
                    switch (k3.tag) {
                      case 7:
                        if (f3.type === fa) {
                          c2(a3, k3.sibling);
                          d3 = e2(k3, f3.props.children);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                        break;
                      default:
                        if (k3.elementType === f3.type) {
                          c2(a3, k3.sibling);
                          d3 = e2(k3, f3.props);
                          d3.ref = Bd(a3, k3, f3);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                    }
                    c2(a3, k3);
                    break;
                  } else
                    b2(a3, k3);
                  k3 = k3.sibling;
                }
                f3.type === fa ? (d3 = Id(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Gd(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Bd(a3, d3, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case ea:
              a: {
                for (k3 = f3.key; d3 !== null; ) {
                  if (d3.key === k3)
                    if (d3.tag === 4 && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a3, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c2(a3, d3);
                      break;
                    }
                  else
                    b2(a3, d3);
                  d3 = d3.sibling;
                }
                d3 = Hd(f3, a3.mode, h3);
                d3.return = a3;
                a3 = d3;
              }
              return g2(a3);
          }
        if (typeof f3 === "string" || typeof f3 === "number")
          return f3 = "" + f3, d3 !== null && d3.tag === 6 ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Fd(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3);
        if (Ad(f3))
          return x2(a3, d3, f3, h3);
        if (va(f3))
          return Y2(a3, d3, f3, h3);
        l3 && Cd(a3, f3);
        if (typeof f3 === "undefined" && !k3)
          switch (a3.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(q2(152, wa(a3.type) || "Component"));
          }
        return c2(a3, d3);
      };
    }
    var Jd = Dd(true), Kd = Dd(false), Ld = {}, L4 = Wb(Ld), Md = Wb(Ld), Nd = Wb(Ld);
    function Od(a2) {
      if (a2 === Ld)
        throw Error(q2(174));
      return a2;
    }
    function Pd(a2, b2) {
      A2(Nd, b2);
      A2(Md, a2);
      A2(L4, Ld);
      a2 = Ea(b2);
      z2(L4);
      A2(L4, a2);
    }
    function Qd() {
      z2(L4);
      z2(Md);
      z2(Nd);
    }
    function Rd(a2) {
      var b2 = Od(Nd.current), c2 = Od(L4.current);
      b2 = Fa(c2, a2.type, b2);
      c2 !== b2 && (A2(Md, a2), A2(L4, b2));
    }
    function Sd(a2) {
      Md.current === a2 && (z2(L4), z2(Md));
    }
    var M2 = Wb(0);
    function Td(a2) {
      for (var b2 = a2; b2 !== null; ) {
        if (b2.tag === 13) {
          var c2 = b2.memoizedState;
          if (c2 !== null && (c2 = c2.dehydrated, c2 === null || Hb(c2) || Ib(c2)))
            return b2;
        } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
          if ((b2.flags & 64) !== 0)
            return b2;
        } else if (b2.child !== null) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a2)
          break;
        for (; b2.sibling === null; ) {
          if (b2.return === null || b2.return === a2)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Ud = null, Vd = null, Wd = false;
    function Xd(a2, b2) {
      var c2 = Yd(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.type = "DELETED";
      c2.stateNode = b2;
      c2.return = a2;
      c2.flags = 8;
      a2.lastEffect !== null ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
    }
    function Zd(a2, b2) {
      switch (a2.tag) {
        case 5:
          return b2 = Fb(b2, a2.type, a2.pendingProps), b2 !== null ? (a2.stateNode = b2, true) : false;
        case 6:
          return b2 = Gb(b2, a2.pendingProps), b2 !== null ? (a2.stateNode = b2, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function $d(a2) {
      if (Wd) {
        var b2 = Vd;
        if (b2) {
          var c2 = b2;
          if (!Zd(a2, b2)) {
            b2 = Jb(c2);
            if (!b2 || !Zd(a2, b2)) {
              a2.flags = a2.flags & -1025 | 2;
              Wd = false;
              Ud = a2;
              return;
            }
            Xd(Ud, c2);
          }
          Ud = a2;
          Vd = Kb(b2);
        } else
          a2.flags = a2.flags & -1025 | 2, Wd = false, Ud = a2;
      }
    }
    function ae2(a2) {
      for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
        a2 = a2.return;
      Ud = a2;
    }
    function be2(a2) {
      if (!Va || a2 !== Ud)
        return false;
      if (!Wd)
        return ae2(a2), Wd = true, false;
      var b2 = a2.type;
      if (a2.tag !== 5 || b2 !== "head" && b2 !== "body" && !Ma(b2, a2.memoizedProps))
        for (b2 = Vd; b2; )
          Xd(a2, b2), b2 = Jb(b2);
      ae2(a2);
      if (a2.tag === 13) {
        if (!Va)
          throw Error(q2(316));
        a2 = a2.memoizedState;
        a2 = a2 !== null ? a2.dehydrated : null;
        if (!a2)
          throw Error(q2(317));
        Vd = Nb(a2);
      } else
        Vd = Ud ? Jb(a2.stateNode) : null;
      return true;
    }
    function ce2() {
      Va && (Vd = Ud = null, Wd = false);
    }
    var de2 = [];
    function ee2() {
      for (var a2 = 0; a2 < de2.length; a2++) {
        var b2 = de2[a2];
        Sa ? b2._workInProgressVersionPrimary = null : b2._workInProgressVersionSecondary = null;
      }
      de2.length = 0;
    }
    var fe2 = ca.ReactCurrentDispatcher, ge2 = ca.ReactCurrentBatchConfig, he2 = 0, N2 = null, O2 = null, P2 = null, ie2 = false, je2 = false;
    function Q2() {
      throw Error(q2(321));
    }
    function ke2(a2, b2) {
      if (b2 === null)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
        if (!I2(a2[c2], b2[c2]))
          return false;
      return true;
    }
    function le2(a2, b2, c2, d2, e2, f2) {
      he2 = f2;
      N2 = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      fe2.current = a2 === null || a2.memoizedState === null ? me2 : ne2;
      a2 = c2(d2, e2);
      if (je2) {
        f2 = 0;
        do {
          je2 = false;
          if (!(25 > f2))
            throw Error(q2(301));
          f2 += 1;
          P2 = O2 = null;
          b2.updateQueue = null;
          fe2.current = oe2;
          a2 = c2(d2, e2);
        } while (je2);
      }
      fe2.current = pe2;
      b2 = O2 !== null && O2.next !== null;
      he2 = 0;
      P2 = O2 = N2 = null;
      ie2 = false;
      if (b2)
        throw Error(q2(300));
      return a2;
    }
    function qe2() {
      var a2 = {memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null};
      P2 === null ? N2.memoizedState = P2 = a2 : P2 = P2.next = a2;
      return P2;
    }
    function re2() {
      if (O2 === null) {
        var a2 = N2.alternate;
        a2 = a2 !== null ? a2.memoizedState : null;
      } else
        a2 = O2.next;
      var b2 = P2 === null ? N2.memoizedState : P2.next;
      if (b2 !== null)
        P2 = b2, O2 = a2;
      else {
        if (a2 === null)
          throw Error(q2(310));
        O2 = a2;
        a2 = {memoizedState: O2.memoizedState, baseState: O2.baseState, baseQueue: O2.baseQueue, queue: O2.queue, next: null};
        P2 === null ? N2.memoizedState = P2 = a2 : P2 = P2.next = a2;
      }
      return P2;
    }
    function se2(a2, b2) {
      return typeof b2 === "function" ? b2(a2) : b2;
    }
    function te2(a2) {
      var b2 = re2(), c2 = b2.queue;
      if (c2 === null)
        throw Error(q2(311));
      c2.lastRenderedReducer = a2;
      var d2 = O2, e2 = d2.baseQueue, f2 = c2.pending;
      if (f2 !== null) {
        if (e2 !== null) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (e2 !== null) {
        e2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = f2 = null, k2 = e2;
        do {
          var l2 = k2.lane;
          if ((he2 & l2) === l2)
            h2 !== null && (h2 = h2.next = {lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null}), d2 = k2.eagerReducer === a2 ? k2.eagerState : a2(d2, k2.action);
          else {
            var n2 = {
              lane: l2,
              action: k2.action,
              eagerReducer: k2.eagerReducer,
              eagerState: k2.eagerState,
              next: null
            };
            h2 === null ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
            N2.lanes |= l2;
            pd |= l2;
          }
          k2 = k2.next;
        } while (k2 !== null && k2 !== e2);
        h2 === null ? f2 = d2 : h2.next = g2;
        I2(d2, b2.memoizedState) || (gd = true);
        b2.memoizedState = d2;
        b2.baseState = f2;
        b2.baseQueue = h2;
        c2.lastRenderedState = d2;
      }
      return [b2.memoizedState, c2.dispatch];
    }
    function ue2(a2) {
      var b2 = re2(), c2 = b2.queue;
      if (c2 === null)
        throw Error(q2(311));
      c2.lastRenderedReducer = a2;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (e2 !== null) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        I2(f2, b2.memoizedState) || (gd = true);
        b2.memoizedState = f2;
        b2.baseQueue === null && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function ve2(a2, b2, c2) {
      var d2 = b2._getVersion;
      d2 = d2(b2._source);
      var e2 = Sa ? b2._workInProgressVersionPrimary : b2._workInProgressVersionSecondary;
      if (e2 !== null)
        a2 = e2 === d2;
      else if (a2 = a2.mutableReadLanes, a2 = (he2 & a2) === a2)
        Sa ? b2._workInProgressVersionPrimary = d2 : b2._workInProgressVersionSecondary = d2, de2.push(b2);
      if (a2)
        return c2(b2._source);
      de2.push(b2);
      throw Error(q2(350));
    }
    function we2(a2, b2, c2, d2) {
      var e2 = R2;
      if (e2 === null)
        throw Error(q2(349));
      var f2 = b2._getVersion, g2 = f2(b2._source), h2 = fe2.current, k2 = h2.useState(function() {
        return ve2(e2, b2, c2);
      }), l2 = k2[1], n2 = k2[0];
      k2 = P2;
      var t2 = a2.memoizedState, p2 = t2.refs, y2 = p2.getSnapshot, x2 = t2.source;
      t2 = t2.subscribe;
      var Y2 = N2;
      a2.memoizedState = {refs: p2, source: b2, subscribe: d2};
      h2.useEffect(function() {
        p2.getSnapshot = c2;
        p2.setSnapshot = l2;
        var a3 = f2(b2._source);
        if (!I2(g2, a3)) {
          a3 = c2(b2._source);
          I2(n2, a3) || (l2(a3), a3 = td(Y2), e2.mutableReadLanes |= a3 & e2.pendingLanes);
          a3 = e2.mutableReadLanes;
          e2.entangledLanes |= a3;
          for (var d3 = e2.entanglements, h3 = a3; 0 < h3; ) {
            var k3 = 31 - mc(h3), t3 = 1 << k3;
            d3[k3] |= a3;
            h3 &= ~t3;
          }
        }
      }, [c2, b2, d2]);
      h2.useEffect(function() {
        return d2(b2._source, function() {
          var a3 = p2.getSnapshot, c3 = p2.setSnapshot;
          try {
            c3(a3(b2._source));
            var d3 = td(Y2);
            e2.mutableReadLanes |= d3 & e2.pendingLanes;
          } catch (Oa) {
            c3(function() {
              throw Oa;
            });
          }
        });
      }, [b2, d2]);
      I2(y2, c2) && I2(x2, b2) && I2(t2, d2) || (a2 = {pending: null, dispatch: null, lastRenderedReducer: se2, lastRenderedState: n2}, a2.dispatch = l2 = xe2.bind(null, N2, a2), k2.queue = a2, k2.baseQueue = null, n2 = ve2(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
      return n2;
    }
    function ye2(a2, b2, c2) {
      var d2 = re2();
      return we2(d2, a2, b2, c2);
    }
    function ze2(a2) {
      var b2 = qe2();
      typeof a2 === "function" && (a2 = a2());
      b2.memoizedState = b2.baseState = a2;
      a2 = b2.queue = {pending: null, dispatch: null, lastRenderedReducer: se2, lastRenderedState: a2};
      a2 = a2.dispatch = xe2.bind(null, N2, a2);
      return [b2.memoizedState, a2];
    }
    function Ae2(a2, b2, c2, d2) {
      a2 = {tag: a2, create: b2, destroy: c2, deps: d2, next: null};
      b2 = N2.updateQueue;
      b2 === null ? (b2 = {lastEffect: null}, N2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, c2 === null ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
      return a2;
    }
    function Be2(a2) {
      var b2 = qe2();
      a2 = {current: a2};
      return b2.memoizedState = a2;
    }
    function Ce2() {
      return re2().memoizedState;
    }
    function De2(a2, b2, c2, d2) {
      var e2 = qe2();
      N2.flags |= a2;
      e2.memoizedState = Ae2(1 | b2, c2, void 0, d2 === void 0 ? null : d2);
    }
    function Ee2(a2, b2, c2, d2) {
      var e2 = re2();
      d2 = d2 === void 0 ? null : d2;
      var f2 = void 0;
      if (O2 !== null) {
        var g2 = O2.memoizedState;
        f2 = g2.destroy;
        if (d2 !== null && ke2(d2, g2.deps)) {
          Ae2(b2, c2, f2, d2);
          return;
        }
      }
      N2.flags |= a2;
      e2.memoizedState = Ae2(1 | b2, c2, f2, d2);
    }
    function Fe2(a2, b2) {
      return De2(516, 4, a2, b2);
    }
    function Ge2(a2, b2) {
      return Ee2(516, 4, a2, b2);
    }
    function He2(a2, b2) {
      return Ee2(4, 2, a2, b2);
    }
    function Ie2(a2, b2) {
      if (typeof b2 === "function")
        return a2 = a2(), b2(a2), function() {
          b2(null);
        };
      if (b2 !== null && b2 !== void 0)
        return a2 = a2(), b2.current = a2, function() {
          b2.current = null;
        };
    }
    function Je2(a2, b2, c2) {
      c2 = c2 !== null && c2 !== void 0 ? c2.concat([a2]) : null;
      return Ee2(4, 2, Ie2.bind(null, b2, a2), c2);
    }
    function Ke2() {
    }
    function Le2(a2, b2) {
      var c2 = re2();
      b2 = b2 === void 0 ? null : b2;
      var d2 = c2.memoizedState;
      if (d2 !== null && b2 !== null && ke2(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Me2(a2, b2) {
      var c2 = re2();
      b2 = b2 === void 0 ? null : b2;
      var d2 = c2.memoizedState;
      if (d2 !== null && b2 !== null && ke2(b2, d2[1]))
        return d2[0];
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Ne2(a2, b2) {
      var c2 = Nc();
      Pc(98 > c2 ? 98 : c2, function() {
        a2(true);
      });
      Pc(97 < c2 ? 97 : c2, function() {
        var c3 = ge2.transition;
        ge2.transition = 1;
        try {
          a2(false), b2();
        } finally {
          ge2.transition = c3;
        }
      });
    }
    function xe2(a2, b2, c2) {
      var d2 = K2(), e2 = td(a2), f2 = {lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null}, g2 = b2.pending;
      g2 === null ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
      b2.pending = f2;
      g2 = a2.alternate;
      if (a2 === N2 || g2 !== null && g2 === N2)
        je2 = ie2 = true;
      else {
        if (a2.lanes === 0 && (g2 === null || g2.lanes === 0) && (g2 = b2.lastRenderedReducer, g2 !== null))
          try {
            var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
            f2.eagerReducer = g2;
            f2.eagerState = k2;
            if (I2(k2, h2))
              return;
          } catch (l2) {
          } finally {
          }
        ud(a2, e2, d2);
      }
    }
    var pe2 = {readContext: J2, useCallback: Q2, useContext: Q2, useEffect: Q2, useImperativeHandle: Q2, useLayoutEffect: Q2, useMemo: Q2, useReducer: Q2, useRef: Q2, useState: Q2, useDebugValue: Q2, useDeferredValue: Q2, useTransition: Q2, useMutableSource: Q2, useOpaqueIdentifier: Q2, unstable_isNewReconciler: false}, me2 = {readContext: J2, useCallback: function(a2, b2) {
      qe2().memoizedState = [a2, b2 === void 0 ? null : b2];
      return a2;
    }, useContext: J2, useEffect: Fe2, useImperativeHandle: function(a2, b2, c2) {
      c2 = c2 !== null && c2 !== void 0 ? c2.concat([a2]) : null;
      return De2(4, 2, Ie2.bind(null, b2, a2), c2);
    }, useLayoutEffect: function(a2, b2) {
      return De2(4, 2, a2, b2);
    }, useMemo: function(a2, b2) {
      var c2 = qe2();
      b2 = b2 === void 0 ? null : b2;
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }, useReducer: function(a2, b2, c2) {
      var d2 = qe2();
      b2 = c2 !== void 0 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a2 = d2.queue = {pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2};
      a2 = a2.dispatch = xe2.bind(null, N2, a2);
      return [d2.memoizedState, a2];
    }, useRef: Be2, useState: ze2, useDebugValue: Ke2, useDeferredValue: function(a2) {
      var b2 = ze2(a2), c2 = b2[0], d2 = b2[1];
      Fe2(function() {
        var b3 = ge2.transition;
        ge2.transition = 1;
        try {
          d2(a2);
        } finally {
          ge2.transition = b3;
        }
      }, [a2]);
      return c2;
    }, useTransition: function() {
      var a2 = ze2(false), b2 = a2[0];
      a2 = Ne2.bind(null, a2[1]);
      Be2(a2);
      return [a2, b2];
    }, useMutableSource: function(a2, b2, c2) {
      var d2 = qe2();
      d2.memoizedState = {refs: {getSnapshot: b2, setSnapshot: null}, source: a2, subscribe: c2};
      return we2(d2, a2, b2, c2);
    }, useOpaqueIdentifier: function() {
      if (Wd) {
        var a2 = false, b2 = Xa(function() {
          a2 || (a2 = true, c2(Ya()));
          throw Error(q2(355));
        }), c2 = ze2(b2)[1];
        (N2.mode & 2) === 0 && (N2.flags |= 516, Ae2(5, function() {
          c2(Ya());
        }, void 0, null));
        return b2;
      }
      b2 = Ya();
      ze2(b2);
      return b2;
    }, unstable_isNewReconciler: false}, ne2 = {
      readContext: J2,
      useCallback: Le2,
      useContext: J2,
      useEffect: Ge2,
      useImperativeHandle: Je2,
      useLayoutEffect: He2,
      useMemo: Me2,
      useReducer: te2,
      useRef: Ce2,
      useState: function() {
        return te2(se2);
      },
      useDebugValue: Ke2,
      useDeferredValue: function(a2) {
        var b2 = te2(se2), c2 = b2[0], d2 = b2[1];
        Ge2(function() {
          var b3 = ge2.transition;
          ge2.transition = 1;
          try {
            d2(a2);
          } finally {
            ge2.transition = b3;
          }
        }, [a2]);
        return c2;
      },
      useTransition: function() {
        var a2 = te2(se2)[0];
        return [Ce2().current, a2];
      },
      useMutableSource: ye2,
      useOpaqueIdentifier: function() {
        return te2(se2)[0];
      },
      unstable_isNewReconciler: false
    }, oe2 = {
      readContext: J2,
      useCallback: Le2,
      useContext: J2,
      useEffect: Ge2,
      useImperativeHandle: Je2,
      useLayoutEffect: He2,
      useMemo: Me2,
      useReducer: ue2,
      useRef: Ce2,
      useState: function() {
        return ue2(se2);
      },
      useDebugValue: Ke2,
      useDeferredValue: function(a2) {
        var b2 = ue2(se2), c2 = b2[0], d2 = b2[1];
        Ge2(function() {
          var b3 = ge2.transition;
          ge2.transition = 1;
          try {
            d2(a2);
          } finally {
            ge2.transition = b3;
          }
        }, [a2]);
        return c2;
      },
      useTransition: function() {
        var a2 = ue2(se2)[0];
        return [Ce2().current, a2];
      },
      useMutableSource: ye2,
      useOpaqueIdentifier: function() {
        return ue2(se2)[0];
      },
      unstable_isNewReconciler: false
    }, Oe2 = ca.ReactCurrentOwner, gd = false;
    function S2(a2, b2, c2, d2) {
      b2.child = a2 === null ? Kd(b2, null, c2, d2) : Jd(b2, a2.child, c2, d2);
    }
    function Pe2(a2, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      fd(b2, e2);
      d2 = le2(a2, b2, c2, d2, f2, e2);
      if (a2 !== null && !gd)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, Re2(a2, b2, e2);
      b2.flags |= 1;
      S2(a2, b2, d2, e2);
      return b2.child;
    }
    function Se2(a2, b2, c2, d2, e2, f2) {
      if (a2 === null) {
        var g2 = c2.type;
        if (typeof g2 === "function" && !Te2(g2) && g2.defaultProps === void 0 && c2.compare === null && c2.defaultProps === void 0)
          return b2.tag = 15, b2.type = g2, Ue2(a2, b2, g2, d2, e2, f2);
        a2 = Gd(c2.type, null, d2, b2, b2.mode, f2);
        a2.ref = b2.ref;
        a2.return = b2;
        return b2.child = a2;
      }
      g2 = a2.child;
      if ((e2 & f2) === 0 && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = c2 !== null ? c2 : Vc, c2(e2, d2) && a2.ref === b2.ref))
        return Re2(a2, b2, f2);
      b2.flags |= 1;
      a2 = Ed(g2, d2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    function Ue2(a2, b2, c2, d2, e2, f2) {
      if (a2 !== null && Vc(a2.memoizedProps, d2) && a2.ref === b2.ref)
        if (gd = false, (f2 & e2) !== 0)
          (a2.flags & 16384) !== 0 && (gd = true);
        else
          return b2.lanes = a2.lanes, Re2(a2, b2, f2);
      return Ve2(a2, b2, c2, d2, f2);
    }
    function We2(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = a2 !== null ? a2.memoizedState : null;
      if (d2.mode === "hidden" || d2.mode === "unstable-defer-without-hiding")
        if ((b2.mode & 4) === 0)
          b2.memoizedState = {baseLanes: 0}, Xe2(b2, c2);
        else if ((c2 & 1073741824) !== 0)
          b2.memoizedState = {baseLanes: 0}, Xe2(b2, f2 !== null ? f2.baseLanes : c2);
        else
          return a2 = f2 !== null ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = {baseLanes: a2}, Xe2(b2, a2), null;
      else
        f2 !== null ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, Xe2(b2, d2);
      S2(a2, b2, e2, c2);
      return b2.child;
    }
    function Ye2(a2, b2) {
      var c2 = b2.ref;
      if (a2 === null && c2 !== null || a2 !== null && a2.ref !== c2)
        b2.flags |= 128;
    }
    function Ve2(a2, b2, c2, d2, e2) {
      var f2 = E2(c2) ? Yb : B2.current;
      f2 = Zb(b2, f2);
      fd(b2, e2);
      c2 = le2(a2, b2, c2, d2, f2, e2);
      if (a2 !== null && !gd)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, Re2(a2, b2, e2);
      b2.flags |= 1;
      S2(a2, b2, c2, e2);
      return b2.child;
    }
    function Ze2(a2, b2, c2, d2, e2) {
      if (E2(c2)) {
        var f2 = true;
        cc(b2);
      } else
        f2 = false;
      fd(b2, e2);
      if (b2.stateNode === null)
        a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), xd(b2, c2, d2), zd(b2, c2, d2, e2), d2 = true;
      else if (a2 === null) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        typeof l2 === "object" && l2 !== null ? l2 = J2(l2) : (l2 = E2(c2) ? Yb : B2.current, l2 = Zb(b2, l2));
        var n2 = c2.getDerivedStateFromProps, t2 = typeof n2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function";
        t2 || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== d2 || k2 !== l2) && yd(b2, g2, d2, l2);
        hd = false;
        var p2 = b2.memoizedState;
        g2.state = p2;
        od(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || p2 !== k2 || D2.current || hd ? (typeof n2 === "function" && (sd(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = hd || wd(b2, c2, h2, d2, p2, k2, l2)) ? (t2 || typeof g2.UNSAFE_componentWillMount !== "function" && typeof g2.componentWillMount !== "function" || (typeof g2.componentWillMount === "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount === "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount === "function" && (b2.flags |= 4)) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : (typeof g2.componentDidMount === "function" && (b2.flags |= 4), d2 = false);
      } else {
        g2 = b2.stateNode;
        jd(a2, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Xc(b2.type, h2);
        g2.props = l2;
        t2 = b2.pendingProps;
        p2 = g2.context;
        k2 = c2.contextType;
        typeof k2 === "object" && k2 !== null ? k2 = J2(k2) : (k2 = E2(c2) ? Yb : B2.current, k2 = Zb(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (n2 = typeof y2 === "function" || typeof g2.getSnapshotBeforeUpdate === "function") || typeof g2.UNSAFE_componentWillReceiveProps !== "function" && typeof g2.componentWillReceiveProps !== "function" || (h2 !== t2 || p2 !== k2) && yd(b2, g2, d2, k2);
        hd = false;
        p2 = b2.memoizedState;
        g2.state = p2;
        od(b2, d2, g2, e2);
        var x2 = b2.memoizedState;
        h2 !== t2 || p2 !== x2 || D2.current || hd ? (typeof y2 === "function" && (sd(b2, c2, y2, d2), x2 = b2.memoizedState), (l2 = hd || wd(b2, c2, l2, d2, p2, x2, k2)) ? (n2 || typeof g2.UNSAFE_componentWillUpdate !== "function" && typeof g2.componentWillUpdate !== "function" || (typeof g2.componentWillUpdate === "function" && g2.componentWillUpdate(d2, x2, k2), typeof g2.UNSAFE_componentWillUpdate === "function" && g2.UNSAFE_componentWillUpdate(d2, x2, k2)), typeof g2.componentDidUpdate === "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate === "function" && (b2.flags |= 256)) : (typeof g2.componentDidUpdate !== "function" || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x2), g2.props = d2, g2.state = x2, g2.context = k2, d2 = l2) : (typeof g2.componentDidUpdate !== "function" || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate !== "function" || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), d2 = false);
      }
      return $e2(a2, b2, c2, d2, f2, e2);
    }
    function $e2(a2, b2, c2, d2, e2, f2) {
      Ye2(a2, b2);
      var g2 = (b2.flags & 64) !== 0;
      if (!d2 && !g2)
        return e2 && dc(b2, c2, false), Re2(a2, b2, f2);
      d2 = b2.stateNode;
      Oe2.current = b2;
      var h2 = g2 && typeof c2.getDerivedStateFromError !== "function" ? null : d2.render();
      b2.flags |= 1;
      a2 !== null && g2 ? (b2.child = Jd(b2, a2.child, null, f2), b2.child = Jd(b2, null, h2, f2)) : S2(a2, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dc(b2, c2, true);
      return b2.child;
    }
    function af(a2) {
      var b2 = a2.stateNode;
      b2.pendingContext ? ac(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ac(a2, b2.context, false);
      Pd(a2, b2.containerInfo);
    }
    var bf = {dehydrated: null, retryLane: 0};
    function cf(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = M2.current, f2 = false, g2;
      (g2 = (b2.flags & 64) !== 0) || (g2 = a2 !== null && a2.memoizedState === null ? false : (e2 & 2) !== 0);
      g2 ? (f2 = true, b2.flags &= -65) : a2 !== null && a2.memoizedState === null || d2.fallback === void 0 || d2.unstable_avoidThisFallback === true || (e2 |= 1);
      A2(M2, e2 & 1);
      if (a2 === null) {
        d2.fallback !== void 0 && $d(b2);
        a2 = d2.children;
        e2 = d2.fallback;
        if (f2)
          return a2 = df(b2, a2, e2, c2), b2.child.memoizedState = {baseLanes: c2}, b2.memoizedState = bf, a2;
        if (typeof d2.unstable_expectedLoadTime === "number")
          return a2 = df(b2, a2, e2, c2), b2.child.memoizedState = {baseLanes: c2}, b2.memoizedState = bf, b2.lanes = 33554432, a2;
        c2 = ef({mode: "visible", children: a2}, b2.mode, c2, null);
        c2.return = b2;
        return b2.child = c2;
      }
      if (a2.memoizedState !== null) {
        if (f2)
          return d2 = ff(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = e2 === null ? {baseLanes: c2} : {baseLanes: e2.baseLanes | c2}, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = bf, d2;
        c2 = gf(a2, b2, d2.children, c2);
        b2.memoizedState = null;
        return c2;
      }
      if (f2)
        return d2 = ff(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = e2 === null ? {baseLanes: c2} : {baseLanes: e2.baseLanes | c2}, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = bf, d2;
      c2 = gf(a2, b2, d2.children, c2);
      b2.memoizedState = null;
      return c2;
    }
    function df(a2, b2, c2, d2) {
      var e2 = a2.mode, f2 = a2.child;
      b2 = {mode: "hidden", children: b2};
      (e2 & 2) === 0 && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = ef(b2, e2, 0, null);
      c2 = Id(c2, e2, d2, null);
      f2.return = a2;
      c2.return = a2;
      f2.sibling = c2;
      a2.child = f2;
      return c2;
    }
    function gf(a2, b2, c2, d2) {
      var e2 = a2.child;
      a2 = e2.sibling;
      c2 = Ed(e2, {mode: "visible", children: c2});
      (b2.mode & 2) === 0 && (c2.lanes = d2);
      c2.return = b2;
      c2.sibling = null;
      a2 !== null && (a2.nextEffect = null, a2.flags = 8, b2.firstEffect = b2.lastEffect = a2);
      return b2.child = c2;
    }
    function ff(a2, b2, c2, d2, e2) {
      var f2 = b2.mode, g2 = a2.child;
      a2 = g2.sibling;
      var h2 = {mode: "hidden", children: c2};
      (f2 & 2) === 0 && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, g2 !== null ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Ed(g2, h2);
      a2 !== null ? d2 = Ed(a2, d2) : (d2 = Id(d2, f2, e2, null), d2.flags |= 2);
      d2.return = b2;
      c2.return = b2;
      c2.sibling = d2;
      b2.child = c2;
      return d2;
    }
    function hf(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      c2 !== null && (c2.lanes |= b2);
      ed(a2.return, b2);
    }
    function jf(a2, b2, c2, d2, e2, f2) {
      var g2 = a2.memoizedState;
      g2 === null ? a2.memoizedState = {isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2} : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
    }
    function kf(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      S2(a2, b2, d2.children, c2);
      d2 = M2.current;
      if ((d2 & 2) !== 0)
        d2 = d2 & 1 | 2, b2.flags |= 64;
      else {
        if (a2 !== null && (a2.flags & 64) !== 0)
          a:
            for (a2 = b2.child; a2 !== null; ) {
              if (a2.tag === 13)
                a2.memoizedState !== null && hf(a2, c2);
              else if (a2.tag === 19)
                hf(a2, c2);
              else if (a2.child !== null) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b2)
                break a;
              for (; a2.sibling === null; ) {
                if (a2.return === null || a2.return === b2)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d2 &= 1;
      }
      A2(M2, d2);
      if ((b2.mode & 2) === 0)
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; c2 !== null; )
              a2 = c2.alternate, a2 !== null && Td(a2) === null && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            c2 === null ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            jf(b2, false, e2, c2, f2, b2.lastEffect);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; e2 !== null; ) {
              a2 = e2.alternate;
              if (a2 !== null && Td(a2) === null) {
                b2.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            jf(b2, true, c2, null, f2, b2.lastEffect);
            break;
          case "together":
            jf(b2, false, null, null, void 0, b2.lastEffect);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function Re2(a2, b2, c2) {
      a2 !== null && (b2.dependencies = a2.dependencies);
      pd |= b2.lanes;
      if ((c2 & b2.childLanes) !== 0) {
        if (a2 !== null && b2.child !== a2.child)
          throw Error(q2(153));
        if (b2.child !== null) {
          a2 = b2.child;
          c2 = Ed(a2, a2.pendingProps);
          b2.child = c2;
          for (c2.return = b2; a2.sibling !== null; )
            a2 = a2.sibling, c2 = c2.sibling = Ed(a2, a2.pendingProps), c2.return = b2;
          c2.sibling = null;
        }
        return b2.child;
      }
      return null;
    }
    function lf(a2) {
      a2.flags |= 4;
    }
    var mf, nf, of, pf;
    if (Ta)
      mf = function(a2, b2) {
        for (var c2 = b2.child; c2 !== null; ) {
          if (c2.tag === 5 || c2.tag === 6)
            Ja(a2, c2.stateNode);
          else if (c2.tag !== 4 && c2.child !== null) {
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
          if (c2 === b2)
            break;
          for (; c2.sibling === null; ) {
            if (c2.return === null || c2.return === b2)
              return;
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          c2 = c2.sibling;
        }
      }, nf = function() {
      }, of = function(a2, b2, c2, d2, e2) {
        a2 = a2.memoizedProps;
        if (a2 !== d2) {
          var f2 = b2.stateNode, g2 = Od(L4.current);
          c2 = La(f2, c2, a2, d2, e2, g2);
          (b2.updateQueue = c2) && lf(b2);
        }
      }, pf = function(a2, b2, c2, d2) {
        c2 !== d2 && lf(b2);
      };
    else if (Ua) {
      mf = function(a2, b2, c2, d2) {
        for (var e2 = b2.child; e2 !== null; ) {
          if (e2.tag === 5) {
            var f2 = e2.stateNode;
            c2 && d2 && (f2 = Db(f2, e2.type, e2.memoizedProps, e2));
            Ja(a2, f2);
          } else if (e2.tag === 6)
            f2 = e2.stateNode, c2 && d2 && (f2 = Eb(f2, e2.memoizedProps, e2)), Ja(a2, f2);
          else if (e2.tag !== 4) {
            if (e2.tag === 13 && (e2.flags & 4) !== 0 && (f2 = e2.memoizedState !== null)) {
              var g2 = e2.child;
              if (g2 !== null && (g2.child !== null && (g2.child.return = g2, mf(a2, g2, true, f2)), f2 = g2.sibling, f2 !== null)) {
                f2.return = e2;
                e2 = f2;
                continue;
              }
            }
            if (e2.child !== null) {
              e2.child.return = e2;
              e2 = e2.child;
              continue;
            }
          }
          if (e2 === b2)
            break;
          for (; e2.sibling === null; ) {
            if (e2.return === null || e2.return === b2)
              return;
            e2 = e2.return;
          }
          e2.sibling.return = e2.return;
          e2 = e2.sibling;
        }
      };
      var qf = function(a2, b2, c2, d2) {
        for (var e2 = b2.child; e2 !== null; ) {
          if (e2.tag === 5) {
            var f2 = e2.stateNode;
            c2 && d2 && (f2 = Db(f2, e2.type, e2.memoizedProps, e2));
            Ab(a2, f2);
          } else if (e2.tag === 6)
            f2 = e2.stateNode, c2 && d2 && (f2 = Eb(f2, e2.memoizedProps, e2)), Ab(a2, f2);
          else if (e2.tag !== 4) {
            if (e2.tag === 13 && (e2.flags & 4) !== 0 && (f2 = e2.memoizedState !== null)) {
              var g2 = e2.child;
              if (g2 !== null && (g2.child !== null && (g2.child.return = g2, qf(a2, g2, true, f2)), f2 = g2.sibling, f2 !== null)) {
                f2.return = e2;
                e2 = f2;
                continue;
              }
            }
            if (e2.child !== null) {
              e2.child.return = e2;
              e2 = e2.child;
              continue;
            }
          }
          if (e2 === b2)
            break;
          for (; e2.sibling === null; ) {
            if (e2.return === null || e2.return === b2)
              return;
            e2 = e2.return;
          }
          e2.sibling.return = e2.return;
          e2 = e2.sibling;
        }
      };
      nf = function(a2) {
        var b2 = a2.stateNode;
        if (a2.firstEffect !== null) {
          var c2 = b2.containerInfo, d2 = zb(c2);
          qf(d2, a2, false, false);
          b2.pendingChildren = d2;
          lf(a2);
          Bb(c2, d2);
        }
      };
      of = function(a2, b2, c2, d2, e2) {
        var f2 = a2.stateNode, g2 = a2.memoizedProps;
        if ((a2 = b2.firstEffect === null) && g2 === d2)
          b2.stateNode = f2;
        else {
          var h2 = b2.stateNode, k2 = Od(L4.current), l2 = null;
          g2 !== d2 && (l2 = La(h2, c2, g2, d2, e2, k2));
          a2 && l2 === null ? b2.stateNode = f2 : (f2 = yb(f2, l2, c2, g2, d2, b2, a2, h2), Ka(f2, c2, d2, e2, k2) && lf(b2), b2.stateNode = f2, a2 ? lf(b2) : mf(f2, b2, false, false));
        }
      };
      pf = function(a2, b2, c2, d2) {
        c2 !== d2 ? (a2 = Od(Nd.current), c2 = Od(L4.current), b2.stateNode = Na(d2, a2, c2, b2), lf(b2)) : b2.stateNode = a2.stateNode;
      };
    } else
      nf = function() {
      }, of = function() {
      }, pf = function() {
      };
    function rf(a2, b2) {
      if (!Wd)
        switch (a2.tailMode) {
          case "hidden":
            b2 = a2.tail;
            for (var c2 = null; b2 !== null; )
              b2.alternate !== null && (c2 = b2), b2 = b2.sibling;
            c2 === null ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d2 = null; c2 !== null; )
              c2.alternate !== null && (d2 = c2), c2 = c2.sibling;
            d2 === null ? b2 || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
    }
    function sf(a2, b2, c2) {
      var d2 = b2.pendingProps;
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return E2(b2.type) && $b(), null;
        case 3:
          Qd();
          z2(D2);
          z2(B2);
          ee2();
          d2 = b2.stateNode;
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (a2 === null || a2.child === null)
            be2(b2) ? lf(b2) : d2.hydrate || (b2.flags |= 256);
          nf(b2);
          return null;
        case 5:
          Sd(b2);
          var e2 = Od(Nd.current);
          c2 = b2.type;
          if (a2 !== null && b2.stateNode != null)
            of(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 128);
          else {
            if (!d2) {
              if (b2.stateNode === null)
                throw Error(q2(166));
              return null;
            }
            a2 = Od(L4.current);
            if (be2(b2)) {
              if (!Va)
                throw Error(q2(175));
              a2 = Lb(b2.stateNode, b2.type, b2.memoizedProps, e2, a2, b2);
              b2.updateQueue = a2;
              a2 !== null && lf(b2);
            } else {
              var f2 = Ia(c2, d2, e2, a2, b2);
              mf(f2, b2, false, false);
              b2.stateNode = f2;
              Ka(f2, c2, d2, e2, a2) && lf(b2);
            }
            b2.ref !== null && (b2.flags |= 128);
          }
          return null;
        case 6:
          if (a2 && b2.stateNode != null)
            pf(a2, b2, a2.memoizedProps, d2);
          else {
            if (typeof d2 !== "string" && b2.stateNode === null)
              throw Error(q2(166));
            a2 = Od(Nd.current);
            e2 = Od(L4.current);
            if (be2(b2)) {
              if (!Va)
                throw Error(q2(176));
              Mb(b2.stateNode, b2.memoizedProps, b2) && lf(b2);
            } else
              b2.stateNode = Na(d2, a2, e2, b2);
          }
          return null;
        case 13:
          z2(M2);
          d2 = b2.memoizedState;
          if ((b2.flags & 64) !== 0)
            return b2.lanes = c2, b2;
          d2 = d2 !== null;
          e2 = false;
          a2 === null ? b2.memoizedProps.fallback !== void 0 && be2(b2) : e2 = a2.memoizedState !== null;
          if (d2 && !e2 && (b2.mode & 2) !== 0)
            if (a2 === null && b2.memoizedProps.unstable_avoidThisFallback !== true || (M2.current & 1) !== 0)
              T2 === 0 && (T2 = 3);
            else {
              if (T2 === 0 || T2 === 3)
                T2 = 4;
              R2 === null || (pd & 134217727) === 0 && (tf & 134217727) === 0 || uf(R2, U2);
            }
          Ua && d2 && (b2.flags |= 4);
          Ta && (d2 || e2) && (b2.flags |= 4);
          return null;
        case 4:
          return Qd(), nf(b2), a2 === null && ab(b2.stateNode.containerInfo), null;
        case 10:
          return dd(b2), null;
        case 17:
          return E2(b2.type) && $b(), null;
        case 19:
          z2(M2);
          d2 = b2.memoizedState;
          if (d2 === null)
            return null;
          e2 = (b2.flags & 64) !== 0;
          f2 = d2.rendering;
          if (f2 === null)
            if (e2)
              rf(d2, false);
            else {
              if (T2 !== 0 || a2 !== null && (a2.flags & 64) !== 0)
                for (a2 = b2.child; a2 !== null; ) {
                  f2 = Td(a2);
                  if (f2 !== null) {
                    b2.flags |= 64;
                    rf(d2, false);
                    a2 = f2.updateQueue;
                    a2 !== null && (b2.updateQueue = a2, b2.flags |= 4);
                    d2.lastEffect === null && (b2.firstEffect = null);
                    b2.lastEffect = d2.lastEffect;
                    a2 = c2;
                    for (d2 = b2.child; d2 !== null; )
                      e2 = d2, c2 = a2, e2.flags &= 2, e2.nextEffect = null, e2.firstEffect = null, e2.lastEffect = null, f2 = e2.alternate, f2 === null ? (e2.childLanes = 0, e2.lanes = c2, e2.child = null, e2.memoizedProps = null, e2.memoizedState = null, e2.updateQueue = null, e2.dependencies = null, e2.stateNode = null) : (e2.childLanes = f2.childLanes, e2.lanes = f2.lanes, e2.child = f2.child, e2.memoizedProps = f2.memoizedProps, e2.memoizedState = f2.memoizedState, e2.updateQueue = f2.updateQueue, e2.type = f2.type, c2 = f2.dependencies, e2.dependencies = c2 === null ? null : {lanes: c2.lanes, firstContext: c2.firstContext}), d2 = d2.sibling;
                    A2(M2, M2.current & 1 | 2);
                    return b2.child;
                  }
                  a2 = a2.sibling;
                }
              d2.tail !== null && G2() > vf && (b2.flags |= 64, e2 = true, rf(d2, false), b2.lanes = 33554432);
            }
          else {
            if (!e2)
              if (a2 = Td(f2), a2 !== null) {
                if (b2.flags |= 64, e2 = true, a2 = a2.updateQueue, a2 !== null && (b2.updateQueue = a2, b2.flags |= 4), rf(d2, true), d2.tail === null && d2.tailMode === "hidden" && !f2.alternate && !Wd)
                  return b2 = b2.lastEffect = d2.lastEffect, b2 !== null && (b2.nextEffect = null), null;
              } else
                2 * G2() - d2.renderingStartTime > vf && c2 !== 1073741824 && (b2.flags |= 64, e2 = true, rf(d2, false), b2.lanes = 33554432);
            d2.isBackwards ? (f2.sibling = b2.child, b2.child = f2) : (a2 = d2.last, a2 !== null ? a2.sibling = f2 : b2.child = f2, d2.last = f2);
          }
          return d2.tail !== null ? (a2 = d2.tail, d2.rendering = a2, d2.tail = a2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = G2(), a2.sibling = null, b2 = M2.current, A2(M2, e2 ? b2 & 1 | 2 : b2 & 1), a2) : null;
        case 23:
        case 24:
          return wf(), a2 !== null && a2.memoizedState !== null !== (b2.memoizedState !== null) && d2.mode !== "unstable-defer-without-hiding" && (b2.flags |= 4), null;
      }
      throw Error(q2(156, b2.tag));
    }
    function xf(a2) {
      switch (a2.tag) {
        case 1:
          E2(a2.type) && $b();
          var b2 = a2.flags;
          return b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
        case 3:
          Qd();
          z2(D2);
          z2(B2);
          ee2();
          b2 = a2.flags;
          if ((b2 & 64) !== 0)
            throw Error(q2(285));
          a2.flags = b2 & -4097 | 64;
          return a2;
        case 5:
          return Sd(a2), null;
        case 13:
          return z2(M2), b2 = a2.flags, b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
        case 19:
          return z2(M2), null;
        case 4:
          return Qd(), null;
        case 10:
          return dd(a2), null;
        case 23:
        case 24:
          return wf(), null;
        default:
          return null;
      }
    }
    function yf(a2, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Wc(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return {value: a2, source: b2, stack: e2};
    }
    function zf(a2, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Af = typeof WeakMap === "function" ? WeakMap : Map;
    function Bf(a2, b2, c2) {
      c2 = kd(-1, c2);
      c2.tag = 3;
      c2.payload = {element: null};
      var d2 = b2.value;
      c2.callback = function() {
        Cf || (Cf = true, Df = d2);
        zf(a2, b2);
      };
      return c2;
    }
    function Ef(a2, b2, c2) {
      c2 = kd(-1, c2);
      c2.tag = 3;
      var d2 = a2.type.getDerivedStateFromError;
      if (typeof d2 === "function") {
        var e2 = b2.value;
        c2.payload = function() {
          zf(a2, b2);
          return d2(e2);
        };
      }
      var f2 = a2.stateNode;
      f2 !== null && typeof f2.componentDidCatch === "function" && (c2.callback = function() {
        typeof d2 !== "function" && (Ff === null ? Ff = new Set([this]) : Ff.add(this), zf(a2, b2));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, {componentStack: c3 !== null ? c3 : ""});
      });
      return c2;
    }
    var Gf = typeof WeakSet === "function" ? WeakSet : Set;
    function Hf(a2) {
      var b2 = a2.ref;
      if (b2 !== null)
        if (typeof b2 === "function")
          try {
            b2(null);
          } catch (c2) {
            If(a2, c2);
          }
        else
          b2.current = null;
    }
    function Jf(a2, b2) {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b2.flags & 256 && a2 !== null) {
            var c2 = a2.memoizedProps, d2 = a2.memoizedState;
            a2 = b2.stateNode;
            b2 = a2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : Xc(b2.type, c2), d2);
            a2.__reactInternalSnapshotBeforeUpdate = b2;
          }
          return;
        case 3:
          Ta && b2.flags & 256 && xb(b2.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(q2(163));
    }
    function Kf(a2, b2) {
      b2 = b2.updateQueue;
      b2 = b2 !== null ? b2.lastEffect : null;
      if (b2 !== null) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a2) === a2) {
            var d2 = c2.destroy;
            c2.destroy = void 0;
            d2 !== void 0 && d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Lf(a2, b2, c2) {
      switch (c2.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b2 = c2.updateQueue;
          b2 = b2 !== null ? b2.lastEffect : null;
          if (b2 !== null) {
            a2 = b2 = b2.next;
            do {
              if ((a2.tag & 3) === 3) {
                var d2 = a2.create;
                a2.destroy = d2();
              }
              a2 = a2.next;
            } while (a2 !== b2);
          }
          b2 = c2.updateQueue;
          b2 = b2 !== null ? b2.lastEffect : null;
          if (b2 !== null) {
            a2 = b2 = b2.next;
            do {
              var e2 = a2;
              d2 = e2.next;
              e2 = e2.tag;
              (e2 & 4) !== 0 && (e2 & 1) !== 0 && (Mf(c2, a2), Nf(c2, a2));
              a2 = d2;
            } while (a2 !== b2);
          }
          return;
        case 1:
          a2 = c2.stateNode;
          c2.flags & 4 && (b2 === null ? a2.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : Xc(c2.type, b2.memoizedProps), a2.componentDidUpdate(d2, b2.memoizedState, a2.__reactInternalSnapshotBeforeUpdate)));
          b2 = c2.updateQueue;
          b2 !== null && qd(c2, b2, a2);
          return;
        case 3:
          b2 = c2.updateQueue;
          if (b2 !== null) {
            a2 = null;
            if (c2.child !== null)
              switch (c2.child.tag) {
                case 5:
                  a2 = Da(c2.child.stateNode);
                  break;
                case 1:
                  a2 = c2.child.stateNode;
              }
            qd(c2, b2, a2);
          }
          return;
        case 5:
          a2 = c2.stateNode;
          b2 === null && c2.flags & 4 && mb(a2, c2.type, c2.memoizedProps, c2);
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          Va && c2.memoizedState === null && (c2 = c2.alternate, c2 !== null && (c2 = c2.memoizedState, c2 !== null && (c2 = c2.dehydrated, c2 !== null && Pb(c2))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(q2(163));
    }
    function Of(a2, b2) {
      if (Ta)
        for (var c2 = a2; ; ) {
          if (c2.tag === 5) {
            var d2 = c2.stateNode;
            b2 ? tb(d2) : vb(c2.stateNode, c2.memoizedProps);
          } else if (c2.tag === 6)
            d2 = c2.stateNode, b2 ? ub(d2) : wb(d2, c2.memoizedProps);
          else if ((c2.tag !== 23 && c2.tag !== 24 || c2.memoizedState === null || c2 === a2) && c2.child !== null) {
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
          if (c2 === a2)
            break;
          for (; c2.sibling === null; ) {
            if (c2.return === null || c2.return === a2)
              return;
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          c2 = c2.sibling;
        }
    }
    function Pf(a2, b2) {
      if (fc && typeof fc.onCommitFiberUnmount === "function")
        try {
          fc.onCommitFiberUnmount(ec, b2);
        } catch (f2) {
        }
      switch (b2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a2 = b2.updateQueue;
          if (a2 !== null && (a2 = a2.lastEffect, a2 !== null)) {
            var c2 = a2 = a2.next;
            do {
              var d2 = c2, e2 = d2.destroy;
              d2 = d2.tag;
              if (e2 !== void 0)
                if ((d2 & 4) !== 0)
                  Mf(b2, c2);
                else {
                  d2 = b2;
                  try {
                    e2();
                  } catch (f2) {
                    If(d2, f2);
                  }
                }
              c2 = c2.next;
            } while (c2 !== a2);
          }
          break;
        case 1:
          Hf(b2);
          a2 = b2.stateNode;
          if (typeof a2.componentWillUnmount === "function")
            try {
              a2.props = b2.memoizedProps, a2.state = b2.memoizedState, a2.componentWillUnmount();
            } catch (f2) {
              If(b2, f2);
            }
          break;
        case 5:
          Hf(b2);
          break;
        case 4:
          Ta ? Qf(a2, b2) : Ua && Ua && (b2 = b2.stateNode.containerInfo, a2 = zb(b2), Cb(b2, a2));
      }
    }
    function Rf(a2, b2) {
      for (var c2 = b2; ; )
        if (Pf(a2, c2), c2.child === null || Ta && c2.tag === 4) {
          if (c2 === b2)
            break;
          for (; c2.sibling === null; ) {
            if (c2.return === null || c2.return === b2)
              return;
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          c2 = c2.sibling;
        } else
          c2.child.return = c2, c2 = c2.child;
    }
    function Sf(a2) {
      a2.alternate = null;
      a2.child = null;
      a2.dependencies = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.return = null;
      a2.updateQueue = null;
    }
    function Tf(a2) {
      return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
    }
    function Uf(a2) {
      if (Ta) {
        a: {
          for (var b2 = a2.return; b2 !== null; ) {
            if (Tf(b2))
              break a;
            b2 = b2.return;
          }
          throw Error(q2(160));
        }
        var c2 = b2;
        b2 = c2.stateNode;
        switch (c2.tag) {
          case 5:
            var d2 = false;
            break;
          case 3:
            b2 = b2.containerInfo;
            d2 = true;
            break;
          case 4:
            b2 = b2.containerInfo;
            d2 = true;
            break;
          default:
            throw Error(q2(161));
        }
        c2.flags & 16 && (sb(b2), c2.flags &= -17);
        a:
          b:
            for (c2 = a2; ; ) {
              for (; c2.sibling === null; ) {
                if (c2.return === null || Tf(c2.return)) {
                  c2 = null;
                  break a;
                }
                c2 = c2.return;
              }
              c2.sibling.return = c2.return;
              for (c2 = c2.sibling; c2.tag !== 5 && c2.tag !== 6 && c2.tag !== 18; ) {
                if (c2.flags & 2)
                  continue b;
                if (c2.child === null || c2.tag === 4)
                  continue b;
                else
                  c2.child.return = c2, c2 = c2.child;
              }
              if (!(c2.flags & 2)) {
                c2 = c2.stateNode;
                break a;
              }
            }
        d2 ? Vf(a2, c2, b2) : Wf(a2, c2, b2);
      }
    }
    function Vf(a2, b2, c2) {
      var d2 = a2.tag, e2 = d2 === 5 || d2 === 6;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? pb(c2, a2, b2) : kb(c2, a2);
      else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
        for (Vf(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
          Vf(a2, b2, c2), a2 = a2.sibling;
    }
    function Wf(a2, b2, c2) {
      var d2 = a2.tag, e2 = d2 === 5 || d2 === 6;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? ob(c2, a2, b2) : jb(c2, a2);
      else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
        for (Wf(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
          Wf(a2, b2, c2), a2 = a2.sibling;
    }
    function Qf(a2, b2) {
      for (var c2 = b2, d2 = false, e2, f2; ; ) {
        if (!d2) {
          d2 = c2.return;
          a:
            for (; ; ) {
              if (d2 === null)
                throw Error(q2(160));
              e2 = d2.stateNode;
              switch (d2.tag) {
                case 5:
                  f2 = false;
                  break a;
                case 3:
                  e2 = e2.containerInfo;
                  f2 = true;
                  break a;
                case 4:
                  e2 = e2.containerInfo;
                  f2 = true;
                  break a;
              }
              d2 = d2.return;
            }
          d2 = true;
        }
        if (c2.tag === 5 || c2.tag === 6)
          Rf(a2, c2), f2 ? rb(e2, c2.stateNode) : qb(e2, c2.stateNode);
        else if (c2.tag === 4) {
          if (c2.child !== null) {
            e2 = c2.stateNode.containerInfo;
            f2 = true;
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
        } else if (Pf(a2, c2), c2.child !== null) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; c2.sibling === null; ) {
          if (c2.return === null || c2.return === b2)
            return;
          c2 = c2.return;
          c2.tag === 4 && (d2 = false);
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    }
    function Xf(a2, b2) {
      if (Ta) {
        switch (b2.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            Kf(3, b2);
            return;
          case 1:
            return;
          case 5:
            var c2 = b2.stateNode;
            if (c2 != null) {
              var d2 = b2.memoizedProps;
              a2 = a2 !== null ? a2.memoizedProps : d2;
              var e2 = b2.type, f2 = b2.updateQueue;
              b2.updateQueue = null;
              f2 !== null && nb(c2, f2, e2, a2, d2, b2);
            }
            return;
          case 6:
            if (b2.stateNode === null)
              throw Error(q2(162));
            c2 = b2.memoizedProps;
            lb(b2.stateNode, a2 !== null ? a2.memoizedProps : c2, c2);
            return;
          case 3:
            Va && (b2 = b2.stateNode, b2.hydrate && (b2.hydrate = false, Ob(b2.containerInfo)));
            return;
          case 12:
            return;
          case 13:
            Yf(b2);
            Zf(b2);
            return;
          case 19:
            Zf(b2);
            return;
          case 17:
            return;
          case 23:
          case 24:
            Of(b2, b2.memoizedState !== null);
            return;
        }
        throw Error(q2(163));
      }
      switch (b2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          Kf(3, b2);
          return;
        case 12:
          return;
        case 13:
          Yf(b2);
          Zf(b2);
          return;
        case 19:
          Zf(b2);
          return;
        case 3:
          Va && (c2 = b2.stateNode, c2.hydrate && (c2.hydrate = false, Ob(c2.containerInfo)));
          break;
        case 23:
        case 24:
          return;
      }
      a:
        if (Ua) {
          switch (b2.tag) {
            case 1:
            case 5:
            case 6:
            case 20:
              break a;
            case 3:
            case 4:
              b2 = b2.stateNode;
              Cb(b2.containerInfo, b2.pendingChildren);
              break a;
          }
          throw Error(q2(163));
        }
    }
    function Yf(a2) {
      a2.memoizedState !== null && ($f = G2(), Ta && Of(a2.child, true));
    }
    function Zf(a2) {
      var b2 = a2.updateQueue;
      if (b2 !== null) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        c2 === null && (c2 = a2.stateNode = new Gf());
        b2.forEach(function(b3) {
          var d2 = ag.bind(null, a2, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function bg(a2, b2) {
      return a2 !== null && (a2 = a2.memoizedState, a2 === null || a2.dehydrated !== null) ? (b2 = b2.memoizedState, b2 !== null && b2.dehydrated === null) : false;
    }
    var cg = 0, dg = 1, eg = 2, fg = 3, gg = 4;
    if (typeof Symbol === "function" && Symbol.for) {
      var hg = Symbol.for;
      cg = hg("selector.component");
      dg = hg("selector.has_pseudo_class");
      eg = hg("selector.role");
      fg = hg("selector.test_id");
      gg = hg("selector.text");
    }
    function ig(a2) {
      var b2 = Wa(a2);
      if (b2 != null) {
        if (typeof b2.memoizedProps["data-testname"] !== "string")
          throw Error(q2(364));
        return b2;
      }
      a2 = cb(a2);
      if (a2 === null)
        throw Error(q2(362));
      return a2.stateNode.current;
    }
    function jg(a2, b2) {
      switch (b2.$$typeof) {
        case cg:
          if (a2.type === b2.value)
            return true;
          break;
        case dg:
          a: {
            b2 = b2.value;
            a2 = [a2, 0];
            for (var c2 = 0; c2 < a2.length; ) {
              var d2 = a2[c2++], e2 = a2[c2++], f2 = b2[e2];
              if (d2.tag !== 5 || !fb(d2)) {
                for (; f2 != null && jg(d2, f2); )
                  e2++, f2 = b2[e2];
                if (e2 === b2.length) {
                  b2 = true;
                  break a;
                } else
                  for (d2 = d2.child; d2 !== null; )
                    a2.push(d2, e2), d2 = d2.sibling;
              }
            }
            b2 = false;
          }
          return b2;
        case eg:
          if (a2.tag === 5 && gb(a2.stateNode, b2.value))
            return true;
          break;
        case gg:
          if (a2.tag === 5 || a2.tag === 6) {
            if (a2 = eb(a2), a2 !== null && 0 <= a2.indexOf(b2.value))
              return true;
          }
          break;
        case fg:
          if (a2.tag === 5 && (a2 = a2.memoizedProps["data-testname"], typeof a2 === "string" && a2.toLowerCase() === b2.value.toLowerCase()))
            return true;
          break;
        default:
          throw Error(q2(365, b2));
      }
      return false;
    }
    function kg(a2) {
      switch (a2.$$typeof) {
        case cg:
          return "<" + (wa(a2.value) || "Unknown") + ">";
        case dg:
          return ":has(" + (kg(a2) || "") + ")";
        case eg:
          return '[role="' + a2.value + '"]';
        case gg:
          return '"' + a2.value + '"';
        case fg:
          return '[data-testname="' + a2.value + '"]';
        default:
          throw Error(q2(365, a2));
      }
    }
    function lg(a2, b2) {
      var c2 = [];
      a2 = [a2, 0];
      for (var d2 = 0; d2 < a2.length; ) {
        var e2 = a2[d2++], f2 = a2[d2++], g2 = b2[f2];
        if (e2.tag !== 5 || !fb(e2)) {
          for (; g2 != null && jg(e2, g2); )
            f2++, g2 = b2[f2];
          if (f2 === b2.length)
            c2.push(e2);
          else
            for (e2 = e2.child; e2 !== null; )
              a2.push(e2, f2), e2 = e2.sibling;
        }
      }
      return c2;
    }
    function mg(a2, b2) {
      if (!bb)
        throw Error(q2(363));
      a2 = ig(a2);
      a2 = lg(a2, b2);
      b2 = [];
      a2 = Array.from(a2);
      for (var c2 = 0; c2 < a2.length; ) {
        var d2 = a2[c2++];
        if (d2.tag === 5)
          fb(d2) || b2.push(d2.stateNode);
        else
          for (d2 = d2.child; d2 !== null; )
            a2.push(d2), d2 = d2.sibling;
      }
      return b2;
    }
    var ng = null;
    function og(a2) {
      if (ng === null)
        try {
          var b2 = ("require" + Math.random()).slice(0, 7);
          ng = (module2 && module2[b2]).call(module2, "timers").setImmediate;
        } catch (c2) {
          ng = function(a3) {
            var b3 = new MessageChannel();
            b3.port1.onmessage = a3;
            b3.port2.postMessage(void 0);
          };
        }
      return ng(a2);
    }
    var pg = Math.ceil, qg = ca.ReactCurrentDispatcher, rg = ca.ReactCurrentOwner, sg = ca.IsSomeRendererActing, V2 = 0, R2 = null, W2 = null, U2 = 0, tg = 0, ug = Wb(0), T2 = 0, vg = null, wg = 0, pd = 0, tf = 0, xg = 0, yg = null, $f = 0, vf = Infinity;
    function zg() {
      vf = G2() + 500;
    }
    var X2 = null, Cf = false, Df = null, Ff = null, Ag = false, Bg = null, Cg = 90, Dg = [], Eg = [], Fg = null, Gg = 0, Hg = null, Ig = -1, Jg = 0, Kg = 0, Lg = null, Mg = false;
    function K2() {
      return (V2 & 48) !== 0 ? G2() : Ig !== -1 ? Ig : Ig = G2();
    }
    function td(a2) {
      a2 = a2.mode;
      if ((a2 & 2) === 0)
        return 1;
      if ((a2 & 4) === 0)
        return Nc() === 99 ? 1 : 2;
      Jg === 0 && (Jg = wg);
      if (Sc.transition !== 0) {
        Kg !== 0 && (Kg = yg !== null ? yg.pendingLanes : 0);
        a2 = Jg;
        var b2 = 4186112 & ~Kg;
        b2 &= -b2;
        b2 === 0 && (a2 = 4186112 & ~a2, b2 = a2 & -a2, b2 === 0 && (b2 = 8192));
        return b2;
      }
      a2 = Nc();
      (V2 & 4) !== 0 && a2 === 98 ? a2 = oc(12, Jg) : (a2 = jc(a2), a2 = oc(a2, Jg));
      return a2;
    }
    function ud(a2, b2, c2) {
      if (50 < Gg)
        throw Gg = 0, Hg = null, Error(q2(185));
      a2 = Ng(a2, b2);
      if (a2 === null)
        return null;
      rc(a2, b2, c2);
      a2 === R2 && (tf |= b2, T2 === 4 && uf(a2, U2));
      var d2 = Nc();
      b2 === 1 ? (V2 & 8) !== 0 && (V2 & 48) === 0 ? Og(a2) : (Z2(a2, c2), V2 === 0 && (zg(), H2())) : ((V2 & 4) === 0 || d2 !== 98 && d2 !== 99 || (Fg === null ? Fg = new Set([a2]) : Fg.add(a2)), Z2(a2, c2));
      yg = a2;
    }
    function Ng(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      c2 !== null && (c2.lanes |= b2);
      c2 = a2;
      for (a2 = a2.return; a2 !== null; )
        a2.childLanes |= b2, c2 = a2.alternate, c2 !== null && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
      return c2.tag === 3 ? c2.stateNode : null;
    }
    function Z2(a2, b2) {
      for (var c2 = a2.callbackNode, d2 = a2.suspendedLanes, e2 = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
        var h2 = 31 - mc(g2), k2 = 1 << h2, l2 = f2[h2];
        if (l2 === -1) {
          if ((k2 & d2) === 0 || (k2 & e2) !== 0) {
            l2 = b2;
            ic(k2);
            var n2 = F2;
            f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
          }
        } else
          l2 <= b2 && (a2.expiredLanes |= k2);
        g2 &= ~k2;
      }
      d2 = lc(a2, a2 === R2 ? U2 : 0);
      b2 = F2;
      if (d2 === 0)
        c2 !== null && (c2 !== Hc && xc(c2), a2.callbackNode = null, a2.callbackPriority = 0);
      else {
        if (c2 !== null) {
          if (a2.callbackPriority === b2)
            return;
          c2 !== Hc && xc(c2);
        }
        b2 === 15 ? (c2 = Og.bind(null, a2), Jc === null ? (Jc = [c2], Kc = wc(Cc, Rc)) : Jc.push(c2), c2 = Hc) : b2 === 14 ? c2 = Qc(99, Og.bind(null, a2)) : (c2 = kc(b2), c2 = Qc(c2, Pg.bind(null, a2)));
        a2.callbackPriority = b2;
        a2.callbackNode = c2;
      }
    }
    function Pg(a2) {
      Ig = -1;
      Kg = Jg = 0;
      if ((V2 & 48) !== 0)
        throw Error(q2(327));
      var b2 = a2.callbackNode;
      if (Qg() && a2.callbackNode !== b2)
        return null;
      var c2 = lc(a2, a2 === R2 ? U2 : 0);
      if (c2 === 0)
        return null;
      var d2 = c2;
      var e2 = V2;
      V2 |= 16;
      var f2 = Rg();
      if (R2 !== a2 || U2 !== d2)
        zg(), Sg(a2, d2);
      do
        try {
          Tg();
          break;
        } catch (h2) {
          Ug(a2, h2);
        }
      while (1);
      bd();
      qg.current = f2;
      V2 = e2;
      W2 !== null ? d2 = 0 : (R2 = null, U2 = 0, d2 = T2);
      if ((wg & tf) !== 0)
        Sg(a2, 0);
      else if (d2 !== 0) {
        d2 === 2 && (V2 |= 64, a2.hydrate && (a2.hydrate = false, xb(a2.containerInfo)), c2 = nc(a2), c2 !== 0 && (d2 = Vg(a2, c2)));
        if (d2 === 1)
          throw b2 = vg, Sg(a2, 0), uf(a2, c2), Z2(a2, G2()), b2;
        a2.finishedWork = a2.current.alternate;
        a2.finishedLanes = c2;
        switch (d2) {
          case 0:
          case 1:
            throw Error(q2(345));
          case 2:
            Zg(a2);
            break;
          case 3:
            uf(a2, c2);
            if ((c2 & 62914560) === c2 && (d2 = $f + 500 - G2(), 10 < d2)) {
              if (lc(a2, 0) !== 0)
                break;
              e2 = a2.suspendedLanes;
              if ((e2 & c2) !== c2) {
                K2();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Pa(Zg.bind(null, a2), d2);
              break;
            }
            Zg(a2);
            break;
          case 4:
            uf(a2, c2);
            if ((c2 & 4186112) === c2)
              break;
            d2 = a2.eventTimes;
            for (e2 = -1; 0 < c2; ) {
              var g2 = 31 - mc(c2);
              f2 = 1 << g2;
              g2 = d2[g2];
              g2 > e2 && (e2 = g2);
              c2 &= ~f2;
            }
            c2 = e2;
            c2 = G2() - c2;
            c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * pg(c2 / 1960)) - c2;
            if (10 < c2) {
              a2.timeoutHandle = Pa(Zg.bind(null, a2), c2);
              break;
            }
            Zg(a2);
            break;
          case 5:
            Zg(a2);
            break;
          default:
            throw Error(q2(329));
        }
      }
      Z2(a2, G2());
      return a2.callbackNode === b2 ? Pg.bind(null, a2) : null;
    }
    function uf(a2, b2) {
      b2 &= ~xg;
      b2 &= ~tf;
      a2.suspendedLanes |= b2;
      a2.pingedLanes &= ~b2;
      for (a2 = a2.expirationTimes; 0 < b2; ) {
        var c2 = 31 - mc(b2), d2 = 1 << c2;
        a2[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Og(a2) {
      if ((V2 & 48) !== 0)
        throw Error(q2(327));
      Qg();
      if (a2 === R2 && (a2.expiredLanes & U2) !== 0) {
        var b2 = U2;
        var c2 = Vg(a2, b2);
        (wg & tf) !== 0 && (b2 = lc(a2, b2), c2 = Vg(a2, b2));
      } else
        b2 = lc(a2, 0), c2 = Vg(a2, b2);
      a2.tag !== 0 && c2 === 2 && (V2 |= 64, a2.hydrate && (a2.hydrate = false, xb(a2.containerInfo)), b2 = nc(a2), b2 !== 0 && (c2 = Vg(a2, b2)));
      if (c2 === 1)
        throw c2 = vg, Sg(a2, 0), uf(a2, b2), Z2(a2, G2()), c2;
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b2;
      Zg(a2);
      Z2(a2, G2());
      return null;
    }
    function $g() {
      if (Fg !== null) {
        var a2 = Fg;
        Fg = null;
        a2.forEach(function(a3) {
          a3.expiredLanes |= 24 & a3.pendingLanes;
          Z2(a3, G2());
        });
      }
      H2();
    }
    function ah(a2, b2) {
      var c2 = V2;
      V2 |= 1;
      try {
        return a2(b2);
      } finally {
        V2 = c2, V2 === 0 && (zg(), H2());
      }
    }
    function bh(a2, b2) {
      var c2 = V2;
      if ((c2 & 48) !== 0)
        return a2(b2);
      V2 |= 1;
      try {
        if (a2)
          return Pc(99, a2.bind(null, b2));
      } finally {
        V2 = c2, H2();
      }
    }
    function Xe2(a2, b2) {
      A2(ug, tg);
      tg |= b2;
      wg |= b2;
    }
    function wf() {
      tg = ug.current;
      z2(ug);
    }
    function Sg(a2, b2) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      c2 !== Ra && (a2.timeoutHandle = Ra, Qa(c2));
      if (W2 !== null)
        for (c2 = W2.return; c2 !== null; ) {
          var d2 = c2;
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              d2 !== null && d2 !== void 0 && $b();
              break;
            case 3:
              Qd();
              z2(D2);
              z2(B2);
              ee2();
              break;
            case 5:
              Sd(d2);
              break;
            case 4:
              Qd();
              break;
            case 13:
              z2(M2);
              break;
            case 19:
              z2(M2);
              break;
            case 10:
              dd(d2);
              break;
            case 23:
            case 24:
              wf();
          }
          c2 = c2.return;
        }
      R2 = a2;
      W2 = Ed(a2.current, null);
      U2 = tg = wg = b2;
      T2 = 0;
      vg = null;
      xg = tf = pd = 0;
    }
    function Ug(a2, b2) {
      do {
        var c2 = W2;
        try {
          bd();
          fe2.current = pe2;
          if (ie2) {
            for (var d2 = N2.memoizedState; d2 !== null; ) {
              var e2 = d2.queue;
              e2 !== null && (e2.pending = null);
              d2 = d2.next;
            }
            ie2 = false;
          }
          he2 = 0;
          P2 = O2 = N2 = null;
          je2 = false;
          rg.current = null;
          if (c2 === null || c2.return === null) {
            T2 = 1;
            vg = b2;
            W2 = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = U2;
            h2.flags |= 2048;
            h2.firstEffect = h2.lastEffect = null;
            if (k2 !== null && typeof k2 === "object" && typeof k2.then === "function") {
              var l2 = k2;
              if ((h2.mode & 2) === 0) {
                var n2 = h2.alternate;
                n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
              }
              var t2 = (M2.current & 1) !== 0, p2 = g2;
              do {
                var y2;
                if (y2 = p2.tag === 13) {
                  var x2 = p2.memoizedState;
                  if (x2 !== null)
                    y2 = x2.dehydrated !== null ? true : false;
                  else {
                    var Y2 = p2.memoizedProps;
                    y2 = Y2.fallback === void 0 ? false : Y2.unstable_avoidThisFallback !== true ? true : t2 ? false : true;
                  }
                }
                if (y2) {
                  var u2 = p2.updateQueue;
                  if (u2 === null) {
                    var v2 = new Set();
                    v2.add(l2);
                    p2.updateQueue = v2;
                  } else
                    u2.add(l2);
                  if ((p2.mode & 2) === 0) {
                    p2.flags |= 64;
                    h2.flags |= 16384;
                    h2.flags &= -2981;
                    if (h2.tag === 1)
                      if (h2.alternate === null)
                        h2.tag = 17;
                      else {
                        var C2 = kd(-1, 1);
                        C2.tag = 2;
                        md(h2, C2);
                      }
                    h2.lanes |= 1;
                    break a;
                  }
                  k2 = void 0;
                  h2 = b2;
                  var Oa = f2.pingCache;
                  Oa === null ? (Oa = f2.pingCache = new Af(), k2 = new Set(), Oa.set(l2, k2)) : (k2 = Oa.get(l2), k2 === void 0 && (k2 = new Set(), Oa.set(l2, k2)));
                  if (!k2.has(h2)) {
                    k2.add(h2);
                    var Qe2 = ch.bind(null, f2, l2, h2);
                    l2.then(Qe2, Qe2);
                  }
                  p2.flags |= 4096;
                  p2.lanes = b2;
                  break a;
                }
                p2 = p2.return;
              } while (p2 !== null);
              k2 = Error((wa(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            T2 !== 5 && (T2 = 2);
            k2 = yf(k2, h2);
            p2 = g2;
            do {
              switch (p2.tag) {
                case 3:
                  f2 = k2;
                  p2.flags |= 4096;
                  b2 &= -b2;
                  p2.lanes |= b2;
                  var Wg = Bf(p2, f2, b2);
                  nd(p2, Wg);
                  break a;
                case 1:
                  f2 = k2;
                  var Xg = p2.type, ld = p2.stateNode;
                  if ((p2.flags & 64) === 0 && (typeof Xg.getDerivedStateFromError === "function" || ld !== null && typeof ld.componentDidCatch === "function" && (Ff === null || !Ff.has(ld)))) {
                    p2.flags |= 4096;
                    b2 &= -b2;
                    p2.lanes |= b2;
                    var Yg = Ef(p2, f2, b2);
                    nd(p2, Yg);
                    break a;
                  }
              }
              p2 = p2.return;
            } while (p2 !== null);
          }
          dh(c2);
        } catch (w3) {
          b2 = w3;
          W2 === c2 && c2 !== null && (W2 = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Rg() {
      var a2 = qg.current;
      qg.current = pe2;
      return a2 === null ? pe2 : a2;
    }
    function Vg(a2, b2) {
      var c2 = V2;
      V2 |= 16;
      var d2 = Rg();
      R2 === a2 && U2 === b2 || Sg(a2, b2);
      do
        try {
          eh();
          break;
        } catch (e2) {
          Ug(a2, e2);
        }
      while (1);
      bd();
      V2 = c2;
      qg.current = d2;
      if (W2 !== null)
        throw Error(q2(261));
      R2 = null;
      U2 = 0;
      return T2;
    }
    function eh() {
      for (; W2 !== null; )
        fh(W2);
    }
    function Tg() {
      for (; W2 !== null && !yc(); )
        fh(W2);
    }
    function fh(a2) {
      var b2 = gh(a2.alternate, a2, tg);
      a2.memoizedProps = a2.pendingProps;
      b2 === null ? dh(a2) : W2 = b2;
      rg.current = null;
    }
    function dh(a2) {
      var b2 = a2;
      do {
        var c2 = b2.alternate;
        a2 = b2.return;
        if ((b2.flags & 2048) === 0) {
          c2 = sf(c2, b2, tg);
          if (c2 !== null) {
            W2 = c2;
            return;
          }
          c2 = b2;
          if (c2.tag !== 24 && c2.tag !== 23 || c2.memoizedState === null || (tg & 1073741824) !== 0 || (c2.mode & 4) === 0) {
            for (var d2 = 0, e2 = c2.child; e2 !== null; )
              d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
            c2.childLanes = d2;
          }
          a2 !== null && (a2.flags & 2048) === 0 && (a2.firstEffect === null && (a2.firstEffect = b2.firstEffect), b2.lastEffect !== null && (a2.lastEffect !== null && (a2.lastEffect.nextEffect = b2.firstEffect), a2.lastEffect = b2.lastEffect), 1 < b2.flags && (a2.lastEffect !== null ? a2.lastEffect.nextEffect = b2 : a2.firstEffect = b2, a2.lastEffect = b2));
        } else {
          c2 = xf(b2);
          if (c2 !== null) {
            c2.flags &= 2047;
            W2 = c2;
            return;
          }
          a2 !== null && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
        }
        b2 = b2.sibling;
        if (b2 !== null) {
          W2 = b2;
          return;
        }
        W2 = b2 = a2;
      } while (b2 !== null);
      T2 === 0 && (T2 = 5);
    }
    function Zg(a2) {
      var b2 = Nc();
      Pc(99, hh.bind(null, a2, b2));
      return null;
    }
    function hh(a2, b2) {
      do
        Qg();
      while (Bg !== null);
      if ((V2 & 48) !== 0)
        throw Error(q2(327));
      var c2 = a2.finishedWork;
      if (c2 === null)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current)
        throw Error(q2(177));
      a2.callbackNode = null;
      var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a2.pendingLanes & ~e2;
      a2.pendingLanes = e2;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= e2;
      a2.mutableReadLanes &= e2;
      a2.entangledLanes &= e2;
      e2 = a2.entanglements;
      for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
        var k2 = 31 - mc(f2), l2 = 1 << k2;
        e2[k2] = 0;
        g2[k2] = -1;
        h2[k2] = -1;
        f2 &= ~l2;
      }
      Fg !== null && (d2 & 24) === 0 && Fg.has(a2) && Fg.delete(a2);
      a2 === R2 && (W2 = R2 = null, U2 = 0);
      1 < c2.flags ? c2.lastEffect !== null ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
      if (d2 !== null) {
        e2 = V2;
        V2 |= 32;
        rg.current = null;
        Lg = Ga(a2.containerInfo);
        Mg = false;
        X2 = d2;
        do
          try {
            ih();
          } catch (v2) {
            if (X2 === null)
              throw Error(q2(330));
            If(X2, v2);
            X2 = X2.nextEffect;
          }
        while (X2 !== null);
        Lg = null;
        X2 = d2;
        do
          try {
            for (g2 = a2; X2 !== null; ) {
              var n2 = X2.flags;
              n2 & 16 && Ta && sb(X2.stateNode);
              if (n2 & 128) {
                var t2 = X2.alternate;
                if (t2 !== null) {
                  var p2 = t2.ref;
                  p2 !== null && (typeof p2 === "function" ? p2(null) : p2.current = null);
                }
              }
              switch (n2 & 1038) {
                case 2:
                  Uf(X2);
                  X2.flags &= -3;
                  break;
                case 6:
                  Uf(X2);
                  X2.flags &= -3;
                  Xf(X2.alternate, X2);
                  break;
                case 1024:
                  X2.flags &= -1025;
                  break;
                case 1028:
                  X2.flags &= -1025;
                  Xf(X2.alternate, X2);
                  break;
                case 4:
                  Xf(X2.alternate, X2);
                  break;
                case 8:
                  h2 = g2;
                  f2 = X2;
                  Ta ? Qf(h2, f2) : Rf(h2, f2);
                  var y2 = f2.alternate;
                  Sf(f2);
                  y2 !== null && Sf(y2);
              }
              X2 = X2.nextEffect;
            }
          } catch (v2) {
            if (X2 === null)
              throw Error(q2(330));
            If(X2, v2);
            X2 = X2.nextEffect;
          }
        while (X2 !== null);
        Mg && $a();
        Ha(a2.containerInfo);
        a2.current = c2;
        X2 = d2;
        do
          try {
            for (n2 = a2; X2 !== null; ) {
              var x2 = X2.flags;
              x2 & 36 && Lf(n2, X2.alternate, X2);
              if (x2 & 128) {
                t2 = void 0;
                var Y2 = X2.ref;
                if (Y2 !== null) {
                  var u2 = X2.stateNode;
                  switch (X2.tag) {
                    case 5:
                      t2 = Da(u2);
                      break;
                    default:
                      t2 = u2;
                  }
                  typeof Y2 === "function" ? Y2(t2) : Y2.current = t2;
                }
              }
              X2 = X2.nextEffect;
            }
          } catch (v2) {
            if (X2 === null)
              throw Error(q2(330));
            If(X2, v2);
            X2 = X2.nextEffect;
          }
        while (X2 !== null);
        X2 = null;
        Ic();
        V2 = e2;
      } else
        a2.current = c2;
      if (Ag)
        Ag = false, Bg = a2, Cg = b2;
      else
        for (X2 = d2; X2 !== null; )
          b2 = X2.nextEffect, X2.nextEffect = null, X2.flags & 8 && (x2 = X2, x2.sibling = null, x2.stateNode = null), X2 = b2;
      d2 = a2.pendingLanes;
      d2 === 0 && (Ff = null);
      d2 === 1 ? a2 === Hg ? Gg++ : (Gg = 0, Hg = a2) : Gg = 0;
      c2 = c2.stateNode;
      if (fc && typeof fc.onCommitFiberRoot === "function")
        try {
          fc.onCommitFiberRoot(ec, c2, void 0, (c2.current.flags & 64) === 64);
        } catch (v2) {
        }
      Z2(a2, G2());
      if (Cf)
        throw Cf = false, a2 = Df, Df = null, a2;
      if ((V2 & 8) !== 0)
        return null;
      H2();
      return null;
    }
    function ih() {
      for (; X2 !== null; ) {
        var a2 = X2.alternate;
        Mg || Lg === null || ((X2.flags & 8) !== 0 ? Ca(X2, Lg) && (Mg = true, Za()) : X2.tag === 13 && bg(a2, X2) && Ca(X2, Lg) && (Mg = true, Za()));
        var b2 = X2.flags;
        (b2 & 256) !== 0 && Jf(a2, X2);
        (b2 & 512) === 0 || Ag || (Ag = true, Qc(97, function() {
          Qg();
          return null;
        }));
        X2 = X2.nextEffect;
      }
    }
    function Qg() {
      if (Cg !== 90) {
        var a2 = 97 < Cg ? 97 : Cg;
        Cg = 90;
        return Pc(a2, jh);
      }
      return false;
    }
    function Nf(a2, b2) {
      Dg.push(b2, a2);
      Ag || (Ag = true, Qc(97, function() {
        Qg();
        return null;
      }));
    }
    function Mf(a2, b2) {
      Eg.push(b2, a2);
      Ag || (Ag = true, Qc(97, function() {
        Qg();
        return null;
      }));
    }
    function jh() {
      if (Bg === null)
        return false;
      var a2 = Bg;
      Bg = null;
      if ((V2 & 48) !== 0)
        throw Error(q2(331));
      var b2 = V2;
      V2 |= 32;
      var c2 = Eg;
      Eg = [];
      for (var d2 = 0; d2 < c2.length; d2 += 2) {
        var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
        e2.destroy = void 0;
        if (typeof g2 === "function")
          try {
            g2();
          } catch (k2) {
            if (f2 === null)
              throw Error(q2(330));
            If(f2, k2);
          }
      }
      c2 = Dg;
      Dg = [];
      for (d2 = 0; d2 < c2.length; d2 += 2) {
        e2 = c2[d2];
        f2 = c2[d2 + 1];
        try {
          var h2 = e2.create;
          e2.destroy = h2();
        } catch (k2) {
          if (f2 === null)
            throw Error(q2(330));
          If(f2, k2);
        }
      }
      for (h2 = a2.current.firstEffect; h2 !== null; )
        a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
      V2 = b2;
      H2();
      return true;
    }
    function kh(a2, b2, c2) {
      b2 = yf(c2, b2);
      b2 = Bf(a2, b2, 1);
      md(a2, b2);
      b2 = K2();
      a2 = Ng(a2, 1);
      a2 !== null && (rc(a2, 1, b2), Z2(a2, b2));
    }
    function If(a2, b2) {
      if (a2.tag === 3)
        kh(a2, a2, b2);
      else
        for (var c2 = a2.return; c2 !== null; ) {
          if (c2.tag === 3) {
            kh(c2, a2, b2);
            break;
          } else if (c2.tag === 1) {
            var d2 = c2.stateNode;
            if (typeof c2.type.getDerivedStateFromError === "function" || typeof d2.componentDidCatch === "function" && (Ff === null || !Ff.has(d2))) {
              a2 = yf(b2, a2);
              var e2 = Ef(c2, a2, 1);
              md(c2, e2);
              e2 = K2();
              c2 = Ng(c2, 1);
              if (c2 !== null)
                rc(c2, 1, e2), Z2(c2, e2);
              else if (typeof d2.componentDidCatch === "function" && (Ff === null || !Ff.has(d2)))
                try {
                  d2.componentDidCatch(b2, a2);
                } catch (f2) {
                }
              break;
            }
          }
          c2 = c2.return;
        }
    }
    function ch(a2, b2, c2) {
      var d2 = a2.pingCache;
      d2 !== null && d2.delete(b2);
      b2 = K2();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      R2 === a2 && (U2 & c2) === c2 && (T2 === 4 || T2 === 3 && (U2 & 62914560) === U2 && 500 > G2() - $f ? Sg(a2, 0) : xg |= c2);
      Z2(a2, b2);
    }
    function ag(a2, b2) {
      var c2 = a2.stateNode;
      c2 !== null && c2.delete(b2);
      b2 = 0;
      b2 === 0 && (b2 = a2.mode, (b2 & 2) === 0 ? b2 = 1 : (b2 & 4) === 0 ? b2 = Nc() === 99 ? 1 : 2 : (Jg === 0 && (Jg = wg), b2 = pc(62914560 & ~Jg), b2 === 0 && (b2 = 4194304)));
      c2 = K2();
      a2 = Ng(a2, b2);
      a2 !== null && (rc(a2, b2, c2), Z2(a2, c2));
    }
    var gh;
    gh = function(a2, b2, c2) {
      var d2 = b2.lanes;
      if (a2 !== null)
        if (a2.memoizedProps !== b2.pendingProps || D2.current)
          gd = true;
        else if ((c2 & d2) !== 0)
          gd = (a2.flags & 16384) !== 0 ? true : false;
        else {
          gd = false;
          switch (b2.tag) {
            case 3:
              af(b2);
              ce2();
              break;
            case 5:
              Rd(b2);
              break;
            case 1:
              E2(b2.type) && cc(b2);
              break;
            case 4:
              Pd(b2, b2.stateNode.containerInfo);
              break;
            case 10:
              cd(b2, b2.memoizedProps.value);
              break;
            case 13:
              if (b2.memoizedState !== null) {
                if ((c2 & b2.child.childLanes) !== 0)
                  return cf(a2, b2, c2);
                A2(M2, M2.current & 1);
                b2 = Re2(a2, b2, c2);
                return b2 !== null ? b2.sibling : null;
              }
              A2(M2, M2.current & 1);
              break;
            case 19:
              d2 = (c2 & b2.childLanes) !== 0;
              if ((a2.flags & 64) !== 0) {
                if (d2)
                  return kf(a2, b2, c2);
                b2.flags |= 64;
              }
              var e2 = b2.memoizedState;
              e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
              A2(M2, M2.current);
              if (d2)
                break;
              else
                return null;
            case 23:
            case 24:
              return b2.lanes = 0, We2(a2, b2, c2);
          }
          return Re2(a2, b2, c2);
        }
      else
        gd = false;
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          d2 = b2.type;
          a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
          a2 = b2.pendingProps;
          e2 = Zb(b2, B2.current);
          fd(b2, c2);
          e2 = le2(null, b2, d2, a2, e2, c2);
          b2.flags |= 1;
          if (typeof e2 === "object" && e2 !== null && typeof e2.render === "function" && e2.$$typeof === void 0) {
            b2.tag = 1;
            b2.memoizedState = null;
            b2.updateQueue = null;
            if (E2(d2)) {
              var f2 = true;
              cc(b2);
            } else
              f2 = false;
            b2.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null;
            id(b2);
            var g2 = d2.getDerivedStateFromProps;
            typeof g2 === "function" && sd(b2, d2, g2, a2);
            e2.updater = vd;
            b2.stateNode = e2;
            e2._reactInternals = b2;
            zd(b2, d2, a2, c2);
            b2 = $e2(null, b2, d2, true, f2, c2);
          } else
            b2.tag = 0, S2(null, b2, e2, c2), b2 = b2.child;
          return b2;
        case 16:
          e2 = b2.elementType;
          a: {
            a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
            a2 = b2.pendingProps;
            f2 = e2._init;
            e2 = f2(e2._payload);
            b2.type = e2;
            f2 = b2.tag = lh(e2);
            a2 = Xc(e2, a2);
            switch (f2) {
              case 0:
                b2 = Ve2(null, b2, e2, a2, c2);
                break a;
              case 1:
                b2 = Ze2(null, b2, e2, a2, c2);
                break a;
              case 11:
                b2 = Pe2(null, b2, e2, a2, c2);
                break a;
              case 14:
                b2 = Se2(null, b2, e2, Xc(e2.type, a2), d2, c2);
                break a;
            }
            throw Error(q2(306, e2, ""));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Xc(d2, e2), Ve2(a2, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Xc(d2, e2), Ze2(a2, b2, d2, e2, c2);
        case 3:
          af(b2);
          d2 = b2.updateQueue;
          if (a2 === null || d2 === null)
            throw Error(q2(282));
          d2 = b2.pendingProps;
          e2 = b2.memoizedState;
          e2 = e2 !== null ? e2.element : null;
          jd(a2, b2);
          od(b2, d2, null, c2);
          d2 = b2.memoizedState.element;
          if (d2 === e2)
            ce2(), b2 = Re2(a2, b2, c2);
          else {
            e2 = b2.stateNode;
            if (f2 = e2.hydrate)
              Va ? (Vd = Kb(b2.stateNode.containerInfo), Ud = b2, f2 = Wd = true) : f2 = false;
            if (f2) {
              if (Va && (a2 = e2.mutableSourceEagerHydrationData, a2 != null))
                for (e2 = 0; e2 < a2.length; e2 += 2)
                  f2 = a2[e2], g2 = a2[e2 + 1], Sa ? f2._workInProgressVersionPrimary = g2 : f2._workInProgressVersionSecondary = g2, de2.push(f2);
              c2 = Kd(b2, null, d2, c2);
              for (b2.child = c2; c2; )
                c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
            } else
              S2(a2, b2, d2, c2), ce2();
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Rd(b2), a2 === null && $d(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = a2 !== null ? a2.memoizedProps : null, g2 = e2.children, Ma(d2, e2) ? g2 = null : f2 !== null && Ma(d2, f2) && (b2.flags |= 16), Ye2(a2, b2), S2(a2, b2, g2, c2), b2.child;
        case 6:
          return a2 === null && $d(b2), null;
        case 13:
          return cf(a2, b2, c2);
        case 4:
          return Pd(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, a2 === null ? b2.child = Jd(b2, null, d2, c2) : S2(a2, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Xc(d2, e2), Pe2(a2, b2, d2, e2, c2);
        case 7:
          return S2(a2, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return S2(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return S2(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            g2 = b2.memoizedProps;
            f2 = e2.value;
            cd(b2, f2);
            if (g2 !== null) {
              var h2 = g2.value;
              f2 = I2(h2, f2) ? 0 : (typeof d2._calculateChangedBits === "function" ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0;
              if (f2 === 0) {
                if (g2.children === e2.children && !D2.current) {
                  b2 = Re2(a2, b2, c2);
                  break a;
                }
              } else
                for (h2 = b2.child, h2 !== null && (h2.return = b2); h2 !== null; ) {
                  var k2 = h2.dependencies;
                  if (k2 !== null) {
                    g2 = h2.child;
                    for (var l2 = k2.firstContext; l2 !== null; ) {
                      if (l2.context === d2 && (l2.observedBits & f2) !== 0) {
                        h2.tag === 1 && (l2 = kd(-1, c2 & -c2), l2.tag = 2, md(h2, l2));
                        h2.lanes |= c2;
                        l2 = h2.alternate;
                        l2 !== null && (l2.lanes |= c2);
                        ed(h2.return, c2);
                        k2.lanes |= c2;
                        break;
                      }
                      l2 = l2.next;
                    }
                  } else
                    g2 = h2.tag === 10 ? h2.type === b2.type ? null : h2.child : h2.child;
                  if (g2 !== null)
                    g2.return = h2;
                  else
                    for (g2 = h2; g2 !== null; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      h2 = g2.sibling;
                      if (h2 !== null) {
                        h2.return = g2.return;
                        g2 = h2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  h2 = g2;
                }
            }
            S2(a2, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, fd(b2, c2), e2 = J2(e2, f2.unstable_observedBits), d2 = d2(e2), b2.flags |= 1, S2(a2, b2, d2, c2), b2.child;
        case 14:
          return e2 = b2.type, f2 = Xc(e2, b2.pendingProps), f2 = Xc(e2.type, f2), Se2(a2, b2, e2, f2, d2, c2);
        case 15:
          return Ue2(a2, b2, b2.type, b2.pendingProps, d2, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Xc(d2, e2), a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, E2(d2) ? (a2 = true, cc(b2)) : a2 = false, fd(b2, c2), xd(b2, d2, e2), zd(b2, d2, e2, c2), $e2(null, b2, d2, true, a2, c2);
        case 19:
          return kf(a2, b2, c2);
        case 23:
          return We2(a2, b2, c2);
        case 24:
          return We2(a2, b2, c2);
      }
      throw Error(q2(156, b2.tag));
    };
    var mh = {current: false}, nh = m2.unstable_flushAllWithoutAsserting, oh = typeof nh === "function";
    function ph() {
      if (nh !== void 0)
        return nh();
      for (var a2 = false; Qg(); )
        a2 = true;
      return a2;
    }
    function qh(a2) {
      try {
        ph(), og(function() {
          ph() ? qh(a2) : a2();
        });
      } catch (b2) {
        a2(b2);
      }
    }
    var rh = 0, sh = false;
    function th(a2, b2, c2, d2) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Yd(a2, b2, c2, d2) {
      return new th(a2, b2, c2, d2);
    }
    function Te2(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function lh(a2) {
      if (typeof a2 === "function")
        return Te2(a2) ? 1 : 0;
      if (a2 !== void 0 && a2 !== null) {
        a2 = a2.$$typeof;
        if (a2 === la)
          return 11;
        if (a2 === oa)
          return 14;
      }
      return 2;
    }
    function Ed(a2, b2) {
      var c2 = a2.alternate;
      c2 === null ? (c2 = Yd(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b2 = a2.dependencies;
      c2.dependencies = b2 === null ? null : {lanes: b2.lanes, firstContext: b2.firstContext};
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function Gd(a2, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a2;
      if (typeof a2 === "function")
        Te2(a2) && (g2 = 1);
      else if (typeof a2 === "string")
        g2 = 5;
      else
        a:
          switch (a2) {
            case fa:
              return Id(c2.children, e2, f2, b2);
            case ra:
              g2 = 8;
              e2 |= 16;
              break;
            case ha:
              g2 = 8;
              e2 |= 1;
              break;
            case ia:
              return a2 = Yd(12, c2, b2, e2 | 8), a2.elementType = ia, a2.type = ia, a2.lanes = f2, a2;
            case ma:
              return a2 = Yd(13, c2, b2, e2), a2.type = ma, a2.elementType = ma, a2.lanes = f2, a2;
            case na:
              return a2 = Yd(19, c2, b2, e2), a2.elementType = na, a2.lanes = f2, a2;
            case sa:
              return ef(c2, e2, f2, b2);
            case ta:
              return a2 = Yd(24, c2, b2, e2), a2.elementType = ta, a2.lanes = f2, a2;
            default:
              if (typeof a2 === "object" && a2 !== null)
                switch (a2.$$typeof) {
                  case ja:
                    g2 = 10;
                    break a;
                  case ka:
                    g2 = 9;
                    break a;
                  case la:
                    g2 = 11;
                    break a;
                  case oa:
                    g2 = 14;
                    break a;
                  case pa:
                    g2 = 16;
                    d2 = null;
                    break a;
                  case qa:
                    g2 = 22;
                    break a;
                }
              throw Error(q2(130, a2 == null ? a2 : typeof a2, ""));
          }
      b2 = Yd(g2, c2, b2, e2);
      b2.elementType = a2;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Id(a2, b2, c2, d2) {
      a2 = Yd(7, a2, d2, b2);
      a2.lanes = c2;
      return a2;
    }
    function ef(a2, b2, c2, d2) {
      a2 = Yd(23, a2, d2, b2);
      a2.elementType = sa;
      a2.lanes = c2;
      return a2;
    }
    function Fd(a2, b2, c2) {
      a2 = Yd(6, a2, null, b2);
      a2.lanes = c2;
      return a2;
    }
    function Hd(a2, b2, c2) {
      b2 = Yd(4, a2.children !== null ? a2.children : [], a2.key, b2);
      b2.lanes = c2;
      b2.stateNode = {containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation};
      return b2;
    }
    function uh(a2, b2, c2) {
      this.tag = b2;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = Ra;
      this.pendingContext = this.context = null;
      this.hydrate = c2;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = qc(0);
      this.expirationTimes = qc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = qc(0);
      Va && (this.mutableSourceEagerHydrationData = null);
    }
    function vh(a2) {
      var b2 = a2._reactInternals;
      if (b2 === void 0) {
        if (typeof a2.render === "function")
          throw Error(q2(188));
        throw Error(q2(268, Object.keys(a2)));
      }
      a2 = Aa(b2);
      return a2 === null ? null : a2.stateNode;
    }
    function wh(a2, b2) {
      a2 = a2.memoizedState;
      if (a2 !== null && a2.dehydrated !== null) {
        var c2 = a2.retryLane;
        a2.retryLane = c2 !== 0 && c2 < b2 ? c2 : b2;
      }
    }
    function xh(a2, b2) {
      wh(a2, b2);
      (a2 = a2.alternate) && wh(a2, b2);
    }
    function yh(a2) {
      a2 = Aa(a2);
      return a2 === null ? null : a2.stateNode;
    }
    function zh() {
      return null;
    }
    exports3.IsThisRendererActing = mh;
    exports3.act = function(a2) {
      function b2() {
        rh--;
        sg.current = c2;
        mh.current = d2;
      }
      sh === false && (sh = true, console.error("act(...) is not supported in production builds of React, and might not behave as expected."));
      rh++;
      var c2 = sg.current, d2 = mh.current;
      sg.current = true;
      mh.current = true;
      try {
        var e2 = ah(a2);
      } catch (f2) {
        throw b2(), f2;
      }
      if (e2 !== null && typeof e2 === "object" && typeof e2.then === "function")
        return {then: function(a3, d3) {
          e2.then(function() {
            1 < rh || oh === true && c2 === true ? (b2(), a3()) : qh(function(c3) {
              b2();
              c3 ? d3(c3) : a3();
            });
          }, function(a4) {
            b2();
            d3(a4);
          });
        }};
      try {
        rh !== 1 || oh !== false && c2 !== false || ph(), b2();
      } catch (f2) {
        throw b2(), f2;
      }
      return {then: function(a3) {
        a3();
      }};
    };
    exports3.attemptContinuousHydration = function(a2) {
      if (a2.tag === 13) {
        var b2 = K2();
        ud(a2, 67108864, b2);
        xh(a2, 67108864);
      }
    };
    exports3.attemptHydrationAtCurrentPriority = function(a2) {
      if (a2.tag === 13) {
        var b2 = K2(), c2 = td(a2);
        ud(a2, c2, b2);
        xh(a2, c2);
      }
    };
    exports3.attemptSynchronousHydration = function(a2) {
      switch (a2.tag) {
        case 3:
          var b2 = a2.stateNode;
          if (b2.hydrate) {
            var c2 = ic(b2.pendingLanes);
            b2.expiredLanes |= c2 & b2.pendingLanes;
            Z2(b2, G2());
            (V2 & 48) === 0 && (zg(), H2());
          }
          break;
        case 13:
          var d2 = K2();
          bh(function() {
            return ud(a2, 1, d2);
          });
          xh(a2, 4);
      }
    };
    exports3.attemptUserBlockingHydration = function(a2) {
      if (a2.tag === 13) {
        var b2 = K2();
        ud(a2, 4, b2);
        xh(a2, 4);
      }
    };
    exports3.batchedEventUpdates = function(a2, b2) {
      var c2 = V2;
      V2 |= 2;
      try {
        return a2(b2);
      } finally {
        V2 = c2, V2 === 0 && (zg(), H2());
      }
    };
    exports3.batchedUpdates = ah;
    exports3.createComponentSelector = function(a2) {
      return {$$typeof: cg, value: a2};
    };
    exports3.createContainer = function(a2, b2, c2) {
      a2 = new uh(a2, b2, c2);
      b2 = Yd(3, null, null, b2 === 2 ? 7 : b2 === 1 ? 3 : 0);
      a2.current = b2;
      b2.stateNode = a2;
      id(b2);
      return a2;
    };
    exports3.createHasPsuedoClassSelector = function(a2) {
      return {$$typeof: dg, value: a2};
    };
    exports3.createPortal = function(a2, b2, c2) {
      var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {$$typeof: ea, key: d2 == null ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2};
    };
    exports3.createRoleSelector = function(a2) {
      return {$$typeof: eg, value: a2};
    };
    exports3.createTestNameSelector = function(a2) {
      return {$$typeof: fg, value: a2};
    };
    exports3.createTextSelector = function(a2) {
      return {$$typeof: gg, value: a2};
    };
    exports3.deferredUpdates = function(a2) {
      return Pc(97, a2);
    };
    exports3.discreteUpdates = function(a2, b2, c2, d2, e2) {
      var f2 = V2;
      V2 |= 4;
      try {
        return Pc(98, a2.bind(null, b2, c2, d2, e2));
      } finally {
        V2 = f2, V2 === 0 && (zg(), H2());
      }
    };
    exports3.findAllNodes = mg;
    exports3.findBoundingRects = function(a2, b2) {
      if (!bb)
        throw Error(q2(363));
      b2 = mg(a2, b2);
      a2 = [];
      for (var c2 = 0; c2 < b2.length; c2++)
        a2.push(db(b2[c2]));
      for (b2 = a2.length - 1; 0 < b2; b2--) {
        c2 = a2[b2];
        for (var d2 = c2.x, e2 = d2 + c2.width, f2 = c2.y, g2 = f2 + c2.height, h2 = b2 - 1; 0 <= h2; h2--)
          if (b2 !== h2) {
            var k2 = a2[h2], l2 = k2.x, n2 = l2 + k2.width, t2 = k2.y, p2 = t2 + k2.height;
            if (d2 >= l2 && f2 >= t2 && e2 <= n2 && g2 <= p2) {
              a2.splice(b2, 1);
              break;
            } else if (!(d2 !== l2 || c2.width !== k2.width || p2 < f2 || t2 > g2)) {
              t2 > f2 && (k2.height += t2 - f2, k2.y = f2);
              p2 < g2 && (k2.height = g2 - t2);
              a2.splice(b2, 1);
              break;
            } else if (!(f2 !== t2 || c2.height !== k2.height || n2 < d2 || l2 > e2)) {
              l2 > d2 && (k2.width += l2 - d2, k2.x = d2);
              n2 < e2 && (k2.width = e2 - l2);
              a2.splice(b2, 1);
              break;
            }
          }
      }
      return a2;
    };
    exports3.findHostInstance = vh;
    exports3.findHostInstanceWithNoPortals = function(a2) {
      a2 = Ba(a2);
      return a2 === null ? null : a2.tag === 20 ? a2.stateNode.instance : a2.stateNode;
    };
    exports3.findHostInstanceWithWarning = function(a2) {
      return vh(a2);
    };
    exports3.flushControlled = function(a2) {
      var b2 = V2;
      V2 |= 1;
      try {
        Pc(99, a2);
      } finally {
        V2 = b2, V2 === 0 && (zg(), H2());
      }
    };
    exports3.flushDiscreteUpdates = function() {
      (V2 & 49) === 0 && ($g(), Qg());
    };
    exports3.flushPassiveEffects = Qg;
    exports3.flushSync = bh;
    exports3.focusWithin = function(a2, b2) {
      if (!bb)
        throw Error(q2(363));
      a2 = ig(a2);
      b2 = lg(a2, b2);
      b2 = Array.from(b2);
      for (a2 = 0; a2 < b2.length; ) {
        var c2 = b2[a2++];
        if (!fb(c2)) {
          if (c2.tag === 5 && hb(c2.stateNode))
            return true;
          for (c2 = c2.child; c2 !== null; )
            b2.push(c2), c2 = c2.sibling;
        }
      }
      return false;
    };
    exports3.getCurrentUpdateLanePriority = function() {
      return hc;
    };
    exports3.getFindAllNodesFailureDescription = function(a2, b2) {
      if (!bb)
        throw Error(q2(363));
      var c2 = 0, d2 = [];
      a2 = [ig(a2), 0];
      for (var e2 = 0; e2 < a2.length; ) {
        var f2 = a2[e2++], g2 = a2[e2++], h2 = b2[g2];
        if (f2.tag !== 5 || !fb(f2)) {
          if (jg(f2, h2) && (d2.push(kg(h2)), g2++, g2 > c2 && (c2 = g2)), g2 < b2.length)
            for (f2 = f2.child; f2 !== null; )
              a2.push(f2, g2), f2 = f2.sibling;
        }
      }
      if (c2 < b2.length) {
        for (a2 = []; c2 < b2.length; c2++)
          a2.push(kg(b2[c2]));
        return "findAllNodes was able to match part of the selector:\n  " + (d2.join(" > ") + "\n\nNo matching component was found for:\n  ") + a2.join(" > ");
      }
      return null;
    };
    exports3.getPublicRootInstance = function(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return Da(a2.child.stateNode);
        default:
          return a2.child.stateNode;
      }
    };
    exports3.injectIntoDevTools = function(a2) {
      a2 = {
        bundleType: a2.bundleType,
        version: a2.version,
        rendererPackageName: a2.rendererPackageName,
        rendererConfig: a2.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ca.ReactCurrentDispatcher,
        findHostInstanceByFiber: yh,
        findFiberByHostInstance: a2.findFiberByHostInstance || zh,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
      };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        a2 = false;
      else {
        var b2 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!b2.isDisabled && b2.supportsFiber)
          try {
            ec = b2.inject(a2), fc = b2;
          } catch (c2) {
          }
        a2 = true;
      }
      return a2;
    };
    exports3.observeVisibleRects = function(a2, b2, c2, d2) {
      if (!bb)
        throw Error(q2(363));
      a2 = mg(a2, b2);
      var e2 = ib(a2, c2, d2).disconnect;
      return {disconnect: function() {
        e2();
      }};
    };
    exports3.registerMutableSourceForHydration = function(a2, b2) {
      var c2 = b2._getVersion;
      c2 = c2(b2._source);
      a2.mutableSourceEagerHydrationData == null ? a2.mutableSourceEagerHydrationData = [b2, c2] : a2.mutableSourceEagerHydrationData.push(b2, c2);
    };
    exports3.runWithPriority = function(a2, b2) {
      var c2 = hc;
      try {
        return hc = a2, b2();
      } finally {
        hc = c2;
      }
    };
    exports3.shouldSuspend = function() {
      return false;
    };
    exports3.unbatchedUpdates = function(a2, b2) {
      var c2 = V2;
      V2 &= -2;
      V2 |= 8;
      try {
        return a2(b2);
      } finally {
        V2 = c2, V2 === 0 && (zg(), H2());
      }
    };
    exports3.updateContainer = function(a2, b2, c2, d2) {
      var e2 = b2.current, f2 = K2(), g2 = td(e2);
      a:
        if (c2) {
          c2 = c2._reactInternals;
          b: {
            if (xa(c2) !== c2 || c2.tag !== 1)
              throw Error(q2(170));
            var h2 = c2;
            do {
              switch (h2.tag) {
                case 3:
                  h2 = h2.stateNode.context;
                  break b;
                case 1:
                  if (E2(h2.type)) {
                    h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h2 = h2.return;
            } while (h2 !== null);
            throw Error(q2(171));
          }
          if (c2.tag === 1) {
            var k2 = c2.type;
            if (E2(k2)) {
              c2 = bc(c2, k2, h2);
              break a;
            }
          }
          c2 = h2;
        } else
          c2 = Xb;
      b2.context === null ? b2.context = c2 : b2.pendingContext = c2;
      b2 = kd(f2, g2);
      b2.payload = {element: a2};
      d2 = d2 === void 0 ? null : d2;
      d2 !== null && (b2.callback = d2);
      md(e2, b2);
      ud(e2, g2, f2);
      return g2;
    };
    return exports3;
  };
});

// node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_react_reconciler_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min2 = __commonJS((exports2) => {
  /** @license React v0.20.1
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var f2;
  var g2;
  var h2;
  var k2;
  if (typeof performance === "object" && typeof performance.now === "function") {
    l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var l2;
  var p2;
  var q2;
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    t2 = null, u2 = null, w3 = function() {
      if (t2 !== null)
        try {
          var a2 = exports2.unstable_now();
          t2(true, a2);
          t2 = null;
        } catch (b2) {
          throw setTimeout(w3, 0), b2;
        }
    };
    f2 = function(a2) {
      t2 !== null ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w3, 0));
    };
    g2 = function(a2, b2) {
      u2 = setTimeout(a2, b2);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    x2 = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E2;
    };
    k2 = function() {
    };
    exports2.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a2 = exports2.unstable_now();
        E2 = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b2) {
          throw G2.postMessage(null), b2;
        }
      } else
        A2 = false;
    };
    f2 = function(a2) {
      B2 = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a2, b2) {
      C2 = x2(function() {
        a2(exports2.unstable_now());
      }, b2);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  var t2;
  var u2;
  var w3;
  var x2;
  var y2;
  var z2;
  var A2;
  var B2;
  var C2;
  var D2;
  var E2;
  var F2;
  var G2;
  function H2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (e2 !== void 0 && 0 < I2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function J2(a2) {
    a2 = a2[0];
    return a2 === void 0 ? null : a2;
  }
  function K2(a2) {
    var b2 = a2[0];
    if (b2 !== void 0) {
      var c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
            if (n2 !== void 0 && 0 > I2(n2, c2))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c2))
              a2[d2] = r2, a2[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b2;
    }
    return null;
  }
  function I2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a2.id - b2.id;
  }
  var L4 = [];
  var M2 = [];
  var N2 = 1;
  var O2 = null;
  var P2 = 3;
  var Q2 = false;
  var R2 = false;
  var S2 = false;
  function T2(a2) {
    for (var b2 = J2(M2); b2 !== null; ) {
      if (b2.callback === null)
        K2(M2);
      else if (b2.startTime <= a2)
        K2(M2), b2.sortIndex = b2.expirationTime, H2(L4, b2);
      else
        break;
      b2 = J2(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (J2(L4) !== null)
        R2 = true, f2(V2);
      else {
        var b2 = J2(M2);
        b2 !== null && g2(U2, b2.startTime - a2);
      }
  }
  function V2(a2, b2) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c2 = P2;
    try {
      T2(b2);
      for (O2 = J2(L4); O2 !== null && (!(O2.expirationTime > b2) || a2 && !exports2.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if (typeof d2 === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d2(O2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          typeof e2 === "function" ? O2.callback = e2 : O2 === J2(L4) && K2(L4);
          T2(b2);
        } else
          K2(L4);
        O2 = J2(L4);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J2(M2);
        n2 !== null && g2(U2, n2.startTime - b2);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q2 = false;
    }
  }
  var W2 = k2;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J2(L4);
  };
  exports2.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = P2;
    }
    var c2 = P2;
    P2 = b2;
    try {
      return a2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W2;
  exports2.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = P2;
    P2 = a2;
    try {
      return b2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports2.unstable_now();
    typeof c2 === "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 === "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = {id: N2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1};
    c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), J2(L4) === null && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e2, H2(L4, a2), R2 || Q2 || (R2 = true, f2(V2)));
    return a2;
  };
  exports2.unstable_wrapCallback = function(a2) {
    var b2 = P2;
    return function() {
      var c2 = P2;
      P2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
});

// node_modules/scheduler/index.js
var require_scheduler2 = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_scheduler_production_min2();
  } else {
    module2.exports = null;
  }
});

// node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS((exports2, module2) => {
  function E2() {
  }
  E2.prototype = {
    on: function(name2, callback, ctx) {
      var e2 = this.e || (this.e = {});
      (e2[name2] || (e2[name2] = [])).push({
        fn: callback,
        ctx
      });
      return this;
    },
    once: function(name2, callback, ctx) {
      var self2 = this;
      function listener() {
        self2.off(name2, listener);
        callback.apply(ctx, arguments);
      }
      ;
      listener._ = callback;
      return this.on(name2, listener, ctx);
    },
    emit: function(name2) {
      var data2 = [].slice.call(arguments, 1);
      var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
      var i2 = 0;
      var len = evtArr.length;
      for (i2; i2 < len; i2++) {
        evtArr[i2].fn.apply(evtArr[i2].ctx, data2);
      }
      return this;
    },
    off: function(name2, callback) {
      var e2 = this.e || (this.e = {});
      var evts = e2[name2];
      var liveEvents = [];
      if (evts && callback) {
        for (var i2 = 0, len = evts.length; i2 < len; i2++) {
          if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
            liveEvents.push(evts[i2]);
        }
      }
      liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
      return this;
    }
  };
  module2.exports = E2;
  module2.exports.TinyEmitter = E2;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function equal(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor)
        return false;
      var length2, i2, keys2;
      if (Array.isArray(a2)) {
        length2 = a2.length;
        if (length2 != b2.length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!equal(a2[i2], b2[i2]))
            return false;
        return true;
      }
      if (a2.constructor === RegExp)
        return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf)
        return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString)
        return a2.toString() === b2.toString();
      keys2 = Object.keys(a2);
      length2 = keys2.length;
      if (length2 !== Object.keys(b2).length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
          return false;
      for (i2 = length2; i2-- !== 0; ) {
        var key = keys2[i2];
        if (!equal(a2[key], b2[key]))
          return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  };
});

// node_modules/debounce/index.js
var require_debounce = __commonJS((exports2, module2) => {
  function debounce2(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (wait == null)
      wait = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    ;
    var debounced = function() {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout)
        timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function() {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }
  debounce2.debounce = debounce2;
  module2.exports = debounce2;
});

// node_modules/chart.xkcd/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  (function() {
    function wb(a3) {
      return a3 && a3.__esModule ? {d: a3.default} : {d: a3};
    }
    var xb = {};
    function yb(t3, e3) {
      var i3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(t3);
        e3 && (o3 = o3.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i3.push.apply(i3, o3);
      }
      return i3;
    }
    function od(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? yb(i3, true).forEach(function(e4) {
          pd(t3, e4, i3[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(i3)) : yb(i3).forEach(function(e4) {
          Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(i3, e4));
        });
      }
      return t3;
    }
    function pd(t3, e3, i3) {
      return e3 in t3 ? Object.defineProperty(t3, e3, {value: i3, enumerable: true, configurable: true, writable: true}) : t3[e3] = i3, t3;
    }
    function qd() {
    }
    var zb = function($3) {
      return $3 == null ? qd : function() {
        return this.querySelector($3);
      };
    };
    var rd = function(e3) {
      typeof e3 != "function" && (e3 = zb(e3));
      for (var r3 = this._groups, t3 = r3.length, a3 = new Array(t3), l3 = 0; l3 < t3; ++l3)
        for (var $3, _3, o3 = r3[l3], n3 = o3.length, i3 = a3[l3] = new Array(n3), p3 = 0; p3 < n3; ++p3)
          ($3 = o3[p3]) && (_3 = e3.call($3, $3.__data__, p3, o3)) && ("__data__" in $3 && (_3.__data__ = $3.__data__), i3[p3] = _3);
      return new m2(a3, this._parents);
    };
    function sd() {
      return [];
    }
    var td = function(t3) {
      return t3 == null ? sd : function() {
        return this.querySelectorAll(t3);
      };
    };
    var ud = function(e3) {
      typeof e3 != "function" && (e3 = td(e3));
      for (var r3 = this._groups, p3 = r3.length, t3 = [], $3 = [], f3 = 0; f3 < p3; ++f3)
        for (var l3, o3 = r3[f3], a3 = o3.length, u3 = 0; u3 < a3; ++u3)
          (l3 = o3[u3]) && (t3.push(e3.call(l3, l3.__data__, u3, o3)), $3.push(l3));
      return new m2(t3, $3);
    };
    var vd = function(r3) {
      return function() {
        return this.matches(r3);
      };
    };
    var wd = function(r3) {
      typeof r3 != "function" && (r3 = vd(r3));
      for (var e3 = this._groups, a3 = e3.length, t3 = new Array(a3), $3 = 0; $3 < a3; ++$3)
        for (var S3, o3 = e3[$3], n3 = o3.length, p3 = t3[$3] = [], i3 = 0; i3 < n3; ++i3)
          (S3 = o3[i3]) && r3.call(S3, S3.__data__, i3, o3) && p3.push(S3);
      return new m2(t3, this._parents);
    };
    var Ab = function(e3) {
      return new Array(e3.length);
    };
    var xd = function() {
      return new m2(this._enter || this._groups.map(Ab), this._parents);
    };
    function ia(e3, t3) {
      this.ownerDocument = e3.ownerDocument, this.namespaceURI = e3.namespaceURI, this._next = null, this._parent = e3, this.__data__ = t3;
    }
    ia.prototype = {constructor: ia, appendChild: function(e3) {
      return this._parent.insertBefore(e3, this._next);
    }, insertBefore: function(e3, t3) {
      return this._parent.insertBefore(e3, t3);
    }, querySelector: function(e3) {
      return this._parent.querySelector(e3);
    }, querySelectorAll: function(e3) {
      return this._parent.querySelectorAll(e3);
    }};
    var yd = function(r3) {
      return function() {
        return r3;
      };
    };
    var Bb = "$";
    function zd(r3, e3, n3, $3, t3, a3) {
      for (var c3, i3 = 0, o3 = e3.length, l3 = a3.length; i3 < l3; ++i3)
        (c3 = e3[i3]) ? (c3.__data__ = a3[i3], $3[i3] = c3) : n3[i3] = new ia(r3, a3[i3]);
      for (; i3 < o3; ++i3)
        (c3 = e3[i3]) && (t3[i3] = c3);
    }
    function Ad(r3, e3, n3, $3, t3, a3, c3) {
      var i3, o3, l3, f3 = {}, q3 = e3.length, _3 = a3.length, O3 = new Array(q3);
      for (i3 = 0; i3 < q3; ++i3)
        (o3 = e3[i3]) && (O3[i3] = l3 = Bb + c3.call(o3, o3.__data__, i3, e3), l3 in f3 ? t3[i3] = o3 : f3[l3] = o3);
      for (i3 = 0; i3 < _3; ++i3)
        (o3 = f3[l3 = Bb + c3.call(r3, a3[i3], i3, a3)]) ? ($3[i3] = o3, o3.__data__ = a3[i3], f3[l3] = null) : n3[i3] = new ia(r3, a3[i3]);
      for (i3 = 0; i3 < q3; ++i3)
        (o3 = e3[i3]) && f3[O3[i3]] === o3 && (t3[i3] = o3);
    }
    var Bd = function(r3, e3) {
      if (!r3)
        return O3 = new Array(this.size()), l3 = -1, this.each(function(r4) {
          O3[++l3] = r4;
        }), O3;
      var n3 = e3 ? Ad : zd, $3 = this._parents, t3 = this._groups;
      typeof r3 != "function" && (r3 = yd(r3));
      for (var a3 = t3.length, c3 = new Array(a3), i3 = new Array(a3), o3 = new Array(a3), l3 = 0; l3 < a3; ++l3) {
        var f3 = $3[l3], q3 = t3[l3], _3 = q3.length, O3 = r3.call(f3, f3 && f3.__data__, l3, $3), d3 = O3.length, u3 = i3[l3] = new Array(d3), v3 = c3[l3] = new Array(d3);
        n3(f3, q3, u3, v3, o3[l3] = new Array(_3), O3, e3);
        for (var p3, y3, h3 = 0, x3 = 0; h3 < d3; ++h3)
          if (p3 = u3[h3]) {
            for (h3 >= x3 && (x3 = h3 + 1); !(y3 = v3[x3]) && ++x3 < d3; )
              ;
            p3._next = y3 || null;
          }
      }
      return (c3 = new m2(c3, $3))._enter = i3, c3._exit = o3, c3;
    };
    var Cd = function() {
      return new m2(this._exit || this._groups.map(Ab), this._parents);
    };
    var Dd = function(e3, t3, r3) {
      var $3 = this.enter(), n3 = this, o3 = this.exit();
      return $3 = typeof e3 == "function" ? e3($3) : $3.append(e3 + ""), t3 != null && (n3 = t3(n3)), r3 == null ? o3.remove() : r3(o3), $3 && n3 ? $3.merge(n3).order() : n3;
    };
    var Ed = function(r3) {
      for (var e3 = this._groups, t3 = r3._groups, $3 = e3.length, n3 = t3.length, a3 = Math.min($3, n3), o3 = new Array($3), x3 = 0; x3 < a3; ++x3)
        for (var p3, i3 = e3[x3], l3 = t3[x3], u3 = i3.length, f3 = o3[x3] = new Array(u3), s3 = 0; s3 < u3; ++s3)
          (p3 = i3[s3] || l3[s3]) && (f3[s3] = p3);
      for (; x3 < $3; ++x3)
        o3[x3] = e3[x3];
      return new m2(o3, this._parents);
    };
    var Fd = function() {
      for (var e3 = this._groups, t3 = -1, r3 = e3.length; ++t3 < r3; )
        for (var o3, $3 = e3[t3], n3 = $3.length - 1, a3 = $3[n3]; --n3 >= 0; )
          (o3 = $3[n3]) && (a3 && 4 ^ o3.compareDocumentPosition(a3) && a3.parentNode.insertBefore(o3, a3), a3 = o3);
      return this;
    };
    var Gd = function(r3) {
      function e3(e4, t4) {
        return e4 && t4 ? r3(e4.__data__, t4.__data__) : !e4 - !t4;
      }
      r3 || (r3 = Hd);
      for (var t3 = this._groups, n3 = t3.length, $3 = new Array(n3), a3 = 0; a3 < n3; ++a3) {
        for (var w4, o3 = t3[a3], i3 = o3.length, u3 = $3[a3] = new Array(i3), _3 = 0; _3 < i3; ++_3)
          (w4 = o3[_3]) && (u3[_3] = w4);
        u3.sort(e3);
      }
      return new m2($3, this._parents).order();
    };
    function Hd(r3, e3) {
      return r3 < e3 ? -1 : r3 > e3 ? 1 : r3 >= e3 ? 0 : NaN;
    }
    var Id = function() {
      var t3 = arguments[0];
      return arguments[0] = this, t3.apply(null, arguments), this;
    };
    var Jd = function() {
      var t3 = new Array(this.size()), a3 = -1;
      return this.each(function() {
        t3[++a3] = this;
      }), t3;
    };
    var Kd = function() {
      for (var r3 = this._groups, t3 = 0, e3 = r3.length; t3 < e3; ++t3)
        for (var $3 = r3[t3], o3 = 0, u3 = $3.length; o3 < u3; ++o3) {
          var a3 = $3[o3];
          if (a3)
            return a3;
        }
      return null;
    };
    var Ld = function() {
      var e3 = 0;
      return this.each(function() {
        ++e3;
      }), e3;
    };
    var Md = function() {
      return !this.node();
    };
    var Nd = function(t3) {
      for (var r3 = this._groups, e3 = 0, $3 = r3.length; e3 < $3; ++e3)
        for (var a3, n3 = r3[e3], p3 = 0, o3 = n3.length; p3 < o3; ++p3)
          (a3 = n3[p3]) && t3.call(a3, a3.__data__, p3, n3);
      return this;
    };
    function Od(t3) {
      return function() {
        this.removeAttribute(t3);
      };
    }
    function Pd(t3) {
      return function() {
        this.removeAttributeNS(t3.space, t3.local);
      };
    }
    function Qd(t3, r3) {
      return function() {
        this.setAttribute(t3, r3);
      };
    }
    function Rd(t3, r3) {
      return function() {
        this.setAttributeNS(t3.space, t3.local, r3);
      };
    }
    function Sd(t3, r3) {
      return function() {
        var e3 = r3.apply(this, arguments);
        e3 == null ? this.removeAttribute(t3) : this.setAttribute(t3, e3);
      };
    }
    function Td(t3, r3) {
      return function() {
        var e3 = r3.apply(this, arguments);
        e3 == null ? this.removeAttributeNS(t3.space, t3.local) : this.setAttributeNS(t3.space, t3.local, e3);
      };
    }
    var Ha = "http://www.w3.org/1999/xhtml";
    var Cb = {svg: "http://www.w3.org/2000/svg", xhtml: Ha, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/"};
    var Db = function(e3) {
      var $3 = e3 += "", a3 = $3.indexOf(":");
      return a3 >= 0 && ($3 = e3.slice(0, a3)) !== "xmlns" && (e3 = e3.slice(a3 + 1)), Cb.hasOwnProperty($3) ? {space: Cb[$3], local: e3} : e3;
    };
    var Ud = function(t3, r3) {
      var e3 = Db(t3);
      if (arguments.length < 2) {
        var a3 = this.node();
        return e3.local ? a3.getAttributeNS(e3.space, e3.local) : a3.getAttribute(e3);
      }
      return this.each((r3 == null ? e3.local ? Pd : Od : typeof r3 == "function" ? e3.local ? Td : Sd : e3.local ? Rd : Qd)(e3, r3));
    };
    function Vd(e3) {
      return function() {
        this.style.removeProperty(e3);
      };
    }
    function Wd(e3, t3, r3) {
      return function() {
        this.style.setProperty(e3, t3, r3);
      };
    }
    function Xd(e3, t3, r3) {
      return function() {
        var $3 = t3.apply(this, arguments);
        $3 == null ? this.style.removeProperty(e3) : this.style.setProperty(e3, $3, r3);
      };
    }
    var Eb = function(e3) {
      return e3.ownerDocument && e3.ownerDocument.defaultView || e3.document && e3 || e3.defaultView;
    };
    var Yd = function(e3, t3, r3) {
      return arguments.length > 1 ? this.each((t3 == null ? Vd : typeof t3 == "function" ? Xd : Wd)(e3, t3, r3 == null ? "" : r3)) : Zd(this.node(), e3);
    };
    function Zd(e3, t3) {
      return e3.style.getPropertyValue(t3) || Eb(e3).getComputedStyle(e3, null).getPropertyValue(t3);
    }
    function $d(r3) {
      return function() {
        delete this[r3];
      };
    }
    function _d(r3, t3) {
      return function() {
        this[r3] = t3;
      };
    }
    function ae2(r3, t3) {
      return function() {
        var n3 = t3.apply(this, arguments);
        n3 == null ? delete this[r3] : this[r3] = n3;
      };
    }
    var be2 = function(r3, t3) {
      return arguments.length > 1 ? this.each((t3 == null ? $d : typeof t3 == "function" ? ae2 : _d)(r3, t3)) : this.node()[r3];
    };
    function Fb(s3) {
      return s3.trim().split(/^|\s+/);
    }
    function Ia(s3) {
      return s3.classList || new Gb(s3);
    }
    function Gb(s3) {
      this._node = s3, this._names = Fb(s3.getAttribute("class") || "");
    }
    function Hb(s3, t3) {
      for (var a3 = Ia(s3), $3 = -1, e3 = t3.length; ++$3 < e3; )
        a3.add(t3[$3]);
    }
    function Ib(s3, t3) {
      for (var a3 = Ia(s3), $3 = -1, e3 = t3.length; ++$3 < e3; )
        a3.remove(t3[$3]);
    }
    function ce2(s3) {
      return function() {
        Hb(this, s3);
      };
    }
    function de2(s3) {
      return function() {
        Ib(this, s3);
      };
    }
    function ee2(s3, t3) {
      return function() {
        (t3.apply(this, arguments) ? Hb : Ib)(this, s3);
      };
    }
    Gb.prototype = {add: function(s3) {
      this._names.indexOf(s3) < 0 && (this._names.push(s3), this._node.setAttribute("class", this._names.join(" ")));
    }, remove: function(s3) {
      var t3 = this._names.indexOf(s3);
      t3 >= 0 && (this._names.splice(t3, 1), this._node.setAttribute("class", this._names.join(" ")));
    }, contains: function(s3) {
      return this._names.indexOf(s3) >= 0;
    }};
    var fe2 = function(s3, t3) {
      var a3 = Fb(s3 + "");
      if (arguments.length < 2) {
        for (var $3 = Ia(this.node()), e3 = -1, n3 = a3.length; ++e3 < n3; )
          if (!$3.contains(a3[e3]))
            return false;
        return true;
      }
      return this.each((typeof t3 == "function" ? ee2 : t3 ? ce2 : de2)(a3, t3));
    };
    function ge2() {
      this.textContent = "";
    }
    function he2(t3) {
      return function() {
        this.textContent = t3;
      };
    }
    function ie2(t3) {
      return function() {
        var n3 = t3.apply(this, arguments);
        this.textContent = n3 == null ? "" : n3;
      };
    }
    var je2 = function(t3) {
      return arguments.length ? this.each(t3 == null ? ge2 : (typeof t3 == "function" ? ie2 : he2)(t3)) : this.node().textContent;
    };
    function ke2() {
      this.innerHTML = "";
    }
    function le2(n3) {
      return function() {
        this.innerHTML = n3;
      };
    }
    function me2(n3) {
      return function() {
        var t3 = n3.apply(this, arguments);
        this.innerHTML = t3 == null ? "" : t3;
      };
    }
    var ne2 = function(n3) {
      return arguments.length ? this.each(n3 == null ? ke2 : (typeof n3 == "function" ? me2 : le2)(n3)) : this.node().innerHTML;
    };
    function oe2() {
      this.nextSibling && this.parentNode.appendChild(this);
    }
    var pe2 = function() {
      return this.each(oe2);
    };
    function qe2() {
      this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    var re2 = function() {
      return this.each(qe2);
    };
    function se2(e3) {
      return function() {
        var r3 = this.ownerDocument, t3 = this.namespaceURI;
        return t3 === Ha && r3.documentElement.namespaceURI === Ha ? r3.createElement(e3) : r3.createElementNS(t3, e3);
      };
    }
    function te2(e3) {
      return function() {
        return this.ownerDocument.createElementNS(e3.space, e3.local);
      };
    }
    var Jb = function(e3) {
      var r3 = Db(e3);
      return (r3.local ? te2 : se2)(r3);
    };
    var ue2 = function(t3) {
      var r3 = typeof t3 == "function" ? t3 : Jb(t3);
      return this.select(function() {
        return this.appendChild(r3.apply(this, arguments));
      });
    };
    function ve2() {
      return null;
    }
    var we2 = function(t3, r3) {
      var e3 = typeof t3 == "function" ? t3 : Jb(t3), $3 = r3 == null ? ve2 : typeof r3 == "function" ? r3 : zb(r3);
      return this.select(function() {
        return this.insertBefore(e3.apply(this, arguments), $3.apply(this, arguments) || null);
      });
    };
    function xe2() {
      var e3 = this.parentNode;
      e3 && e3.removeChild(this);
    }
    var ye2 = function() {
      return this.each(xe2);
    };
    function ze2() {
      return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
    }
    function Ae2() {
      return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
    }
    var Be2 = function(e3) {
      return this.select(e3 ? Ae2 : ze2);
    };
    var Ce2 = function(t3) {
      return arguments.length ? this.property("__data__", t3) : this.node().__data__;
    };
    var De2 = {}, Kb = null;
    if (typeof document != "undefined") {
      var Ee2 = document.documentElement;
      "onmouseenter" in Ee2 || (De2 = {mouseenter: "mouseover", mouseleave: "mouseout"});
    }
    function Fe2(e3, t3, n3) {
      return e3 = Lb(e3, t3, n3), function(t4) {
        var n4 = t4.relatedTarget;
        n4 && (n4 === this || 8 & n4.compareDocumentPosition(this)) || e3.call(this, t4);
      };
    }
    function Lb(e3, t3, n3) {
      return function(r3) {
        var $3 = Kb;
        Kb = r3;
        try {
          e3.call(this, this.__data__, t3, n3);
        } finally {
          Kb = $3;
        }
      };
    }
    function Ge2(e3) {
      return e3.trim().split(/^|\s+/).map(function(e4) {
        var t3 = "", n3 = e4.indexOf(".");
        return n3 >= 0 && (t3 = e4.slice(n3 + 1), e4 = e4.slice(0, n3)), {type: e4, name: t3};
      });
    }
    function He2(e3) {
      return function() {
        var t3 = this.__on;
        if (t3) {
          for (var n3, r3 = 0, $3 = -1, i3 = t3.length; r3 < i3; ++r3)
            n3 = t3[r3], e3.type && n3.type !== e3.type || n3.name !== e3.name ? t3[++$3] = n3 : this.removeEventListener(n3.type, n3.listener, n3.capture);
          ++$3 ? t3.length = $3 : delete this.__on;
        }
      };
    }
    function Ie2(e3, t3, n3) {
      var r3 = De2.hasOwnProperty(e3.type) ? Fe2 : Lb;
      return function($3, i3, p3) {
        var o3, a3 = this.__on, v3 = r3(t3, i3, p3);
        if (a3) {
          for (var s3 = 0, u3 = a3.length; s3 < u3; ++s3)
            if ((o3 = a3[s3]).type === e3.type && o3.name === e3.name)
              return this.removeEventListener(o3.type, o3.listener, o3.capture), this.addEventListener(o3.type, o3.listener = v3, o3.capture = n3), void (o3.value = t3);
        }
        this.addEventListener(e3.type, v3, n3), o3 = {type: e3.type, name: e3.name, value: t3, listener: v3, capture: n3}, a3 ? a3.push(o3) : this.__on = [o3];
      };
    }
    var Je2 = function(e3, t3, n3) {
      var r3, $3, i3 = Ge2(e3 + ""), p3 = i3.length;
      if (!(arguments.length < 2)) {
        for (o3 = t3 ? Ie2 : He2, n3 == null && (n3 = false), r3 = 0; r3 < p3; ++r3)
          this.each(o3(i3[r3], t3, n3));
        return this;
      }
      var o3 = this.node().__on;
      if (o3) {
        for (var a3, v3 = 0, s3 = o3.length; v3 < s3; ++v3)
          for (r3 = 0, a3 = o3[v3]; r3 < p3; ++r3)
            if (($3 = i3[r3]).type === a3.type && $3.name === a3.name)
              return a3.value;
      }
    };
    function Mb(t3, n3, e3) {
      var $3 = Eb(t3), a3 = $3.CustomEvent;
      typeof a3 == "function" ? a3 = new a3(n3, e3) : (a3 = $3.document.createEvent("Event"), e3 ? (a3.initEvent(n3, e3.bubbles, e3.cancelable), a3.detail = e3.detail) : a3.initEvent(n3, false, false)), t3.dispatchEvent(a3);
    }
    function Ke2(t3, n3) {
      return function() {
        return Mb(this, t3, n3);
      };
    }
    function Le2(t3, n3) {
      return function() {
        return Mb(this, t3, n3.apply(this, arguments));
      };
    }
    var Me2 = function(t3, n3) {
      return this.each((typeof n3 == "function" ? Le2 : Ke2)(t3, n3));
    };
    var Ne2 = [null];
    function m2(e3, $3) {
      this._groups = e3, this._parents = $3;
    }
    m2.prototype = {constructor: m2, select: rd, selectAll: ud, filter: wd, data: Bd, enter: xd, exit: Cd, join: Dd, merge: Ed, order: Fd, sort: Gd, call: Id, nodes: Jd, node: Kd, size: Ld, empty: Md, each: Nd, attr: Ud, style: Yd, property: be2, classed: fe2, text: je2, html: ne2, raise: pe2, lower: re2, append: ue2, insert: we2, remove: ye2, clone: Be2, datum: Ce2, on: Je2, dispatch: Me2};
    var f2 = function(e3) {
      return typeof e3 == "string" ? new m2([[document.querySelector(e3)]], [document.documentElement]) : new m2([[e3]], Ne2);
    };
    var Oe2 = function() {
      for (var e3, r3 = Kb; e3 = r3.sourceEvent; )
        r3 = e3;
      return r3;
    };
    var Pe2 = function(e3, t3) {
      var n3 = e3.ownerSVGElement || e3;
      if (n3.createSVGPoint) {
        var r3 = n3.createSVGPoint();
        return r3.x = t3.clientX, r3.y = t3.clientY, [(r3 = r3.matrixTransform(e3.getScreenCTM().inverse())).x, r3.y];
      }
      var i3 = e3.getBoundingClientRect();
      return [t3.clientX - i3.left - e3.clientLeft, t3.clientY - i3.top - e3.clientTop];
    };
    var w3 = function(e3) {
      var $3 = Oe2();
      return $3.changedTouches && ($3 = $3.changedTouches[0]), Pe2(e3, $3);
    };
    function ja() {
      var n3, r3, t3 = Sb().unknown(void 0), e3 = t3.domain, i3 = t3.range, u3 = 0, a3 = 1, o3 = false, $3 = 0, l3 = 0, g3 = 0.5;
      function d3() {
        var t4 = e3().length, d4 = a3 < u3, p3 = d4 ? a3 : u3, c3 = d4 ? u3 : a3;
        n3 = (c3 - p3) / Math.max(1, t4 - $3 + 2 * l3), o3 && (n3 = Math.floor(n3)), p3 += (c3 - p3 - n3 * (t4 - $3)) * g3, r3 = n3 * (1 - $3), o3 && (p3 = Math.round(p3), r3 = Math.round(r3));
        var f3 = Te2(t4).map(function(r4) {
          return p3 + n3 * r4;
        });
        return i3(d4 ? f3.reverse() : f3);
      }
      return delete t3.unknown, t3.domain = function(n4) {
        return arguments.length ? (e3(n4), d3()) : e3();
      }, t3.range = function(n4) {
        return arguments.length ? ([u3, a3] = n4, u3 = +u3, a3 = +a3, d3()) : [u3, a3];
      }, t3.rangeRound = function(n4) {
        return [u3, a3] = n4, u3 = +u3, a3 = +a3, o3 = true, d3();
      }, t3.bandwidth = function() {
        return r3;
      }, t3.step = function() {
        return n3;
      }, t3.round = function(n4) {
        return arguments.length ? (o3 = !!n4, d3()) : o3;
      }, t3.padding = function(n4) {
        return arguments.length ? ($3 = Math.min(1, l3 = +n4), d3()) : $3;
      }, t3.paddingInner = function(n4) {
        return arguments.length ? ($3 = Math.min(1, n4), d3()) : $3;
      }, t3.paddingOuter = function(n4) {
        return arguments.length ? (l3 = +n4, d3()) : l3;
      }, t3.align = function(n4) {
        return arguments.length ? (g3 = Math.max(0, Math.min(1, n4)), d3()) : g3;
      }, t3.copy = function() {
        return ja(e3(), [u3, a3]).round(o3).paddingInner($3).paddingOuter(l3).align(g3);
      }, la.apply(d3(), arguments);
    }
    function Nb(n3) {
      var r3 = n3.copy;
      return n3.padding = n3.paddingOuter, delete n3.paddingInner, delete n3.paddingOuter, n3.copy = function() {
        return Nb(r3());
      }, n3;
    }
    function Qe2() {
      return Nb(ja.apply(null, arguments).paddingInner(1));
    }
    var Ob = function($3, t3) {
      return $3 < t3 ? -1 : $3 > t3 ? 1 : $3 >= t3 ? 0 : NaN;
    };
    var Pb = function(r3) {
      return r3.length === 1 && (r3 = Re2(r3)), {left: function(n3, t3, e3, $3) {
        for (e3 == null && (e3 = 0), $3 == null && ($3 = n3.length); e3 < $3; ) {
          var a3 = e3 + $3 >>> 1;
          r3(n3[a3], t3) < 0 ? e3 = a3 + 1 : $3 = a3;
        }
        return e3;
      }, right: function(n3, t3, e3, $3) {
        for (e3 == null && (e3 = 0), $3 == null && ($3 = n3.length); e3 < $3; ) {
          var a3 = e3 + $3 >>> 1;
          r3(n3[a3], t3) > 0 ? $3 = a3 : e3 = a3 + 1;
        }
        return e3;
      }};
    };
    function Re2(r3) {
      return function(n3, t3) {
        return Ob(r3(n3), t3);
      };
    }
    var Qb = Pb(Ob), Se2 = Qb.right;
    var ci = Qb.left;
    var Te2 = function(t3, e3, r3) {
      t3 = +t3, e3 = +e3, r3 = (a3 = arguments.length) < 2 ? (e3 = t3, t3 = 0, 1) : a3 < 3 ? 1 : +r3;
      for (var $3 = -1, a3 = 0 | Math.max(0, Math.ceil((e3 - t3) / r3)), c3 = new Array(a3); ++$3 < a3; )
        c3[$3] = t3 + $3 * r3;
      return c3;
    };
    var Ja = Math.sqrt(50), Ka = Math.sqrt(10), La = Math.sqrt(2), Ue2 = function($3, t3, r3) {
      var e3, a3, o3, g3, z3 = -1;
      if (r3 = +r3, ($3 = +$3) === (t3 = +t3) && r3 > 0)
        return [$3];
      if ((e3 = t3 < $3) && (a3 = $3, $3 = t3, t3 = a3), (g3 = ka($3, t3, r3)) === 0 || !isFinite(g3))
        return [];
      if (g3 > 0)
        for ($3 = Math.ceil($3 / g3), t3 = Math.floor(t3 / g3), o3 = new Array(a3 = Math.ceil(t3 - $3 + 1)); ++z3 < a3; )
          o3[z3] = ($3 + z3) * g3;
      else
        for ($3 = Math.floor($3 * g3), t3 = Math.ceil(t3 * g3), o3 = new Array(a3 = Math.ceil($3 - t3 + 1)); ++z3 < a3; )
          o3[z3] = ($3 - z3) / g3;
      return e3 && o3.reverse(), o3;
    };
    function ka($3, t3, r3) {
      var e3 = (t3 - $3) / Math.max(0, r3), a3 = Math.floor(Math.log(e3) / Math.LN10), o3 = e3 / Math.pow(10, a3);
      return a3 >= 0 ? (o3 >= Ja ? 10 : o3 >= Ka ? 5 : o3 >= La ? 2 : 1) * Math.pow(10, a3) : -Math.pow(10, -a3) / (o3 >= Ja ? 10 : o3 >= Ka ? 5 : o3 >= La ? 2 : 1);
    }
    function Ma($3, t3, r3) {
      var e3 = Math.abs(t3 - $3) / Math.max(0, r3), a3 = Math.pow(10, Math.floor(Math.log(e3) / Math.LN10)), o3 = e3 / a3;
      return o3 >= Ja ? a3 *= 10 : o3 >= Ka ? a3 *= 5 : o3 >= La && (a3 *= 2), t3 < $3 ? -a3 : a3;
    }
    function la(t3, e3) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(t3);
          break;
        default:
          this.range(e3).domain(t3);
      }
      return this;
    }
    const Rb = Symbol("implicit");
    function Sb() {
      var t3 = new Map(), n3 = [], e3 = [], r3 = Rb;
      function i3(i4) {
        var $3 = i4 + "", o3 = t3.get($3);
        if (!o3) {
          if (r3 !== Rb)
            return r3;
          t3.set($3, o3 = n3.push(i4));
        }
        return e3[(o3 - 1) % e3.length];
      }
      return i3.domain = function(e4) {
        if (!arguments.length)
          return n3.slice();
        n3 = [], t3 = new Map();
        for (const r4 of e4) {
          const e5 = r4 + "";
          t3.has(e5) || t3.set(e5, n3.push(r4));
        }
        return i3;
      }, i3.range = function(t4) {
        return arguments.length ? (e3 = Array.from(t4), i3) : e3.slice();
      }, i3.unknown = function(t4) {
        return arguments.length ? (r3 = t4, i3) : r3;
      }, i3.copy = function() {
        return Sb(n3, e3).unknown(r3);
      }, la.apply(i3, arguments), i3;
    }
    function Ve2(t3) {
      var r3 = t3.domain;
      return t3.ticks = function(t4) {
        var $3 = r3();
        return Ue2($3[0], $3[$3.length - 1], t4 == null ? 10 : t4);
      }, t3.tickFormat = function(t4, $3) {
        var e3 = r3();
        return Of(e3[0], e3[e3.length - 1], t4 == null ? 10 : t4, $3);
      }, t3.nice = function($3) {
        $3 == null && ($3 = 10);
        var e3, i3 = r3(), n3 = 0, o3 = i3.length - 1, a3 = i3[n3], k3 = i3[o3];
        return k3 < a3 && (e3 = a3, a3 = k3, k3 = e3, e3 = n3, n3 = o3, o3 = e3), (e3 = ka(a3, k3, $3)) > 0 ? (a3 = Math.floor(a3 / e3) * e3, k3 = Math.ceil(k3 / e3) * e3, e3 = ka(a3, k3, $3)) : e3 < 0 && (a3 = Math.ceil(a3 * e3) / e3, k3 = Math.floor(k3 * e3) / e3, e3 = ka(a3, k3, $3)), e3 > 0 ? (i3[n3] = Math.floor(a3 / e3) * e3, i3[o3] = Math.ceil(k3 / e3) * e3, r3(i3)) : e3 < 0 && (i3[n3] = Math.ceil(a3 * e3) / e3, i3[o3] = Math.floor(k3 * e3) / e3, r3(i3)), t3;
      }, t3;
    }
    function A2() {
      var t3 = Bc(z2, z2);
      return t3.copy = function() {
        return Ac(t3, A2());
      }, la.apply(t3, arguments), Ve2(t3);
    }
    function x2() {
    }
    var G2 = function(t3, e3, r3) {
      t3.prototype = e3.prototype = r3, r3.constructor = t3;
    };
    function P2(t3, e3) {
      var r3 = Object.create(t3.prototype);
      for (var o3 in e3)
        r3[o3] = e3[o3];
      return r3;
    }
    var t2 = 0.7;
    var H2 = 1 / t2;
    var I2 = "\\s*([+-]?\\d+)\\s*", R2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", e2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", We2 = /^#([0-9a-f]{3})$/, Xe2 = /^#([0-9a-f]{6})$/, Ye2 = new RegExp("^rgb\\(" + [I2, I2, I2] + "\\)$"), Ze2 = new RegExp("^rgb\\(" + [e2, e2, e2] + "\\)$"), $e2 = new RegExp("^rgba\\(" + [I2, I2, I2, R2] + "\\)$"), _e2 = new RegExp("^rgba\\(" + [e2, e2, e2, R2] + "\\)$"), af = new RegExp("^hsl\\(" + [R2, e2, e2] + "\\)$"), bf = new RegExp("^hsla\\(" + [R2, e2, e2, R2] + "\\)$"), Tb = {aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074};
    function Ub() {
      return this.rgb().formatHex();
    }
    function cf() {
      return _b(this).formatHsl();
    }
    function Vb() {
      return this.rgb().formatRgb();
    }
    function S2(r3) {
      var a3;
      return r3 = (r3 + "").trim().toLowerCase(), (a3 = We2.exec(r3)) ? new g2((a3 = parseInt(a3[1], 16)) >> 8 & 15 | a3 >> 4 & 240, a3 >> 4 & 15 | 240 & a3, (15 & a3) << 4 | 15 & a3, 1) : (a3 = Xe2.exec(r3)) ? Wb(parseInt(a3[1], 16)) : (a3 = Ye2.exec(r3)) ? new g2(a3[1], a3[2], a3[3], 1) : (a3 = Ze2.exec(r3)) ? new g2(255 * a3[1] / 100, 255 * a3[2] / 100, 255 * a3[3] / 100, 1) : (a3 = $e2.exec(r3)) ? Xb(a3[1], a3[2], a3[3], a3[4]) : (a3 = _e2.exec(r3)) ? Xb(255 * a3[1] / 100, 255 * a3[2] / 100, 255 * a3[3] / 100, a3[4]) : (a3 = af.exec(r3)) ? $b(a3[1], a3[2] / 100, a3[3] / 100, 1) : (a3 = bf.exec(r3)) ? $b(a3[1], a3[2] / 100, a3[3] / 100, a3[4]) : Tb.hasOwnProperty(r3) ? Wb(Tb[r3]) : r3 === "transparent" ? new g2(NaN, NaN, NaN, 0) : null;
    }
    function Wb(r3) {
      return new g2(r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3, 1);
    }
    function Xb(r3, a3, e3, $3) {
      return $3 <= 0 && (r3 = a3 = e3 = NaN), new g2(r3, a3, e3, $3);
    }
    function Na(r3) {
      return r3 instanceof x2 || (r3 = S2(r3)), r3 ? new g2((r3 = r3.rgb()).r, r3.g, r3.b, r3.opacity) : new g2();
    }
    function ma(r3, a3, e3, $3) {
      return arguments.length === 1 ? Na(r3) : new g2(r3, a3, e3, $3 == null ? 1 : $3);
    }
    function g2(r3, a3, e3, $3) {
      this.r = +r3, this.g = +a3, this.b = +e3, this.opacity = +$3;
    }
    function Yb() {
      return "#" + Oa(this.r) + Oa(this.g) + Oa(this.b);
    }
    function Zb() {
      var r3 = this.opacity;
      return ((r3 = isNaN(r3) ? 1 : Math.max(0, Math.min(1, r3))) === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (r3 === 1 ? ")" : ", " + r3 + ")");
    }
    function Oa(r3) {
      return ((r3 = Math.max(0, Math.min(255, Math.round(r3) || 0))) < 16 ? "0" : "") + r3.toString(16);
    }
    function $b(r3, a3, e3, $3) {
      return $3 <= 0 ? r3 = a3 = e3 = NaN : e3 <= 0 || e3 >= 1 ? r3 = a3 = NaN : a3 <= 0 && (r3 = NaN), new s2(r3, a3, e3, $3);
    }
    function _b(r3) {
      if (r3 instanceof s2)
        return new s2(r3.h, r3.s, r3.l, r3.opacity);
      if (r3 instanceof x2 || (r3 = S2(r3)), !r3)
        return new s2();
      if (r3 instanceof s2)
        return r3;
      var a3 = (r3 = r3.rgb()).r / 255, e3 = r3.g / 255, $3 = r3.b / 255, t3 = Math.min(a3, e3, $3), o3 = Math.max(a3, e3, $3), n3 = NaN, i3 = o3 - t3, f3 = (o3 + t3) / 2;
      return i3 ? (n3 = a3 === o3 ? (e3 - $3) / i3 + 6 * (e3 < $3) : e3 === o3 ? ($3 - a3) / i3 + 2 : (a3 - e3) / i3 + 4, i3 /= f3 < 0.5 ? o3 + t3 : 2 - o3 - t3, n3 *= 60) : i3 = f3 > 0 && f3 < 1 ? 0 : n3, new s2(n3, i3, f3, r3.opacity);
    }
    function Pa(r3, a3, e3, $3) {
      return arguments.length === 1 ? _b(r3) : new s2(r3, a3, e3, $3 == null ? 1 : $3);
    }
    function s2(r3, a3, e3, $3) {
      this.h = +r3, this.s = +a3, this.l = +e3, this.opacity = +$3;
    }
    function Qa(r3, a3, e3) {
      return 255 * (r3 < 60 ? a3 + (e3 - a3) * r3 / 60 : r3 < 180 ? e3 : r3 < 240 ? a3 + (e3 - a3) * (240 - r3) / 60 : a3);
    }
    G2(x2, S2, {copy: function(r3) {
      return Object.assign(new this.constructor(), this, r3);
    }, displayable: function() {
      return this.rgb().displayable();
    }, hex: Ub, formatHex: Ub, formatHsl: cf, formatRgb: Vb, toString: Vb}), G2(g2, ma, P2(x2, {brighter: function(r3) {
      return r3 = r3 == null ? H2 : Math.pow(H2, r3), new g2(this.r * r3, this.g * r3, this.b * r3, this.opacity);
    }, darker: function(r3) {
      return r3 = r3 == null ? t2 : Math.pow(t2, r3), new g2(this.r * r3, this.g * r3, this.b * r3, this.opacity);
    }, rgb: function() {
      return this;
    }, displayable: function() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    }, hex: Yb, formatHex: Yb, formatRgb: Zb, toString: Zb})), G2(s2, Pa, P2(x2, {brighter: function(r3) {
      return r3 = r3 == null ? H2 : Math.pow(H2, r3), new s2(this.h, this.s, this.l * r3, this.opacity);
    }, darker: function(r3) {
      return r3 = r3 == null ? t2 : Math.pow(t2, r3), new s2(this.h, this.s, this.l * r3, this.opacity);
    }, rgb: function() {
      var r3 = this.h % 360 + 360 * (this.h < 0), a3 = isNaN(r3) || isNaN(this.s) ? 0 : this.s, e3 = this.l, $3 = e3 + (e3 < 0.5 ? e3 : 1 - e3) * a3, t3 = 2 * e3 - $3;
      return new g2(Qa(r3 >= 240 ? r3 - 240 : r3 + 120, t3, $3), Qa(r3, t3, $3), Qa(r3 < 120 ? r3 + 240 : r3 - 120, t3, $3), this.opacity);
    }, displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    }, formatHsl: function() {
      var r3 = this.opacity;
      return ((r3 = isNaN(r3) ? 1 : Math.max(0, Math.min(1, r3))) === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + 100 * (this.s || 0) + "%, " + 100 * (this.l || 0) + "%" + (r3 === 1 ? ")" : ", " + r3 + ")");
    }}));
    var ac = Math.PI / 180;
    var bc = 180 / Math.PI;
    var na = 18, cc = 0.96422, dc = 1, ec = 0.82521, fc = 4 / 29, J2 = 6 / 29, gc = 3 * J2 * J2, df = J2 * J2 * J2;
    function hc($3) {
      if ($3 instanceof i2)
        return new i2($3.l, $3.a, $3.b, $3.opacity);
      if ($3 instanceof n2)
        return ic($3);
      $3 instanceof g2 || ($3 = Na($3));
      var r3, t3, v3 = Ua($3.r), a3 = Ua($3.g), f3 = Ua($3.b), e3 = Ra((0.2225045 * v3 + 0.7168786 * a3 + 0.0606169 * f3) / dc);
      return v3 === a3 && a3 === f3 ? r3 = t3 = e3 : (r3 = Ra((0.4360747 * v3 + 0.3850649 * a3 + 0.1430804 * f3) / cc), t3 = Ra((0.0139322 * v3 + 0.0971045 * a3 + 0.7141733 * f3) / ec)), new i2(116 * e3 - 16, 500 * (r3 - e3), 200 * (e3 - t3), $3.opacity);
    }
    function ef($3, r3, t3, v3) {
      return arguments.length === 1 ? hc($3) : new i2($3, r3, t3, v3 == null ? 1 : v3);
    }
    function i2($3, r3, t3, v3) {
      this.l = +$3, this.a = +r3, this.b = +t3, this.opacity = +v3;
    }
    function Ra($3) {
      return $3 > df ? Math.pow($3, 1 / 3) : $3 / gc + fc;
    }
    function Sa($3) {
      return $3 > J2 ? $3 * $3 * $3 : gc * ($3 - fc);
    }
    function Ta($3) {
      return 255 * ($3 <= 31308e-7 ? 12.92 * $3 : 1.055 * Math.pow($3, 1 / 2.4) - 0.055);
    }
    function Ua($3) {
      return ($3 /= 255) <= 0.04045 ? $3 / 12.92 : Math.pow(($3 + 0.055) / 1.055, 2.4);
    }
    function ff($3) {
      if ($3 instanceof n2)
        return new n2($3.h, $3.c, $3.l, $3.opacity);
      if ($3 instanceof i2 || ($3 = hc($3)), $3.a === 0 && $3.b === 0)
        return new n2(NaN, 0 < $3.l && $3.l < 100 ? 0 : NaN, $3.l, $3.opacity);
      var r3 = Math.atan2($3.b, $3.a) * bc;
      return new n2(r3 < 0 ? r3 + 360 : r3, Math.sqrt($3.a * $3.a + $3.b * $3.b), $3.l, $3.opacity);
    }
    function Va($3, r3, t3, v3) {
      return arguments.length === 1 ? ff($3) : new n2($3, r3, t3, v3 == null ? 1 : v3);
    }
    function n2($3, r3, t3, v3) {
      this.h = +$3, this.c = +r3, this.l = +t3, this.opacity = +v3;
    }
    function ic($3) {
      if (isNaN($3.h))
        return new i2($3.l, 0, 0, $3.opacity);
      var r3 = $3.h * ac;
      return new i2($3.l, Math.cos(r3) * $3.c, Math.sin(r3) * $3.c, $3.opacity);
    }
    G2(i2, ef, P2(x2, {brighter: function($3) {
      return new i2(this.l + na * ($3 == null ? 1 : $3), this.a, this.b, this.opacity);
    }, darker: function($3) {
      return new i2(this.l - na * ($3 == null ? 1 : $3), this.a, this.b, this.opacity);
    }, rgb: function() {
      var $3 = (this.l + 16) / 116, r3 = isNaN(this.a) ? $3 : $3 + this.a / 500, t3 = isNaN(this.b) ? $3 : $3 - this.b / 200;
      return r3 = cc * Sa(r3), $3 = dc * Sa($3), t3 = ec * Sa(t3), new g2(Ta(3.1338561 * r3 - 1.6168667 * $3 - 0.4906146 * t3), Ta(-0.9787684 * r3 + 1.9161415 * $3 + 0.033454 * t3), Ta(0.0719453 * r3 - 0.2289914 * $3 + 1.4052427 * t3), this.opacity);
    }})), G2(n2, Va, P2(x2, {brighter: function($3) {
      return new n2(this.h, this.c, this.l + na * ($3 == null ? 1 : $3), this.opacity);
    }, darker: function($3) {
      return new n2(this.h, this.c, this.l - na * ($3 == null ? 1 : $3), this.opacity);
    }, rgb: function() {
      return ic(this).rgb();
    }}));
    var jc = -0.14861, Wa = 1.78277, Xa = -0.29227, oa = -0.90649, T2 = 1.97294, kc = T2 * oa, lc = T2 * Wa, mc = Wa * Xa - oa * jc;
    function gf($3) {
      if ($3 instanceof B2)
        return new B2($3.h, $3.s, $3.l, $3.opacity);
      $3 instanceof g2 || ($3 = Na($3));
      var r3 = $3.r / 255, t3 = $3.g / 255, e3 = $3.b / 255, C3 = (mc * e3 + kc * r3 - lc * t3) / (mc + kc - lc), a3 = e3 - C3, M3 = (T2 * (t3 - C3) - Xa * a3) / oa, i3 = Math.sqrt(M3 * M3 + a3 * a3) / (T2 * C3 * (1 - C3)), X3 = i3 ? Math.atan2(M3, a3) * bc - 120 : NaN;
      return new B2(X3 < 0 ? X3 + 360 : X3, i3, C3, $3.opacity);
    }
    function Ya($3, r3, t3, e3) {
      return arguments.length === 1 ? gf($3) : new B2($3, r3, t3, e3 == null ? 1 : e3);
    }
    function B2($3, r3, t3, e3) {
      this.h = +$3, this.s = +r3, this.l = +t3, this.opacity = +e3;
    }
    G2(B2, Ya, P2(x2, {brighter: function($3) {
      return $3 = $3 == null ? H2 : Math.pow(H2, $3), new B2(this.h, this.s, this.l * $3, this.opacity);
    }, darker: function($3) {
      return $3 = $3 == null ? t2 : Math.pow(t2, $3), new B2(this.h, this.s, this.l * $3, this.opacity);
    }, rgb: function() {
      var $3 = isNaN(this.h) ? 0 : (this.h + 120) * ac, r3 = +this.l, t3 = isNaN(this.s) ? 0 : this.s * r3 * (1 - r3), e3 = Math.cos($3), C3 = Math.sin($3);
      return new g2(255 * (r3 + t3 * (jc * e3 + Wa * C3)), 255 * (r3 + t3 * (Xa * e3 + oa * C3)), 255 * (r3 + t3 * (T2 * e3)), this.opacity);
    }}));
    function nc($3, r3, t3, e3, a3) {
      var l3 = $3 * $3, o3 = l3 * $3;
      return ((1 - 3 * $3 + 3 * l3 - o3) * r3 + (4 - 6 * l3 + 3 * o3) * t3 + (1 + 3 * $3 + 3 * l3 - 3 * o3) * e3 + o3 * a3) / 6;
    }
    var hf = function($3) {
      var r3 = $3.length - 1;
      return function(t3) {
        var e3 = t3 <= 0 ? t3 = 0 : t3 >= 1 ? (t3 = 1, r3 - 1) : Math.floor(t3 * r3), a3 = $3[e3], l3 = $3[e3 + 1], o3 = e3 > 0 ? $3[e3 - 1] : 2 * a3 - l3, s3 = e3 < r3 - 1 ? $3[e3 + 2] : 2 * l3 - a3;
        return nc((t3 - e3 / r3) * r3, o3, a3, l3, s3);
      };
    };
    var jf = function(r3) {
      var $3 = r3.length;
      return function(t3) {
        var e3 = Math.floor(((t3 %= 1) < 0 ? ++t3 : t3) * $3), n3 = r3[(e3 + $3 - 1) % $3], a3 = r3[e3 % $3], o3 = r3[(e3 + 1) % $3], h3 = r3[(e3 + 2) % $3];
        return nc((t3 - e3 / $3) * $3, n3, a3, o3, h3);
      };
    };
    function oc($3, t3) {
      return function(r3) {
        return $3 + r3 * t3;
      };
    }
    function kf($3, t3, r3) {
      return $3 = Math.pow($3, r3), t3 = Math.pow(t3, r3) - $3, r3 = 1 / r3, function(n3) {
        return Math.pow($3 + n3 * t3, r3);
      };
    }
    function Za($3, t3) {
      var r3 = t3 - $3;
      return r3 ? oc($3, r3 > 180 || r3 < -180 ? r3 - 360 * Math.round(r3 / 360) : r3) : pa(isNaN($3) ? t3 : $3);
    }
    function lf($3) {
      return ($3 = +$3) == 1 ? j2 : function(t3, r3) {
        return r3 - t3 ? kf(t3, r3, $3) : pa(isNaN(t3) ? r3 : t3);
      };
    }
    function j2($3, t3) {
      var r3 = t3 - $3;
      return r3 ? oc($3, r3) : pa(isNaN($3) ? t3 : $3);
    }
    var pa = function(t3) {
      return function() {
        return t3;
      };
    };
    var pc = function r3($3) {
      var o3 = lf($3);
      function e3(r4, $4) {
        var e4 = o3((r4 = ma(r4)).r, ($4 = ma($4)).r), a3 = o3(r4.g, $4.g), t3 = o3(r4.b, $4.b), i3 = j2(r4.opacity, $4.opacity);
        return function($5) {
          return r4.r = e4($5), r4.g = a3($5), r4.b = t3($5), r4.opacity = i3($5), r4 + "";
        };
      }
      return e3.gamma = r3, e3;
    }(1);
    function qc(r3) {
      return function($3) {
        var o3, e3, a3 = $3.length, t3 = new Array(a3), i3 = new Array(a3), v3 = new Array(a3);
        for (o3 = 0; o3 < a3; ++o3)
          e3 = ma($3[o3]), t3[o3] = e3.r || 0, i3[o3] = e3.g || 0, v3[o3] = e3.b || 0;
        return t3 = r3(t3), i3 = r3(i3), v3 = r3(v3), e3.opacity = 1, function(r4) {
          return e3.r = t3(r4), e3.g = i3(r4), e3.b = v3(r4), e3 + "";
        };
      };
    }
    var di = qc(hf);
    var ei = qc(jf);
    var mf = function(r3, e3) {
      var t3, $3 = e3 ? e3.length : 0, a3 = r3 ? Math.min($3, r3.length) : 0, n3 = new Array(a3), o3 = new Array($3);
      for (t3 = 0; t3 < a3; ++t3)
        n3[t3] = ab(r3[t3], e3[t3]);
      for (; t3 < $3; ++t3)
        o3[t3] = e3[t3];
      return function(r4) {
        for (t3 = 0; t3 < a3; ++t3)
          o3[t3] = n3[t3](r4);
        return o3;
      };
    };
    var nf = function(e3, t3) {
      var r3 = new Date();
      return t3 -= e3 = +e3, function($3) {
        return r3.setTime(e3 + t3 * $3), r3;
      };
    };
    var v2 = function(t3, $3) {
      return $3 -= t3 = +t3, function(e3) {
        return t3 + $3 * e3;
      };
    };
    var of = function(e3, r3) {
      var t3, $3 = {}, i3 = {};
      for (t3 in e3 !== null && typeof e3 == "object" || (e3 = {}), r3 !== null && typeof r3 == "object" || (r3 = {}), r3)
        t3 in e3 ? $3[t3] = ab(e3[t3], r3[t3]) : i3[t3] = r3[t3];
      return function(e4) {
        for (t3 in $3)
          i3[t3] = $3[t3](e4);
        return i3;
      };
    };
    var $a = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, _a = new RegExp($a.source, "g");
    function pf(r3) {
      return function() {
        return r3;
      };
    }
    function qf(r3) {
      return function($3) {
        return r3($3) + "";
      };
    }
    var rf = function(r3, $3) {
      var n3, e3, t3, a3 = $a.lastIndex = _a.lastIndex = 0, u3 = -1, E3 = [], o3 = [];
      for (r3 += "", $3 += ""; (n3 = $a.exec(r3)) && (e3 = _a.exec($3)); )
        (t3 = e3.index) > a3 && (t3 = $3.slice(a3, t3), E3[u3] ? E3[u3] += t3 : E3[++u3] = t3), (n3 = n3[0]) === (e3 = e3[0]) ? E3[u3] ? E3[u3] += e3 : E3[++u3] = e3 : (E3[++u3] = null, o3.push({i: u3, x: v2(n3, e3)})), a3 = _a.lastIndex;
      return a3 < $3.length && (t3 = $3.slice(a3), E3[u3] ? E3[u3] += t3 : E3[++u3] = t3), E3.length < 2 ? o3[0] ? qf(o3[0].x) : pf($3) : ($3 = o3.length, function(r4) {
        for (var n4, e4 = 0; e4 < $3; ++e4)
          E3[(n4 = o3[e4]).i] = n4.x(r4);
        return E3.join("");
      });
    };
    var ab = function(r3, $3) {
      var e3, c3 = typeof $3;
      return $3 == null || c3 === "boolean" ? pa($3) : (c3 === "number" ? v2 : c3 === "string" ? (e3 = S2($3)) ? ($3 = e3, pc) : rf : $3 instanceof S2 ? pc : $3 instanceof Date ? nf : Array.isArray($3) ? mf : typeof $3.valueOf != "function" && typeof $3.toString != "function" || isNaN($3) ? of : v2)(r3, $3);
    };
    var sf = function(t3, n3) {
      return n3 -= t3 = +t3, function(r3) {
        return Math.round(t3 + n3 * r3);
      };
    };
    function rc(r3, e3, t3, l3) {
      function n3(r4) {
        return r4.length ? r4.pop() + " " : "";
      }
      return function(a3, $3) {
        var s3 = [], o3 = [];
        return a3 = r3(a3), $3 = r3($3), function(r4, l4, n4, a4, $4, s4) {
          if (r4 !== n4 || l4 !== a4) {
            var o4 = $4.push("translate(", null, e3, null, t3);
            s4.push({i: o4 - 4, x: v2(r4, n4)}, {i: o4 - 2, x: v2(l4, a4)});
          } else
            (n4 || a4) && $4.push("translate(" + n4 + e3 + a4 + t3);
        }(a3.translateX, a3.translateY, $3.translateX, $3.translateY, s3, o3), function(r4, e4, t4, a4) {
          r4 !== e4 ? (r4 - e4 > 180 ? e4 += 360 : e4 - r4 > 180 && (r4 += 360), a4.push({i: t4.push(n3(t4) + "rotate(", null, l3) - 2, x: v2(r4, e4)})) : e4 && t4.push(n3(t4) + "rotate(" + e4 + l3);
        }(a3.rotate, $3.rotate, s3, o3), function(r4, e4, t4, a4) {
          r4 !== e4 ? a4.push({i: t4.push(n3(t4) + "skewX(", null, l3) - 2, x: v2(r4, e4)}) : e4 && t4.push(n3(t4) + "skewX(" + e4 + l3);
        }(a3.skewX, $3.skewX, s3, o3), function(r4, e4, t4, l4, a4, $4) {
          if (r4 !== t4 || e4 !== l4) {
            var s4 = a4.push(n3(a4) + "scale(", null, ",", null, ")");
            $4.push({i: s4 - 4, x: v2(r4, t4)}, {i: s4 - 2, x: v2(e4, l4)});
          } else
            t4 === 1 && l4 === 1 || a4.push(n3(a4) + "scale(" + t4 + "," + l4 + ")");
        }(a3.scaleX, a3.scaleY, $3.scaleX, $3.scaleY, s3, o3), a3 = $3 = null, function(r4) {
          for (var e4, t4 = -1, l4 = o3.length; ++t4 < l4; )
            s3[(e4 = o3[t4]).i] = e4.x(r4);
          return s3.join("");
        };
      };
    }
    var qa, sc, tf, bb;
    function uf($3) {
      return $3 === "none" ? cb : (qa || (qa = document.createElement("DIV"), sc = document.documentElement, tf = document.defaultView), qa.style.transform = $3, $3 = tf.getComputedStyle(sc.appendChild(qa), null).getPropertyValue("transform"), sc.removeChild(qa), $3 = $3.slice(7, -1).split(","), uc(+$3[0], +$3[1], +$3[2], +$3[3], +$3[4], +$3[5]));
    }
    function vf($3) {
      return $3 == null ? cb : (bb || (bb = document.createElementNS("http://www.w3.org/2000/svg", "g")), bb.setAttribute("transform", $3), ($3 = bb.transform.baseVal.consolidate()) ? ($3 = $3.matrix, uc($3.a, $3.b, $3.c, $3.d, $3.e, $3.f)) : cb);
    }
    var tc = 180 / Math.PI, cb = {translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1};
    var uc = function(t3, e3, a3, $3, r3, s3) {
      var X3, n3, w4;
      return (X3 = Math.sqrt(t3 * t3 + e3 * e3)) && (t3 /= X3, e3 /= X3), (w4 = t3 * a3 + e3 * $3) && (a3 -= t3 * w4, $3 -= e3 * w4), (n3 = Math.sqrt(a3 * a3 + $3 * $3)) && (a3 /= n3, $3 /= n3, w4 /= n3), t3 * $3 < e3 * a3 && (t3 = -t3, e3 = -e3, w4 = -w4, X3 = -X3), {translateX: r3, translateY: s3, rotate: Math.atan2(e3, t3) * tc, skewX: Math.atan(w4) * tc, scaleX: X3, scaleY: n3};
    };
    var fi = rc(uf, "px, ", "px)", "deg)");
    var gi = rc(vf, ", ", ")", ")");
    var hi = Math.SQRT2;
    function vc($3) {
      return function(r3, e3) {
        var o3 = $3((r3 = Pa(r3)).h, (e3 = Pa(e3)).h), t3 = j2(r3.s, e3.s), l3 = j2(r3.l, e3.l), d3 = j2(r3.opacity, e3.opacity);
        return function($4) {
          return r3.h = o3($4), r3.s = t3($4), r3.l = l3($4), r3.opacity = d3($4), r3 + "";
        };
      };
    }
    var ii = vc(Za);
    var ji = vc(j2);
    function wc($3) {
      return function(r3, o3) {
        var c3 = $3((r3 = Va(r3)).h, (o3 = Va(o3)).h), t3 = j2(r3.c, o3.c), x3 = j2(r3.l, o3.l), l3 = j2(r3.opacity, o3.opacity);
        return function($4) {
          return r3.h = c3($4), r3.c = t3($4), r3.l = x3($4), r3.opacity = l3($4), r3 + "";
        };
      };
    }
    var ki = wc(Za);
    var li = wc(j2);
    function xc($3) {
      return function r3(o3) {
        function V3(r4, V4) {
          var e3 = $3((r4 = Ya(r4)).h, (V4 = Ya(V4)).h), t3 = j2(r4.s, V4.s), i3 = j2(r4.l, V4.l), l3 = j2(r4.opacity, V4.opacity);
          return function($4) {
            return r4.h = e3($4), r4.s = t3($4), r4.l = i3(Math.pow($4, o3)), r4.opacity = l3($4), r4 + "";
          };
        }
        return o3 = +o3, V3.gamma = r3, V3;
      }(1);
    }
    var mi = xc(Za);
    var ni = xc(j2);
    var wf = function(t3) {
      return function() {
        return t3;
      };
    };
    var xf = function($3) {
      return +$3;
    };
    var yc = [0, 1];
    function z2(r3) {
      return r3;
    }
    function db(r3, n3) {
      return (n3 -= r3 = +r3) ? function(t3) {
        return (t3 - r3) / n3;
      } : wf(isNaN(n3) ? NaN : 0.5);
    }
    function zc(r3) {
      var n3, t3 = r3[0], e3 = r3[r3.length - 1];
      return t3 > e3 && (n3 = t3, t3 = e3, e3 = n3), function(r4) {
        return Math.max(t3, Math.min(e3, r4));
      };
    }
    function yf(r3, n3, t3) {
      var e3 = r3[0], $3 = r3[1], a3 = n3[0], o3 = n3[1];
      return $3 < e3 ? (e3 = db($3, e3), a3 = t3(o3, a3)) : (e3 = db(e3, $3), a3 = t3(a3, o3)), function(r4) {
        return a3(e3(r4));
      };
    }
    function zf(r3, n3, t3) {
      var e3 = Math.min(r3.length, n3.length) - 1, $3 = new Array(e3), a3 = new Array(e3), o3 = -1;
      for (r3[e3] < r3[0] && (r3 = r3.slice().reverse(), n3 = n3.slice().reverse()); ++o3 < e3; )
        $3[o3] = db(r3[o3], r3[o3 + 1]), a3[o3] = t3(n3[o3], n3[o3 + 1]);
      return function(n4) {
        var t4 = Se2(r3, n4, 1, e3) - 1;
        return a3[t4]($3[t4](n4));
      };
    }
    function Ac(r3, n3) {
      return n3.domain(r3.domain()).range(r3.range()).interpolate(r3.interpolate()).clamp(r3.clamp()).unknown(r3.unknown());
    }
    function Af() {
      var r3, n3, t3, e3, $3, a3, o3 = yc, i3 = yc, u3 = ab, p3 = z2;
      function l3() {
        return e3 = Math.min(o3.length, i3.length) > 2 ? zf : yf, $3 = a3 = null, c3;
      }
      function c3(n4) {
        return isNaN(n4 = +n4) ? t3 : ($3 || ($3 = e3(o3.map(r3), i3, u3)))(r3(p3(n4)));
      }
      return c3.invert = function(t4) {
        return p3(n3((a3 || (a3 = e3(i3, o3.map(r3), v2)))(t4)));
      }, c3.domain = function(r4) {
        return arguments.length ? (o3 = Array.from(r4, xf), p3 === z2 || (p3 = zc(o3)), l3()) : o3.slice();
      }, c3.range = function(r4) {
        return arguments.length ? (i3 = Array.from(r4), l3()) : i3.slice();
      }, c3.rangeRound = function(r4) {
        return i3 = Array.from(r4), u3 = sf, l3();
      }, c3.clamp = function(r4) {
        return arguments.length ? (p3 = r4 ? zc(o3) : z2, c3) : p3 !== z2;
      }, c3.interpolate = function(r4) {
        return arguments.length ? (u3 = r4, l3()) : u3;
      }, c3.unknown = function(r4) {
        return arguments.length ? (t3 = r4, c3) : t3;
      }, function(t4, e4) {
        return r3 = t4, n3 = e4, l3();
      };
    }
    function Bc(r3, n3) {
      return Af()(r3, n3);
    }
    var eb, Bf, Cf;
    function Df($3) {
      return eb = Kf($3), Bf = eb.format, Cf = eb.formatPrefix, eb;
    }
    var ra = function(e3, t3) {
      if ((l3 = (e3 = t3 ? e3.toExponential(t3 - 1) : e3.toExponential()).indexOf("e")) < 0)
        return null;
      var l3, n3 = e3.slice(0, l3);
      return [n3.length > 1 ? n3[0] + n3.slice(2) : n3, +e3.slice(l3 + 1)];
    };
    var K2 = function(t3) {
      return (t3 = ra(Math.abs(t3))) ? t3[1] : NaN;
    };
    var Ef = function(r3, t3) {
      return function(e3, n3) {
        for (var $3 = e3.length, u3 = [], o3 = 0, a3 = r3[0], f3 = 0; $3 > 0 && a3 > 0 && (f3 + a3 + 1 > n3 && (a3 = Math.max(1, n3 - f3)), u3.push(e3.substring($3 -= a3, $3 + a3)), !((f3 += a3 + 1) > n3)); )
          a3 = r3[o3 = (o3 + 1) % r3.length];
        return u3.reverse().join(t3);
      };
    };
    var Ff = function(t3) {
      return function(e3) {
        return e3.replace(/[0-9]/g, function(e4) {
          return t3[+e4];
        });
      };
    };
    var Gf = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function sa(i3) {
      return new fb(i3);
    }
    function fb(i3) {
      if (!(t3 = Gf.exec(i3)))
        throw new Error("invalid format: " + i3);
      var t3;
      this.fill = t3[1] || " ", this.align = t3[2] || ">", this.sign = t3[3] || "-", this.symbol = t3[4] || "", this.zero = !!t3[5], this.width = t3[6] && +t3[6], this.comma = !!t3[7], this.precision = t3[8] && +t3[8].slice(1), this.trim = !!t3[9], this.type = t3[10] || "";
    }
    sa.prototype = fb.prototype, fb.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
    };
    var Hf = function(e3) {
      e:
        for (var r3, t3 = e3.length, a3 = 1, $3 = -1; a3 < t3; ++a3)
          switch (e3[a3]) {
            case ".":
              $3 = r3 = a3;
              break;
            case "0":
              $3 === 0 && ($3 = a3), r3 = a3;
              break;
            default:
              if ($3 > 0) {
                if (!+e3[a3])
                  break e;
                $3 = 0;
              }
          }
      return $3 > 0 ? e3.slice(0, $3) + e3.slice(r3 + 1) : e3;
    };
    var If;
    var Jf = function(e3, p3) {
      var r3, a3 = ra(e3, p3);
      if (!a3)
        return e3 + "";
      var $3 = a3[0], t3 = a3[1], f3 = t3 - (r3 = If = 3 * Math.max(-8, Math.min(8, Math.floor(t3 / 3))), r3) + 1, o3 = $3.length;
      return f3 === o3 ? $3 : f3 > o3 ? $3 + new Array(f3 - o3 + 1).join("0") : f3 > 0 ? $3.slice(0, f3) + "." + $3.slice(f3) : "0." + new Array(1 - f3).join("0") + ra(e3, Math.max(0, p3 + f3 - 1))[0];
    };
    var Cc = function(r3, e3) {
      var t3 = ra(r3, e3);
      if (!t3)
        return r3 + "";
      var $3 = t3[0], a3 = t3[1];
      return a3 < 0 ? "0." + new Array(-a3).join("0") + $3 : $3.length > a3 + 1 ? $3.slice(0, a3 + 1) + "." + $3.slice(a3 + 1) : $3 + new Array(a3 - $3.length + 2).join("0");
    };
    var Dc = {"%": function(t3, r3) {
      return (100 * t3).toFixed(r3);
    }, b: function(t3) {
      return Math.round(t3).toString(2);
    }, c: function(t3) {
      return t3 + "";
    }, d: function(t3) {
      return Math.round(t3).toString(10);
    }, e: function(t3, r3) {
      return t3.toExponential(r3);
    }, f: function(t3, r3) {
      return t3.toFixed(r3);
    }, g: function(t3, r3) {
      return t3.toPrecision(r3);
    }, o: function(t3) {
      return Math.round(t3).toString(8);
    }, p: function(t3, r3) {
      return Cc(100 * t3, r3);
    }, r: Cc, s: Jf, X: function(t3) {
      return Math.round(t3).toString(16).toUpperCase();
    }, x: function(t3) {
      return Math.round(t3).toString(16);
    }};
    var Ec = function(t3) {
      return t3;
    };
    var Fc = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"], Kf = function(r3) {
      var e3 = r3.grouping && r3.thousands ? Ef(r3.grouping, r3.thousands) : Ec, t3 = r3.currency, a3 = r3.decimal, m3 = r3.numerals ? Ff(r3.numerals) : Ec, $3 = r3.percent || "%";
      function i3(r4) {
        var i4 = (r4 = sa(r4)).fill, o3 = r4.align, n3 = r4.sign, p3 = r4.symbol, f3 = r4.zero, l3 = r4.width, s3 = r4.comma, u3 = r4.precision, M3 = r4.trim, c3 = r4.type;
        c3 === "n" ? (s3 = true, c3 = "g") : Dc[c3] || (u3 == null && (u3 = 12), M3 = true, c3 = "g"), (f3 || i4 === "0" && o3 === "=") && (f3 = true, i4 = "0", o3 = "=");
        var I3 = p3 === "$" ? t3[0] : p3 === "#" && /[boxX]/.test(c3) ? "0" + c3.toLowerCase() : "", V3 = p3 === "$" ? t3[1] : /[%p]/.test(c3) ? $3 : "", h3 = Dc[c3], g3 = /[defgprs%]/.test(c3);
        function x3(r5) {
          var t4, $4, p4, x4 = I3, d3 = V3;
          if (c3 === "c")
            d3 = h3(r5) + d3, r5 = "";
          else {
            var v3 = (r5 = +r5) < 0;
            if (r5 = h3(Math.abs(r5), u3), M3 && (r5 = Hf(r5)), v3 && +r5 == 0 && (v3 = false), x4 = (v3 ? n3 === "(" ? n3 : "-" : n3 === "-" || n3 === "(" ? "" : n3) + x4, d3 = (c3 === "s" ? Fc[8 + If / 3] : "") + d3 + (v3 && n3 === "(" ? ")" : ""), g3) {
              for (t4 = -1, $4 = r5.length; ++t4 < $4; )
                if (48 > (p4 = r5.charCodeAt(t4)) || p4 > 57) {
                  d3 = (p4 === 46 ? a3 + r5.slice(t4 + 1) : r5.slice(t4)) + d3, r5 = r5.slice(0, t4);
                  break;
                }
            }
          }
          s3 && !f3 && (r5 = e3(r5, 1 / 0));
          var y3 = x4.length + r5.length + d3.length, q3 = y3 < l3 ? new Array(l3 - y3 + 1).join(i4) : "";
          switch (s3 && f3 && (r5 = e3(q3 + r5, q3.length ? l3 - d3.length : 1 / 0), q3 = ""), o3) {
            case "<":
              r5 = x4 + r5 + d3 + q3;
              break;
            case "=":
              r5 = x4 + q3 + r5 + d3;
              break;
            case "^":
              r5 = q3.slice(0, y3 = q3.length >> 1) + x4 + r5 + d3 + q3.slice(y3);
              break;
            default:
              r5 = q3 + x4 + r5 + d3;
          }
          return m3(r5);
        }
        return u3 = u3 == null ? 6 : /[gprs]/.test(c3) ? Math.max(1, Math.min(21, u3)) : Math.max(0, Math.min(20, u3)), x3.toString = function() {
          return r4 + "";
        }, x3;
      }
      return {format: i3, formatPrefix: function(r4, e4) {
        var t4 = i3(((r4 = sa(r4)).type = "f", r4)), a4 = 3 * Math.max(-8, Math.min(8, Math.floor(K2(e4) / 3))), m4 = Math.pow(10, -a4), $4 = Fc[8 + a4 / 3];
        return function(r5) {
          return t4(m4 * r5) + $4;
        };
      }};
    };
    Df({decimal: ".", thousands: ",", grouping: [3], currency: ["$", ""]});
    var Lf = function(e3) {
      return Math.max(0, -K2(Math.abs(e3)));
    };
    var Mf = function(t3, $3) {
      return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(K2($3) / 3))) - K2(Math.abs(t3)));
    };
    var Nf = function($3, e3) {
      return $3 = Math.abs($3), e3 = Math.abs(e3) - $3, Math.max(0, K2(e3) - K2($3)) + 1;
    };
    var Of = function(a3, r3, e3, i3) {
      var $3, t3 = Ma(a3, r3, e3);
      switch ((i3 = sa(i3 == null ? ",f" : i3)).type) {
        case "s":
          var p3 = Math.max(Math.abs(a3), Math.abs(r3));
          return i3.precision != null || isNaN($3 = Mf(t3, p3)) || (i3.precision = $3), Cf(i3, p3);
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
          i3.precision != null || isNaN($3 = Nf(t3, Math.max(Math.abs(a3), Math.abs(r3)))) || (i3.precision = $3 - (i3.type === "e"));
          break;
        case "f":
        case "%":
          i3.precision != null || isNaN($3 = Lf(t3)) || (i3.precision = $3 - 2 * (i3.type === "%"));
      }
      return Bf(i3);
    };
    var gb = Array.prototype.slice;
    var Pf = function(x3) {
      return x3;
    };
    var hb = 1, ib = 2, jb = 3, Y2 = 4, Gc = 1e-6;
    function Qf(t3) {
      return "translate(" + (t3 + 0.5) + ",0)";
    }
    function Rf(t3) {
      return "translate(0," + (t3 + 0.5) + ")";
    }
    function Sf(t3) {
      return function(r3) {
        return +t3(r3);
      };
    }
    function Tf(t3) {
      var r3 = Math.max(0, t3.bandwidth() - 1) / 2;
      return t3.round() && (r3 = Math.round(r3)), function($3) {
        return +t3($3) + r3;
      };
    }
    function Uf() {
      return !this.__axis;
    }
    function Hc(t3, r3) {
      var $3 = [], n3 = null, e3 = null, a3 = 6, i3 = 6, c3 = 3, o3 = t3 === hb || t3 === Y2 ? -1 : 1, l3 = t3 === Y2 || t3 === ib ? "x" : "y", s3 = t3 === hb || t3 === jb ? Qf : Rf;
      function u3(u4) {
        var M3 = n3 == null ? r3.ticks ? r3.ticks.apply(r3, $3) : r3.domain() : n3, F3 = e3 == null ? r3.tickFormat ? r3.tickFormat.apply(r3, $3) : Pf : e3, f3 = Math.max(a3, 0) + c3, p3 = r3.range(), v3 = +p3[0] + 0.5, x3 = +p3[p3.length - 1] + 0.5, m3 = (r3.bandwidth ? Tf : Sf)(r3.copy()), h3 = u4.selection ? u4.selection() : u4, g3 = h3.selectAll(".domain").data([null]), d3 = h3.selectAll(".tick").data(M3, r3).order(), k3 = d3.exit(), y3 = d3.enter().append("g").attr("class", "tick"), b3 = d3.select("line"), _3 = d3.select("text");
        g3 = g3.merge(g3.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), d3 = d3.merge(y3), b3 = b3.merge(y3.append("line").attr("stroke", "currentColor").attr(l3 + "2", o3 * a3)), _3 = _3.merge(y3.append("text").attr("fill", "currentColor").attr(l3, o3 * f3).attr("dy", t3 === hb ? "0em" : t3 === jb ? "0.71em" : "0.32em")), u4 !== h3 && (g3 = g3.transition(u4), d3 = d3.transition(u4), b3 = b3.transition(u4), _3 = _3.transition(u4), k3 = k3.transition(u4).attr("opacity", Gc).attr("transform", function(t4) {
          return isFinite(t4 = m3(t4)) ? s3(t4) : this.getAttribute("transform");
        }), y3.attr("opacity", Gc).attr("transform", function(t4) {
          var r4 = this.parentNode.__axis;
          return s3(r4 && isFinite(r4 = r4(t4)) ? r4 : m3(t4));
        })), k3.remove(), g3.attr("d", t3 === Y2 || t3 == ib ? i3 ? "M" + o3 * i3 + "," + v3 + "H0.5V" + x3 + "H" + o3 * i3 : "M0.5," + v3 + "V" + x3 : i3 ? "M" + v3 + "," + o3 * i3 + "V0.5H" + x3 + "V" + o3 * i3 : "M" + v3 + ",0.5H" + x3), d3.attr("opacity", 1).attr("transform", function(t4) {
          return s3(m3(t4));
        }), b3.attr(l3 + "2", o3 * a3), _3.attr(l3, o3 * f3).text(F3), h3.filter(Uf).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t3 === ib ? "start" : t3 === Y2 ? "end" : "middle"), h3.each(function() {
          this.__axis = m3;
        });
      }
      return u3.scale = function(t4) {
        return arguments.length ? (r3 = t4, u3) : r3;
      }, u3.ticks = function() {
        return $3 = gb.call(arguments), u3;
      }, u3.tickArguments = function(t4) {
        return arguments.length ? ($3 = t4 == null ? [] : gb.call(t4), u3) : $3.slice();
      }, u3.tickValues = function(t4) {
        return arguments.length ? (n3 = t4 == null ? null : gb.call(t4), u3) : n3 && n3.slice();
      }, u3.tickFormat = function(t4) {
        return arguments.length ? (e3 = t4, u3) : e3;
      }, u3.tickSize = function(t4) {
        return arguments.length ? (a3 = i3 = +t4, u3) : a3;
      }, u3.tickSizeInner = function(t4) {
        return arguments.length ? (a3 = +t4, u3) : a3;
      }, u3.tickSizeOuter = function(t4) {
        return arguments.length ? (i3 = +t4, u3) : i3;
      }, u3.tickPadding = function(t4) {
        return arguments.length ? (c3 = +t4, u3) : c3;
      }, u3;
    }
    function Vf(t3) {
      return Hc(jb, t3);
    }
    function Wf(t3) {
      return Hc(Y2, t3);
    }
    const Xf = (t3, {yScale: l3, tickCount: e3, fontFamily: i3, unxkcdify: s3, stroke: a3}) => {
      t3.append("g").call(Wf(l3).tickSize(1).tickPadding(10).ticks(e3, "s")), t3.selectAll(".domain").attr("filter", s3 ? null : "url(#xkcdify)").style("stroke", a3), t3.selectAll(".tick > text").style("font-family", i3).style("font-size", "16").style("fill", a3);
    }, Yf = (t3, {xScale: l3, tickCount: e3, moveDown: i3, fontFamily: s3, unxkcdify: a3, stroke: $3}) => {
      t3.append("g").attr("transform", `translate(0,${i3})`).call(Vf(l3).tickSize(0).tickPadding(6).ticks(e3)), t3.selectAll(".domain").attr("filter", a3 ? null : "url(#xkcdify)").style("stroke", $3), t3.selectAll(".tick > text").style("font-family", s3).style("font-size", "16").style("fill", $3);
    };
    var y2 = {xAxis: Yf, yAxis: Xf};
    const Zf = (t3, e3, a3) => {
      t3.append("text").style("font-size", "20").style("font-weight", "bold").style("fill", a3).attr("x", "50%").attr("y", 30).attr("text-anchor", "middle").text(e3);
    }, $f = (t3, e3, a3) => {
      t3.append("text").style("font-size", 17).style("fill", a3).attr("x", "50%").attr("y", t3.attr("height") - 10).attr("text-anchor", "middle").text(e3);
    }, _f = (t3, e3, a3) => {
      t3.append("text").attr("text-anchor", "end").attr("dy", ".75em").attr("transform", "rotate(-90)").style("font-size", 17).style("fill", a3).text(e3).attr("y", 6).call((e4) => {
        const a4 = e4.node().getComputedTextLength();
        e4.attr("x", 0 - t3.attr("height") / 2 + a4 / 2);
      });
    };
    var k2 = {title: Zf, xLabel: $f, yLabel: _f};
    const b2 = {positionType: {upLeft: 1, upRight: 2, downLeft: 3, downRight: 4}};
    class L4 {
      constructor({parent: t3, title: i3, items: e3, position: s3, unxkcdify: r3, backgroundColor: o3, strokeColor: h3}) {
        this.title = i3, this.items = e3, this.position = s3, this.filter = r3 ? null : "url(#xkcdify)", this.backgroundColor = o3, this.strokeColor = h3, this.svg = t3.append("svg").attr("x", this._getUpLeftX()).attr("y", this._getUpLeftY()).style("visibility", "hidden"), this.tipBackground = this.svg.append("rect").style("fill", this.backgroundColor).attr("fill-opacity", 0.9).attr("stroke", h3).attr("stroke-width", 2).attr("rx", 5).attr("ry", 5).attr("filter", this.filter).attr("width", this._getBackgroundWidth()).attr("height", this._getBackgroundHeight()).attr("x", 5).attr("y", 5), this.tipTitle = this.svg.append("text").style("font-size", 15).style("font-weight", "bold").style("fill", this.strokeColor).attr("x", 15).attr("y", 25).text(i3), this.tipItems = e3.map((t4, i4) => {
          return this._generateTipItem(t4, i4);
        });
      }
      show() {
        this.svg.style("visibility", "visible");
      }
      hide() {
        this.svg.style("visibility", "hidden");
      }
      update({title: t3, items: i3, position: e3}) {
        if (t3 && t3 !== this.title && (this.title = t3, this.tipTitle.text(t3)), i3 && JSON.stringify(i3) !== JSON.stringify(this.items)) {
          this.items = i3, this.tipItems.forEach((t5) => t5.svg.remove()), this.tipItems = this.items.map((t5, i4) => {
            return this._generateTipItem(t5, i4);
          });
          const t4 = Math.max(...this.tipItems.map((t5) => t5.width), this.tipTitle.node().getBBox().width);
          this.tipBackground.attr("width", t4 + 15).attr("height", this._getBackgroundHeight());
        }
        e3 && (this.position = e3, this.svg.attr("x", this._getUpLeftX()), this.svg.attr("y", this._getUpLeftY()));
      }
      _generateTipItem(t3, i3) {
        const e3 = this.svg.append("svg");
        e3.append("rect").style("fill", t3.color).attr("width", 8).attr("height", 8).attr("rx", 2).attr("ry", 2).attr("filter", this.filter).attr("x", 15).attr("y", 37 + 20 * i3), e3.append("text").style("font-size", "15").style("fill", this.strokeColor).attr("x", 27).attr("y", 37 + 20 * i3 + 8).text(t3.text);
        const s3 = e3.node().getBBox();
        return {svg: e3, width: s3.width + 15, height: s3.height + 10};
      }
      _getBackgroundWidth() {
        const t3 = this.items.reduce((t4, i3) => t4 > i3.text.length ? t4 : i3.text.length, 0);
        return 7.4 * Math.max(t3, this.title.length) + 25;
      }
      _getBackgroundHeight() {
        return 20 * (this.items.length + 1) + 10;
      }
      _getUpLeftX() {
        return this.position.type === b2.positionType.upRight || this.position.type === b2.positionType.downRight ? this.position.x : this.position.x - this._getBackgroundWidth() - 20;
      }
      _getUpLeftY() {
        return this.position.type === b2.positionType.downLeft || this.position.type === b2.positionType.downRight ? this.position.y : this.position.y - this._getBackgroundHeight() - 20;
      }
    }
    function M2(A3) {
      A3.append("defs").append("style").attr("type", "text/css").text(`@font-face {
      font-family: "xkcd";
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AAJx4AAsAAAAAxwwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAFGAAAlcwAAL0RC0F+QkZGVE0AAJsAAAAAGgAAABw+UK5QR0RFRgAAmuQAAAAcAAAAHgAnAJFPUy8yAAABZAAAAFUAAABgWJzhv2NtYXAAAAM4AAABywAAAyqDxHFiaGVhZAAAAQgAAAAxAAAANsz4KqBoaGVhAAABPAAAAB4AAAAkCEQESmhtdHgAAJscAAABXAAAAiwGQwpzbWF4cAAAAVwAAAAGAAAABgCLUABuYW1lAAABvAAAAXkAAALBbi7owXBvc3QAAAUEAAAAEwAAACD/gwAzeJxjYGRgYADiynnODfH8Nl8ZuJkjgCIMWyZ9YYDTwv++sSxgDgVyORiYQKIAPLQLYwAAAHicY2BkYGAO/feNwZflBAMQsCxgYGRABd0AbW8ElwAAAABQAACLAAB4nGNgZlzLOIGBlYGBSYcpnIGBoRxCM85i0GK4y8DAzMDKzAAGDQwM7UwMDA4MUBCQ5poCpBT+/2eK+M/A4MscysgF5DOC5BjXMgUwKAAhIwBQMwyLAAAAeJyNkE1OAkEQhV8D/hs3GuOyVwYTBjSewMzCDWEhCfuhaaADTJOexsjaA3gTt17B6Dm8gCfwTdMo0Y1MQn1Vr6rrB8ARniGw+g3wFlngQNxGrmBHqMhVxh8j13AsXiJv4VB8RN7GfmWXmaK2R+81VJUscCpakSs4Et3IVcYnkWs4F0+Rt3Am3iNv40R8IoXFHEs4GIwwhodEHQoXtCYonlGLHC08YEJlgATDEClzVaSyvo8FyZILNKilJI2MMYN7kgzdZvzKmoL+DbXNWhOUBJ1g19maGYpahilrrtHEJW2bEUWtfEkDqZ0vnRmNvayrC2nmSz+2eethogbJ0OZeKv45019464qGTJ3OvLnXMrWzmc0LeeNXqrF50rF5GdZOmWwqr5uXsm2Uzgt2WZ9Aokvrwok8w2wju8qZOZ07jjPiOlMO7Ojq0WKauf/V/px4Myf5/WZYa1WTfL/fC4cq4hElruKh0NOu4F7yipv8tPgzRJzhC2aqiNgAAAB4nI3RW08TQRgG4HdpOYggUBHb0uo4nNSWgwfkoBVBhXLSgoooAuVQjED4CSCnBLjzksQ7Em4Jl/4AErjlGjbwGyThBjK8u7MEDWCc5Nmv8+10951ZAMkAXBQmNx3A4BVJhewadt+FdLvvxqY9F/yVgX5MYhXr2MAWtrGDQ8NjxFwrwieCIiL9MiSjMi4Tckwp/ktg4MLVXhH4Y/WwHFVK7as99UutqZ9qWf1QC2pCdav8o10r1V7YTJhdZq1ZYIrdY530wpGLvHO9JSxiHCPMzmFUOF2vnQ7cD+znDdAk1dOqw7q37ojThsNau+UYpG3HEO04hunQkeArPBpGWWMaxvgJVjR8ZxyvxsQQPo3ZIQIadwER1LgfiIiGb4D0a5hiDWmYZo1qmGGNa5hlZT7JXJhjZSbJLPgK4/eMDVhgxhT846j1MJJc7uSU1LQr6VczMq9lZed4rufeyLvp9fnzA8Fbt8UdWVBYVFxy9979ULi0rLziwcNHjyufVFXX1D59Fnle9wL1DS9fvW5sija3tLa1v3kb6+h89/5D18fuT597vvT2WWc9qA/zP8as9Z3m5vVk+rQ7Ze39bIyPLC0mLn/G0N/TE5rzdrgAeJxjYGYAg/8NDMYMWAAAKBQBtgB4nDx8CYBkVXlutWPDiZpRp+2X5CUCmmhMosY9xriAiIKgICr70MzSM9PTe3d111516+5nvXvtW+/brDDADLuggKKRTYEBFWNekpdoFvN81b7OS95/irxUTfdUd1Xduvec//+W//yn+2Kvf32sr6/vjcnRAwe/emBmZCoe63tdrC924/YnY9uf6tv+9Ou2P7Nr+7dff9FPX7f8H2/addFXFv/jTa+/6A2xtx55539Q+l8P3nRha6f9e69f+PXf9789Fnvdm98M32Oxt8D3XX/wVvn4A/DtAXVP7F3y4Cj25th/i7099sex98U+EPt87KrYNbFrY1+L3Ri7JbY3dkfsQOxQbCQ2FpuMzcTmYtlYMYZjYawRW4mdjj0Q+2bsO7Hv9X2w73N9185NjHzoQx+77LX/Piv/+8CHP3fF+L4DM5MT1x6Zmzi8b2ZufGzfXPzA0OTk0ORVQ0dSU0eGJ4amhmaGJocm4GtuaOKKocsuH7r28qHrrx26fOjKK4au+NrQ164Z+uwVQ9dfP3T9NUOXXTN0zbVDX7586LLrhr76taFrZ/YdHDmwb+yrI4fH941MxIcPz+wb2zc1NTOZHJ6e2zc2MRnv/T82PDvbe3B4ZnhffHim93j/vpmh//xZPj8EP8998PMf/viHPvj+D1w+OZWaGTl8JH7Jew780SUjU6n4kcmJP5Xz8r5DkxPxSw7At5mR/XPxyZnZ915yuTzKyPzwJZdPjo9PTsxecln8tWdHJife9+XJCfnr4ZkDI/vGLvnw+z9wyTUjB4YnZod7R3ttmt93/fDhubF9M/JXl/znzMOtL/a62K7Y62P9sQtiF8aOxH4j9obYG2Nviv1mbDdM2ltib43tiQ3E3hYbhAn8rdhvx34n9t9jvxv7PZjMi2IXxy6JvSP2ztjvx/4g9q7Yu2N/GHtP7I9gkv8k9l6Y6PfH/hQm+4OxD8U+HPtI7KOxj8X+LPbx2J/HPhH7i9gnY5+KfTr2mdilsc/GLo99LnYFBMUXYldCYHwxdjUEx5diX4YAuS72ldj1sa9CoHw9dgMEy02xmyFgbo3dBkFze2wo1oEQORm7M/ZQ7LFYO5bos/rsPtxH+mhspI/18T7R5/S5fV6f3xf0hX1RX6mv3Ffpq/bV+up9jb5mX6uv3dfpW+hb7FvqW+5b6VvtW4NQvSxGZczuggF5vG9uF7vg9y984Tdu+I0H3jD+xve9qf2b2m/+y+4bdp9587m3Drz14MAlb8ODZ37ra789+zvp/779e+/+vb98+3MX8Yv1Sz71Dvb7Y3+gv/vGP5x4z11//LY/6Xtv+X1b73vy/c//6f/6QP1Df/Lhz3/kwEdbf/auj9/75//3E+f+4gef/NdPK59xLt132eHPTlyufc684tor7v78v1z5m1f+3y/uuvqt17z9S9/88qPXWl/54vWzX33v1/Z//aYbbr5x+eY33Hz3LU/d+tJt5/YWb39m6Bf7bt3/y4PewROH3nnonw5/f+TS0bePKeM/nvzc1JHp52Y/Hl+ff3fipdR9mWtzuwpvV/Lahw1qX0VfEDX3j/xM9JXK9bVP11eb/95542Jn+aaVq9dm1s9vXr4VP0aOt068cGrPvcP3Pn72c3O7d27YvdO494UvvDKg/GD7lcHDCraCo1zlo0JDA5cKg16Ld/rxR1je01x9PR+ygAUudSgXnLPI4w5tI3oneYG9jAYU+g/MyJ012qavOcgQNk0ZaP3ftEFCMSecCIvpVKWYZgrJnGUWk1oGz3lJL+mrLkWMurZje5YgFVqGT3AdweEfFTQKo3JQqpftBsJVXFZD07UFHJOml22Kdu9c13nlM+cHYt2P/vq6wSnVs42EmYd35rhCbP2r2tVkwteQZ/R7etledhpCiNBHzQtpzTnrf4P53GeMcxJxJvjc44aHdF+jcxraebMyaNu2QSwYCZy1U3QerpEcwioewjfzYkNxbU7roiUCEpRcn3J2D7ySLbNjrMmXaYQjq+OHuYrpYjpP5yilhoF2v/Kv35195Znn93S//sS1T9XPD8S3/6D7rkGPNlmDbcGweiXHJ8etQK/a7AhN0zlShLtGKEWElV9ljIq/1NdqZS+o6FXsYpdy6pohpvAKGGOEA41N4zzJEoMi5QJe5WV3vfJT6owHKO1qZn9O1UeNuD5BSvowMkZncX+eFIhNihZlrIIGjjGfdXjTucdOkNPkJK5aMDGYpagiJ49YRFOogaiNFaxYCWvUStk5+yZsEWxilejEJHAqcDxMkUkz1pyhwYjZ1KKqlS0WNEUj8mZQgxQZCRQU5j275JVcx647NfFQ4FCP5v8U3qNyetictHx7zkQpy7A11dApYQrPCj0yGoW7wkWGKqwfF2gBT+Mjdsoy4cgmNalGia87lmPCqWBh+yaCa4CwiqgHk82YjN6AOx6P3A4P4YnQ/ykNEHXu9xx4nlK4TJvOkmmyl2DHCLOhXiIR8XDgIc9teMLnHg0xt4XzcwcO6TCI4DINnApFO+h7gxQftXSSsTFhgnHqQ5QtwMUtI7G4zPqrrMI5hDglMFxW/hPUQruD1kt7um+9b//qo984fPbo3Q+/PPBo96rtfxy0DDNBkiSDTZsadFY1LMu2SW+ICYO7BU8gxRCWBrfkKFaIaSTglRhmgNiY3+BkRD7MBiqCk7XlcLTzApKqVXTgpJiN5+A+YSWwwlK2iuTsFUtKWQ+LLUhGH3PL1apwrr7J00baNBnJIDtuB9GYm3PyHHMMaW2H8ROHF7OoorIj/WyWKhyjgUVGuAFzkWesjEPCqOOige+EFVHjW6i1eOFS2UtdTDXHdlRXCUxeYDpgAGngYtsrccEC0iSLFDAAcbgxCPPQWa94InQ9txJtHKcuZfCs45eqZ0QHiRZ5DDesZWUp1VajVEV1UoArMzgJIcEc7oktUkIkatr9j2iClxb9OmPYt0OjlzqYyskcCgoUDTyuUMJZXZwkTsbJCQyAYmsYwhbbLGvCS3UGqVWkZKWfdogvh4kwjSGNwaCb6NzORwdp3MjSOLVtbNhINflaP1tzynQBRcGFPfgkApt5WkSf2z9o30JNC9LDcqzQdokPONBmImj6db8kADSs/SSLupe+d9AxhSXnnRVZgR+yx7UZM01wNqsoqq4BSPkFg5b7yZPsfghhh30TBsgPnRavcccu5dDOhTvvG6QzdJ5hbtg4yVCK9Yum2PSe8Z4guOS4gObyxpJw6nFykM6g3b/afsd3b/vRFwGu7vruX70wcFO3f9satCE7MOSvDjGOBioaTqbNIrYwRJxhpffitHpZ59aHlAivuZHXLi20mouoUgcYX6psRCu5DdvDHmWUySE3PJcaDhr4eLqcL48zlGB5XDDRtz41iJV+feSGL2UDQ1CHLJEGDUXJXeAihAsTDOLC9xteBDntGJ4J59FdOzOIqc1sboqM0OF0sgWbQtqoxCDm4eHrrpuZmZ21DGQZBgxA0dh7w/6vDd9USNAchdns5CoaoIREv069g6qtu+6pNCuNv//HcoXS8y/VG37gewzi4ybHK/kXU4fBPCJWNpZzFF2zk4DP1qlObjUnrtG/bicp9kYpZjbEi1mbLxVPjjzSOrmGji0zUW+Wy9UVtkBdJmPYzzeTdd0brQBjcXiHiwCyBIaQSFVMih7biQGe5DJKQVGShaxZtBnEiumRGm+Klt8WmBEX7qiCH9QAmXc/duer2xe82NdNvLir+yfb3x+cxkmrqFu2BbBh08SMntdyRLen7FF3sn7YVVrjvo5CGAFFNyx4HS6aU+OQuBDwBCeG7b31a0pD7am74mg5S2kdQMHrpcx9FNKSBSLk58rnTp5+BFWUft8oF1w9yvlWRH16ekl4TkBKpod5aq2HPjDlqBgV/UJJieDa3aDh3WMuIDvKOf1JzwL0wrZpWpamMtNUkK2lav2JRrydrKFCFEX9ruf5QpTry6cEZAkTlAmXtUjHfPILD+z1M9zhMwS1PjlYtyOzmqvmQcIkgbksU9UyuXShoMB1GiLjj99vriBzLViucZA0HI5DPeIR9OLOtwY9q6yEKmqmDbXfNnO5QmF6WtFnzKxNaEHknHhZC3XfKpsr+WcbrXuXEER5pr+TXpxt5UCPPLq9t0v7ll7e9dCvvzaYxoQUgb3gyhOQtlmqkXeTWQ6YKb+YXsn5NoqsJeEEkLU9WmCehGa3AqMmSImepM8ER5SXkblFfEtYIs2SNnzKx9rd5K5u9pODoMUkCka0VgxStYkNtZpdTG4VN+zAaJi1yVfI82t/h/wF4TZOdO459XDFc7jjcOGGPnNLSITFdn96UxdjmaJZ0GyrWEzNQpgQyGecLwxflT1kFU0Fmwh+IcEPYgICA+dvtuaAbObIYXK5n6rcFo74hWgGRbOrt1QTtfmlmYVUuegQj1ZpqwbUunvnM3f9+q2DOvCqkbRyBAuDW57umvXsPTfJYBOaq0XpxgE3g4Tijbuq0MWUuFXcoivGPuXK1B37b9XVomIZSibLzQTCGgCoTg1fKamB7tCI3xflWGth69TKydpKUGvdTR0EpAEh6ji1p7BDJCg6wYL4pXHS3LJ89bi+VlzW2khbHH1odt0ItMh2bRde+J98YDmHShpkoQk8inY/1Z359tef2dMdeWmg053frg0aJhBCyk6DjDnM4ixOLaYBWgP4FGAeUjXFS1dQpmyQXK4IQcd0XvRzUS4obEx0Uq2M7ozjSXyZmteBIEAfpWma65EeaU+BdkTH6KHh/sR8KiVPhsp0gwmxLQvUKIibArc7uUahxOt15IBQlif82CPwyHMw1s0Z6yNO2kn79iZugURwXVSKsM+3xGPiNKshXukvZz2zmq6lO0mQMSRirgBFJCGZRHUnCOq+n6ihoj+/nFhCLdx/0j4tqIcG7pAhepFH/YhXmIddO9BrdjsuFR4Zh/hOcwA7trC2uYkq1UoF0juyg3wrvWSIhKpZupFOzc0aejaFcK2fVPF9VolAjDCXl9R10DB83AdmJRSuFEL8kW7m/BfP7+keeeUTPxm4rnv82UEqtRtEL1tlj9JVtgZupArTS3z8qH2cnMV1168jDgSLI1yhdd03XUaG+K38DpES6MyFA3fQBbxKSvaSsWK6lpNl8xYkNdGSaOA6swC0n+NZ/jEMEZ6DCdlPbzZsIFYXeI2oWMOKbWEFrtYo6DlP8QpewbFB8Q1c9whvRN/g6AQjn+snd+BxkGWQ8Y7m54RbUgI1sj0XTh2EJSVA6gwCswqGAbIit/PJl/q6l/zdoIqnVPhcApduWhqE3yyfJBl1rjgzfRh4hRYy3EDMMORjneFaxtMrhuAubwmALnbilAhYTw+hcm35AWfDWRWV4jGzYcEg6B5mGsTwVnf+J5e+smfg0q7oPj04oGTwBP4oHiYzkiaJaRs4oSmQxqWJ0D7jBWyRt+HqLj3JzosNvsK+zdY40Bfz3Aj0L2nhZSIM3/AIBTExy3Zej+clMq1lun19S7/a9eDfD2ayYBiyMHJF+AAbm3JcGHYKwSy3F/SyVcIlH7mAX4wGLCpXVvwKaekV+zVb44DVg9g3hOGi+aZhJFJod/edf7X3+QGl+7G/GaQOkKjDvNICgxAqL0pZ4FaqWw5QEsSyU1pmICwupaK2IUO7eUwK5vo6HJg1j0uh0zrBeRRufUcHY+lpgcUI1bkmJkt5y4pjVc1ZKhDgGPgqqoNxQcW872p5mB4drI559IsStmwQQUrSTubHwRxamq31zI9u60rcmC7Ow290KdOzo/IDUyOgHyidu91QtLxwjGxu1E6HmpD+Cj7EtwOrqgOlchSIeom5MNIVuBoQZgTed/x75CLaOM4u3n1sO/fLvvZPuuGPd3UfWh0Ek8zkLXAjtxZ4TrlaqYalsOQ4nePyakH+Oog7ftNrlo5BDm2wBq1D4gHNUJe3M3+t1YBpXOIgHCVPFsuFmhJlQ1OYjqTruTAn5l2bGZ7lGBxsqIiXjIvA0MF12WKCKbZJiqZhwR1L4Jzp0Qf4FgMVi5kJvVCYn7oUJJYFSWSpE9YhupcOB4drR7nJYQAR1VtTjuKox45W1Yq2qDSNyPLoEu3QEvMgvl0geeTShTJYrHdvjwx6BqHL5Dhpmm2lpXh6abI55N9Gv4Lofj3eXxjOTE3PHhk9oB4sx/3pjcJSfolxa0E/Tu52jot2+RtOiID9yk45XCivAJKJzqojg9IUMngfWX9517e3nxqcMSFydVOjafExNk1vJxNkL965wdyPU4w4OpCDKQgKrZMAMWDvfCHvz4ruR51umk/kXrRaphgHMRbN/vgTP5EZl97+p8EEntXGsiOZRG5+fnLKNPSEVQAm1ITOSUUPrNAE4+RanAkhbaqE/kcfKkdh0PZLXiM6EzTtKu6Yrg12NsxJImZSRNhOEbhlQhvV5s1CcuQ1tsA2MrXRQ8DiRNXU4vTk4UOqmskVsunMxNT1X5FzVIhzguQswg9qMC8ds2+BNsc+ZiAqwdzJOgwRoHJZSCMWsTL3eEm8Qlq0RCsQMZF9t1vGLjmFGeCkAoqe1vzI9Xwa0lKlWowMT5e5KFTQYRrhjoqRRXrnzKb5UQkut7FrgD1tSeVgJpQijsL+WuWZZ8tV149C36tVFldLpUYjKstQFkI4nh9VvQgC2nGAtgS4FshuMIzA88GiqDKYiV461FgD8XXcAZIRRBIH15e0uhVaPqUiHF4ueCa3BGGI8JEAhDbGEqEZubiIR0iBoN3r6fPb177S1/0/53d1/1f3Q4PUtgqmUpyfHlWMojlnTRI0RWaD/skoBXpQ96ce1NtERgZHqpO2+4/o2nx9f2nCrtSnQB3lAq2ZKhtPJE8o69ay23HuEaWoZ25hnNlKJ4jC0tIJOXvyZJsL5XvI3b1RZ0Dy6jf1RaMlrGxDLemuLkxuODL/5nxbaN5NJSATylUYVj/0wnr74e8BtLmBA68Bk1H2ABtB/nCBgoq1XgA6sDl4Vl8VGabSrJAKQ+bnYevjxjRBt5O8MQnBCYitgXS1nJQbd/E6rbMAzmFRHOOnGDoGYwWCxJg5It8NtAU3rWio+QSmhbSah3lOI3OG2p1kM+0Fq/C+CB8rrBdbRUd3dO92CsbLSFAF7SbdlX/88x91pxN72i/f/kr38p985i+vfOEzPxlYj/399v8YTMOImKamanESJypRQAjp2l57Hg2ciZnDSpEMkSmnEGXqMxuZM+CHzpaFLPEwTst0q1QSaOBgrOrcy4UNAA9yDn3mwoF9MXoZv91LcYMrPUItMJVnGQk11/RNTj26CBCBQgFB5iHzTD8cw16wNnHNvJf9jfe3oIUUtuD8M1tgdRIaq2hgf8xqmi3sGGWLjRs5O48BKgemFMotfJFKg9uYwpPkg3ge4Wz/wKlY6oIROm0dUIaVOUOxFTsD00696Am36a+5i6wiOY1zBGMAV+PQdXSfX7v1ot3PNX+4/bEXbvzhnn/9UfcPnxk4u33l9v8eHHjxtvzO7xpftEy4PsBsbrAEyZGCLNeBWCEFexZ/iEwhfBvLhakg6xoefBgkBfaM034Qul4jbAcnKseM5jyqZpw0388mqGWM6sMsKMaNXGJS1TCMOyGKMqtO2wjmmM76WSfvGY4BAS9lquEafrFUrKstMzIpraEKmJWLchSDWyAmLtqaNks1pwBnp0mBDcFKHIsWHQvJOpIUsStT5aJrAQJK4U4lKJfB9Di4YpYsdE/uGW+r5fCVSq/0A+bT5ce3qHgNFcr1pYfAOhPmlJ0oaDm/1BeJa/RMpzwUdYotENflTLUQIBNsVE/lQxoYAkyzyPv7xYyZtidVbAOf+WwTsbOUBsLjp9waXWYPiw5MxtnjzjfcTlj1ym0ztMHcmI7uCl91kObYNG8B3nf/x0/AlsGkaHgkQeDjyWu2G2zkXGLqcOJIfi45bMVBbRXsItLj2k04g3Ps6zzpjPk5bz48un776nyor+bq2sOz36vcvYQC1wOBxKjvhX6z2mr3khmuv1Kt3yUWGeQ+XUC0WtjQAhu0BKCdO7UqS0WKo3gH2yPshsK8eUsmXkQqSBdpJ1gL9MX3fLdxtn6mvnh8Y3M18ktwWBfgFPlu0+QluDchRBxLSBLIlXQ26SrMwOgX//bxQQ9kDkuzBFa1bG4mn5/NDc8dYoeWMqViqNbURu4USC/mNMON0nrJJCeiB6pn7KUJtFvd5uc/+/LVj+3pnvtb0PSf3P7ZYDLD2MUAJeCzQGrP2zkyY86DljBMRcWmk/CPcrzOFpkJ5wNS2wNZEMjTY6ukRU6QJZAK7V4pFJu2aRRHPk8xkvrDUi3VLNi6ngDxNlrYa8xCABvpy4lCTTtr55A+bhwtzKopbAB/Gp65UKjoFQsUQa/cyOQah0Dl1XAxvNs/UTlXethbCxb9VX+Fan6ntNW+r7Ja21i4E+wV8IYU9QMfYJUFdhFoJAa40CRM9cCwQ/BJkgUeZuwib+ed9PMX7Z7Ybr7c13Wf3dX90jZIf3ooXShOzWeU5MjUrf5tp4Zr2VKxpqLI0I3+TGHkSDFjqHq2d0UgSW07f4Ro1gTf60LmwchhKaIOB5pjgU6TdGs79pmxH5jPdhquzatexVtZDMvI8TyfA222z4qSW3NOSU+MfUiwJX2p0MAC95yJGN3KlVRf65XofDf0Qz8qOW6lybVw1WsxTloIRp6AxwrVdVtgnl+kFir4/dRJbtigHORqj+0koryTd4osDUjELYWih/9s0DUh4eGwIC5I78wtqnIDRIeUMHGeVo2ihgrFMYAXk379mBYUI70hArextbVY9kRFlGgA7w9UpO3og45dViN1Y9ovODNOnKRMRU+nZotaAlTnPr6PF93iCjKqznJ/8M1j992/2a5g2syh3Ub3DIz+3u2dQYXM6UVD1tBtQKiJpKaPjs9NFsZBwGsEZ0fZbbWjqDq5Fj+ulu0zxAFegSRhdf5oe6mKCnf0U9NI2KZtpa8zZsyEEsdxUrQytgF8mLdySJvpFwAwwkDLWv+yRiSgCFAy8iIczoUDWN8Rtdb3omPlu/y10ikUHXPXq6tOUDkJstJzvR7UebKMBiagRJrUzvmo4JFKPwFBpAM4aqHpZZoAkr3aMAyrWxCyrjpezQikclVgcDWzpk7QqU8NbhorM9VhoVOaS2eS89nx7HAyrk+TeVJ0jEituif8Gmrcdeb0neUKuLKalMQb3z7fTXcv6Ot0d+16Yjs1mFYmrvQVRgIj1BugJUrC564bgOTzItf1vNIyB4ldJqEVYMfuAS3p2RvFL5A8KYR5DeV3fjZomaYlCVmZBVaPl9J1w7c9M6IoKIH+haG+mMsKo5D1LcFDN4icklvBC4YrbYlcUNScjIfiQUFXCnCe8z/+lz/+EVjDy7YvGOwtDbiuzwWN6KIZqSXLyXngyamsvGmOygFtDDyVkDrYtnp3k9hy2Up6GDsF3KOTCU+uSwqbm26R45LdMao8DDlfKINcpNUmu/jGna3BpAUBVAQpa+nEpGPkZiOTPqLECaSobttAwBikkKyZUfgRWXDBruIWQpANoKYA1AVvlQBjgWqk13Fc4SI/Wjjn1kBsy+UqHhzjZQrDANfkko65ZFdwScpWOdkCe0VXVqlkfQLtvrH70Pa5waJ5y03JWSnI5ODnlXzu8OGDR6aTeTVXsOSw25igHDg0nCFFzDnYh0ZyaW4lvjHmqdW5lWx9vppcnK6nkK8FmgBCAb1pcSvQPKNaKFkVR65MVJqVFvPVCNkCXAOgB5B/NL3s2zOr45tlPHw8W73lkWxF9wxfQqBYX5C6amP95Zd//gvb0qsYQlcN5xdAJ2po96vdq+8cee6fXv7is3sGLum+sn3N4PvpzkVqQlft2zDJIlCLqUDvd+XiL3A+wA5w0+P8Hu9eb5Z0PypAnfIlpyEakKRo4C0gDpggPo4cH+iTedYKrsFVuFqQZFMmOmoUrSFpP360c+XguHmYHXRu8nYuV22Vyqq3rDqAdFKtKYOqctUXbhfZJBiWSuK1chzHgLK91eqALvMF/g33+26bopCu4EX8mHmCrftw+JKo85AtcM8Dz+SxACRL1TKtCBUXDxbGQS/cePf2yUEVHBq29Jzt/PyPzv/F5oRUZ+tzYIqIoetGNn/LDdkcSqbzWduw9SOHpNUePmLr2LYM21aLTK8kKylKSzZIrpJTLXteAHAhM0CADg4CP6g3F1eqrXp7pV5dQF64sbmyuLTQaPEIpCX4J7PDgmQAJk7IsliunA/RdOvgicMn89V8ScYQ6AqRXLrloaKbDogzP4d2z010f7Ov/e1d3T8FBiM4bxbtAoCQoivG2GzPT8BN19Kzet4G8YdTyJrqD8BzLeAqHNHzQLSJHhdIUHX9Enf9uuM2m2h5uR5u+Bt+m3X0Rc0HccYMbkkEsSasopGZOQyjkc3NZ/fPjCbnMpZWiINvS7OZYM5LCMXBEM96SfExEiTiVbftwyh4pXbimLGAI0I8Vwjfcfhi6d6NpTZqVDeOQZ71FFUQNu/02m6LL9htXNEWTIAaLAmcOrmGCbgxX9eYXMXA3HCPhHkaZ1cUTQPV/00MGnYyoQEUGXkYxiR1FubLSkllAOAejUQoOG+2UWuBRv00AmlQUqPptTwzqQ6gg3b/tP5CX/d9z+3qjm//7iDIxXghnZ4pzNDbaIJYrhqmLNbKVYsCMr9GGm5doCXv9CmOpQmDu1ZJRQbkBNh2YVWtOq1RwcoAJAIuHhJl45TrLS6V/zF1mjJtvae1QSVapdy6UkXZ9vi6JiwG5MxVf94rgOjS6TTZb48qo2nNOjyqFdHwrXs/VRwu3A6SdoruZ5qbcFP+rNOrAsk1rvqU6IEl2N8oD/pFL4GoCEFiOJKS7E3cYfez71bPtVDTb5bB3UhAA4YjgenbDu6ZeEC01xbsHaRHKo1r+7LX5kfxJBl1Ct5Ebfpu407jpDgVrTbvP/fc1hpq1GqgyNaC01pHCay1iTAvTD/nFmoHnaHijJkvZGwBMIl9GuAHcFgsGT6QWhkUM9MD2dYgVV6mZsuasw22qRAMuVkjqZt2b329J9wzOXj6Z/sGZceJoQCiqwDmICTB1WBDN/ViIVdIa6Zc/JSQDNo0FBXuhbXqImXNUi0MRAgsyrvixT0Lz3ULz3/u5YGnu1Pbfz+YxnP5dPrA/ukvJm9QJowksKCFdThoMvdnxrB6PR5xhhCobAtkHfipDl2joSNqogxsUKdV8PdbvMa3RBWUtn+XzCV4ht3p/NK800Rstn/gVT6Mb8AJcz+hS/nIKJsCsKoaOMCKAAuAkk9z7q2ysvMt/CPzXhLiOimZZ5N/o3awa0Z2oLVMUawjrTwBbgL3RggVohEnbqG7PjoYGqWUn3YLIFDAPHvT8Cyu/AWMGdWoygy280G5PgpEHIjAa2E3qAvfq4iodGLxdKtRLpVJRUW7k13/V923v7Jn6cUbXuxe/8OBv+v+fPvUIKZKb1lefiQIUay4WX8UkLvIitRmGreNIkd5vh/sk02mdekmFcugOWoXQH6BoJOky0wGztJgs7RIdWdSpJ2kc6ssQvIx9zY08CLL8ZvZ7fz9PAViV3dAW4EFAlyvKOfmW7ZHQrkeWMWPsrIoi43QE2VvoSPRUlbZgxIWbsNrYiHqSCzajxolKzTKtmsFySV56jBrjhYkItUj7I5ObyQEc2AwNpuOw3r21ROLi6VKY6G0xFtS7b1W6Dkna94quEsCwoNQZFMjwBTtxA4OljB8quyIsiKzogMRmsIA+aJoE3sPjRemlKQBusSgM1nLALkhV6NnKCsXItU370yenTuWrCqO7ekgR90iM9xZZ07dq6g28JxqZ01Cx1gK4s2GgTmwQF0ky3Y2Q3ipH1iuQYHHrO9a95rnyMv6KviGECDGV+ueKDlnQ3DHJwSni0BpzWd+3td+aVfX2P73QRXPaXl9Oj98x+gNmanEMFaJDXODLVOdAYkvu1QwwrY+ZaWMWXuWpmkR/BmGrzEA/XiUcrPNr58+cF8arRUfwcuBz8HBQBQ/tRH6rrtYleb02JYXhVUnxAHCAaWZSiEymCrrtyC5LALGKZ9M3TEzpcwUbzFmyijrp1pa1faMilXWO+BnjpMT3hMhOBuY0Ebtvub60klU7axvVvx6WLdrakXfmg3+q0r/GkZFtsMQZ77jOSU4JRbySrYNSeOlm6pf9ONVE8YRvjjSvTEnAwjw4OoPttXEnsWffO7Zgae3+7YbEOWJhjxY0VX8+YrKUuFk9Y5gH0vTDMNEw/OmbqOkKkqZueS0bbAs1ZmUejt92s7r7PeQm60KvQUNvEonISWkQJNsQF8rCDdIxQztNVIRsqPBoWiR/mzFDxmLvJK3WetU15YatVOnpA8Lwl6BBDgULmjhFPdBhFbdqt+Bi2qxiteyuMRQEuAGRFVZDjLJbBWWKEu3wDYHuNcF1IvUTENG6p7sYMUoWxQidS1RUjvJjdloJkj7eTyBU+pBPZMdueWmqRRK5IcTKWNOH8pMU50SIUo88P6KPcwf9/7BfBDcTpX4CLcKdNU/FjyeWQWRv9Q98dPuHYk9x1+66jzA6APbTw9miGencMZO2VkyaRf0GX1CJyRhgB6xTarSAgheZJnKvIw3rgkduQX6qX56HRmzD8LoFXf+G4mLSZaX/XmmKde2iUQwmxulnERVaTWQb91lNAB2v1MugahaCzaDx2tn/DW+xiseXQe6Za91DjqqXOmi8Db3KjMDFzeLJ/WE+d4p05NLsdhB2AOcvk9816nwbyC29SDtf4y1cVV3MYgNUAvLZcd1Xb5scYR5v/DyPXo0edYtijzYZ4DtafEFc9JEpy6kbdKBtwRMql3AqZJzrrbgPhCc9VeZb3pW5AQ2ahgN7oZy3dQBFyVKti8rRNRhjaIAI+Il+SGGEnSeGaBD7tku/Kxv6Qe7uh/afmFw3ppIGjlsy94eQzVnTFCp6pg5k/oATxV33ojj1qS+H1kzZjzIOqqLF+wqXIIvIhCRHuQnrYjQqTiLrIz4ggMgisTWPaJ/ia+CKN50tkStLuCkYIipL6WxryyBiGEK4Dya5FU2asftr1nzGKmEtfv5RvRkeNpbwE7YiJo2+aEakSWzROswZaukRldxi6AWacDRSry2addwZER2bylfKts5dql3iwNoytG89wkvbcv10Mb57kdf7Dv+N13jhV3dm7dfGjSo3utwkP2LGh2aymTTmb2ftFPE1BK0105IJMRaX8JZnGAZnuKHhfCmnLlw0jUZqUz3UhAzDBB76lDJCC1fj+yaadJFbUVds1edEqSVbJxxgYWRx0GtE59873uyJiBcB+5+1FtMcmWbYvkEryB3kwWkQhp2vZeJ8hOqaacInFXgoNnErJinaPRqDUwmwRcD5gG+AhvaLM9nHLukeuYPwiapk6pkcUMbtjWkzeXnEnPx6XxxXlcsm2b5USdRirfTNcyVBa1uRSRE9rKxiLfwKnVEg0fSg7Jy9S4vZL1rpLzU8iPkeEJWisTSQuiW/Q2naTWtZd23Xbtu3lmoWhUTssfBJVnNZm7oRqUlWo2HadCls2HeTfiKMx0JPOWjpDvOZ8HDprrK+S+/vOf+l7qXvnrF+YGp7uPdnw7GWf/AqVvETt8skfW1Cqu5Pya/kGsgEMxweMzm6BzMHShVy8B56+PmToyMgWGY0i7p1ZZ1kFeqnSQZe4piR0UcuJP3BLPUehGMbxukquyDgLmRJU+gGuR16CmxJU7RkjiF+Gq/LwIegZ6vgsRDA1PfKZ1y6hhFBB/pJ0maobJF8F0854wyq55xjRKWBWSHtyIQXZ5VQWaTnGaPo4Ej/KeV7jvIX8MxyF2ipJTB1bIER3O8f+BIJocL+Ms0h8fwLJ4lCQppuXPfyvz2N4E9nvvCCwOv3rP9xOAlbxh4+h1vGHj1nW/Y/c8P/Wv3uRcO/3BPd+0FAMXnt58dvC4/b37BmJBFd90AjYAzeI7akVFVT5ptZ8Hd8ECtcwqDkC1/2c+TS+nX09flpooJ00yn5uIGnjJQyswG/dmgUNaqlq9EJrcBIfL2vGnbEPwZppbnhLEyyaXs9yzfqoPUaRgLWgfEUsPdqDkygoXDfffYcSYQ8wJyEaEAQ2613TkLYqvn0R3fv7cnmb9vg/giEY0QbRt3qqfsil2SgbUgpKE/5bkve5tkiYBkdXyHUt4USxTCzIwstp+hK5mFP59Du1vr37/phQGl+8z2zwZ1MpWW9R1VLSi3DF1+aX7eUPM5WXiUK2yMQd4FiAR2k5TtRZuwFvOA5HyjQwBBaAfeztMQ6EAfhbx9jZsTujNGJQkrTJfe/pPuR8jOG8k+qgrDy3p4mS9xh3ll7rKI3ofoL+l9/YG1AmbKMe8dldphGUw9w4EWqcfH7rmxMsNtqjED8UxQkCTs9OzbquzP6kUhpyGILF6lHaOClKXEcd0zvPSizL6RE5OrqWaijimln31Ya5gRJYaDbHhbWG4t/8OvakHJ21p2y6UFLia3EBYFpkEgkfp838kXdp3dPjdoWKSIryUz+DBOWLfTOXvIuJR92J/wpqqTZcU3CPWAK411JaBtuslrXtNb9Rb8Bxpn/FW8Cp9UWgzqjGPg6NCM/qv86Ohs2p12EqDp5m1w/8Zk/spMRiBD9nt6xbb5mHiMn6LfcDfdTed/4uP4LPEMV9YvExTNU8xUHe3+y+7fvdSNPb+n/eJVL1/zRPfe8wN/vX3h9i8GZf95r1lWNk/juQy4EjoxpuYzs4TNjSYmJkZM2Xaeris1I1SqRmCAvZRRNLolm2vkOgF2cq5sjScZYPtsBufZzhvp1/hNLMtyIL1kf02GF9DA87zAxtgMu4E2nWGe5Rm5JeK7ICBkFZFwS2DXYrQBOPDXIYuYDNLvchbViezyYdJePe+U2QP2Ci6TsuzItR4EZgqMvyUuvAVCbIMcR+TJqNBfyruysYK64PPCYgjGy7Hbdg0YYSXy3dWFUmXzLNo4e/qcrAv5KZFxJ8S7ZK87VUnRvsn4NNasjH0bPYjoCDWcnJNlGHyHEVhCijZH9MhYajxZFEICBsQODNAy3jn3OF10TgbPsS3yMHnIOm2W7KC4SgWi7sSa6qCiM8ZNYEpn+5XEns7Ll//o8093D54fqHT/8dd9g6qWH7NmjFH8GXEVO8pvpTOI7TX8fpCfZS1MLA49ET8xezJ1bOZs4rQRyiUS0lsZsEEcI4vnKzANhQsG1ousYORySpGP0kk08CTZeQubZkfRwDrf5+2lB+it3pddBQ1UIFtMmG/dU71exaDKF0UoZJmXnbFOwOsJeEqA7mX7JNmSBzpnb+J7EN6sT/ev3n78luN3VFP1uUqukjtzrYC8C21w1lYVAoTTBY9SRLHnuUFQFlW+7txHuv3mE3iTPes8wOrhcSeUnWWyidzT/GyAklGB5EGS3tl+sbv24q7udds/GJxRhD8zPzU3OTx7m5bVc6AjbG2aaEQxUrhgZ+wrWR6BscmxghijxE248/UDUaI+ujSzno3MkgHCDE6+zFGZ191QnKjcfezYGc/3fNnd0DreONY8Hi75W06D300XEFlnFWWtsJU4nqmB+Oy33OnFnvcEY6h541XV1cWYq4m0P+/Pqah22aCrtXJl33d90jDr5lK2kark2hNyvwB4PdXLwvDGER0yRvLjynRqVMmkp2+8KW9JN6LZaSNDc77iguwvo2I7dxeuEhAmOLAW7Pt5y3uifvfJR0uN9a1eXQVyDe0Ou9ZLe06/eNWL3aM/BNfz4e23DcpGBLC/DrsfTEOvdRnkUUP2I2CYVKuUK5lg5GR9t7dCS7jpH1zL+jbThS4yvkXSbtIdFTmMxs1pTbWSxYO5XE5KHtPOqVQzs/q8D+mPQpuk+kmRjpJJ/Amb0/cDi9D387HwgJNhYP8cywPUgQPTpteWBcEKD/G6Ddn5NJzHSXzOfoI1ZWdVCeJq03pGdLwz5U55uRH5x44TjgiT7Seu79dkd1a4wC7euaL7zsEt467petxXfLljxgQPSFxTmcwlconb4qNW3L6W5QQqcOmp1/lD/JtkQTISkXVYuZOEn6ie9O5R0e7u2xZe6D7y3K7uHds/H5RLVJikjBuG5iYO700OZ65Xx+0b3cMiTufDpKv6c5AhSzdF6ZX48tzDU01ZdZQqn6yJlttwNltVL3Q6jXIZhWFk9h9Pt/P1bCNDeRWGYGnZEb4nN3QhFiVa/UqpGMpVkOFFCCWWlCzMvAjC0XFrInDrtdO4jogj28rcyFoBZdkAJ1ql7dyG3lKXZs4q9Ww72UqXUD4crcjqjAXaIeelXZXm6ZSmmegHHx+UFBMWI6XsBV4l0xypHKkOOyl6Kx2lppU35q2ckkRqZqbenwszJd3NRxNNGRIA/qRIKC1kiwWCmcZUYQYGEtjXQGor6/MlDXS43Gdmx7MpbSJnsbg76yh+ooNyNSNQG1MPWjXyTXIKUmrBW2s/WGmVaqub1UopotTDKLRqTiWshi4tK2i3tb3y3J72Tz/x9Bef/+zLA52ut/3Pg4RkSZpca92YH0vpVrxg6eCRbIw1TT3sJtGA7aRtW0yjgY67F++8Rf9znCTDBH5+hNzWD7/M9vsJz1ihIUB8T0qDFhESeyJ4SSRLEmv4UXPMeYotsS3ZxbTR34qXC8cmTo5uTgQKt2TBqpxrjjeP+Dk/z7GnR6RX73ZZyVssg5OoM+fwC7KRlcjju2P3qYFMMNtBRnjHPZj0amvwY7aWraCppf6Kd7rVjE60GrWVpU5Lt6vNUpXgUBZARFAD7OvwMmKuVpZdlr21W663TVl7DqXfNQPJy9nApgh8E1cFqPk7PNtGOx/euWCQ1lcqj0dl/rgIiKzeBBAyvt3UUAkMej9NJsfGJo6OfenQqK7hPNYxjGDOps3+AZd2rG/ZVYhjHz63BJIkRLsb+ktd94W+7r+8tOve7sAgwKju6p7uqsDJej3VTh0bf3h6laLFC+6mdy622+fOLpyIzvqbrEa2yKbe0JbV9dG18QaaqYzT/iOsgG8tJM20aQOdTqgYF4tkETK+Salfbd35wLkHXdTiS1ZLrekN3ZH9JjaMAZVtxiUL8iwsN3mkO8Botmx4d3T5LE9VMmE6HC1pMDpYyg6xD/wH0u05U7eL5qFsKpPJTUyaxdSR2dHwqyLJzF4VxuIm4kVfrWcjFcw6yNs1ZyOqOOcXTlLw+riZbie9ND2EyBWFzNHh5LxpKWYBRiYF/sOgRWcqSlcPnzl6ivBcGSUbFk1lcnmSKyeFxXtlXA8mDO0+sa2/MPuDPd33/QiC+gfb/z44ht+XG9V0nLHz9pSRMKbwDDZ0PI5I2jf6I3VNa4tl0fEXHPSeC+nOG72dXfa7SY5Zsu+gbLjMoas2yF/u9XY4yT12SAjmk6fpGfw42bCfZd13SWdrl2E2PcIC9kiYI895qM1bQAdo4A4HdFRAKzB8jhMEQLZAcZ1+0zU900WjpP8QVfE4OERn4YfXPt+Ny3T8/varg7KKCBaWajP+pCj6hR79mMwIDke3OMPOAfewsReZR1L7pofzSVWZn5+a2jc8eqdSyZy0a9pp40l6jJ52zjvH4RREm3d6jTAeuHHIT75Oe6uwwtX9RIgSUX/eMAx1XksQk+hEsWXV2QCGh6DtWKp2FRm13s9u9/a7h4LR1rCrAOYBlnamXXMpWdVOWagFkr0BYBo5AqxMpyS3uC53opLrBYHjbB2795nK3Yh73GccwHaLb/B18hCWRtejnn2X+kjhDJBWQDnCnlWFtC/PLWpyM5fGMIzN7Pbzib72X+0CB/TUIMZmShvPXq9PYQOkSBEX9bH0NXbCni9m5P40uS6NMLYz1iQuyF2gKH97P6VGzWhkztqs8LjVURfMjl2d/y5wvafWZflbqxRrKLXanwWvkVLSRWwBqgMccMst8jlP5a/FmRWOgvPnpDwMqs2sfQ2y0wgmQF0Dk3MjPOrm3ZxTgIHNIT/RHPVNsA4mHEMVuGk0jSUwlXKxVZbEWgt+BXmlynEMMpnIfcFB4yW+4D24/HL0sLvMTH9VlP01bxF5i05bvkWrWHJflMwoV2dZOg+KXQE0737m3Kvd//nM3hc+++LAI9uz278aBDrJgaFTvJxrcSLyPO3dBiP/JTTg8q+zuAmiv0NgHKXw1I/Iba62ZqvZW2+75tBsPKv62mlzwVplHDFuBnI3A+FyJ4NsLDWiWZxWVMMy5w4cuXp+pKghA4wLFoavL1pLuIorvT4YiW0eXsGr2v/mD2qvIBAMNQojPfaIyYrCwOmiahRNgi2TT7gFPx1cKa5EbArcSZHNelfKZTN3HzxWvYRsbOCy9cuqTnpAirYLJxMVlrUWa/Nm2G61mk6weAYctNdrFDIcHTm6pwlL2L334cV8ybozf6K21Ar9wJMedH3D9REXS5u9tQ+QPH7QOe23opXAF6C64dy5z+WS6j04wGX8V6RsrVmnrQ5wmV3Nrxqe6UxHYMsGXAAfuS3YJrm83LndfrEzyC8A7X08ajmBX3G8zrHHfyXnzFOC/OrepfFjQ63p1tEojuRWgBJ2QXSAXHACp9cgyIXnhNLLYBf7BMwvTLpeLnRy7dmtsTOp5bGH43dih4P9aW16pbBx9rnN+9DKnbJSyioYtLHNbAHEW5p2M2paNVSgdWv2YHIS6UpmOj+P4gfTm/2z90ZzM/dPP1joyJ3n86uGAVOIAUOJbuumogHJ6gig3XL0lRscqzbRGq7Ey0m/4CnSEnuKp6DS/JHr+pNHEyNmMR/PJwpxJRkf9RLMOhGXZBGBOUO7n91+zwu7tq/b/vagRXr7HljeNCF4wOkWaNFQ912fnI6PaQWtoBYhbS17+CuyuPmp7oDmYX7oIa1s+kbZ8ottw1NdpDlZs1+1ValLdCsvCqJw/BofNO9LOxd0DoXZ2lwIgolRDGdvEZVo1jDJmvvNO6gb3Mi0QPOpT0/IvWhChLSD6Kb7fcD2OlkSbdGhPKxtPFSrrp1ZvXPzTGe1ueSV/XXEI8qMitbURdpCux8/8cPtN8+ffr6v+w/bL4FqMuG6cjSFDxqXKl/SprAOtiKjzRZydv1oaY6ROkV1Grgt3oY467AmK4tlZ811yDF3y33Ec8EwYDufR+nUl69Opw8duu5q2Z+cS2tqLjc1nE/Hx5OjxanCOLPbsygqPOVvsFPslDjBjrGKOGY/a1TpZlASQcBDHmnHTOBs8IFfYh/kX6WHrUPWftmD6zzwl+0F16vWo/Lyxr3nHnoYnX+52S7VvdCVreyyO1B4vqjZEXGwJ4WA5RsAxqyntHjGBa7nY0GB2WwfxAbavfOWD53f/tb5PYuvXvriwKsL278YZLP94HUT+LPkBpoVU+4QiI1b6SE6Rw7RNCtyHSyI0ECOjJFbrDK5HQ28CnpzDqvagaCwVFgsPFhZAwF7rywzMMkfQJjccZDvw2evk4ZsDNPhcREEgQaKQnX2M0Aukun9FQGF5i8aeHp2/QJal9unuCC/lE6M3kcflYtJ5+kilkrmx/xxxM9UcX8bdwc8JpvvZfmBipAtsw4RtqOFNruejlMAdYJkjwychzfXW7edZXOQ7RrRLZTWcFH2Z22/kNjTfdtzt/80+fyA272/u3sQxI5vhcWOp6rtYsdcURYBa23f8nsl9MAK9FrhOOT1wCOUZ1ckrI9+V/7FA8u3AeA9q1jRSnpJ4oXtmj4qVo1Ir6l13ppnBh1XZNeVLtfT01vXRKoDiChMRJsj5GKKGxOyGtQ8KruDq6NUkjezyjNgLohQHa066uSlqi3Hwb8Z5TlmAHoxqzpNLUTqI5ScuIrKWiYYbUdz88xgZk0JAIgYqfqAT0KeFCClQGGAG7mt3o5nuNku+M4wfj9MA0sfpxfvftf7X7n0O9tPnt/TnX3pU68MrD+3/R+DKWnHMUQ6kTuKwfnppk4Vd95N+Na9uEUiUCdIbtb2ARAXyCJFZwjX+nle7PwWvYp9wIzTd9Kb6V5iIKxkaL9KCzBBs/b1JM50WrRBlQ9MvbbCYVNLsVJWGk7M4GAIXmvVk3c4YRtFpkNatNwr1YJ5dvjd/D66QCsEcN4OmVzHBniVy+Yur7OS062AhRxYd+4yu3P4B+Q4DvTAdrB4TddavV7rafpnQHdZgWaceXOCod1T7b/7yD93P//iwB3dge3fGWRh85hcj/QqftWvBTXuIadUzfQHWiUHDk8L9Nc6XLkNst9cnK1lfUDYIBvokQ0GKBQVdyVyHKsOTOxCggizrNb1sunuvf/L30mDMUZidhmunbGLIFhFzpoxXKOQzSbU5OSX4jdirKqycQnsnKnqFAIG1CVk8UAHpkTuUikyWs80UxzXvEAc25SbTEW1TgXa/eRXXrny2T0Dl25ftjlokxF8QO5neS8eNnYucD7NQRCN29MUe1qUC/Ej5Pu4+y7uCgbJtEnRwwwsjtyt5sjfQZZ5rgeSp6K1+/WGLQzRazDXQbdPdP/m6T2dH179VPf6nw083f3Y9jsGAVQLFlb0sfFiLjmdT2cPFKeUeX6EqqwopYsz7RZg+v5TGcidtsUgVU+G5r2zDfKtmsuWapEfBaFXKUO8+rl+RxO6fKVjukYjsZwr8xJ3vbBVWgA68xU/27DKCPKwYdfMTVYPFktb3n29BU6HuLiBxQzoKIuaNrIwxv+/lwYeeDjCwOw2+EYOB1dlhZIjImbCIpN/tcMkSCdZzaDoyY8Pctl1CHdPc81QhakFAIIjWRC5OjFwzs7RLKKF4qSSTE9+8pOHv21E9gJdoVV/02+GnaXTrY7rnVgUFAXUTbjAR3++/dHEnruev/qpgc43AIZtEw42Bcg6jxV7ThTthHToBp0hc+SreM4esQ5af2jPG3eIRC0faY5e8yHt5BY4GETwNzBTvd0Jbm8jw5JawlV7i1ZF2z3VrlZgKNfuka363BOuX8XUbTrgxkTV6ajnlVM4KLYBtIwgW5N5aPrWa32FYBTjIgU0OakbJiambWJUNDNFEI+6yWr9YJsWWEOcw93XWaGsGKYpSlMTGyrqXr5TGizr0YTY715tTs8fVXOGWdBH0/Ps0ApKVWjQT12n6TSj+yzRPlNZabSWy8tll5V1tPuL23/wVF/369sjg5akCsCgw1OF/MzUxL78mK2ZmtxRVpjAgB7qkDWL9L3Rre1Rv7A67fa6B6Tk7GhVvGWeFQ1PyL+NQFGJPFmXILHY6yWXa0H1gFWVjlGyHVNojkn2KWhKv12bNm/XEm3jpLHlfiuqAyX5svfVr7rl5Yfvf6RDkUdBJsMbooJf9IuBKmVzvVdZ8inwslxpCpFbAy6Wm+blh4vCgloygEJ0z3Dzr3UTATEj3dvPCwbaPbf5zJ7uPecPPwom8qe/ftMglc2/RDdyO33mR0iKZCRez4aYqc5hMmvOWzpPwRTYcpOjTafSujk+O7kvf8hIGwVrCvzTiMg7iepkpKGNqZOFc7RNH3AduSuNuKzCloIIZCsFB+faJ5nPIdIC4bfZKluk/0Jq9lb4PDvD7hRn2D3sHtHhJyUjdfrlQmqBFbjuwPxahsWphq7aeWwwMsOEGxcZNmdfJ4N2jsxLrNIKRn/OyFqH9DnLIDPsdpb2zVPWhr9ZPwXif70cVkvLUcdBi84K9yEjUsce6qLv3PLkntVvA5i8rnvboOyo4biqPsbPOneKDbZaAugAO9xbpV9YDsqlplthi+KMujy1mqsebWedtDsdxA1kkWkT4oBNKwVjtjA0bIKfBP1qZTO56eJk+hbtK8FRxDWuSgcYzZey1cRKcj1/MvMP7t0t0C+9T4gC7qLe3+dhLmehUdGrtlBZBmJs1pw2rjJzIisUL1v7f4S9Z5Rd13UmKC66pLPGFuxGqXqmZ7pJtdwaW3K7bUvuWSPJpqhAkxRFiaKYwASCABErp5ffu/nek26+L6fKhUIhEAAJkAIYQIqkJMqSSDFJVLAcJGs5Ta9pv+Iqz5rZ+xbl/jn1FkGQVa/eveees/f37fBtUq5Tz647kRNzsA3eKZkAk3GtmJPBJwfXjVTtXgH7zESZlZhCHVPXVcYP0Sm2/RtFOLSytVpvk/5qE07AZmvBXdDIrvpW8uZVg19/4+qBsfUXI9gSB4iVlW3FnCqram7MMrR5DNgBncbi6gk2Sfh0gQ3lWYnOWQXHdowK1v7LChbkgJ3w7KHYWLCwPqSeljcKAF/ykGzI/fIg7IoxMRE+xI4QPueP13UwAbwvF11Jg3rc0t6mifG4NbjaWSYsromhb/sej2MShawzxHo2AHQLeMMXbZJNqyM2hAiWwhVGq81GO3ZP0iXm8q7eMgP40Uj3WMhIjbphgu0ziRe7YK9tIKA7xT+2b/uZpfu7+yNCb/XNa3c9t629svvr7kuvDb7w9AM/HP7FYG3r4yNZu2KVdeAkDh6CqRlKpzPlmcqoYwCWB8RiTtI5Yh9wx+KpoFAf941q/uyREAWV0EDQJpDyxOyxZUke807WgWJGYMjL2uembxk9Oj93rDTJ9/G7O+PAQTOLVpVYNaCmsGPiCAtxGf4OR1EcLDDUbRWluWSZyIxfaeSS8onJht5Vzmfx8McAxVb1Fj/ptmGtsfocbvMajy8AOKv66x28Z0BnbrXW6kT1Rr//hKwL3626CQk63gmv49bY15zH6Angtk1vlV2wIsfPY3HT8D/pwmKwin0ZoqAU+ChEHlU9NIOZhiM0oaGGAfYZgLFRwn1y2iRXPjeS0Jrt09iuq9gTBt+1YVeXaYVp4GbBJgA2VAk1AKrN84Oiqs+oY4Y+lqnoNis4R82sl+vM95Xj/Azhb5288mK76zO+YJFdf7D148zuxR9e/+LgY98bPnN+6+2Riulk5I3iEK8giGT4SVln+8P29UAqnAf4lDfjZgRtKjXNpYHAuqBQtjx/GVG9103Okfql+mZvI2k20VC0vKHIDG2hRLdZHxJ3kofex0qu09fbYMPhuPIAGyQxdxCLhJ8D8tDlSwAC3fPmE+qG0WNUq8PW8hyAyOXEBIw642KVyiiYUWLac6ZlwUECkwq2NoMiQo6NF01T2QveY6tgfOi3rSfsK4T1jWAIxQbKnOhALbBqentm6z++cNVzr1/9D1vFkQo9UtINh5qWTYs6K1XngoqLml20FWGKz8OCm8gLnMhLgMrVDHCevA6uhkosmKeBX/UiCrCawHEA/1RMfD4VK57G5xxybPuzI3rFuJ/dyb4K+2SvzEjVK0UzkbkA2wB78zzPx0oFQAgxYFarOmTFAIb69KRxOjjjLdGLZhX7NTBwAYZLWq4tCpxk37vrD7a/+MLW6cH7dw/2vXLzz774/O2v3vLifd8EcxxvnRjJW/PFFLaloiTWLLXU0fYjm7DYXlo5jwEaAoa5B5y04TG5TIZfEg3YrC3HtXwAV05Y9HSH3PT/7AW+5buBu1JP8IgIz/cBcP60WWt1kUHWawjekjpqJlwBX53g08VC4aDO+25HVnlLxmT4WenZAisKWY3XWJ/H4hRvsQZgoFCmvcsAun0y/DyvOTZKM/EAg/cyxAYC3qTwy18Ck73BIi6AGUjL5zwDfOT5ece0gRvMyXmsI3YPpu3nwN/SRlFk1I8IIGnPwqH5HP0Ke5gKOwvXyRwbCyKprVmqWbYMQ4c7MtOYiWs9NFemZipHR5jNYZtxgPyAPE2Rc3M1wCpAIgxZ8SivmCUjlWApYR8giQzPTrPlaZPHYgFN5HIlrUz3sYjhggXETrQ9cS2XLY4yHkb/9YdfGL5+8J7BjSMe7wEtbWqnj7Uyy2NP3rV5NNYiFdmVmzbnYV6TcKfJkB8u+L+qOHJ5WEtLUzCEGDLf8YjjUkw/yom1+y5pcaVhhsfOzi2XUZnBx97v6S5FOYlc5Aeev7HUb3bq0q2FoXei1652a5HXbgS+SOyImNXyggNstSwwl2uD9zKtz9+HbS73Hc2XNKOiGgYpV0Q85K76f8vPsCtc4uNhCO5CS+bArmHPruKYwCbh6pnOzNIn+Yf0P6CTzpedKWA6dFKYbJLOCjswQr1G26IrIh42pCsv8A3SDr8lrtm1fWLr/83sXn7lxte+8Pqwf2Vre8R2qGHlzDl4ROP8sL7976x91l521BsFWCOLYp4rgIS4InJS9ffz6dohjOxjbW29EFmBvUxDN0ICFhBRhf1XZYkdm2JHwMCpWeedNqznP2JW9xmgy+ck0FbZ4V35rKfKF5HVP+Mp/CJv4dV6fVMRXR7C+sPtT/mltNSPAWHeNfg3J175/BuDv3oNaOofbu0ZOaDPTWeOEC2vsSHAxtzSiaWxvUPsS86Cfi9V6e38GB/jdnK/sATuYpQ3MsHSi44gy+AQw6YbpsUzw31wAINPsoglInTrMpEJLnr9ArDfbhAnVRInoQk4Is7Kgptz/4w/wO+QuUgDNuz0USsTkbUXNUVAkueXv71yptnbPFUL61HbD+FkRhPene5X/TXtD5xJ/UtsgrBZzupFEuo9MdSDKwngC3bZYvQTnvMuBa+LDXvVWWKn9RZzsS+D8DC7qcVGmK0ZAEVHecW5r7zv6ME7TQ3OlGQddV1vE7NpebDvk8m2IknZZeDcyK5POatXLbw5+L0Xrx58buv6EQreHoibzQBR5bRcrlDQdMPkGMN1sRMbbLtD5iwR8o+z7TsAQxVcMHhxLipEZpWvorJD3UXRNGzYQNvkV63XjT5z2QJbYpdEVFuL+364uNhshkHVJ1WwyC6N7N6D4XgwW7tLlsMH+aeMQ3bWU2tWQFulUBAs3tnBA9KLql5HAkHjr9jLDMW3Eta2Ttl1VNU8iUWB+acwVOZ4zDO6pYVyHcCVj8QCfKkkZnDYMwBUD27Y+v0RystUo3lLMebmVW1+6t1GQ0stVSb0yeJ9sN/3EIA7tleKj3VHm/AbUAC1U3rM2Ag67ka9HvnYvwUgkq/1k6RabXbDxAsbbS/t7cIWAq8aLidnrCvqKrBxmsoKGpg9k2VcE29mGTZdoAaaX0iO+XM2MZlq2Zz8xUdHJK9PuVg0XpFqcEw5oOaLk3NT47mxvG5nYN/q2DqrLdK+tx5/s33x5OlaPfCAjjt1XHeJ1tm1EzBERGANJaxfo4iubaUJF7xL2/q113YvvP6F14BbTWx9GZ67xUyhiEOpRiDqAJVtnxctIE4Amim1DVUhlZJWRltOTXAFGrxjls1xoP+eLuZpESh/nhUIL9IDdAwzCzfT7WutR+xxtwCM16QelrvDPcu0uoRHvNrjTcI74LVC8HuDj2NBVh/sbMyrhHebxtAi8NAl67j+qHys2gt01o5jLwoaAAY1o9b1Ai9Ky6CiZeDMJ/mmdtapU8upm4uFTaVtxeMbmEQ3XcsjxWrBPxqRrCe4TUl4/UifNoxurl6RdpyNCp7iFrr/tXTfbeVZK8MngynfkrMNUgl110YDQ18fYuf5ORYSVg/joaTeSZbCflgTa2B3Fgbf/+7Vgw8M3hlx+MGHjYpRKWSMItELQwCdDpkAgu1RUeZgE9NCZ1NYfs6bqxV2onlgqXu5utbQenpi942zbAmoeSwj2fZ6YFWsh+m0f5Sgh0VQJudcLHvXpO4VqkfibFiINF+vZzfzTZ/U3MSN4npTBk5sth2rHJcS09ENIwB73xj9Fn2r8XPi9gFWREEsQrtK/eBU8qyMZU0Esl49I07yPhezkmTAr6PDZsyKrIi6lagS2X45LAeuLHsqbKMKJzbcEipEjFlYjW2mUaSZsmE7zDLTfjMTfN/gvZMjNTsxsROzpYLTpqsaNhSX99AcM5xi+UaqWkamTKbyBWPCvs8cbeXX509VX+ic7JxePXVqqdfoeV2D7CpjwvQTW58YOaAdK+VLiErfVbEF649NlrpeOGbO2wX47V8l/Dq3FtzpHvFMb9zNS2wesjB5scRhiaIQwJHdJTRky2yZvmot879CmoB6jtiGWOsttY6Hq+E39RNlUjd9p6q1S00nAQwdYLMmkB0RuV3OSu2Z1cnoWI0UgntqKM5yl4MF+jd2X7vq+EtXD/5k686ROUdzxor3TN1/T+MzfknQeqmdo/4itiGxjnzKq7vn+6SX1FzU6Ii/wlT72Ggmm4Wzbk3AEeNci8s1tQG+k4dazEK758gZJwtrrSmWwQwPyEK1UC+2stRaKZOeyuFAJbwGR6zuHgcL24mafqcd+EkShl+72Hwi+zpYSobQ0XWqyJQpeBAryXYUvxBKd1xgiK9kE8U2aEYlU6UJOlSkpVTHSCR+4vpRNYo63eOdTQUbSKrATYSIW8RPdpIvTkB9O2aoRw3HyhR515MoOvYng5+/fvPru4eVwe9s/fUIh0eGpgRNjaXaBaBZZUByZWPUmnPy9iQweDx495oWtZmmU/gXYMIKoEEaWbEJxEMsiNg3ZwE40gIYnjydYRVnzL8nGgtnZKE5157x7X5pPXfWPlsjEXhyYCv0OKxEFe5B9EQb7sgz4YQXJCkJTRsqlcZ0zM7aUo+ml9TT/FXewYJjEYXfdbFTWLgev8LJN98b8jjCHhyOum4c6IXHAdIYUvMOuIc4OchlNISiPsKVYbjprdf/UljHAkWqGJikukKv3TUav3bV4PnXrx5c2fqDkZKOnYrU5I6nVafhhM+IsqiA2bb5p8ESM1qmJWLuUwpHsvOVg8Y4PyYo1xIVDpbdd7r0ZTT4wRnZA4AVnw66Yc+yvLYH4GAqyYdwStMqI4whYPsMsa3iYUzyw5m1HZ3mbFOv8IP2vPaAf3vzvtaeEzNPa2TdWvIX/EejJzq1KsJfFEBqtWvNRqd63D8tsY/RIzJkP6GbdM1uVlYAT9ctkfWoXVDJrge2/jRz1eB9//3qn2z9xgh3TSw48eHE+jzQZIEVmeUYGpIAOeftr05HR0g45heCsWC8c0f1UJCL825R6p1sYkV2LQ1t9QApkMDvrqEia225efziXwt5anBV47HGOTfwayJCNc6xTprow+ozzi3bwi/dgbUtH648krm1cD+GSVGlg9iaOq1mSPaQ1R5STprNzA+1R0sXzJYT0QizZDrANrKrtfXBzO7ei1/+3hdeu/Kz//79m14dZoPB1n0jhmEfDsCqCYs9RIbb7DbbY3ezg7SgT5TuA9yUVRTB1LbetGvGqrEGcPcE4QlwqZD7BhZRhraryHlPtcsZS7d0Dk535harQsyyXkHxBGudNXlMW7RKhtdplW3SdedF+yxgmOGXkILAq2l485wM1/OY6C7Bj1kq//QQ34NVB3BNAM5KXBWzye2hgWgAHYhreEZzql9elcflyqO1ZTi1Xogq0PE46gcIpLFObwKL16q6xzEow+yEtq5t805tKAmiNPHn+UHQ7y8+HS6HS/XLHAgtY1E4+ACLaN83nEXaNRtaYAIESytrODalBqqhaWTXS1tXb2lYI25T29IVi6oYP7dgW+qKoc2N77sbQ+2f+c7EOik1XLOcKDHDAnxBWQm+0pYfEzip7oFfR+/JAiMw2tnv3Jjqw9q+SWLV0IdS5QowLscO2SZ1dFXTMvPH9hZLul6cs1QtJ83j86RfjN3jZ9r9k+eqjaT+zJWkhYIfrvQ9zn3LdXzbpaSlXtjbnXLtC9d5qZgDhgYSjjHsehWF0P0AjIMb1epqQl2tZtQnL02dHt2o1CoJkFcv03QQNNpfe4l0FrtLWEK0fprVWM0Ki4DO0gZnfxr5/67K9nXfkC9tfThz1cvfGNz+jasHz25/ZMTnJzco8HzX94Jqs7nJw1QmzJeh20R1NX/N2yTBZXpZv2yv0p55HLmpbMtFLnUst0xVlrE0hugV3boWbCCm9FWW5aN8LzzcCjUoZpIsNacUy7n5TKZAZnMHS2XXlGpsx1bNXmA9+qi44p0VdfE8sG/flGVOsHTCNA1TSOugeZBZ9DZ2kBfgSdlCg4c02jrQyJCo7NGumliP6kmEmUhfNOAot6JHu49urJwkYcKODaHxBrrxVeXA3IQNmwG9+kxZty240ilxWFTc+ZDMJdlwvpEFRomxOdNBCRtNBbSn+jp2XMYFiUQbltruFFbKj5UeL7n8FF/msWi4CUCcNA+fNlDyRoK1HIfr377t8p5vDfJPPvD87d9EvzQ3ODVCdZVew3g+j+5iatTBHnJwtmT0yJBg9+xBjZBjY2B9eW6M2Y4qiugwPPBHNq9rISWJU8UKBXEmwL3S8/GcYuMfGf5gzTvOGrLrfk34jmReWhMAP05XrKqIg8iHi6sT9KdmAM5Gh32vAGQ0XApvVhyZxU7V4Q+C2RAGrPL91BTEfu+wDwTcrPAyzzsVRhSaJEPNhqk1281WFDWbUXTpeeCHYTgURusbYSjlxglkAc02FiU0WmkdILxc32JpotTEahds9EewGsO2GSaYiW1s/7HNrx3+Nco+C1bcZvvActl0VlIHfwABIGc7IbA0NqhaMcrGDRs8d5z23Y77LOuJmkCBwIA/IxNGwOFi6cyv3gQHuVhI26j+z9/+8Q2vDDpvDfj3d58d3DmcvTh4Y8TmYCSAYBgloXAVsJwmSpIumB3Lo5FsuB4NKsRXncIQ1ayirRhZU5neq2SpbT5Cy8m9AeAGkdbd93NNjYR2qxj+qgJ++GJgduwe6zJPVH0gsBKJSHZHny7ikQfeJWKx0SNGpxIMVYKKKAP4tBg2el5EsV8zrXbWw0zH6jUXsXILf3frJJzOoL7uJkQGbgRr7InAX/K69qredSInNaXYg15stCK3TgCyYS5KsvN2i0Y0wCegtWhYOVeg2kVid/x4yI/DsFsL/arsyJ6sub7v+f4Cb/HIiHVXdcddgxE4FnaFK3xGLSlAZ1PhpPmMbRhlo8TpztMCJ3gNf1f0Rlii7O91lfZoWI6KruGXqwVZRqlkRSemZTgONuyUdJv//3S5bf/O9nt+tPXfXt/912/f9bc3vz380++/89tAilJVZJNhUiATZ+t6bMJOlz03MWv6UkHbVzhGzMrsI6aulKwCn+JHvEo3Xy8LjsSTIZVgcNZswC0Akio0L0vBDCojmCmjsj21Ng1O0de8nDsjS+b9Zl6fM9SKXbENXvRKWLcLq6CMsTKhM231SbrOTLsbhDJxA9kJFns8AUcHh6DacK9B7QDp1RbjS/Q8WzPPWhE2G2BUGJ9WbCd6x1iXsQjqQUPWpe9X/QgHUgRERnFPw/IebEAH92G4GvgSHUhexVMwjjsfVmKsGwjq1U4ATDYVxUSTNPwSHMW1eCVa8tacdbpktMuotBRh9M9x8QZNdzIkRc/imsBco+oQHb4FEHnX4EOD6uDzV21tbl0/wqMJTzdN2/YtqwzuVOjCGJvMajMV1Zutl6KvPJqGZQxX92arGW+Kz8MWyBqKrdoUluTQnGlX9AP7uUNQERD+FzwSXsF6ikahXnJpwJvci6uBJ1uNZoP0+3FUC1Yaa25Xi+0zs4vFqoHQHPY+kIqavmH3KHnC+v6VxiJ2AGHjrJcuIywfStel4eUdRTOExqi1/MzKjz716vD1a+/8+siwIj7KDtNZhuyDOib/kKtJS+iswgqMAZN0sGmU0IbpXSO5Tz2KyTlTqLKipWNQUsBDFVqxp53t/0UexdKNW3mRPmx/WbBHjY7Deeyhxg3G0xW3gQMo3A3eYJtsgT3Pv8b/gp6yIysp1FS3AawPqz2AMTl/w87yqv+U/xx36bP0AqulnTAIcCO1YWBiSeUqy1FwU4YN5w+PnMpMXiS7XnzlrT0/GNzw1vXP3PP27sGeH97y6vAHlrc+MqJxf8wFkp5YHXbWScQFsPS/8YTke4b4HaKcALbbnZaG74gaUfQfNTAQQYB4MvSAggESSH0boDlMxAMHI8MfsGq0K88QuVljQyFr0gYlwx86bb8sOkHdC3wZCc9ZsjvcRcUmM2BMZ7P2Hn7YI3f7PmMx91iC44REj7eJ2CgtDBk1MwEIIYsc40SapZlwofMVSr1JNyeuxyXHvou74cl/US9RxTEtuA6H7hSVcmaiQ7l+MLedGfkSkL4HdVj5CStrFa15w2aWYhRdGWTBp9HAxtkmGNyuy42QPFU9G5wFs3x9X2AuZI2/TDdYn3UY8nE4ymBAxUnHt4B47pdkn9x+nyiAN/nJ1v5fpqXW/XfeGrFYwQKDyObMVD0fiKVBx2cNrZCp7Kdj8Iw0zEM40TFP9ctLk1VrQe3ZJ6K6V/MQPYB55oFYX/YlqYcnLmMRPHaIS9/t4PgYe4VGTjV7GhslS2EhJnBmeYmSpd8bCUtMUeaVed2YUEjeGNJjwBRLfMVv1RtxIkREMaOA4cIGHA1wzPCsyfbv/MuJkd57T/PYvyiXxUlvwSNnwyFpgt1TvMPhfbLi5vmXnSJVOPUVT/VsHwC4r0eM+LxBsQWkW8XaDr+BFdpsA3NK7IqzbryqPFv8HqlcmXlp4vFy/8hZ3FiA/r1KLRMWA8PF2SI5eBoVnWhmuYJn1gELXioXpvKH84dnbmMKRx0c21LnPuFkiD1rTdrz1qTQzFEnTzM8C1bc9g0X84qs7jyGo0AAv9axNtGNsHDEX/YWvcXgrLcErx6YgMG/HXRH2srCWPtIbSYZA19Btz9eLpiANqTf7FxpnmkuVNvtto+7HDaGTXYt53++9YFfXrX686sHf/nOz0YUx6F3P/jx6wzjwMOZeYBvCrxoKxcriSb4guPJekJCAFoo8rKxDn8JLj+BSaRqXIOvdgNcaztIRAdYtONlu/mWIwo2+c/bT47MOTnnNvUBoxXfM3+sDC5pjEy8j3+Z3uh8wtl+j7jJL7o6RjJsgx4Bi29EamTVjGfYsyHxRUe25FPBL9sXwE17IvbrUdxJVfUjWI4m0HifGN5X2ZhdoiitOencqk47BpsHwi4CgGBoXQA0E4GVR8JGBPUS4d/pyKF177xbZw1a873ES8LQi5Kl6dW8xKYfJhz/S9YRi4jLQ+IUa9FUIQTeCyYsEj9qNIPBe8STHBalFcGRZn3COtSzwnJHslv4IT6Ge3fXU3f/cuvZt68a/Po73xzRwKTqRS1HaZz11Vg5Pn5xr6TNSru0OZuq/qMIR2CdKybwGRGG2QJwsGD2wR00nUXwnejJBZp7ATRUZv39feR3dz1TDi1XCyysZXOxVcmQtiSqb3HFIT/ZXhtxKFL4O/NjB6fuMopaybEBORZs07GVPZhFQmBInKI96ozSOe8rfrZ+x8nbzk1HVpTK1KJGemA2ncgma5VL9uP+m/GFU6uvtZ9gK/7z/lP8KWvTOuvzwuXC0/Nr9y6RqXrZPeTqKGIkDf8hrlnkr7evGvHtiEasSwMjHm/c599owos7ZkYfF+W5nKbbLOcAAM/A4ciBH8qEo1XLVWvHzpS/G307/KbfXXxi9dmlpSWHNNg5cJRk10L2td2PvXrb4DcHf/gPw/7g6XfoyHSlVFAmrbJUo0wydaqykbQCi9fCWtjoujW/H9QqPaI3HPFIlRS8oe2Z7Mjwmcl5pcQLHJhIvbB6JOSPbjTrzRriGIlPPGZuqU1yC5aLU3QcmimSQWf7KyOpDaRlC6i4jvMMvIyX5RW2/R66/e/YATjfurlXOETa6ripZ6dmKgd4htuiHMzW5jfUs5Un7Sts8D8DPGKD32SrNKEAU2a8rItlhaatYaN2qksC1l9hKjGu028K/7N3R/Wz8PAdT3W1cDbOxGXP9FIctzYGDwhzQYHTUzR+2jitr4hTUSQTCYZWdKsBnJeN9XqX1FqOkSwlS8Gy/1hw2X1JDH6bX3C+60RGR2+YrgaU0HKIZcMRAjPxjQH97s0/2D24/a8+++bwBwfKljNCWUH5V6rilFDUSBEsMJqAtE+DswfgHhEvDEO8rgjLXFvcdRIuM3XscCgHOrj5gsWvHfz77U+PDF/P+a3sM/C6AYj1LM2h3OuwAi6PXUNT9Et0Q5SGxLivdmgLSGvfBU+27q6IX4jv8cGHgRl5PElFOtPmKoBG2E9FRUGSvLxLUkq2P7z9KTiBmoP1hmUU46lYjl/yFFGOHRRT3BFmYzsl7gHzHZw9V0uwoi/N/fQxVYIyzG4S86jSrywyrgVqoIocrNE26Q3e84W/2X+8883h3xp86Z3/bQTMTCnNsNvCcisyhn/0JO9YLB1u5U56RsMBk+SBn2kaDS9uYLFOWpjsA2mquT0nBry8wsCjsvIGTzvLcWBLfgXosi9CLUVwOPkgj7MIK6EjMO/ombpuGkzxK2jF8AmFmovlE0kFSPv2H66PDPuG7ZT4HK8IMI1k+DbfOXkUs7etWUCRZVdxARhK7OhTwUEXRd6brgLo+EMpGL2W2wl+l7bSIg/PAdA5fBsOKboGPFOQSrkK0RWAT8FU1xzXadAmgJoq880q0mOBWA9DQKgGChwOUJavttQ2xmTg/vBzAPYFVqTXy9V0Clw6VtERJXHUxbgFAPY/eeGnVw2e2foFtn45FvyjaDgZTjeQ8KUa7Q78l1lWx6aOjhL8Kz7Z+dzM3MEjhm6ULc3WALfr7b2R4to4241Ia2l2Mbc+uzqzduxbn1ufX6rCLbmppKdww2o9vgYMfSD9oEFDta7WbIk9j2agJ8fO3f7cobUjK0bAcBZPUm3UTqyd2dxYW1v+xjfQZ/hBELTazMv2sz0tLitkIP/LCDhgr1LP9kw/SwsscG+945bbm517HiqUyiqKb+azlg50jem8xEbNoDkZKL6GQcvNY57uq8uzG3M1rVOONbI+celgy+wYrVojirywDpjPBYzgRTW1/uDpclJoGAEpNP/4RfApwoy0mBRa3dbQ8mK9vrKw2BVev1WPl5fqoSclhlRCP21A3Vnkja2/HbEpSnfmMsxqFQLTN5HwfuPWtemNiTNHTkw2KomC+Nw2zCNThyZuv+PYfl01DKSqDlUrapkacAwsaYIh0arl0JWMOTU7vqbGl1v9Xhz3F5rttROrS+uLi52lRVSHdVPpufYFhsMK7diKjboRHTw5szCf9kbrgR4d3RhbKSd6oEWOS5x0khh8A4VcIyUGn+Gr1bJOtmfB6aT8j9aM5Zm61i8IezG7MteoLM+Sbr5QHNI0AyOs1tjk2PyBCVs/PPngIaUcVXBTUMc2gjKY1IbeqnTDVnDpzPpaHLfrtXhjYWXRT7xoM5UB8OOgSpqrpsWQ/IRAHqM8dkDyEqz+PY+38rc8f+uV0M4LoggDrM/OilbK1AYrpHmCG2TXxuC6f/rY3w0rW+9/Z2bk3Xogb64KSFVm3BIjZWafGKIdu5UaqbQ1DO/bCCx21J5xuKsXwQNZfJxgk+y74yctwtX5ytB4fjZXzBu6pjsolZM1dNs2FFObOySUpcJqLqRVlwQy9MOoVj97GlCWC38NSa0+NHy9HBsaVuR95v+u348aD27Om+CTxpRTZpNumdvtUsh6TsPpRASLVNB+AZMCtgoH56Tos2VWJ3ShtjjUXPNDpHiBu9poRE8/nYZhsQLW7T8l6sHz6hOjzxFgR3E6U5MmJie3f2qkXqnf40zZR6cPTioY03P44PNDHbcpI5185F+eAI5bdh4aRYVOdEWWZc8CuHdcC556OVJa2mIl4P06Wagn1bATNMTaDgVEuU4VZUuTYw0UyXp70Pr54Hf/9ke/+NiPP/23uxf+bvivBn//Tmdk3KRsj/yiLPAjNhn+fpHmqclNVDMFn6zYCo6shA81TfBUeV4Utq8RF6O7/zp54Em6gUooy16L/wNd5Uvghsnwy5FcCjGQ0Upgv0s3cP1qi/nZRa2qJ2nIQsAimEKzMza5uP152A8P0T10+381N/gtdoYdK02D0bDhk1HTGYi6JrfvFIzAu7Zvob/H7uUTsiArQkG4iHrpkeWxBf4Y/3nvkkdW5HdqxyXZlHVzCBwPjyMXp++Ihhe22Cp23thSiYwA5RvnAHoSd1LOXvMg+6qxfVVu1p5ydEZKVAzeNyS+KZ7hvOW02AZQ/hA+KjJqsoWzFjA0K4FTBqTa1yKrZYOVMAMjGJMPssNMYyZ4dJslQ8yna2zNfpsbvuh5g8+EPbEEziNwqnbVr/KYLyRYKy1Fk7fFSepjix+N0OH+c//vB0/9w9VbN7zz8xGbFcvFUrFUrqTiCQ7K8tqmTU372CPY7gT/wyKWSbH9ohIYC8Wq7rJQxDIJ6g0fvgRPeP9ENSCJv7KC/Qxu4AdJFVxZWyRMGuHcghKUTLAopRFNu+tO01QqhRlbNeZdvV/sFwLR6TSb3Gr0wrjZqddIvV5rAnRvypYV2P5Yn3KDqsjlv7+dA/BkwD6qYNRTs2wb6GeWK3rZKBn33VuaM1Qla5aJWTbKlMLHXG+MafvcaX6YT3oZPx/NBNnGxE7/MeEsUWrl5amV7IqKgplwV/abvO4FsPQuX/ZeXDu9QurJKazrkdjWGgR+PQg8v3n+3TSIB2bse84i0V80LlrLQJaq4JYX5y8Xe8ce27N4W30a1gag4IX/OBLZie3TxO7kgnL7QPuD/Cb+MC0XjpbGDT6XnZ6/N3PAInnq8LK/v1GsFzbNmtEGMNq2v42jfkQAQHq19b36cdK9eObyQg2H2kR2w3SCutHSA1FrBqGfdpAF8C5AVLs2n7/zG0d/9qXvsNeHP/jyO+A0MR8FnLkyjwdM19M/VYkBEWFp/NphBeOc1NJmMn92DgyJFHWv6QMGreKIrI6fuE2wbLg1g7Aqw2gpaYTw5t/1qg2MT0i584+4FtAgUsUqTZSF/yGpVKZ5U3O01IJgjQ8xLF3Dh+DoqDYw+K/b7x8ZBpcVRu+uNpB0m/uh6yeLvny3jjUVRSWB21jh2PzvppY6/YYJzqvcYELjJa6VNR3gt2MjotF1S7cM2M6Go+ZQUZRh+ZBZhgdTIZYqGezDAp03CyytTUVPKDRR5BTTqzhOlYApEtcI1BMHuPdbaC2rcFwTXIl0GhBYwyCdH+J5YPjhCSwQ3pdJsizSunnCg4Rxvyqu2TX4nvz2oP3D276/e+G14TODc1ufH/n8+s2H7703n9fU4uzc0fID9l46D8yvLDSpclvO9fb3Z0mzsJ5fNnDqkktD5yLruBfCK93+MuxHHE3tchaUSWN0beqs1nA2WOwuhIAQ4eOXq9hSsLmw1GpVa9WVNdLpoYbITnWYEK5XXYq73tPWirVKXbPuoGoADniYO6FW55dGO4djXU7wB+gY405eHy/tubH8ELMdMOGEWupDFHgZvyHIpmMacHo1QGucA1LWVH2iVLLJhHaXM1tT/fkFKwHztgwcvxtsxEu1zVrSXWx2PK+TkMW6L3FGR0CbRWBziRoZbhrEFVRase05iQrQJvDagaj09Mb8so1RZNM1PWIiF3LJYOYTIx6vqlh+hhHdgC80ESELHrFT1tq+5EhySN+bnSe2rZQ1ZWZibP5gMatThooYAPy9qU7lpdoLta+3NzdPkVYbdhk4Eex4Jbu2frP++iD71mfe3j14CwWKTm79zoiWZo4cPj5WKebmLCd7UJkvHrAyVAcjiV+hiIjsMoO1ecPxWY1FhZNmyMTUZpo+9Cy/XFODbESGz8wmOa8C/k9GedfeCZy480KhWTgXBUUz9Z06+NysklGypWPgQBmzAFxp5rQ9ZU+7D4dT0gqKQYXEWc+qKrVKe0eTFPX2nU0lciVQIpfWrCcbGMURqOu54D5/CtBYFOwkAdI+h/Zm3CVBleaH6KTIeMVw1is1ckiahBOUnhrFlgisd/bsE2zDI215KsENngoo8Ed7vdpSc32t2onq1U2/5/dYz+iTwqW9Tx5YGe/CQfSpr9f0iEytPqRMFMj2P35xhGvrYGewBQZ7kQOf4KyudIyNDU5P7c7HecAZDPWmpvX8kFG0rLm58fF8ZUzNmRYgtWO8XC0vl5fpin/Gf5Tz2irpXWx3V0IpEgNsy9Z7MiPD343smEWiKX3W0ntqQ61VYq1qBtrCqKdiqIQq1CDaRCF7aHYiN17Zy3Hkg+JPVysL9obTA57W95aDRvM4qS/Xeo1mtYaT6MkuVnvzxh9/4vL939764zduAIJ/01vD7x1sbf23EaA2FPySlbPnuYqTxhkZBpv3e+ZXOdnHdXOooIDVyssjdeMVTh7lMj/kHqAH9Y+Z1/Eb9OsZfHcaTM3uLNPFNDBErSywnVFxVGkY6QTzLMsJx7PgZwDHUkzhfBa5sAfvgls766AAYN/DGmccgwPfXRLL7jL8qt2ropZOzDgLHAr8nYWog3OscI3Bk5PhD6WmloEbqQvpBWzd3NFb963EEDowGMtWXDL8Z5osiEmu8HHHScMYsG2lqKWV6olYk8+xrPsNIl8Us+5T8kn3tLhM+KNVMXRCbLgnIjj3QAZdz8PBVTLs4UC5/Jqxo+aFwm9FOF9w9I6+8tbgI9/64qu3fm/w8ed3P//6Ox97c/jUX269PAIPX9EMyzasdCDHzjw7IK4GmHZYPj0dG18vGCKY93PyiMx4E/JmeUweEtu/5WeFVa2AwTLDkmeT0KzxJb/lPlZfCTcilW/6p/2T4Tl70YlF5AWoWO2QRUdy360Gbs173DsH1/6YrMsGYPVFxhAvoOQ0alxKX8b+ipd4ZLgbyZ+GZ8UK9s/AolRraTSjLFRRig/IgpsRv+uUiVMIx3E6EzoX36pR30uHsIlAtJsChzid4I8S8ZZ9Qe/tSPLyevFS6VTma4e/PnFcrY6tY/764ErJJYacjXQb85XIiwwday7KCv7XzFQln53IH83dT2yE3bBSyuG02FhxlOKd2h3GrdZD8F/S9PdGWUYm2H0mDvIy4ZWlXyigUDagP0pUm/lDcJGDEd4iS+/zMYYslrwnPZTl9Bw0DYs0isnwn4NBkci3g5ilU3WlG1b1hulPLRz1b65g/YfDiQG+0znHWk4XuxmUx+HnvG8td/2nG9/014yQ9oDLEilj7Dd0Y8we+D4mGYAZYP0R89i7bIQw38BpBWC087IovyQr7JC9RwFGiQ2bcAoeLjHMi42VgRhsvbRvpK6dOpqUk3ITLExciPOI9LN8hk/xHMNO7i5lCsVB76em2TyY9QLQlQKcrW7QGnJjGWJ1V3MD56+1TiXtsNbph36EgNsE6v+Dzhtbn/7+Vf3XB5+9PPibt67e2t5aGdkJjTFhgosyYKEr1ULLcuf9qeBArligFBuciMOnJ9SCAWBWze4MS3ccZQpFqZ2KXTHm7Qk7AzuGfQVushiNegWv0jriOaFlAQEwcAAncExuGvibLGo7mdIRfS8nR3g+GCoEYHHao8ddr3JCXac14DPPRierZ5LN1a/1+km1k4Q4Q3Mdo/d0ZQJXBDlYaHdjz6tWPSzLCEqYjnY8E8xGoV6p5oKin5VlarBJDUv80jACP3RULZCje2bvMY7aGStrjlKF3STzctYtejo4EwO2ntrbVyuQX+UUQz3WWoXjc7BBUhWj2PiWsSlb4nTkuSSdTSqafq8ax+nMkobAUdY7g0Hgj15BOkSwEwXs5mjbEa9yZtfheHbcWLTl+aVW3K2ef7S5QIBB+2JHMAhHd8FXGNZPuB1Z87hoiga95NSJ1aM1Zc1s6vW5DbUxeRyTBrk67JsP7xmplSI7ggPqph/s2i5iEOvdCJvj6j7YAowE4GxBV9BaoT0XlJPDftY7SIs4YR5rWlLsC0DbpGbp4JGD+2c/s2/PSuFn2mX3YvuKV/fqOD63dzqukyBeWE6lboD6wb56u//G4OMXnvvRYPTVqwcvbP0ZjvWOvThowTFqs4RhSgdeuC5KHf6MZ8HJET2alAWmwhMyLfxstNWzBSw1PnZELR26V5nN30HMrHmEF9M6EnAzYsqfTG47cef5qdAKEK84G5UQmwxCGrCqc1o0XR+smi+q4ngtCrFeDS7Z7fRxIIAX9YEk+GDIR3FAoGdUs229HrqpDEQERjSskiAS6aWyDmo68kVxXrwsL6MWfj9fNXuVb927MkvOH2rO1R7wSrKUVvDZvk0ivSGG1mF1wygIBGoXpiWwkpsnbFSA8zB6WjhHBXHc/ComrlC8x47ufQK32SNrWkSMYKgLW2wxXAXbvlBrRpvrqWYRfFWTxqmg5VUdRzaI27YYbbJEBdgNpKKFcQWriouHIRaHjy05ghhupoZTUfAuHG+sWk7FH0xhiGOUYfCYp4fapjllujg9k5/C+bdFB+AG9shr7lcBfehCESjn5m6/n8JHAh7NwWuC5Qkd1aIhC6s1UekHOLhhwKfDgysbKB9rAY0pmwadssgtlcPLmSeUFSdmm+xR72S01Hku6Z44s7Cy1OrinMhZniMcNdMB5NvcNRE0hLRh+ziW1nNxz7jAHT0yMP95pGPXrL6ykV+d9HJCt2YsXS/PzZd11cwYhxUbq3Y5yQOXnGEH4dIqCmGrQ2zNZ3bXadBNZKuo+N06sbS81qwCwuwCHX2nGb52zxuDm94Y/Nb8pdd3b+17Y3D6z295fXDd68NlBSzkj1L9Sga27oF7kaOZqq6U5uYetopWwdStjDmnzzvTWGF3WTudf+XeK7d2S96s0KgJG0hpqy0jwirNHNcYqdCsVqyYFth/WLmJCXwUE/vRomHzqGUa5Zl7CAozMdsuGTlrJv9p7+Mre2BZrLT8dBqBv+e4Dmw4VFyNrVUzcRr2xWAh6cXnWrX6zvy/gL/8UqtP/CCsBTG8cLo2TpKWOxOLAD5FMiR+gx8Z4ofd8WAOx1oKx8/2D9SLgelhVay9kqkbi+XH1C6AqqcUT0Q4C4gdj0LhiV7oA7TebLhA1prVHYEEcIkuFlz4xE+GfCCt3TLGp4I0IJEkAdA7xONujflmX4TiHBm+rIhFflYsEXGhQYdCNviwROwHsNR0Ss7d/G6+l5fBOM+Fc4EWl2qZRUoaLJQejnmAxxl7smr3mK9HqSik74R2TEPWIqxGawwL4L4Le+77/lrjH6On/ZedwAnM0PkVmIPTA1ucZMRQGSdAPeKMqZ+z9mFGDju+tz8Px56Ygj09xJ63XnACXIV/bYLF+SU+2F9wzQ61DBxeyg7iDdF7/Qn+IJ/CcDC+wzb4mK+6JrfYMZZhh9kMYQ9ZfMjk81mT51lBzRvTyoQ1znHwVMVXsEiike1Sqa2QyiZt8Mf5BSCmG52XL//keDuA1QnswErKOHnZl65JpB0avhXp0uxE7QiurstxWljVDh2stgvVdrFJSg1bVnwyF03QvEL+5d/80QincdGzPRtLr2HHuIHsRiFvGcvK6ng0KSxPkQpJHsjdmJml1NBNrZR5+OGZ/GyhYkzrZLio5C2LFcA2WwAdNK/QciKwaNjR0qI+69MT3sn4cVL9Wm1j9ULUqLb9IKmtreHqJYBqyCCzfWAEdhJ23IpgSOjwyAGjbN3dnj/z+g1vDO587eZv//OPP/vGLW/uvvTW4O23h48/s/XJyyNuaQjLCASN1Iao6pEJbpYv8LZ7Pl4JHvOX/MfjC+4TkqyJWm2o0eDC7Ntw60Zgu4fcDJtkGWfCuReY+z7zftOwxk1SAICTloSA35Z+9JS3mDwdv8wWUe8adilsbpeSXv4H1pPmcafFMBMZ1JAeSPmu/Ck4OxkxjzD4Y0fB2PZQD0FzK/49/r2A3YpckTmXc8Mioj/Eu3QJOzux3Hchqbonva50+Kp7yns5Ok0l36S+S0IsYdrp7HOxisfGts5mKkQTIXSGsw/OhM/CTvsj50/UrxQBulIb65RUBwDaqIkJZgAUcCgDPR1FbiaGu5NZBCr2DE+2ifMF7F5+5hjbTwv8CMs5U5pqaw5FKU6E1TabZtex3xZLxheJvd/WYAfnmGXutUdpTsxyDWfcViu+LlSphGqI9SfwfNkJ81T4eHU5PO6fcE/CWpyEs7jIGpycBOTWaJDtrw3+YuTp950HvneN5BiuJcPffKYmf+5fgjtuibZYlzG7YEesEWDeKIlTkZYKLxNewl7a4BHjj5x9dHx8+xa+xD0jMHAMOJZxuNu7seE972wPzSmIXHEKuEsjB5va3eWh8NnoRe9ZjmFxHDnF6gCd42d6QMMv8NM4d4xKhl0ODTwSoQfni6eIXuC8HLEG7gl7zEIqFURW3r0So+Z5VuZk9L16KpgMW/jBLfVbe9+8/We7B7t/9uW3BvPfnX5z+Hff+fo77wFyOEfn6B4zw/bCEboJLvOTOgcijhBMA2dgyWLwMfOjBTLsfK5SoA/RuwHBYmcKGKQ8GBse6h7qEbw7yYdwuoahYXqer7ikJoaYhXkMMvU+cbf9QXucDN9mPmJv/0/qI44iDGxduGDEfr/qPAkHZVW0UDrUzciLZPgL7rP+z9gLhF0e6oFNX3ZPu8vBk+6jLlB2QVam38sfNm/WPmsddB6xjjkF82anSIb/k1N27sJwFCakpREqmGbcNNMS/ODd0cZY3YSTeFkQNimSsTpqYVRfA8DlyqpMgjM8EABqVqOneZ2jpAMw/Y/6PfcJfpmvAwCD4/2TpOntqKsChAZq03TPyaZLqrLNU/WGtAE9iLzYTQUVjZZsz3JS4gEtYxnov9z52u6lH1//7UHtJ59+e9h/57qtV0ZsnouxfFZ3NXc+nA4q4iE5ITL0gEX5w5myqSi2SqiJnNXkCiAcG2dTF9yj3n4xiSoFM95X3Zws8u3rgFoGRXcebLvG9pbvLBw0snJeajV9g9hwgewF+n33//IxThyyHuuwCAdj96Wr/pC51NcDhFbIZzMAXkx41hyAGCvBL8PqV3Bqv8sq1n1s+8PeQZlL9kd5AAMY+LAXZyK7bgSO55DQOGUvu5cDRT6WnEvK8nKw7CZp7aMw5YzIBzOeSQK9VgkcpDE4ylGIejk0IlMi1lX9nbwWI77zIsUnhy1aLcBi7fhUpx6efLTTi6rrT/VOtS6xRUI3sU8dXCCqdLupEDr2QIOBKTbfda6SUHe+XgptqaSTf1SGMGRtvd4Mo7jhRV7kwzUAXhBLsiqqRsxj7qs9G0Fppg8MfPvXHxo5Y50vhhVfmzs0mz00diR7RJk3izpLmypRSjt4yHPS6cTS8bXIwTmFT/NlukQDs2+sq/28n/PzxqHyFJnaoxTHx/PgvEqWDfS5wrOY5fe0oNjDvHqlocWE/WKI/TU9Y1+yL7gt7aLVt9baOPkwlcNrhg0XnAw7BYhx64uPvzy447Wbruy++IPBD94clF699YfDbw/+8p1fG7nRmDb2qbPmI0rRKJoHJhXFsqhuTzODHgULewPdS48ROkbvs+eo6hw076TgC30DtcIAW2Zio2XWbClWcCBZRRyXJ+UJfzVY9TV7zV/1X/axTWGH4yHQI1Kiplfs4ohdItQhUQmVCA5YDc5JD34sCMKQ0eCK97i/4p5zT4CvOk5ES7jYRrWQwdnFv7jBtySNjcjoFdYnQrVaqB3gWYIFgoCVDJetA9ngHOdOpiMv0e+J2Nefs1FE3glopB3PHB/dyHbHF+86Syb6ER+q8Y2g63f9S314wBI7weNgsY9GC1EbGf5BHNdX4DIazhpabTu0Q637yBkV2QTw1rn6RG0yIFnvTjeNBaE4N1cAb88ZAc+qBS1TskzqoLMjWWpr4ASLZkYW/fH89oPmfmfemaRTLAvetmO1KT/KyVEwzvea+4y79c9rRU6M97p9uQwYT4I1Cbx+8IL7dbnupCOgqmxBrssVONXEt5aCOCLDl34lcuHHQOVSku1KnuIrLdXmwqn1RI0f8L4IkO/tEpxemobLgbq3rJdkQzZDJw56jcG/XX/aW0F8juVcwMzBpV+gODxJpIMFkhjPHq5wNVKa2OsdAscKqF+Ulks0fx8/5pDBDz88smqdyi/Nk+Fmq+TpKNgkeLGYyzE2pRws3OPcbldY3tSxPUHy84QvsT4Go3jEIkIbUTAExGpnKLsX+mu9k80nddjV/2Wr8+e7T7/1mR8P9rxSf3vAvgt7+v1bPx1BIROLV8Dxl7jGHbajepPKXDLHsW2tpMwTx5L7XAuO4jQ2Z8ovi4+K28WdKHAP76zAGtI5+bBX8QtxIXQie5WFXj0USVADdge0DpbNbtAF+hQ7zpfTNIUTW7HVV9v6ZvFrE+1KU12cDSskVKXuzsi8a8U6CcyWGIqB6wM3kRH6aWQ3WMq7lrY0pbNf61mAbwLpOANioPvhr2YkuV7g11CWr8kTCtaMsB3FkCXn0bRT4W+w7yGyAmAAzwBFE3RlXnLi/eB6+1pON/cjEwu1SG3PMa8xnxQl7By4BNmqLrbg8fvEbVCZW5o6mV2e3Bg7+eBFHfy2GmnwKtXA7gCu9CTx5LmGL1DHpx2sJCpbrK01T640FsNaXPe7XpOetuCYMSnDw5v6tQ4/2sHJKdhbbrj3R1MuwCGRZffSGWuyXNAtu1IklmmDaUGdCkMn4qtDYvs/sO08jVlQ2DCqem30pPOvwyn14N35uJKUkvuXxhq6V8aas2LY9oeWIosvx99ZuXxm9Yn6AjzvDXg0Hh5YLa3XMRo74SLX9Mu1QCskSvhgqyQrct4rCzIr7wrmLfKtm0bO2ptGV4/tyNlJoARWVReoDqpaRjaTy86WjpSJYpdMC8DYpYr5kFK2UGoDsa74uuzIGmDfGmtYy2bXSc67T1lkcGX7UyNMPB5dy+uoUUeb9HJao5ImOxeSltdwQ3GSfZ2u2OdzpGV44Ft5eXpiMp+rPJwvUYerjubMG/srGLYAyIzptP8wyLx90+u7F/5+4PxwsPnD4Ytb39j6y5G0jR6rnkyDqVQtGwbmbzE4aAEpKmesgjpHjKKVM8oUTRWyVwfbMsoPWlPa/WZG/QrR7rTcofnql+dM27Rvnh/VR/V5pkRqoLVpvfTTzuCPZN9dDTb4CuENv2ElZtWRGZdkXd0awkI4RuGxzquftQ5bX6b30bsY4i6WzvuZqe2r5ncCllSYVd2zAr1hRWar8jRd8Y8Hf95bq9eCx2qSEsmMQ9hXLjRPcYHktpUW4NgAYAIq+YRBa0UEBHCZl0adEpG4vehp2RMhDukDk3Fcwq4NAMeQJlsWF4ARZy8FbXmWk9PCrQwFh8PtT1o6QxFxM1BCHYklFv8BFmqhUArm0AhKEHNX/Dm7jCNbWZ37fFF/3F6x141Vc8U4rnWNDslfmLw4vYIdlen8oyUVqGt1MqjY5OTHR5YK5+4IU4bq6o0jnubmyDgdKgAC04EN3WdOAIAqM7xR2fS73e/4nf75zmkvCFyS+C5rqgAKX6ffm/7e7t5bN37nxrcH/reGl/+BjkjM29PIeobXAa/h4MmQr4TwFhlgSYNYjz1wXgdcebGB3SXVBtyTJ1ms1ksBa2irxbPm+WDV+05twydtuRi23Q0/iIwNu8O5Fmg+5wU2R8fsvD2qP4wF6FnnIK+E+cSoGSftHn/DO+8eF8/5ywCJfkw7tFtws4wUwI8AUzVhU4H9ZQa27jh5+2Gm0DIzjX3G9u/7txFuhdMYH4fziKPOhMWz7KBWMsjwck77fG6GwYWPUzPUzlmLzvNy3d3k/xw1yDCm6Gv8JD/L6saq8jiVR7QsKncqwGsqblYWmcbzRByi4xRw77K1h+1lf8oPiZIsSVVqqGsVo9YFYunmMdeQ1upEKurVwOLUXVsfWX5z8He/vKr35uAHrw1Kb129ZX59ZIdQua4Y/HvnMVY1B9dgS2moBZWVPbW51tTqg375/FfJ+dur5XYuAZuZCr+i/LAVq0CDU5IZ0jZKCcOTAWjiyRD1kzjOZfYifp5eppedV9im81MrjgeEiKZsAg6JUIMBfo+bj+YTwBqOSVXVwkn3iv0Isfbyj/gflQdReJKI0aFKY/5EuTW/es9PtJ7ZfOgNvVVeG30FIa+ynMrguY5L9NCUZaqykkGt8hSz+PYH+P/B8s467airxSU7FYQmXB45VUnm2/l6JSiFB5vpiAHsog5sL+3XTlu9BNhsobmmpbECHZvIHFbzpXFt1lZtFR6rlb+BK2RH6RO+FFpxsqwi9oOXddxi/EjzaC8T6gkABlIzHadtgdmkHb4Ia72ZVN2NZuCH4PAQvpw/szPS1/O8lZX+ZuuxsNtYB+OObZ3YobY9wm/jt2FGiGAxYppcTzNaVdgrPY4VtOkpFtwPUHJu+7mt/zQiwaj7wLQXglTegVfNthYa/czaZFQKjyQPaoY6TiqH5w9Ozz24v6LO6hXbZAqfBxieX6KuVbfrxFjkTw3xE6KbRik94dXfdBvdc9WlIAmrpMGG2mBc3DKc318Mpt8YfPHruwdbPxio37j1e8O/GHxqbAQV24DR0AueDxT+2eWlTrsG20UXTs1esqq0mkQ9Uj8RbsrjvB5f4k3C6pve0MvBsliiNaBnVb7EHS98MDjgPyTyooRVxxjmAqKB4QXMkoRFF1DePwX6E1hPO/wL7qYCfanJjGL6tvYYDeF3RbStPGGsFl5UasWniN2oLJuRVjNaakNpHtvEqpS5TopugTqX/fuAjRAMy6f5TNOyC5XMMXW2dEzbrx81M/SICXzBOkynCCvSivUwLYAxwMJ2TJvYjBnCgLOvqZaJ5R8YF6oUtZwyps7ZRUp5xZ0JZ5bK6/t+eXzwkbOvrz935vGTTdIKE94w20BBTx+uVVzRqlYjP7AalfVyr1S1PNNPedxYy9opXZSWd4TnrTlTivlKSdf1bK5cLuYtk4w+WJ7M7S8eLXyFHrXv4H/mqZjg59TNJAdxlAX2TBMgOuWgUpvpT+GosB2FnwsTvWu2Hhn8eEQVQ7PubTxDs3RaFNP6cCT1yeVwo/lC9zTOhPKcmkI6hbhUn07mO/sAk+q1cR+R6+87bw32vTb40+/sfvKNG98cvPry8P89+M3HRlbex654g/dj2D8Ae/G48oN4s9UKm/FSK/JPHH9XRzAgfhAkXkiC2lBwNJ7rZbu5mC1bNdj3kZvOUgF7hvsRjse1Pj9Rb8XN6Hgc0yo9OZ8o9VLjy84cVdQx8//r6UpjJLuq8wymzMV2nNEUBZGSzDhgBEH5QaKQSCiASbAAE2RsJ4DHnmFszz69TndXV3Wtb7/Le+++/dXW3dV79/TsNhgGW4yxAeOxwhYb25iE5UdQBEpYomqrkZJzXtuZ92O6W931qt6995zvu/c736k3p6rNgyUyAbm1JE6LclRaqfcaC9iTxXRgoaBPAqK5fZlcBQsWRR2IP6CdhqlC+i4SeyqdyKWTjjVbXhm7Mva0nLeZmzo99/HZxbbnYqevwD27kSnuZeRF6VK04c47HX6OJcaK1WPYZyBbmdUN0yO1TiOdTivReCuLWIDMVW9I6BZjZmYQO1bLFEtNq25MqzNotpF5f1oul7RrLbuGswSJrNtqkzTdmO3Keb/nL8tl6YhNfcEMRavjQVgB8hKyGJ143Gqqy0o05I/zEX64PkMb7GRluo6CN4Rzp8ayeVDNjrUzsS2F4AsXs3CnzkzUlh6fvsAyFZU0ZCVVA4zrimz4U8lIXHYfCu7TT9Vr5vCMrpPhMWqZ02ZZWLLk1j2zRUlMc/lf2kdz9iE2ZBnUpGO4xy1G6FGS/x3ggkPiEcL/PocFVdIk8zduQhhMIjK4aata6JlrjbbaUTeHgkaAXSsqaI+CALk0oSil8snyGYNge/LT9gh6pQIY+GXT5T/Pia/yL8On53Eic/3oaXsJD0WvbX3yJf2FvYP3vTyofiU/Nhjdeq4wat3fKBkG0xgFajSuNTTNGJ7iCtcc2p5Ja6EZY+5EEii9yPfs1IkhuWGnkABGG5ZSwz4ptt/Phgg7bG6/mQ3zqm06lt8I6Fk2C5QE5jOsFO/fvZ+Lc/ZgD3nBeVbsE8JDomv3nK5z0Xs5QAkFRAp96Pj4PbVPMMC13CTGiPXXciy+c+7Ql466dL2Omp1N5gHjXff6ft+biy+vkNBbmI+T2bnzT0Z9SKi+g2XeV2QfwCJ2oP+Ksjn6JWIGZogFc8cu4djVIzynrPt1gIuXRltFb5ST8o2WhOwnGzD9G4I4nZzT5jYWlI/pqeVOOeRe+fHmQY0Mqtt/WgAMyF1NwlOKLB9IRAp0KXDRiuCS69INLOFc0iLzcnHlVOcLySk61jxVPzr18CT8OzJW1EnJKPGKV/UAMM7pKfOMteZT4nLyPf+yLZKz0drcRYjorpVSH7cL/3Dr8R/sXvqPGwbrr+0BjjE2bhqVM3Je+4B10DyiH9AfpHcbI2ax+WHa4Lr+ADMIsGDP6DTWZK25ZiUwCz3cG0NDh/HlYrsaa1ZplGhNrvmK1LFVT2AsfSos9T/Xrazfj11sHBaoC1YQEOwsiCXKUSijsOevzQ5ydjT3axHbaXARaOJm/JK3Srw1+0vuFeJswmRfMvr8onvJPc/aWYFI4KaeJdIgCYJY68A78YVLfD2x9uHKNoE9m/Y9/K/4tHusTW3TYja59Zef/9FHXv3g724fkK27BoUzcu+Afv+3L+XftfU33yhYotlAQwfOjwmS/4eimOAGwBszmIEkKCr0C7zMVW7u9AgTeia5wv3A9gJuVQWRH5PeqqXPry+ck/7SStqKMk1Re7bT9X2JDwkumxOgz7hljAeU6IQU2pGcZ6ne0+ZmLqB7EXw0gCwOPDq4mh0tBqQTodBx+JLSqfWFHbHnmiL6hkM27Ui0aIjkQpC5G1ndrkK+wYIdeI9rNBUtEfiAY1qu5aVEJtZSLv8WPETEUm/qZQUYEpBd/mbDF0CuT3LDPO40YMEjFfkY04E4HgDWy5z7HCDnFMUBkIuOZ/IJml0mgAaSt2im86XCs7B0k2p2za5KJW66NGz6SmtK8qRIgnpaXRtu1ZJS2gi0hSPAU61jD2On2NPHUeLOLMqIZhRHG9OVsdOHZoqTo8UjTh3AmY4bdy6Wc5mBEUMwUyi/YHVYYO9YSMw5MGAd59ui7SZOwoCriKuoUc6/y7G/bqLxSh6bGONBbmB7QJVsGneitjPPFgnv1NNcrWWLaQ5gopJ1PBq8a/ujg3e+NvzK7sHln93w1PYfFQRdnvRQ/AWYOjRsvgBok4tOCLNXAp+U/cVOn8AcyDxmlp7AspBkzQm8+WhVrsvV2V/JWScQ865PAFG20DnLXXBb6bd4J7qK36OlLGZd4I2pu0qcrrduzznr4ZfDRSLbuUQkOMaRkkOrv3DGpoEemr1mxFO4KfxRaKO4A811WiIkwsMqO+rqkRVp7fFz1s42iKuFDXfIrooqYBwYTgMwlUIn65pWq5UP0hEAWg2qwHWENc0z1lFzlNAKrdrZKTVeQMMUerJ+r35CP175oHnCGrNq1jjRHxi57/hR0qg30pwR1NtqoiZ6nNUxwISpuadHhckV1I/YdHY8c5ZolSA93joY3rrt1fL03le/l+8P/nbrZOGUNqNNlk1LN0yqGpNjOC3QDqg8blWXi61myCIPmG232+rOLc52NuOWTFxXdOwr2qI6r33txMJ0t9bRFylJYRbgKOAWcsgfheSdWQ+5Hfhxp9VtrZ/3E8BBItV9eF8SLbUOa2ExMbLq2MnxkdMz1RljWhP2yMLhzQdXx0IgfDBI2PpGHg6nBBkSbT6ik5XtDxUeMaaUyYlajVn6iD4i+KIW0QQWWCLaHRl1LjzBHpsmsdkzYmtF9Whaj5uxkRiQdbSYtdicSCC/hDa2YhCrMWRDGUIunAs2VhY351dtl8U8MLxiuxGaroG22pZVmqgUK7W6XlYsOmGQklnycxUPSFVU7FPnRGskGW6fCNH3pAEP+reDQ6+++ALKp396PX9p8NmtTxXy371T3E2L1gw1FDGOPVfHQ/Npa5717AX7vPO8jcDFVIym0VSnzQZcCnbUANw6QT+tH1QyYR9aFJsAX4G+S8VnO+QJ0P2SJfG5OxE8gmsB7nIe/wAscJ1iT9CmyTyFuKakgOPqsR13guSxn809Trxkzs5dl7H9MrvKW0DaHDdKHae/ULwyzA/w7XdkXTjDXjxHehfWRe77bNO+4Pt2EmQborFIieirUU5JLGeUzfCPZEIzL/HTeN713K6b1pcUoQtHKm84V5qOgsVsrDZZHyMTD+QUd0wcgAiw+OKPf/Di7sHzW18u0Mlxul9AAsTyzOJ0uXz8hKoPjxSLBpsuKcqn78vKGbBdj6Y4M2FzdiJgT7hz9iwqSJ1vS99J5YBEfdbiEnk8bjplmkkHu9JGZ0UsQghvEF2KmbXYw/YEJQov8Rof40eMCVbljJ1bf/Ti4G2DvViWMb+QNczDAOdJF605fO7OdMpdyHmUiaFRAJU//v0fF3SqiRP2n8kPs/u0CVrdsbHiO0feAPdMTp06cacd07da6iq/6l/1r9vPW9+xVuXcbICj1oKwA7mDKKlYmFDJrV/8rx9d/rfB1end/7n1UqGBRmyqMBzdNT318uHAcrhnudbsmUF++23YEdNiJU4+Y72v+plk3MNNCAXuaZXMKWFKVeqB1bWwrTDkREl/wZfca37fQd6Q2omz6G7I1F5znuyHqRfyFcMnpi9CVHqhozLwbQ8Pxk6vTM810mYWbPRQjUmprwSV+Vrv7m9V0qme4aqZ9LtRI8/+/p0FwSuizI/xh3SY1QbTYdZOopV4aCyKy37PHey1NxhZZ4+zi2INNUCy5XkoOe43XatjdRzxcfuUfdxWbFJ2tknWyPHnW1eu7+3/5I4f5ZuDoa2NQiq6pSfv8rV2JWmsjHZHz46QUNeNXFO7525dsUxNNbSJ4WZl/JHqZHXCNHQl87NruOZcnXSbQKgB88Wt/ubZq6uX55ZmF77/r6i6bc+i50MQ2QkBALm4k+S5o6VabDrArLOSZOog9RhfxzJvZ3K1NF/pHnoGyeWDT1oAVlAfSQGFWXbTPWmbjDRgPFiRlQQHZIZVxFmRtSoF2f7oc4V8H+ZJzT4m/tL6ENvOY/+SD7E7uc7qQONNPNGxGTARHsI6Tt00SWL5TTG4EX3Anw8HVqZSADZqbKJWhHBMcDDm+4FUACsjt/5m689e+cKP87sGV157a6Guq6pSmTo+NXro0Ojo4Qe1BpqNWGajVj1TH68OMT1pEGm5mThs7cxs9fHjL2/ftHDYbwYNLFKcR02GH2dVWrYXJ95+kZUEBm2zX4cIb/pGUl23rclzMyvNztAXd9pdwVOq9ZSk2h1d2imekWHU27xy7sLyqvTW1paWl9baC2T1MQ/L8TvMnQpJKeBCM8ngH61CkTY1XsxOtBnJ3wFwcIYX+TH9Ln6ajVCVH2MPiGV2gE/DWraYQf+ZHSH5plDUv3AVt7pgzFk9a7YDryztTBLrzNvL9rJzyVkg0eAW54lgsAte1rkcfo0/JSLaZbGxRp1hdK6umV996OuDi+21c6d71cXqpvaVwR3f3fub5fmedmViM7mgr17d1M6VHxtZeuVrB79+bL6znD/8zJ4XBy8XnHJODvkH5El30j0iK46B+/2iKS2nLieiyUjBFpMYw80I1eQ8tHFXGBgrDc1E9MJOENoQ8Iw1EfkkkC4sSRjwa3t8ExXhoVjAgz034Fi21cdTNxmKwITEJFKHBHaQKYk87lOSf+jantiyOWQJd5ZGgM1mQ5QAiRZuF8inZBd/hTqBjUqvxG+7aXRp9pvuZRuLIgSeZ71hI03wpHg/qjA8J/aS8P/Px2x7Ad0cxQp1EbZnwNqI1PD4BcUbFRUBwFQy/6imZpjXXbBT2rPwfCxrhuZYoR7urCpcVwJQ10hSRcdaNKoSbpgCtMzOp+Fm+1HODPcKFmdjbzl16YIfOn0l6+nixRn2t13i+KGwIoYjHtshX379TBUw+EPP62qkMlUzTIOha1dR1bK+NpmDFUexsMXqBilr09Vm3TKtbHNULWMtu1bLhJWUUUOVRpWROm6b0hodm4J0l3X1gtugR3LDpHbJnrGdGUpg8Weu4Bxb3mAhN0xkbKimGgDhIQ4D1nDIdHTSKFewbTtlOgDGJm1QE63BsZsvRA9tHIKg0nSGUwD72cwxN4xo33f+p0AhWO/Lv/O7u4DnYS+/zJiI97ODX2yHSPJ//ux7gWegRlNuZFK/nh1I9FL3aWjFIpEt6VmZ/MWF+d+yAAWjuzXv6y1Lii6slcRYYgswhJ0qadcFM2tUtXjFxNNaygyjZIq2kGWum6YFwB7NL5DwNFrVRg0yYENHbY7uYz2ABh8+SCSdTokuAdSoei3gQDUUK6chqbFfb1OL/2fCD+ZUO48cqXQzax6R+SPu53IastyO0xVucGKwKusiysrohAZ/rZqkaXBhhPg+dsw6GGQgBdvZofIGchqEco/oc9zG0ZhBa3WHSy8i+CjRwRirrvGhvdFWxPUAZiRx1ELDebghSbb/qWDX/M86Vafs10WFNNL79X35236xC4cMoIwt9wvJIhYYK6JjnIcAnWrP0CV9mc3zCEipi2pyByYr6iDQHfrB4F4yuC6BBTENrUJpg6m0ahRFXTS0+3F7Xgh056GQWLCpAHxTNzkskHCW03RwO8nfdu0TzoZ3VpwXmzbAsEATwEt7wnQTiUZQjg6pCQIP8U3BWAN//zOsamHHYsVQhQo/eG7X9pkHCtvv1t9iCnwLVc3lvM8XAGX0YWZ1WWJssg5bhsvnfSIChhpFn52Hb11s0+tiZZAbedmJuzXrBfL1UjdYwnf93f5fDPYXnDe6g2KtrNXiiZtg/QXMebPIq6wELzeFPm51rgP1+aR9CkjD03fYZ3SR0yZUuj/ff/oOrP2xsh4mcsZR0Stlng/ewV8Vj6HXtG37NDU6QeT6bi/xDTL41McLQtdVrrIq/GVVPSWcxkF8AISpTBEWfrkHnsIoEJMGd5qw2nhOrsrLThg8mn4r+0gbtuf16GorJKHnqzlpuha6VlaAYsO0eWrX9qHB7QUzrMt9+duf2uV1Erkff+w223SfWVfN/Q/YBXjMQprSxFMjEoQ5dOrD2VVNdmalBUnvPbxgqo6VGCQyc2EYhdWoGVBsqpG//Zld25+nBciINGiS/Puf2RU0JW+FPrwO7iZU+1nPeeBy8Iluv/amwfferkNUszVHcVhot7FjdEhgAO0aJb+/s1HIv/faLksBEkFjyMwyIjLUZU7xKKcaefLt+dt+sgtjI3oZwIiiIFVmhpm2xsjgV6xgAfn1fCmV0NLxGb7ZKhdMzaaJTgLL93MBZBXNI1WY8PD+b93mW5cGo7uv//cNg92vmYBHlOrUwdF7q8d4VahO03m9FtbV0W27m20/kQBb73Sd1EvixfZGstldCBM35a2sLMo2/aG5TOUFUJvCDewtfSB3v/IvN1x+rVFAozujaJbhkyHyyupXdvp6Oq939swUB44VKZ1K+3POAWeUs5YSGLboQ0zDcrZWAndfInbbuqiv0pSmwuVx/SKKFMyIRmavEY0H4wE+c3Lr1nvetvXZwvSjW7e98tJjN27rT75l30273/2/t7y1d8tNr950PXa81i23/PDmH0p5yx/8ya7353fdsHv3no/dX2dakT3MG+72BwCl3wwh8EH7Hnf7TXbRP+6WHUPqUc1lHbEOXM/ruhGfR/lpbPxKvCB+ai3xX5ObxbPsHID81HKAMytCYTAPbv4/3shwe3icY2BkYGDgAWIxIGZiYATCLiBmAfMYAAmMALl4nGNgYGBkAIKrWsf8QfSWSV8YYDQARc4GigAAeJwtks8rRFEUgM+5bwjbezOykLKQifwFUhZSSqwsWFsoJXYWysJONiRFWUiK0cyG8iM1JYkp5VczLDCThcKKlGJ8776Z+vrOuee9c++58zQposLvQKxWijMWn+NW/CNWFnEjxFkz4vRbnORxAafwArUi8RJxlvgRZ8SamnK+jzfwEc/s0O+JfJ5ecW+rSeI64hNIkd/AJ/E9vBMXIM17q/RsZu2WPMM7FfgUXuGCWhc+pn4NLxDWtnhuDN/hatZ+oduf2ekwbELJn8/pOMz48/j99DKaX0fYu+jt9JAZttmrk3iCtbBPOF+OeBdPwyTxOoT3dlXuvwdr0BDNoe306Pd3ZvWPuJbaA3yR5zirEPfhUWqgz9H/YtpY78ElsUFHdM/BMlQB9x07w7MwJy5I4ClgzqAXx/AgZq9giH4f9KGHacIDeAUn6JlnvzfyemgB5pUsZ+Wb+Acw2Fhw) format('woff');
    }`);
    }
    function N2(t3) {
      t3.append("filter").attr("id", "xkcdify").attr("filterUnits", "userSpaceOnUse").attr("x", -5).attr("y", -5).attr("width", "100%").attr("height", "100%").call((t4) => t4.append("feTurbulence").attr("type", "fractalNoise").attr("baseFrequency", "0.05").attr("result", "noise")).call((t4) => t4.append("feDisplacementMap").attr("scale", "5").attr("xChannelSelector", "R").attr("yChannelSelector", "G").attr("in", "SourceGraphic").attr("in2", "noise")), t3.append("filter").attr("id", "xkcdify-pie").call((t4) => t4.append("feTurbulence").attr("type", "fractalNoise").attr("baseFrequency", "0.05").attr("result", "noise")).call((t4) => t4.append("feDisplacementMap").attr("scale", "5").attr("xChannelSelector", "R").attr("yChannelSelector", "G").attr("in", "SourceGraphic").attr("in2", "noise"));
    }
    var O2 = ["#dd4528", "#28a3dd", "#f3db52", "#ed84b5", "#4ab74e", "#9179c0", "#8e6d5a", "#f19839", "#949494"];
    const l2 = {top: 50, right: 30, bottom: 50, left: 50};
    class ag {
      constructor(t3, {title: e3, xLabel: i3, yLabel: o3, data: {labels: r3, datasets: s3}, options: a3}) {
        this.options = od({unxkcdify: false, yTickCount: 3, dataColors: O2, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white"}, a3), e3 && (this.title = e3, l2.top = 60), i3 && (this.xLabel = i3, l2.bottom = 50), o3 && (this.yLabel = o3, l2.left = 70), this.data = {labels: r3, datasets: s3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${l2.left},${l2.top})`), this.width = this.svgEl.attr("width") - l2.left - l2.right, this.height = this.svgEl.attr("height") - l2.top - l2.bottom, M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k2.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k2.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b2.positionType.upRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), e3 = ja().range([0, this.width]).domain(this.data.labels).padding(0.4), i3 = this.data.datasets.reduce((t4, e4) => t4.concat(e4.data), []), o3 = A2().domain([0, Math.max(...i3)]).range([this.height, 0]), r3 = this.chart.append("g");
        y2.xAxis(r3, {xScale: e3, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(r3, {yScale: o3, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), r3.selectAll(".xkcd-chart-bar").data(this.data.datasets[0].data).enter().append("rect").attr("class", "xkcd-chart-bar").attr("x", (t4, i4) => e3(this.data.labels[i4])).attr("width", e3.bandwidth()).attr("y", (t4) => o3(t4)).attr("height", (t4) => this.height - o3(t4)).attr("fill", "none").attr("pointer-events", "all").attr("stroke", this.options.strokeColor).attr("stroke-width", 3).attr("rx", 2).attr("filter", this.filter).on("mouseover", (e4, i4, o4) => {
          f2(o4[i4]).attr("fill", this.options.dataColors[i4]), t3.show();
        }).on("mouseout", (e4, i4, o4) => {
          f2(o4[i4]).attr("fill", "none"), t3.hide();
        }).on("mousemove", (e4, i4, o4) => {
          const r4 = w3(o4[i4])[0] + l2.left + 10, s3 = w3(o4[i4])[1] + l2.top + 10;
          let a3 = b2.positionType.downRight;
          r4 > this.width / 2 && s3 < this.height / 2 ? a3 = b2.positionType.downLeft : r4 > this.width / 2 && s3 > this.height / 2 ? a3 = b2.positionType.upLeft : r4 < this.width / 2 && s3 > this.height / 2 && (a3 = b2.positionType.upRight), t3.update({title: this.data.labels[i4], items: [{color: this.options.dataColors[i4], text: `${this.data.datasets[0].label || ""}: ${e4}`}], position: {x: r4, y: s3, type: a3}});
        });
      }
      update() {
      }
    }
    function Ic(t3, o3) {
      var e3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var i3 = Object.getOwnPropertySymbols(t3);
        o3 && (i3 = i3.filter(function(o4) {
          return Object.getOwnPropertyDescriptor(t3, o4).enumerable;
        })), e3.push.apply(e3, i3);
      }
      return e3;
    }
    function bg(t3) {
      for (var o3 = 1; o3 < arguments.length; o3++) {
        var e3 = arguments[o3] != null ? arguments[o3] : {};
        o3 % 2 ? Ic(e3, true).forEach(function(o4) {
          cg(t3, o4, e3[o4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(e3)) : Ic(e3).forEach(function(o4) {
          Object.defineProperty(t3, o4, Object.getOwnPropertyDescriptor(e3, o4));
        });
      }
      return t3;
    }
    function cg(t3, o3, e3) {
      return o3 in t3 ? Object.defineProperty(t3, o3, {value: e3, enumerable: true, configurable: true, writable: true}) : t3[o3] = e3, t3;
    }
    function Z2(t3, {items: r3, position: e3, unxkcdify: i3, parentWidth: o3, parentHeight: a3, strokeColor: p3, backgroundColor: n3}) {
      const l3 = i3 ? null : "url(#xkcdify)", $3 = t3.append("svg"), d3 = $3.append("svg"), s3 = $3.append("svg");
      r3.forEach((t4, r4) => {
        s3.append("rect").style("fill", t4.color).attr("width", 8).attr("height", 8).attr("rx", 2).attr("ry", 2).attr("filter", l3).attr("x", 15).attr("y", 17 + 20 * r4), s3.append("text").style("font-size", "15").style("fill", p3).attr("x", 27).attr("y", 17 + 20 * r4 + 8).text(t4.text);
      });
      const f3 = s3.node().getBBox(), c3 = f3.width + 15, g3 = f3.height + 10;
      let y3 = 0, h3 = 0;
      e3 !== b2.positionType.downLeft && e3 !== b2.positionType.downRight || (h3 = a3 - g3 - 13), e3 !== b2.positionType.upRight && e3 !== b2.positionType.downRight || (y3 = o3 - c3 - 13), d3.append("rect").style("fill", n3).attr("fill-opacity", 0.85).attr("stroke", p3).attr("stroke-width", 2).attr("rx", 5).attr("ry", 5).attr("filter", l3).attr("width", c3).attr("height", g3).attr("x", 8).attr("y", 5), $3.attr("x", y3).attr("y", h3);
    }
    const p2 = {top: 50, right: 30, bottom: 50, left: 50};
    class dg {
      constructor(t3, {title: o3, xLabel: e3, yLabel: i3, data: {labels: r3, datasets: s3}, options: a3}) {
        this.options = bg({unxkcdify: false, yTickCount: 3, dataColors: O2, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", legendPosition: b2.positionType.upLeft, showLegend: true}, a3), o3 && (this.title = o3, p2.top = 60), e3 && (this.xLabel = e3, p2.bottom = 50), i3 && (this.yLabel = i3, p2.left = 70), this.data = {labels: r3, datasets: s3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${p2.left},${p2.top})`), this.width = this.svgEl.attr("width") - p2.left - p2.right, this.height = this.svgEl.attr("height") - p2.top - p2.bottom, M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k2.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k2.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b2.positionType.upRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), o3 = ja().range([0, this.width]).domain(this.data.labels).padding(0.4), e3 = this.data.datasets.reduce((t4, o4) => o4.data.map((o5, e4) => (t4[e4] || 0) + o5), []), i3 = A2().domain([0, Math.max(...e3)]).range([this.height, 0]), r3 = this.chart.append("g");
        y2.xAxis(r3, {xScale: o3, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(r3, {yScale: i3, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor});
        const s3 = this.data.datasets.reduce((t4, o4) => t4.concat(o4.data), []), a3 = this.data.datasets[0].data.length, n3 = this.data.datasets.reduce((t4, o4, e4) => (e4 > 0 ? t4.push(o4.data.map((o5, i4) => this.data.datasets[e4 - 1].data[i4] + t4[e4 - 1][i4])) : t4.push(new Array(o4.data.length).fill(0)), t4), []).flat();
        if (r3.selectAll(".xkcd-chart-stacked-bar").data(s3).enter().append("rect").attr("class", "xkcd-chart-stacked-bar").attr("x", (t4, e4) => o3(this.data.labels[e4 % a3])).attr("width", o3.bandwidth()).attr("y", (t4, o4) => i3(t4 + n3[o4])).attr("height", (t4) => this.height - i3(t4)).attr("fill", (t4, o4) => this.options.dataColors[Math.floor(o4 / a3)]).attr("pointer-events", "all").attr("stroke", this.options.strokeColor).attr("stroke-width", 3).attr("rx", 2).attr("filter", this.filter).on("mouseover", () => t3.show()).on("mouseout", () => t3.hide()).on("mousemove", (o4, e4, i4) => {
          const r4 = w3(i4[e4])[0] + p2.left + 10, s4 = w3(i4[e4])[1] + p2.top + 10, n4 = this.data.datasets.map((t4, o5) => ({color: this.options.dataColors[o5], text: `${this.data.datasets[o5].label || ""}: ${this.data.datasets[o5].data[e4 % a3]}`})).reverse();
          let l3 = b2.positionType.downRight;
          r4 > this.width / 2 && s4 < this.height / 2 ? l3 = b2.positionType.downLeft : r4 > this.width / 2 && s4 > this.height / 2 ? l3 = b2.positionType.upLeft : r4 < this.width / 2 && s4 > this.height / 2 && (l3 = b2.positionType.upRight), t3.update({title: this.data.labels[e4], items: n4, position: {x: r4, y: s4, type: l3}});
        }), this.options.showLegend) {
          const t4 = this.data.datasets.map((t5, o4) => ({color: this.options.dataColors[o4], text: `${this.data.datasets[o4].label || ""}`})).reverse();
          Z2(r3, {items: t4, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        }
      }
      update() {
      }
    }
    function Jc(t3, e3) {
      var i3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(t3);
        e3 && (o3 = o3.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i3.push.apply(i3, o3);
      }
      return i3;
    }
    function eg(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? Jc(i3, true).forEach(function(e4) {
          fg(t3, e4, i3[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(i3)) : Jc(i3).forEach(function(e4) {
          Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(i3, e4));
        });
      }
      return t3;
    }
    function fg(t3, e3, i3) {
      return e3 in t3 ? Object.defineProperty(t3, e3, {value: i3, enumerable: true, configurable: true, writable: true}) : t3[e3] = i3, t3;
    }
    var c2 = function(e3) {
      return function() {
        return e3;
      };
    };
    var gg = function($3, t3) {
      return t3 < $3 ? -1 : t3 > $3 ? 1 : t3 >= $3 ? 0 : NaN;
    };
    var hg = function($3) {
      return $3;
    };
    var Kc = Math.abs;
    var Q2 = Math.atan2;
    var W2 = Math.cos;
    var ig = Math.max;
    var kb = Math.min;
    var V2 = Math.sin;
    var X2 = Math.sqrt;
    var U2 = 1e-12;
    var _2 = Math.PI;
    var ta = _2 / 2;
    var ua = 2 * _2;
    function jg($3) {
      return $3 > 1 ? 0 : $3 < -1 ? _2 : Math.acos($3);
    }
    function Lc($3) {
      return $3 >= 1 ? ta : $3 <= -1 ? -ta : Math.asin($3);
    }
    var kg = function() {
      var t3 = hg, n3 = gg, r3 = null, e3 = c2(0), $3 = c2(ua), o3 = c2(0);
      function a3(a4) {
        var i3, u3, l3, p3, c3, A3 = a4.length, f3 = 0, s3 = new Array(A3), b3 = new Array(A3), U3 = +e3.apply(this, arguments), Z3 = Math.min(ua, Math.max(-ua, $3.apply(this, arguments) - U3)), m3 = Math.min(Math.abs(Z3) / A3, o3.apply(this, arguments)), d3 = m3 * (Z3 < 0 ? -1 : 1);
        for (i3 = 0; i3 < A3; ++i3)
          (c3 = b3[s3[i3] = i3] = +t3(a4[i3], i3, a4)) > 0 && (f3 += c3);
        for (n3 != null ? s3.sort(function(t4, r4) {
          return n3(b3[t4], b3[r4]);
        }) : r3 != null && s3.sort(function(t4, n4) {
          return r3(a4[t4], a4[n4]);
        }), i3 = 0, l3 = f3 ? (Z3 - A3 * d3) / f3 : 0; i3 < A3; ++i3, U3 = p3)
          u3 = s3[i3], p3 = U3 + ((c3 = b3[u3]) > 0 ? c3 * l3 : 0) + d3, b3[u3] = {data: a4[u3], index: i3, value: c3, startAngle: U3, endAngle: p3, padAngle: m3};
        return b3;
      }
      return a3.value = function(n4) {
        return arguments.length ? (t3 = typeof n4 == "function" ? n4 : c2(+n4), a3) : t3;
      }, a3.sortValues = function(t4) {
        return arguments.length ? (n3 = t4, r3 = null, a3) : n3;
      }, a3.sort = function(t4) {
        return arguments.length ? (r3 = t4, n3 = null, a3) : r3;
      }, a3.startAngle = function(t4) {
        return arguments.length ? (e3 = typeof t4 == "function" ? t4 : c2(+t4), a3) : e3;
      }, a3.endAngle = function(t4) {
        return arguments.length ? ($3 = typeof t4 == "function" ? t4 : c2(+t4), a3) : $3;
      }, a3.padAngle = function(t4) {
        return arguments.length ? (o3 = typeof t4 == "function" ? t4 : c2(+t4), a3) : o3;
      }, a3;
    };
    function lg($3) {
      return $3.innerRadius;
    }
    function mg($3) {
      return $3.outerRadius;
    }
    function ng($3) {
      return $3.startAngle;
    }
    function og($3) {
      return $3.endAngle;
    }
    function pg($3) {
      return $3 && $3.padAngle;
    }
    function qg($3, t3, r3, n3, i3, o3, a3, p3) {
      var e3 = r3 - $3, c3 = n3 - t3, I3 = a3 - i3, B3 = p3 - o3, L5 = B3 * e3 - I3 * c3;
      if (!(L5 * L5 < U2))
        return [$3 + (L5 = (I3 * (t3 - o3) - B3 * ($3 - i3)) / L5) * e3, t3 + L5 * c3];
    }
    function va($3, t3, r3, n3, i3, o3, a3) {
      var p3 = $3 - r3, e3 = t3 - n3, c3 = (a3 ? o3 : -o3) / X2(p3 * p3 + e3 * e3), I3 = c3 * e3, B3 = -c3 * p3, L5 = $3 + I3, m3 = t3 + B3, s3 = r3 + I3, l3 = n3 + B3, u3 = (L5 + s3) / 2, y3 = (m3 + l3) / 2, f3 = s3 - L5, x3 = l3 - m3, v3 = f3 * f3 + x3 * x3, g3 = i3 - o3, h3 = L5 * l3 - s3 * m3, d3 = (x3 < 0 ? -1 : 1) * X2(ig(0, g3 * g3 * v3 - h3 * h3)), T3 = (h3 * x3 - f3 * d3) / v3, A3 = (-h3 * f3 - x3 * d3) / v3, R3 = (h3 * x3 + f3 * d3) / v3, q3 = (-h3 * f3 + x3 * d3) / v3, P3 = T3 - u3, b3 = A3 - y3, E3 = R3 - u3, O3 = q3 - y3;
      return P3 * P3 + b3 * b3 > E3 * E3 + O3 * O3 && (T3 = R3, A3 = q3), {cx: T3, cy: A3, x01: -I3, y01: -B3, x11: T3 * (i3 / g3 - 1), y11: A3 * (i3 / g3 - 1)};
    }
    var lb = Math.PI, mb = 2 * lb, C2 = 1e-6, rg = mb - C2;
    function nb() {
      this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
    }
    function ob() {
      return new nb();
    }
    nb.prototype = ob.prototype = {constructor: nb, moveTo: function(t3, h3) {
      this._ += "M" + (this._x0 = this._x1 = +t3) + "," + (this._y0 = this._y1 = +h3);
    }, closePath: function() {
      this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
    }, lineTo: function(t3, h3) {
      this._ += "L" + (this._x1 = +t3) + "," + (this._y1 = +h3);
    }, quadraticCurveTo: function(t3, h3, i3, s3) {
      this._ += "Q" + +t3 + "," + +h3 + "," + (this._x1 = +i3) + "," + (this._y1 = +s3);
    }, bezierCurveTo: function(t3, h3, i3, s3, $3, o3) {
      this._ += "C" + +t3 + "," + +h3 + "," + +i3 + "," + +s3 + "," + (this._x1 = +$3) + "," + (this._y1 = +o3);
    }, arcTo: function(t3, h3, i3, s3, $3) {
      t3 = +t3, h3 = +h3, i3 = +i3, s3 = +s3, $3 = +$3;
      var o3 = this._x1, a3 = this._y1, r3 = i3 - t3, _3 = s3 - h3, n3 = o3 - t3, M3 = a3 - h3, e3 = n3 * n3 + M3 * M3;
      if ($3 < 0)
        throw new Error("negative radius: " + $3);
      if (this._x1 === null)
        this._ += "M" + (this._x1 = t3) + "," + (this._y1 = h3);
      else if (e3 > C2) {
        if (Math.abs(M3 * r3 - _3 * n3) > C2 && $3) {
          var u3 = i3 - o3, b3 = s3 - a3, v3 = r3 * r3 + _3 * _3, l3 = u3 * u3 + b3 * b3, x3 = Math.sqrt(v3), p3 = Math.sqrt(e3), c3 = $3 * Math.tan((lb - Math.acos((v3 + e3 - l3) / (2 * x3 * p3))) / 2), f3 = c3 / p3, y3 = c3 / x3;
          Math.abs(f3 - 1) > C2 && (this._ += "L" + (t3 + f3 * n3) + "," + (h3 + f3 * M3)), this._ += "A" + $3 + "," + $3 + ",0,0," + +(M3 * u3 > n3 * b3) + "," + (this._x1 = t3 + y3 * r3) + "," + (this._y1 = h3 + y3 * _3);
        } else
          this._ += "L" + (this._x1 = t3) + "," + (this._y1 = h3);
      } else
        ;
    }, arc: function(t3, h3, i3, s3, $3, o3) {
      t3 = +t3, h3 = +h3, o3 = !!o3;
      var a3 = (i3 = +i3) * Math.cos(s3), r3 = i3 * Math.sin(s3), _3 = t3 + a3, n3 = h3 + r3, M3 = 1 ^ o3, e3 = o3 ? s3 - $3 : $3 - s3;
      if (i3 < 0)
        throw new Error("negative radius: " + i3);
      this._x1 === null ? this._ += "M" + _3 + "," + n3 : (Math.abs(this._x1 - _3) > C2 || Math.abs(this._y1 - n3) > C2) && (this._ += "L" + _3 + "," + n3), i3 && (e3 < 0 && (e3 = e3 % mb + mb), e3 > rg ? this._ += "A" + i3 + "," + i3 + ",0,1," + M3 + "," + (t3 - a3) + "," + (h3 - r3) + "A" + i3 + "," + i3 + ",0,1," + M3 + "," + (this._x1 = _3) + "," + (this._y1 = n3) : e3 > C2 && (this._ += "A" + i3 + "," + i3 + ",0," + +(e3 >= lb) + "," + M3 + "," + (this._x1 = t3 + i3 * Math.cos($3)) + "," + (this._y1 = h3 + i3 * Math.sin($3))));
    }, rect: function(t3, h3, i3, s3) {
      this._ += "M" + (this._x0 = this._x1 = +t3) + "," + (this._y0 = this._y1 = +h3) + "h" + +i3 + "v" + +s3 + "h" + -i3 + "Z";
    }, toString: function() {
      return this._;
    }};
    var sg = function() {
      var $3 = lg, t3 = mg, r3 = c2(0), n3 = null, i3 = ng, o3 = og, a3 = pg, p3 = null;
      function e3() {
        var e4, c3, I3 = +$3.apply(this, arguments), B3 = +t3.apply(this, arguments), L5 = i3.apply(this, arguments) - ta, m3 = o3.apply(this, arguments) - ta, s3 = Kc(m3 - L5), l3 = m3 > L5;
        if (p3 || (p3 = e4 = ob()), B3 < I3 && (c3 = B3, B3 = I3, I3 = c3), B3 > U2) {
          if (s3 > ua - U2)
            p3.moveTo(B3 * W2(L5), B3 * V2(L5)), p3.arc(0, 0, B3, L5, m3, !l3), I3 > U2 && (p3.moveTo(I3 * W2(m3), I3 * V2(m3)), p3.arc(0, 0, I3, m3, L5, l3));
          else {
            var u3, y3, f3 = L5, x3 = m3, v3 = L5, g3 = m3, h3 = s3, d3 = s3, T3 = a3.apply(this, arguments) / 2, A3 = T3 > U2 && (n3 ? +n3.apply(this, arguments) : X2(I3 * I3 + B3 * B3)), R3 = kb(Kc(B3 - I3) / 2, +r3.apply(this, arguments)), q3 = R3, P3 = R3;
            if (A3 > U2) {
              var b3 = Lc(A3 / I3 * V2(T3)), E3 = Lc(A3 / B3 * V2(T3));
              (h3 -= 2 * b3) > U2 ? (v3 += b3 *= l3 ? 1 : -1, g3 -= b3) : (h3 = 0, v3 = g3 = (L5 + m3) / 2), (d3 -= 2 * E3) > U2 ? (f3 += E3 *= l3 ? 1 : -1, x3 -= E3) : (d3 = 0, f3 = x3 = (L5 + m3) / 2);
            }
            var O3 = B3 * W2(f3), S3 = B3 * V2(f3), j3 = I3 * W2(g3), k3 = I3 * V2(g3);
            if (R3 > U2) {
              var w4, z3 = B3 * W2(x3), C3 = B3 * V2(x3), D3 = I3 * W2(v3), F3 = I3 * V2(v3);
              if (s3 < _2 && (w4 = qg(O3, S3, D3, F3, z3, C3, j3, k3))) {
                var G3 = O3 - w4[0], H3 = S3 - w4[1], J3 = z3 - w4[0], K3 = C3 - w4[1], M3 = 1 / V2(jg((G3 * J3 + H3 * K3) / (X2(G3 * G3 + H3 * H3) * X2(J3 * J3 + K3 * K3))) / 2), N3 = X2(w4[0] * w4[0] + w4[1] * w4[1]);
                q3 = kb(R3, (I3 - N3) / (M3 - 1)), P3 = kb(R3, (B3 - N3) / (M3 + 1));
              }
            }
            d3 > U2 ? P3 > U2 ? (u3 = va(D3, F3, O3, S3, B3, P3, l3), y3 = va(z3, C3, j3, k3, B3, P3, l3), p3.moveTo(u3.cx + u3.x01, u3.cy + u3.y01), P3 < R3 ? p3.arc(u3.cx, u3.cy, P3, Q2(u3.y01, u3.x01), Q2(y3.y01, y3.x01), !l3) : (p3.arc(u3.cx, u3.cy, P3, Q2(u3.y01, u3.x01), Q2(u3.y11, u3.x11), !l3), p3.arc(0, 0, B3, Q2(u3.cy + u3.y11, u3.cx + u3.x11), Q2(y3.cy + y3.y11, y3.cx + y3.x11), !l3), p3.arc(y3.cx, y3.cy, P3, Q2(y3.y11, y3.x11), Q2(y3.y01, y3.x01), !l3))) : (p3.moveTo(O3, S3), p3.arc(0, 0, B3, f3, x3, !l3)) : p3.moveTo(O3, S3), I3 > U2 && h3 > U2 ? q3 > U2 ? (u3 = va(j3, k3, z3, C3, I3, -q3, l3), y3 = va(O3, S3, D3, F3, I3, -q3, l3), p3.lineTo(u3.cx + u3.x01, u3.cy + u3.y01), q3 < R3 ? p3.arc(u3.cx, u3.cy, q3, Q2(u3.y01, u3.x01), Q2(y3.y01, y3.x01), !l3) : (p3.arc(u3.cx, u3.cy, q3, Q2(u3.y01, u3.x01), Q2(u3.y11, u3.x11), !l3), p3.arc(0, 0, I3, Q2(u3.cy + u3.y11, u3.cx + u3.x11), Q2(y3.cy + y3.y11, y3.cx + y3.x11), l3), p3.arc(y3.cx, y3.cy, q3, Q2(y3.y11, y3.x11), Q2(y3.y01, y3.x01), !l3))) : p3.arc(0, 0, I3, g3, v3, l3) : p3.lineTo(j3, k3);
          }
        } else
          p3.moveTo(0, 0);
        if (p3.closePath(), e4)
          return p3 = null, e4 + "" || null;
      }
      return e3.centroid = function() {
        var r4 = (+$3.apply(this, arguments) + +t3.apply(this, arguments)) / 2, n4 = (+i3.apply(this, arguments) + +o3.apply(this, arguments)) / 2 - _2 / 2;
        return [W2(n4) * r4, V2(n4) * r4];
      }, e3.innerRadius = function(t4) {
        return arguments.length ? ($3 = typeof t4 == "function" ? t4 : c2(+t4), e3) : $3;
      }, e3.outerRadius = function($4) {
        return arguments.length ? (t3 = typeof $4 == "function" ? $4 : c2(+$4), e3) : t3;
      }, e3.cornerRadius = function($4) {
        return arguments.length ? (r3 = typeof $4 == "function" ? $4 : c2(+$4), e3) : r3;
      }, e3.padRadius = function($4) {
        return arguments.length ? (n3 = $4 == null ? null : typeof $4 == "function" ? $4 : c2(+$4), e3) : n3;
      }, e3.startAngle = function($4) {
        return arguments.length ? (i3 = typeof $4 == "function" ? $4 : c2(+$4), e3) : i3;
      }, e3.endAngle = function($4) {
        return arguments.length ? (o3 = typeof $4 == "function" ? $4 : c2(+$4), e3) : o3;
      }, e3.padAngle = function($4) {
        return arguments.length ? (a3 = typeof $4 == "function" ? $4 : c2(+$4), e3) : a3;
      }, e3.context = function($4) {
        return arguments.length ? (p3 = $4 == null ? null : $4, e3) : p3;
      }, e3;
    };
    const tg = 50;
    class ug {
      constructor(t3, {title: e3, data: {labels: i3, datasets: o3}, options: r3}) {
        this.options = eg({unxkcdify: false, innerRadius: 0.5, legendPosition: b2.positionType.upLeft, dataColors: O2, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, r3), this.title = e3, this.data = {labels: i3, datasets: o3}, this.filter = "url(#xkcdify-pie)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.width = this.svgEl.attr("width"), this.height = this.svgEl.attr("height"), this.chart = this.svgEl.append("g").attr("transform", `translate(${this.width / 2},${this.height / 2})`), M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "tooltip", items: [{color: "red", text: "weweyang: 12"}, {color: "blue", text: "timqian: 13"}], position: {x: 30, y: 30, type: b2.positionType.upRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor}), e3 = Math.min(this.width, this.height) / 2 - tg, i3 = kg()(this.data.datasets[0].data), o3 = sg().innerRadius(e3 * (this.options.innerRadius === void 0 ? 0.5 : this.options.innerRadius)).outerRadius(e3);
        this.chart.selectAll(".xkcd-chart-arc").data(i3).enter().append("path").attr("class", ".xkcd-chart-arc").attr("d", o3).attr("fill", "none").attr("stroke", this.options.strokeColor).attr("stroke-width", 2).attr("fill", (t4, e4) => this.options.dataColors[e4]).attr("filter", this.filter).on("mouseover", (e4, i4, o4) => {
          f2(o4[i4]).attr("fill-opacity", 0.6), t3.show();
        }).on("mouseout", (e4, i4, o4) => {
          f2(o4[i4]).attr("fill-opacity", 1), t3.hide();
        }).on("mousemove", (e4, i4, o4) => {
          const r4 = w3(o4[i4])[0] + this.width / 2 + 10, s4 = w3(o4[i4])[1] + this.height / 2 + 10;
          t3.update({title: this.data.labels[i4], items: [{color: this.options.dataColors[i4], text: `${this.data.datasets[0].label || ""}: ${e4.data}`}], position: {x: r4, y: s4, type: b2.positionType.downRight}});
        });
        const r3 = this.data.datasets[0].data.map((t4, e4) => ({color: this.options.dataColors[e4], text: this.data.labels[e4]})), s3 = this.svgEl.append("g").attr("transform", "translate(0, 30)");
        this.options.showLegend && Z2(s3, {items: r3, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
      }
      update() {
      }
    }
    function Mc(t3, i3) {
      var o3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var e3 = Object.getOwnPropertySymbols(t3);
        i3 && (e3 = e3.filter(function(i4) {
          return Object.getOwnPropertyDescriptor(t3, i4).enumerable;
        })), o3.push.apply(o3, e3);
      }
      return o3;
    }
    function vg(t3) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var o3 = arguments[i3] != null ? arguments[i3] : {};
        i3 % 2 ? Mc(o3, true).forEach(function(i4) {
          wg(t3, i4, o3[i4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(o3)) : Mc(o3).forEach(function(i4) {
          Object.defineProperty(t3, i4, Object.getOwnPropertyDescriptor(o3, i4));
        });
      }
      return t3;
    }
    function wg(t3, i3, o3) {
      return i3 in t3 ? Object.defineProperty(t3, i3, {value: o3, enumerable: true, configurable: true, writable: true}) : t3[i3] = o3, t3;
    }
    function Nc(t3) {
      this._context = t3;
    }
    Nc.prototype = {areaStart: function() {
      this._line = 0;
    }, areaEnd: function() {
      this._line = NaN;
    }, lineStart: function() {
      this._point = 0;
    }, lineEnd: function() {
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    }, point: function(t3, i3) {
      switch (t3 = +t3, i3 = +i3, this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t3, i3) : this._context.moveTo(t3, i3);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(t3, i3);
      }
    }};
    var xg = function(t3) {
      return new Nc(t3);
    };
    function yg($3) {
      return $3[0];
    }
    function zg($3) {
      return $3[1];
    }
    var pb = function() {
      var n3 = yg, t3 = zg, r3 = c2(true), e3 = null, $3 = xg, o3 = null;
      function u3(u4) {
        var i3, l3, p3, h3 = u4.length, c3 = false;
        for (e3 == null && (o3 = $3(p3 = ob())), i3 = 0; i3 <= h3; ++i3)
          !(i3 < h3 && r3(l3 = u4[i3], i3, u4)) === c3 && ((c3 = !c3) ? o3.lineStart() : o3.lineEnd()), c3 && o3.point(+n3(l3, i3, u4), +t3(l3, i3, u4));
        if (p3)
          return o3 = null, p3 + "" || null;
      }
      return u3.x = function(t4) {
        return arguments.length ? (n3 = typeof t4 == "function" ? t4 : c2(+t4), u3) : n3;
      }, u3.y = function(n4) {
        return arguments.length ? (t3 = typeof n4 == "function" ? n4 : c2(+n4), u3) : t3;
      }, u3.defined = function(n4) {
        return arguments.length ? (r3 = typeof n4 == "function" ? n4 : c2(!!n4), u3) : r3;
      }, u3.curve = function(n4) {
        return arguments.length ? ($3 = n4, e3 != null && (o3 = $3(e3)), u3) : $3;
      }, u3.context = function(n4) {
        return arguments.length ? (n4 == null ? e3 = o3 = null : o3 = $3(e3 = n4), u3) : e3;
      }, u3;
    };
    function Oc(t3) {
      return t3 < 0 ? -1 : 1;
    }
    function Pc(t3, o3, n3) {
      var i3 = t3._x1 - t3._x0, e3 = o3 - t3._x1, $3 = (t3._y1 - t3._y0) / (i3 || e3 < 0 && -0), s3 = (n3 - t3._y1) / (e3 || i3 < 0 && -0), x3 = ($3 * e3 + s3 * i3) / (i3 + e3);
      return (Oc($3) + Oc(s3)) * Math.min(Math.abs($3), Math.abs(s3), 0.5 * Math.abs(x3)) || 0;
    }
    function Qc(t3, o3) {
      var n3 = t3._x1 - t3._x0;
      return n3 ? (3 * (t3._y1 - t3._y0) / n3 - o3) / 2 : o3;
    }
    function qb(t3, o3, n3) {
      var i3 = t3._x0, e3 = t3._y0, $3 = t3._x1, s3 = t3._y1, x3 = ($3 - i3) / 3;
      t3._context.bezierCurveTo(i3 + x3, e3 + x3 * o3, $3 - x3, s3 - x3 * n3, $3, s3);
    }
    function $2(t3) {
      this._context = t3;
    }
    function Rc(t3) {
      return new $2(t3);
    }
    $2.prototype = {areaStart: function() {
      this._line = 0;
    }, areaEnd: function() {
      this._line = NaN;
    }, lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
    }, lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          qb(this, this._t0, Qc(this, this._t0));
      }
      (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
    }, point: function(t3, o3) {
      var n3 = NaN;
      if (o3 = +o3, (t3 = +t3) !== this._x1 || o3 !== this._y1) {
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this._context.lineTo(t3, o3) : this._context.moveTo(t3, o3);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, qb(this, Qc(this, n3 = Pc(this, t3, o3)), n3);
            break;
          default:
            qb(this, this._t0, n3 = Pc(this, t3, o3));
        }
        this._x0 = this._x1, this._x1 = t3, this._y0 = this._y1, this._y1 = o3, this._t0 = n3;
      }
    }}, Object.create($2.prototype).point = function(t3, o3) {
      $2.prototype.point.call(this, o3, t3);
    };
    const q2 = {top: 50, right: 30, bottom: 50, left: 50};
    class Ag {
      constructor(t3, {title: i3, xLabel: o3, yLabel: e3, data: {labels: s3, datasets: r3}, options: a3}) {
        this.options = vg({unxkcdify: false, yTickCount: 3, legendPosition: b2.positionType.upLeft, dataColors: O2, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, a3), i3 && (this.title = i3, q2.top = 60), o3 && (this.xLabel = o3, q2.bottom = 50), e3 && (this.yLabel = e3, q2.left = 70), this.data = {labels: s3, datasets: r3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${q2.left},${q2.top})`), this.width = this.svgEl.attr("width") - q2.left - q2.right, this.height = this.svgEl.attr("height") - q2.top - q2.bottom, M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k2.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k2.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "", items: [{color: "red", text: "weweyang"}, {color: "blue", text: "timqian"}], position: {x: 60, y: 60, type: b2.positionType.downRight}, unxkcdify: this.options.unxkcdify, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor}), i3 = Qe2().domain(this.data.labels).range([0, this.width]), o3 = this.data.datasets.reduce((t4, i4) => t4.concat(i4.data), []), e3 = A2().domain([Math.min(...o3), Math.max(...o3)]).range([this.height, 0]), s3 = this.chart.append("g").attr("pointer-events", "all");
        y2.xAxis(s3, {xScale: i3, tickCount: 3, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(s3, {yScale: e3, tickCount: this.options.yTickCount || 3, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), this.svgEl.selectAll(".domain").attr("filter", this.filter);
        const r3 = pb().x((t4, o4) => i3(this.data.labels[o4])).y((t4) => e3(t4)).curve(Rc);
        s3.selectAll(".xkcd-chart-line").data(this.data.datasets).enter().append("path").attr("class", "xkcd-chart-line").attr("d", (t4) => r3(t4.data)).attr("fill", "none").attr("stroke", (t4, i4) => this.options.dataColors[i4]).attr("filter", this.filter);
        const a3 = s3.append("line").attr("x1", 30).attr("y1", 0).attr("x2", 30).attr("y2", this.height).attr("stroke", "#aaa").attr("stroke-width", 1.5).attr("stroke-dasharray", "7,7").style("visibility", "hidden"), l3 = this.data.datasets.map((t4, i4) => s3.append("circle").style("stroke", this.options.dataColors[i4]).style("fill", this.options.dataColors[i4]).attr("r", 3.5).style("visibility", "hidden"));
        if (s3.append("rect").attr("width", this.width).attr("height", this.height).attr("fill", "none").on("mouseover", () => {
          l3.forEach((t4) => t4.style("visibility", "visible")), a3.style("visibility", "visible"), t3.show();
        }).on("mouseout", () => {
          l3.forEach((t4) => t4.style("visibility", "hidden")), a3.style("visibility", "hidden"), t3.hide();
        }).on("mousemove", (o4, s4, r4) => {
          const n3 = w3(r4[s4])[0] + q2.left + 10, $3 = w3(r4[s4])[1] + q2.top + 10, h3 = this.data.labels.map((t4) => i3(t4) + q2.left).map((t4) => Math.abs(t4 - w3(r4[s4])[0] - q2.left)), d3 = h3.indexOf(Math.min(...h3));
          a3.attr("x1", i3(this.data.labels[d3])).attr("x2", i3(this.data.labels[d3])), this.data.datasets.forEach((t4, o5) => {
            l3[o5].style("visibility", "visible").attr("cx", i3(this.data.labels[d3])).attr("cy", e3(t4.data[d3]));
          });
          const m3 = this.data.datasets.map((t4, i4) => ({color: this.options.dataColors[i4], text: `${this.data.datasets[i4].label || ""}: ${this.data.datasets[i4].data[d3]}`}));
          let p3 = b2.positionType.downRight;
          n3 > this.width / 2 && $3 < this.height / 2 ? p3 = b2.positionType.downLeft : n3 > this.width / 2 && $3 > this.height / 2 ? p3 = b2.positionType.upLeft : n3 < this.width / 2 && $3 > this.height / 2 && (p3 = b2.positionType.upRight), t3.update({title: this.data.labels[d3], items: m3, position: {x: n3, y: $3, type: p3}});
        }), this.options.showLegend) {
          const t4 = this.data.datasets.map((t5, i4) => ({color: this.options.dataColors[i4], text: t5.label}));
          Z2(s3, {items: t4, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor});
        }
      }
      update() {
      }
    }
    function Sc(t3, o3) {
      var i3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var e3 = Object.getOwnPropertySymbols(t3);
        o3 && (e3 = e3.filter(function(o4) {
          return Object.getOwnPropertyDescriptor(t3, o4).enumerable;
        })), i3.push.apply(i3, e3);
      }
      return i3;
    }
    function Bg(t3) {
      for (var o3 = 1; o3 < arguments.length; o3++) {
        var i3 = arguments[o3] != null ? arguments[o3] : {};
        o3 % 2 ? Sc(i3, true).forEach(function(o4) {
          Cg(t3, o4, i3[o4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(i3)) : Sc(i3).forEach(function(o4) {
          Object.defineProperty(t3, o4, Object.getOwnPropertyDescriptor(i3, o4));
        });
      }
      return t3;
    }
    function Cg(t3, o3, i3) {
      return o3 in t3 ? Object.defineProperty(t3, o3, {value: i3, enumerable: true, configurable: true, writable: true}) : t3[o3] = i3, t3;
    }
    var rb = new Date(), sb = new Date();
    function d2(t3, r3, e3, n3) {
      function o3(r4) {
        return t3(r4 = new Date(+r4)), r4;
      }
      return o3.floor = o3, o3.ceil = function(e4) {
        return t3(e4 = new Date(e4 - 1)), r3(e4, 1), t3(e4), e4;
      }, o3.round = function(t4) {
        var r4 = o3(t4), e4 = o3.ceil(t4);
        return t4 - r4 < e4 - t4 ? r4 : e4;
      }, o3.offset = function(t4, e4) {
        return r3(t4 = new Date(+t4), e4 == null ? 1 : Math.floor(e4)), t4;
      }, o3.range = function(e4, n4, $3) {
        var u3, f3 = [];
        if (e4 = o3.ceil(e4), $3 = $3 == null ? 1 : Math.floor($3), !(e4 < n4 && $3 > 0))
          return f3;
        do {
          f3.push(u3 = new Date(+e4)), r3(e4, $3), t3(e4);
        } while (u3 < e4 && e4 < n4);
        return f3;
      }, o3.filter = function(e4) {
        return d2(function(r4) {
          if (r4 >= r4)
            for (; t3(r4), !e4(r4); )
              r4.setTime(r4 - 1);
        }, function(t4, n4) {
          if (t4 >= t4)
            if (n4 < 0)
              for (; ++n4 <= 0; )
                for (; r3(t4, -1), !e4(t4); )
                  ;
            else
              for (; --n4 >= 0; )
                for (; r3(t4, 1), !e4(t4); )
                  ;
        });
      }, e3 && (o3.count = function(r4, n4) {
        return rb.setTime(+r4), sb.setTime(+n4), t3(rb), t3(sb), Math.floor(e3(rb, sb));
      }, o3.every = function(t4) {
        return t4 = Math.floor(t4), isFinite(t4) && t4 > 0 ? t4 > 1 ? o3.filter(n3 ? function(r4) {
          return n3(r4) % t4 == 0;
        } : function(r4) {
          return o3.count(0, r4) % t4 == 0;
        }) : o3 : null;
      }), o3;
    }
    var wa = d2(function() {
    }, function(e3, t3) {
      e3.setTime(+e3 + t3);
    }, function(e3, t3) {
      return t3 - e3;
    });
    wa.every = function(e3) {
      return e3 = Math.floor(e3), isFinite(e3) && e3 > 0 ? e3 > 1 ? d2(function(t3) {
        t3.setTime(Math.floor(t3 / e3) * e3);
      }, function(t3, $3) {
        t3.setTime(+t3 + $3 * e3);
      }, function(t3, $3) {
        return ($3 - t3) / e3;
      }) : wa : null;
    };
    var oi = wa.range;
    var xa = 1e3;
    var D2 = 6e4;
    var ya = 36e5;
    var Tc = 864e5;
    var Uc = 6048e5;
    var Vc = d2(function(e3) {
      e3.setTime(e3 - e3.getMilliseconds());
    }, function(e3, $3) {
      e3.setTime(+e3 + $3 * xa);
    }, function(e3, $3) {
      return ($3 - e3) / xa;
    }, function(e3) {
      return e3.getUTCSeconds();
    });
    var pi = Vc.range;
    var Wc = d2(function(e3) {
      e3.setTime(e3 - e3.getMilliseconds() - e3.getSeconds() * xa);
    }, function(e3, t3) {
      e3.setTime(+e3 + t3 * D2);
    }, function(e3, t3) {
      return (t3 - e3) / D2;
    }, function(e3) {
      return e3.getMinutes();
    });
    var qi = Wc.range;
    var Xc = d2(function(r3) {
      r3.setTime(r3 - r3.getMilliseconds() - r3.getSeconds() * xa - r3.getMinutes() * D2);
    }, function(r3, $3) {
      r3.setTime(+r3 + $3 * ya);
    }, function(r3, $3) {
      return ($3 - r3) / ya;
    }, function(r3) {
      return r3.getHours();
    });
    var ri = Xc.range;
    var za = d2(function(r3) {
      r3.setHours(0, 0, 0, 0);
    }, function(r3, e3) {
      r3.setDate(r3.getDate() + e3);
    }, function(r3, e3) {
      return (e3 - r3 - (e3.getTimezoneOffset() - r3.getTimezoneOffset()) * D2) / Tc;
    }, function(r3) {
      return r3.getDate() - 1;
    });
    var si = za.range;
    function r2(e3) {
      return d2(function($3) {
        $3.setDate($3.getDate() - ($3.getDay() + 7 - e3) % 7), $3.setHours(0, 0, 0, 0);
      }, function(e4, $3) {
        e4.setDate(e4.getDate() + 7 * $3);
      }, function(e4, $3) {
        return ($3 - e4 - ($3.getTimezoneOffset() - e4.getTimezoneOffset()) * D2) / Uc;
      });
    }
    var tb = r2(0);
    var Aa = r2(1);
    var Dg = r2(2);
    var Eg = r2(3);
    var Ba = r2(4);
    var Fg = r2(5);
    var Gg = r2(6);
    var ti = tb.range;
    var ui = Aa.range;
    var vi = Dg.range;
    var wi = Eg.range;
    var xi = Ba.range;
    var yi = Fg.range;
    var zi = Gg.range;
    var Yc = d2(function(t3) {
      t3.setDate(1), t3.setHours(0, 0, 0, 0);
    }, function(t3, e3) {
      t3.setMonth(t3.getMonth() + e3);
    }, function(t3, e3) {
      return e3.getMonth() - t3.getMonth() + 12 * (e3.getFullYear() - t3.getFullYear());
    }, function(t3) {
      return t3.getMonth();
    });
    var Ai = Yc.range;
    var o2 = d2(function(e3) {
      e3.setMonth(0, 1), e3.setHours(0, 0, 0, 0);
    }, function(e3, t3) {
      e3.setFullYear(e3.getFullYear() + t3);
    }, function(e3, t3) {
      return t3.getFullYear() - e3.getFullYear();
    }, function(e3) {
      return e3.getFullYear();
    });
    o2.every = function(e3) {
      return isFinite(e3 = Math.floor(e3)) && e3 > 0 ? d2(function(t3) {
        t3.setFullYear(Math.floor(t3.getFullYear() / e3) * e3), t3.setMonth(0, 1), t3.setHours(0, 0, 0, 0);
      }, function(t3, r3) {
        t3.setFullYear(t3.getFullYear() + r3 * e3);
      }) : null;
    };
    var Bi = o2.range;
    var Hg = d2(function(t3) {
      t3.setUTCSeconds(0, 0);
    }, function(t3, e3) {
      t3.setTime(+t3 + e3 * D2);
    }, function(t3, e3) {
      return (e3 - t3) / D2;
    }, function(t3) {
      return t3.getUTCMinutes();
    });
    var Ci = Hg.range;
    var Ig = d2(function(r3) {
      r3.setUTCMinutes(0, 0, 0);
    }, function(r3, $3) {
      r3.setTime(+r3 + $3 * ya);
    }, function(r3, $3) {
      return ($3 - r3) / ya;
    }, function(r3) {
      return r3.getUTCHours();
    });
    var Di = Ig.range;
    var ub = d2(function(t3) {
      t3.setUTCHours(0, 0, 0, 0);
    }, function(t3, $3) {
      t3.setUTCDate(t3.getUTCDate() + $3);
    }, function(t3, $3) {
      return ($3 - t3) / Tc;
    }, function(t3) {
      return t3.getUTCDate() - 1;
    });
    var Ei = ub.range;
    function E2($3) {
      return d2(function(t3) {
        t3.setUTCDate(t3.getUTCDate() - (t3.getUTCDay() + 7 - $3) % 7), t3.setUTCHours(0, 0, 0, 0);
      }, function($4, t3) {
        $4.setUTCDate($4.getUTCDate() + 7 * t3);
      }, function($4, t3) {
        return (t3 - $4) / Uc;
      });
    }
    var Zc = E2(0);
    var Ca = E2(1);
    var Jg = E2(2);
    var Kg = E2(3);
    var Da = E2(4);
    var Lg = E2(5);
    var Mg = E2(6);
    var Fi = Zc.range;
    var Gi = Ca.range;
    var Hi = Jg.range;
    var Ii = Kg.range;
    var Ji = Da.range;
    var Ki = Lg.range;
    var Li = Mg.range;
    var Ng = d2(function(t3) {
      t3.setUTCDate(1), t3.setUTCHours(0, 0, 0, 0);
    }, function(t3, e3) {
      t3.setUTCMonth(t3.getUTCMonth() + e3);
    }, function(t3, e3) {
      return e3.getUTCMonth() - t3.getUTCMonth() + 12 * (e3.getUTCFullYear() - t3.getUTCFullYear());
    }, function(t3) {
      return t3.getUTCMonth();
    });
    var Mi = Ng.range;
    var F2 = d2(function(e3) {
      e3.setUTCMonth(0, 1), e3.setUTCHours(0, 0, 0, 0);
    }, function(e3, t3) {
      e3.setUTCFullYear(e3.getUTCFullYear() + t3);
    }, function(e3, t3) {
      return t3.getUTCFullYear() - e3.getUTCFullYear();
    }, function(e3) {
      return e3.getUTCFullYear();
    });
    F2.every = function(e3) {
      return isFinite(e3 = Math.floor(e3)) && e3 > 0 ? d2(function(t3) {
        t3.setUTCFullYear(Math.floor(t3.getUTCFullYear() / e3) * e3), t3.setUTCMonth(0, 1), t3.setUTCHours(0, 0, 0, 0);
      }, function(t3, r3) {
        t3.setUTCFullYear(t3.getUTCFullYear() + r3 * e3);
      }) : null;
    };
    var Ni = F2.range;
    var aa, Og, Oi, Pg, Qg;
    function Rg($3) {
      return aa = Tg($3), Og = aa.format, Oi = aa.parse, Pg = aa.utcFormat, Qg = aa.utcParse, aa;
    }
    function Sg(r3) {
      if (0 <= r3.y && r3.y < 100) {
        var $3 = new Date(-1, r3.m, r3.d, r3.H, r3.M, r3.S, r3.L);
        return $3.setFullYear(r3.y), $3;
      }
      return new Date(r3.y, r3.m, r3.d, r3.H, r3.M, r3.S, r3.L);
    }
    function Ea(r3) {
      if (0 <= r3.y && r3.y < 100) {
        var $3 = new Date(Date.UTC(-1, r3.m, r3.d, r3.H, r3.M, r3.S, r3.L));
        return $3.setUTCFullYear(r3.y), $3;
      }
      return new Date(Date.UTC(r3.y, r3.m, r3.d, r3.H, r3.M, r3.S, r3.L));
    }
    function ba(r3) {
      return {y: r3, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
    }
    function Tg(r3) {
      var $3 = r3.dateTime, e3 = r3.date, a3 = r3.time, t3 = r3.periods, U3 = r3.days, n3 = r3.shortDays, o3 = r3.months, u3 = r3.shortMonths, b3 = ca(t3), i3 = da(t3), H3 = ca(U3), v3 = da(U3), c3 = ca(n3), f3 = da(n3), m3 = ca(o3), s3 = da(o3), l3 = ca(u3), d3 = da(u3), p3 = {a: function(r4) {
        return n3[r4.getDay()];
      }, A: function(r4) {
        return U3[r4.getDay()];
      }, b: function(r4) {
        return u3[r4.getMonth()];
      }, B: function(r4) {
        return o3[r4.getMonth()];
      }, c: null, d: bd, e: bd, f: ph, H: mh, I: nh, j: oh, L: cd, m: qh, M: rh, p: function(r4) {
        return t3[+(r4.getHours() >= 12)];
      }, Q: gd, s: hd, S: sh, u: th, U: uh, V: vh, w: wh, W: xh, x: null, X: null, y: yh, Y: zh, Z: Ah, "%": fd}, y3 = {a: function(r4) {
        return n3[r4.getUTCDay()];
      }, A: function(r4) {
        return U3[r4.getUTCDay()];
      }, b: function(r4) {
        return u3[r4.getUTCMonth()];
      }, B: function(r4) {
        return o3[r4.getUTCMonth()];
      }, c: null, d: dd, e: dd, f: Eh, H: Bh, I: Ch, j: Dh, L: ed, m: Fh, M: Gh, p: function(r4) {
        return t3[+(r4.getUTCHours() >= 12)];
      }, Q: gd, s: hd, S: Hh, u: Ih, U: Jh, V: Kh, w: Lh, W: Mh, x: null, X: null, y: Nh, Y: Oh, Z: Ph, "%": fd}, g3 = {a: function(r4, $4, e4) {
        var a4 = c3.exec($4.slice(e4));
        return a4 ? (r4.w = f3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, A: function(r4, $4, e4) {
        var a4 = H3.exec($4.slice(e4));
        return a4 ? (r4.w = v3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, b: function(r4, $4, e4) {
        var a4 = l3.exec($4.slice(e4));
        return a4 ? (r4.m = d3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, B: function(r4, $4, e4) {
        var a4 = m3.exec($4.slice(e4));
        return a4 ? (r4.m = s3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, c: function(r4, e4, a4) {
        return h3(r4, $3, e4, a4);
      }, d: _c, e: _c, f: ih, H: ad, I: ad, j: eh, L: hh, m: dh, M: fh, p: function(r4, $4, e4) {
        var a4 = b3.exec($4.slice(e4));
        return a4 ? (r4.p = i3[a4[0].toLowerCase()], e4 + a4[0].length) : -1;
      }, Q: kh, s: lh, S: gh, u: Yg, U: Zg, V: $g, w: Xg, W: _g, x: function(r4, $4, a4) {
        return h3(r4, e3, $4, a4);
      }, X: function(r4, $4, e4) {
        return h3(r4, a3, $4, e4);
      }, y: bh, Y: ah, Z: ch, "%": jh};
      function T3(r4, $4) {
        return function(e4) {
          var a4, t4, U4, n4 = [], o4 = -1, u4 = 0, b4 = r4.length;
          for (e4 instanceof Date || (e4 = new Date(+e4)); ++o4 < b4; )
            r4.charCodeAt(o4) === 37 && (n4.push(r4.slice(u4, o4)), (t4 = $c[a4 = r4.charAt(++o4)]) != null ? a4 = r4.charAt(++o4) : t4 = a4 === "e" ? " " : "0", (U4 = $4[a4]) && (a4 = U4(e4, t4)), n4.push(a4), u4 = o4 + 1);
          return n4.push(r4.slice(u4, o4)), n4.join("");
        };
      }
      function M3(r4, $4) {
        return function(e4) {
          var a4, t4, U4 = ba(1900);
          if (h3(U4, r4, e4 += "", 0) != e4.length)
            return null;
          if ("Q" in U4)
            return new Date(U4.Q);
          if ("p" in U4 && (U4.H = U4.H % 12 + 12 * U4.p), "V" in U4) {
            if (U4.V < 1 || U4.V > 53)
              return null;
            "w" in U4 || (U4.w = 1), "Z" in U4 ? (t4 = (a4 = Ea(ba(U4.y))).getUTCDay(), a4 = t4 > 4 || t4 === 0 ? Ca.ceil(a4) : Ca(a4), a4 = ub.offset(a4, 7 * (U4.V - 1)), U4.y = a4.getUTCFullYear(), U4.m = a4.getUTCMonth(), U4.d = a4.getUTCDate() + (U4.w + 6) % 7) : (t4 = (a4 = $4(ba(U4.y))).getDay(), a4 = t4 > 4 || t4 === 0 ? Aa.ceil(a4) : Aa(a4), a4 = za.offset(a4, 7 * (U4.V - 1)), U4.y = a4.getFullYear(), U4.m = a4.getMonth(), U4.d = a4.getDate() + (U4.w + 6) % 7);
          } else
            ("W" in U4 || "U" in U4) && ("w" in U4 || (U4.w = "u" in U4 ? U4.u % 7 : "W" in U4 ? 1 : 0), t4 = "Z" in U4 ? Ea(ba(U4.y)).getUTCDay() : $4(ba(U4.y)).getDay(), U4.m = 0, U4.d = "W" in U4 ? (U4.w + 6) % 7 + 7 * U4.W - (t4 + 5) % 7 : U4.w + 7 * U4.U - (t4 + 6) % 7);
          return "Z" in U4 ? (U4.H += U4.Z / 100 | 0, U4.M += U4.Z % 100, Ea(U4)) : $4(U4);
        };
      }
      function h3(r4, $4, e4, a4) {
        for (var t4, U4, n4 = 0, o4 = $4.length, u4 = e4.length; n4 < o4; ) {
          if (a4 >= u4)
            return -1;
          if ((t4 = $4.charCodeAt(n4++)) === 37) {
            if (t4 = $4.charAt(n4++), !(U4 = g3[t4 in $c ? $4.charAt(n4++) : t4]) || (a4 = U4(r4, e4, a4)) < 0)
              return -1;
          } else if (t4 != e4.charCodeAt(a4++))
            return -1;
        }
        return a4;
      }
      return p3.x = T3(e3, p3), p3.X = T3(a3, p3), p3.c = T3($3, p3), y3.x = T3(e3, y3), y3.X = T3(a3, y3), y3.c = T3($3, y3), {format: function(r4) {
        var $4 = T3(r4 += "", p3);
        return $4.toString = function() {
          return r4;
        }, $4;
      }, parse: function(r4) {
        var $4 = M3(r4 += "", Sg);
        return $4.toString = function() {
          return r4;
        }, $4;
      }, utcFormat: function(r4) {
        var $4 = T3(r4 += "", y3);
        return $4.toString = function() {
          return r4;
        }, $4;
      }, utcParse: function(r4) {
        var $4 = M3(r4, Ea);
        return $4.toString = function() {
          return r4;
        }, $4;
      }};
    }
    var $c = {"-": "", _: " ", 0: "0"}, h2 = /^\s*\d+/, Ug = /^%/, Vg = /[\\^$*+?|[\]().{}]/g;
    function a2(r3, $3, e3) {
      var a3 = r3 < 0 ? "-" : "", t3 = (a3 ? -r3 : r3) + "", U3 = t3.length;
      return a3 + (U3 < e3 ? new Array(e3 - U3 + 1).join($3) + t3 : t3);
    }
    function Wg(r3) {
      return r3.replace(Vg, "\\$&");
    }
    function ca(r3) {
      return new RegExp("^(?:" + r3.map(Wg).join("|") + ")", "i");
    }
    function da(r3) {
      for (var $3 = {}, e3 = -1, a3 = r3.length; ++e3 < a3; )
        $3[r3[e3].toLowerCase()] = e3;
      return $3;
    }
    function Xg(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 1));
      return a3 ? (r3.w = +a3[0], e3 + a3[0].length) : -1;
    }
    function Yg(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 1));
      return a3 ? (r3.u = +a3[0], e3 + a3[0].length) : -1;
    }
    function Zg(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.U = +a3[0], e3 + a3[0].length) : -1;
    }
    function $g(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.V = +a3[0], e3 + a3[0].length) : -1;
    }
    function _g(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.W = +a3[0], e3 + a3[0].length) : -1;
    }
    function ah(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 4));
      return a3 ? (r3.y = +a3[0], e3 + a3[0].length) : -1;
    }
    function bh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.y = +a3[0] + (+a3[0] > 68 ? 1900 : 2e3), e3 + a3[0].length) : -1;
    }
    function ch(r3, $3, e3) {
      var a3 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec($3.slice(e3, e3 + 6));
      return a3 ? (r3.Z = a3[1] ? 0 : -(a3[2] + (a3[3] || "00")), e3 + a3[0].length) : -1;
    }
    function dh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.m = a3[0] - 1, e3 + a3[0].length) : -1;
    }
    function _c(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.d = +a3[0], e3 + a3[0].length) : -1;
    }
    function eh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 3));
      return a3 ? (r3.m = 0, r3.d = +a3[0], e3 + a3[0].length) : -1;
    }
    function ad(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.H = +a3[0], e3 + a3[0].length) : -1;
    }
    function fh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.M = +a3[0], e3 + a3[0].length) : -1;
    }
    function gh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 2));
      return a3 ? (r3.S = +a3[0], e3 + a3[0].length) : -1;
    }
    function hh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 3));
      return a3 ? (r3.L = +a3[0], e3 + a3[0].length) : -1;
    }
    function ih(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3, e3 + 6));
      return a3 ? (r3.L = Math.floor(a3[0] / 1e3), e3 + a3[0].length) : -1;
    }
    function jh(r3, $3, e3) {
      var a3 = Ug.exec($3.slice(e3, e3 + 1));
      return a3 ? e3 + a3[0].length : -1;
    }
    function kh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3));
      return a3 ? (r3.Q = +a3[0], e3 + a3[0].length) : -1;
    }
    function lh(r3, $3, e3) {
      var a3 = h2.exec($3.slice(e3));
      return a3 ? (r3.Q = 1e3 * +a3[0], e3 + a3[0].length) : -1;
    }
    function bd(r3, $3) {
      return a2(r3.getDate(), $3, 2);
    }
    function mh(r3, $3) {
      return a2(r3.getHours(), $3, 2);
    }
    function nh(r3, $3) {
      return a2(r3.getHours() % 12 || 12, $3, 2);
    }
    function oh(r3, $3) {
      return a2(1 + za.count(o2(r3), r3), $3, 3);
    }
    function cd(r3, $3) {
      return a2(r3.getMilliseconds(), $3, 3);
    }
    function ph(r3, $3) {
      return cd(r3, $3) + "000";
    }
    function qh(r3, $3) {
      return a2(r3.getMonth() + 1, $3, 2);
    }
    function rh(r3, $3) {
      return a2(r3.getMinutes(), $3, 2);
    }
    function sh(r3, $3) {
      return a2(r3.getSeconds(), $3, 2);
    }
    function th(r3) {
      var $3 = r3.getDay();
      return $3 === 0 ? 7 : $3;
    }
    function uh(r3, $3) {
      return a2(tb.count(o2(r3), r3), $3, 2);
    }
    function vh(r3, $3) {
      var e3 = r3.getDay();
      return r3 = e3 >= 4 || e3 === 0 ? Ba(r3) : Ba.ceil(r3), a2(Ba.count(o2(r3), r3) + (o2(r3).getDay() === 4), $3, 2);
    }
    function wh(r3) {
      return r3.getDay();
    }
    function xh(r3, $3) {
      return a2(Aa.count(o2(r3), r3), $3, 2);
    }
    function yh(r3, $3) {
      return a2(r3.getFullYear() % 100, $3, 2);
    }
    function zh(r3, $3) {
      return a2(r3.getFullYear() % 1e4, $3, 4);
    }
    function Ah(r3) {
      var $3 = r3.getTimezoneOffset();
      return ($3 > 0 ? "-" : ($3 *= -1, "+")) + a2($3 / 60 | 0, "0", 2) + a2($3 % 60, "0", 2);
    }
    function dd(r3, $3) {
      return a2(r3.getUTCDate(), $3, 2);
    }
    function Bh(r3, $3) {
      return a2(r3.getUTCHours(), $3, 2);
    }
    function Ch(r3, $3) {
      return a2(r3.getUTCHours() % 12 || 12, $3, 2);
    }
    function Dh(r3, $3) {
      return a2(1 + ub.count(F2(r3), r3), $3, 3);
    }
    function ed(r3, $3) {
      return a2(r3.getUTCMilliseconds(), $3, 3);
    }
    function Eh(r3, $3) {
      return ed(r3, $3) + "000";
    }
    function Fh(r3, $3) {
      return a2(r3.getUTCMonth() + 1, $3, 2);
    }
    function Gh(r3, $3) {
      return a2(r3.getUTCMinutes(), $3, 2);
    }
    function Hh(r3, $3) {
      return a2(r3.getUTCSeconds(), $3, 2);
    }
    function Ih(r3) {
      var $3 = r3.getUTCDay();
      return $3 === 0 ? 7 : $3;
    }
    function Jh(r3, $3) {
      return a2(Zc.count(F2(r3), r3), $3, 2);
    }
    function Kh(r3, $3) {
      var e3 = r3.getUTCDay();
      return r3 = e3 >= 4 || e3 === 0 ? Da(r3) : Da.ceil(r3), a2(Da.count(F2(r3), r3) + (F2(r3).getUTCDay() === 4), $3, 2);
    }
    function Lh(r3) {
      return r3.getUTCDay();
    }
    function Mh(r3, $3) {
      return a2(Ca.count(F2(r3), r3), $3, 2);
    }
    function Nh(r3, $3) {
      return a2(r3.getUTCFullYear() % 100, $3, 2);
    }
    function Oh(r3, $3) {
      return a2(r3.getUTCFullYear() % 1e4, $3, 4);
    }
    function Ph() {
      return "+0000";
    }
    function fd() {
      return "%";
    }
    function gd(r3) {
      return +r3;
    }
    function hd(r3) {
      return Math.floor(+r3 / 1e3);
    }
    Rg({dateTime: "%x, %X", date: "%-m/%-d/%Y", time: "%-I:%M:%S %p", periods: ["AM", "PM"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]});
    var id = "%Y-%m-%dT%H:%M:%S.%LZ";
    function Qh($3) {
      return $3.toISOString();
    }
    var Pi = Date.prototype.toISOString ? Qh : Pg(id);
    function Rh(e3) {
      var $3 = new Date(e3);
      return isNaN($3) ? null : $3;
    }
    var Qi = +new Date("2000-01-01T00:00:00.000Z") ? Rh : Qg(id);
    var Sh = function(e3, t3) {
      var $3, r3 = 0, M3 = (e3 = e3.slice()).length - 1, l3 = e3[r3], o3 = e3[M3];
      return o3 < l3 && ($3 = r3, r3 = M3, M3 = $3, $3 = l3, l3 = o3, o3 = $3), e3[r3] = t3.floor(l3), e3[M3] = t3.ceil(o3), e3;
    };
    var ea = 1e3, fa = 60 * ea, ga = 60 * fa, ha = 24 * ga, Th = 7 * ha, jd = 30 * ha, vb = 365 * ha;
    function Uh(t3) {
      return new Date(t3);
    }
    function Vh(t3) {
      return t3 instanceof Date ? +t3 : +new Date(+t3);
    }
    function kd(t3, $3, r3, a3, n3, e3, i3, o3, u3) {
      var k3 = Bc(z2, z2), V3 = k3.invert, X3 = k3.domain, d3 = u3(".%L"), v3 = u3(":%S"), c3 = u3("%I:%M"), p3 = u3("%I %p"), m3 = u3("%a %d"), l3 = u3("%b %d"), f3 = u3("%B"), y3 = u3("%Y"), M3 = [[i3, 1, ea], [i3, 5, 5 * ea], [i3, 15, 15 * ea], [i3, 30, 30 * ea], [e3, 1, fa], [e3, 5, 5 * fa], [e3, 15, 15 * fa], [e3, 30, 30 * fa], [n3, 1, ga], [n3, 3, 3 * ga], [n3, 6, 6 * ga], [n3, 12, 12 * ga], [a3, 1, ha], [a3, 2, 2 * ha], [r3, 1, Th], [$3, 1, jd], [$3, 3, 3 * jd], [t3, 1, vb]];
      function D3(o4) {
        return (i3(o4) < o4 ? d3 : e3(o4) < o4 ? v3 : n3(o4) < o4 ? c3 : a3(o4) < o4 ? p3 : $3(o4) < o4 ? r3(o4) < o4 ? m3 : l3 : t3(o4) < o4 ? f3 : y3)(o4);
      }
      function h3($4, r4, a4) {
        if ($4 == null && ($4 = 10), typeof $4 == "number") {
          var n4, e4 = Math.abs(a4 - r4) / $4, i4 = Pb(function(t4) {
            return t4[2];
          }).right(M3, e4);
          return i4 === M3.length ? (n4 = Ma(r4 / vb, a4 / vb, $4), $4 = t3) : i4 ? (n4 = (i4 = M3[e4 / M3[i4 - 1][2] < M3[i4][2] / e4 ? i4 - 1 : i4])[1], $4 = i4[0]) : (n4 = Math.max(Ma(r4, a4, $4), 1), $4 = o3), $4.every(n4);
        }
        return $4;
      }
      return k3.invert = function(t4) {
        return new Date(V3(t4));
      }, k3.domain = function(t4) {
        return arguments.length ? X3(Array.from(t4, Vh)) : X3().map(Uh);
      }, k3.ticks = function(t4) {
        var $4, r4 = X3(), a4 = r4[0], n4 = r4[r4.length - 1], e4 = n4 < a4;
        return e4 && ($4 = a4, a4 = n4, n4 = $4), $4 = ($4 = h3(t4, a4, n4)) ? $4.range(a4, n4 + 1) : [], e4 ? $4.reverse() : $4;
      }, k3.tickFormat = function(t4, $4) {
        return $4 == null ? D3 : u3($4);
      }, k3.nice = function(t4) {
        var $4 = X3();
        return (t4 = h3(t4, $4[0], $4[$4.length - 1])) ? X3(Sh($4, t4)) : k3;
      }, k3.copy = function() {
        return Ac(k3, kd(t3, $3, r3, a3, n3, e3, i3, o3, u3));
      }, k3;
    }
    var Wh = function() {
      return la.apply(kd(o2, Yc, tb, za, Xc, Wc, Vc, wa, Og).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
    };
    var Fa = {};
    !function(t3, n3) {
      typeof Fa == "object" ? Fa = n3() : typeof define == "function" && define.amd ? define(n3) : t3.dayjs = n3();
    }(Fa, function() {
      var t3 = "millisecond", n3 = "second", e3 = "minute", r3 = "hour", i3 = "day", s3 = "week", u3 = "month", a3 = "quarter", o3 = "year", h3 = /^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/, f3 = /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, c3 = function(t4, n4, e4) {
        var r4 = String(t4);
        return !r4 || r4.length >= n4 ? t4 : "" + Array(n4 + 1 - r4.length).join(e4) + t4;
      }, d3 = {s: c3, z: function(t4) {
        var n4 = -t4.utcOffset(), e4 = Math.abs(n4), r4 = Math.floor(e4 / 60), i4 = e4 % 60;
        return (n4 <= 0 ? "+" : "-") + c3(r4, 2, "0") + ":" + c3(i4, 2, "0");
      }, m: function(t4, n4) {
        var e4 = 12 * (n4.year() - t4.year()) + (n4.month() - t4.month()), r4 = t4.clone().add(e4, u3), i4 = n4 - r4 < 0, s4 = t4.clone().add(e4 + (i4 ? -1 : 1), u3);
        return Number(-(e4 + (n4 - r4) / (i4 ? r4 - s4 : s4 - r4)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(h4) {
        return {M: u3, y: o3, w: s3, d: i3, h: r3, m: e3, s: n3, ms: t3, Q: a3}[h4] || String(h4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return t4 === void 0;
      }}, $3 = {name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")}, l3 = "en", m3 = {};
      m3[l3] = $3;
      var y3 = function(t4) {
        return t4 instanceof v3;
      }, M3 = function(t4, n4, e4) {
        var r4;
        if (!t4)
          return l3;
        if (typeof t4 == "string")
          m3[t4] && (r4 = t4), n4 && (m3[t4] = n4, r4 = t4);
        else {
          var i4 = t4.name;
          m3[i4] = t4, r4 = i4;
        }
        return e4 || (l3 = r4), r4;
      }, g3 = function(t4, n4, e4) {
        if (y3(t4))
          return t4.clone();
        var r4 = n4 ? typeof n4 == "string" ? {format: n4, pl: e4} : n4 : {};
        return r4.date = t4, new v3(r4);
      }, D3 = d3;
      D3.l = M3, D3.i = y3, D3.w = function(t4, n4) {
        return g3(t4, {locale: n4.$L, utc: n4.$u});
      };
      var v3 = function() {
        function c4(t4) {
          this.$L = this.$L || M3(t4.locale, null, true), this.parse(t4);
        }
        var d4 = c4.prototype;
        return d4.parse = function(t4) {
          this.$d = function(t5) {
            var n4 = t5.date, e4 = t5.utc;
            if (n4 === null)
              return new Date(NaN);
            if (D3.u(n4))
              return new Date();
            if (n4 instanceof Date)
              return new Date(n4);
            if (typeof n4 == "string" && !/Z$/i.test(n4)) {
              var r4 = n4.match(h3);
              if (r4)
                return e4 ? new Date(Date.UTC(r4[1], r4[2] - 1, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, r4[7] || 0)) : new Date(r4[1], r4[2] - 1, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, r4[7] || 0);
            }
            return new Date(n4);
          }(t4), this.init();
        }, d4.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, d4.$utils = function() {
          return D3;
        }, d4.isValid = function() {
          return !(this.$d.toString() === "Invalid Date");
        }, d4.isSame = function(t4, n4) {
          var e4 = g3(t4);
          return this.startOf(n4) <= e4 && e4 <= this.endOf(n4);
        }, d4.isAfter = function(t4, n4) {
          return g3(t4) < this.startOf(n4);
        }, d4.isBefore = function(t4, n4) {
          return this.endOf(n4) < g3(t4);
        }, d4.$g = function(t4, n4, e4) {
          return D3.u(t4) ? this[n4] : this.set(e4, t4);
        }, d4.year = function(t4) {
          return this.$g(t4, "$y", o3);
        }, d4.month = function(t4) {
          return this.$g(t4, "$M", u3);
        }, d4.day = function(t4) {
          return this.$g(t4, "$W", i3);
        }, d4.date = function(t4) {
          return this.$g(t4, "$D", "date");
        }, d4.hour = function(t4) {
          return this.$g(t4, "$H", r3);
        }, d4.minute = function(t4) {
          return this.$g(t4, "$m", e3);
        }, d4.second = function(t4) {
          return this.$g(t4, "$s", n3);
        }, d4.millisecond = function(n4) {
          return this.$g(n4, "$ms", t3);
        }, d4.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, d4.valueOf = function() {
          return this.$d.getTime();
        }, d4.startOf = function(t4, a4) {
          var h4 = this, f4 = !!D3.u(a4) || a4, c5 = D3.p(t4), d5 = function(t5, n4) {
            var e4 = D3.w(h4.$u ? Date.UTC(h4.$y, n4, t5) : new Date(h4.$y, n4, t5), h4);
            return f4 ? e4 : e4.endOf(i3);
          }, $4 = function(t5, n4) {
            return D3.w(h4.toDate()[t5].apply(h4.toDate(), (f4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(n4)), h4);
          }, l4 = this.$W, m4 = this.$M, y4 = this.$D, M4 = "set" + (this.$u ? "UTC" : "");
          switch (c5) {
            case o3:
              return f4 ? d5(1, 0) : d5(31, 11);
            case u3:
              return f4 ? d5(1, m4) : d5(0, m4 + 1);
            case s3:
              var g4 = this.$locale().weekStart || 0, v4 = (l4 < g4 ? l4 + 7 : l4) - g4;
              return d5(f4 ? y4 - v4 : y4 + (6 - v4), m4);
            case i3:
            case "date":
              return $4(M4 + "Hours", 0);
            case r3:
              return $4(M4 + "Minutes", 1);
            case e3:
              return $4(M4 + "Seconds", 2);
            case n3:
              return $4(M4 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, d4.endOf = function(t4) {
          return this.startOf(t4, false);
        }, d4.$set = function(s4, a4) {
          var h4, f4 = D3.p(s4), c5 = "set" + (this.$u ? "UTC" : ""), d5 = (h4 = {}, h4[i3] = c5 + "Date", h4.date = c5 + "Date", h4[u3] = c5 + "Month", h4[o3] = c5 + "FullYear", h4[r3] = c5 + "Hours", h4[e3] = c5 + "Minutes", h4[n3] = c5 + "Seconds", h4[t3] = c5 + "Milliseconds", h4)[f4], $4 = f4 === i3 ? this.$D + (a4 - this.$W) : a4;
          if (f4 === u3 || f4 === o3) {
            var l4 = this.clone().set("date", 1);
            l4.$d[d5]($4), l4.init(), this.$d = l4.set("date", Math.min(this.$D, l4.daysInMonth())).toDate();
          } else
            d5 && this.$d[d5]($4);
          return this.init(), this;
        }, d4.set = function(t4, n4) {
          return this.clone().$set(t4, n4);
        }, d4.get = function(t4) {
          return this[D3.p(t4)]();
        }, d4.add = function(t4, a4) {
          var h4, f4 = this;
          t4 = Number(t4);
          var c5 = D3.p(a4), d5 = function(n4) {
            var e4 = g3(f4);
            return D3.w(e4.date(e4.date() + Math.round(n4 * t4)), f4);
          };
          if (c5 === u3)
            return this.set(u3, this.$M + t4);
          if (c5 === o3)
            return this.set(o3, this.$y + t4);
          if (c5 === i3)
            return d5(1);
          if (c5 === s3)
            return d5(7);
          var $4 = (h4 = {}, h4[e3] = 6e4, h4[r3] = 36e5, h4[n3] = 1e3, h4)[c5] || 1, l4 = this.valueOf() + t4 * $4;
          return D3.w(l4, this);
        }, d4.subtract = function(t4, n4) {
          return this.add(-1 * t4, n4);
        }, d4.format = function(t4) {
          var n4 = this;
          if (!this.isValid())
            return "Invalid Date";
          var e4 = t4 || "YYYY-MM-DDTHH:mm:ssZ", r4 = D3.z(this), i4 = this.$locale(), s4 = this.$H, u4 = this.$m, a4 = this.$M, o4 = i4.weekdays, h4 = i4.months, c5 = function(t5, r5, i5, s5) {
            return t5 && (t5[r5] || t5(n4, e4)) || i5[r5].substr(0, s5);
          }, d5 = function(t5) {
            return D3.s(s4 % 12 || 12, t5, "0");
          }, $4 = i4.meridiem || function(t5, n5, e5) {
            var r5 = t5 < 12 ? "AM" : "PM";
            return e5 ? r5.toLowerCase() : r5;
          }, l4 = {YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: D3.s(a4 + 1, 2, "0"), MMM: c5(i4.monthsShort, a4, h4, 3), MMMM: h4[a4] || h4(this, e4), D: this.$D, DD: D3.s(this.$D, 2, "0"), d: String(this.$W), dd: c5(i4.weekdaysMin, this.$W, o4, 2), ddd: c5(i4.weekdaysShort, this.$W, o4, 3), dddd: o4[this.$W], H: String(s4), HH: D3.s(s4, 2, "0"), h: d5(1), hh: d5(2), a: $4(s4, u4, true), A: $4(s4, u4, false), m: String(u4), mm: D3.s(u4, 2, "0"), s: String(this.$s), ss: D3.s(this.$s, 2, "0"), SSS: D3.s(this.$ms, 3, "0"), Z: r4};
          return e4.replace(f3, function(t5, n5) {
            return n5 || l4[t5] || r4.replace(":", "");
          });
        }, d4.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, d4.diff = function(t4, h4, f4) {
          var c5, d5 = D3.p(h4), $4 = g3(t4), l4 = 6e4 * ($4.utcOffset() - this.utcOffset()), m4 = this - $4, y4 = D3.m(this, $4);
          return y4 = (c5 = {}, c5[o3] = y4 / 12, c5[u3] = y4, c5[a3] = y4 / 3, c5[s3] = (m4 - l4) / 6048e5, c5[i3] = (m4 - l4) / 864e5, c5[r3] = m4 / 36e5, c5[e3] = m4 / 6e4, c5[n3] = m4 / 1e3, c5)[d5] || m4, f4 ? y4 : D3.a(y4);
        }, d4.daysInMonth = function() {
          return this.endOf(u3).$D;
        }, d4.$locale = function() {
          return m3[this.$L];
        }, d4.locale = function(t4, n4) {
          if (!t4)
            return this.$L;
          var e4 = this.clone();
          return e4.$L = M3(t4, n4, true), e4;
        }, d4.clone = function() {
          return D3.w(this.toDate(), this);
        }, d4.toDate = function() {
          return new Date(this.$d);
        }, d4.toJSON = function() {
          return this.toISOString();
        }, d4.toISOString = function() {
          return this.$d.toISOString();
        }, d4.toString = function() {
          return this.$d.toUTCString();
        }, c4;
      }();
      return g3.prototype = v3.prototype, g3.extend = function(t4, n4) {
        return t4(n4, v3, g3), g3;
      }, g3.locale = M3, g3.isDayjs = y3, g3.unix = function(t4) {
        return g3(1e3 * t4);
      }, g3.en = m3[l3], g3.Ls = m3, g3;
    });
    const u2 = {top: 50, right: 30, bottom: 50, left: 50};
    class Xh {
      constructor(t3, {title: o3, xLabel: i3, yLabel: e3, data: {datasets: r3}, options: s3}) {
        this.options = Bg({unxkcdify: false, dotSize: 1, showLine: false, timeFormat: "", xTickCount: 3, yTickCount: 3, legendPosition: b2.positionType.upLeft, dataColors: O2, fontFamily: "xkcd", strokeColor: "black", backgroundColor: "white", showLegend: true}, s3), o3 && (this.title = o3, u2.top = 60), i3 && (this.xLabel = i3, u2.bottom = 50), e3 && (this.yLabel = e3, u2.left = 70), this.data = {datasets: r3}, this.filter = "url(#xkcdify)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", 3).style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.chart = this.svgEl.append("g").attr("transform", `translate(${u2.left},${u2.top})`), this.width = this.svgEl.attr("width") - u2.left - u2.right, this.height = this.svgEl.attr("height") - u2.top - u2.bottom, M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor), this.xLabel && k2.xLabel(this.svgEl, this.xLabel, this.options.strokeColor), this.yLabel && k2.yLabel(this.svgEl, this.yLabel, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "", items: [{color: "red", text: "weweyang"}, {color: "blue", text: "timqian"}], position: {x: 60, y: 60, type: b2.positionType.dowfnRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        this.options.timeFormat && this.data.datasets.forEach((t4) => {
          t4.data.forEach((t5) => {
            var $dZYI$$interop$default = wb(Fa);
            t5.x = $dZYI$$interop$default.d(t5.x);
          });
        });
        const o3 = this.data.datasets.reduce((t4, o4) => t4.concat(o4.data), []), i3 = o3.map((t4) => t4.x), e3 = o3.map((t4) => t4.y);
        let r3 = A2().domain([Math.min(...i3), Math.max(...i3)]).range([0, this.width]);
        this.options.timeFormat && (r3 = Wh().domain([Math.min(...i3), Math.max(...i3)]).range([0, this.width]));
        const s3 = A2().domain([Math.min(...e3), Math.max(...e3)]).range([this.height, 0]), a3 = this.chart.append("g").attr("pointer-events", "all");
        if (y2.xAxis(a3, {xScale: r3, tickCount: this.options.xTickCount === void 0 ? 3 : this.options.xTickCount, moveDown: this.height, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), y2.yAxis(a3, {yScale: s3, tickCount: this.options.yTickCount === void 0 ? 3 : this.options.yTickCount, fontFamily: this.fontFamily, unxkcdify: this.options.unxkcdify, stroke: this.options.strokeColor}), this.options.showLine) {
          const t4 = pb().x((t5) => r3(t5.x)).y((t5) => s3(t5.y)).curve(Rc);
          a3.selectAll(".xkcd-chart-xyline").data(this.data.datasets).enter().append("path").attr("class", "xkcd-chart-xyline").attr("d", (o4) => t4(o4.data)).attr("fill", "none").attr("stroke", (t5, o4) => this.options.dataColors[o4]).attr("filter", this.filter);
        }
        const n3 = 3.5 * (this.options.dotSize === void 0 ? 1 : this.options.dotSize), l3 = 6 * (this.options.dotSize === void 0 ? 1 : this.options.dotSize);
        if (a3.selectAll(".xkcd-chart-xycircle-group").data(this.data.datasets).enter().append("g").attr("class", ".xkcd-chart-xycircle-group").attr("filter", this.filter).attr("xy-group-index", (t4, o4) => o4).selectAll(".xkcd-chart-xycircle-circle").data((t4) => t4.data).enter().append("circle").style("stroke", (t4, o4, i4) => {
          const e4 = Number(f2(i4[o4].parentElement).attr("xy-group-index"));
          return this.options.dataColors[e4];
        }).style("fill", (t4, o4, i4) => {
          const e4 = Number(f2(i4[o4].parentElement).attr("xy-group-index"));
          return this.options.dataColors[e4];
        }).attr("r", n3).attr("cx", (t4) => r3(t4.x)).attr("cy", (t4) => s3(t4.y)).attr("pointer-events", "all").on("mouseover", (o4, i4, e4) => {
          const a4 = Number(f2(e4[i4].parentElement).attr("xy-group-index"));
          f2(e4[i4]).attr("r", l3);
          const n4 = r3(o4.x) + u2.left + 5, $3 = s3(o4.y) + u2.top + 5;
          let p3 = b2.positionType.downRight;
          var $dZYI$$interop$default = wb(Fa);
          n4 > this.width / 2 && $3 < this.height / 2 ? p3 = b2.positionType.downLeft : n4 > this.width / 2 && $3 > this.height / 2 ? p3 = b2.positionType.upLeft : n4 < this.width / 2 && $3 > this.height / 2 && (p3 = b2.positionType.upRight), t3.update({title: this.options.timeFormat ? $dZYI$$interop$default.d(this.data.datasets[a4].data[i4].x).format(this.options.timeFormat) : `${this.data.datasets[a4].data[i4].x}`, items: [{color: this.options.dataColors[a4], text: `${this.data.datasets[a4].label || ""}: ${o4.y}`}], position: {x: n4, y: $3, type: p3}}), t3.show();
        }).on("mouseout", (o4, i4, e4) => {
          f2(e4[i4]).attr("r", n3), t3.hide();
        }), this.options.showLegend) {
          const t4 = this.data.datasets.map((t5, o4) => ({color: this.options.dataColors[o4], text: t5.label}));
          Z2(a3, {items: t4, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor});
        }
      }
      update() {
      }
    }
    function ld(t3, e3) {
      var a3 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var r3 = Object.getOwnPropertySymbols(t3);
        e3 && (r3 = r3.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), a3.push.apply(a3, r3);
      }
      return a3;
    }
    function Yh(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var a3 = arguments[e3] != null ? arguments[e3] : {};
        e3 % 2 ? ld(a3, true).forEach(function(e4) {
          Zh(t3, e4, a3[e4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(a3)) : ld(a3).forEach(function(e4) {
          Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(a3, e4));
        });
      }
      return t3;
    }
    function Zh(t3, e3, a3) {
      return e3 in t3 ? Object.defineProperty(t3, e3, {value: a3, enumerable: true, configurable: true, writable: true}) : t3[e3] = a3, t3;
    }
    function md(t3) {
      this._context = t3;
    }
    var nd = function() {
    };
    md.prototype = {areaStart: nd, areaEnd: nd, lineStart: function() {
      this._point = 0;
    }, lineEnd: function() {
      this._point && this._context.closePath();
    }, point: function(t3, o3) {
      t3 = +t3, o3 = +o3, this._point ? this._context.lineTo(t3, o3) : (this._point = 1, this._context.moveTo(t3, o3));
    }};
    var $h = function(t3) {
      return new md(t3);
    };
    const _h = 50, Ga = -Math.PI / 2, ai = 0.2;
    class bi {
      constructor(t3, {title: e3, data: {labels: a3, datasets: r3}, options: i3}) {
        this.options = Yh({showLabels: false, ticksCount: 3, showLegend: false, legendPosition: b2.positionType.upLeft, dataColors: O2, fontFamily: "xkcd", dotSize: 1, strokeColor: "black", backgroundColor: "white"}, i3), this.title = e3, this.data = {labels: a3, datasets: r3}, this.directionsCount = r3[0].data.length, this.filter = "url(#xkcdify-pie)", this.fontFamily = this.options.fontFamily || "xkcd", this.options.unxkcdify && (this.filter = null, this.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'), this.svgEl = f2(t3).style("stroke-width", "3").style("font-family", this.fontFamily).style("background", this.options.backgroundColor).attr("width", t3.parentElement.clientWidth).attr("height", Math.min(2 * t3.parentElement.clientWidth / 3, window.innerHeight)), this.svgEl.selectAll("*").remove(), this.width = this.svgEl.attr("width"), this.height = this.svgEl.attr("height"), this.chart = this.svgEl.append("g").attr("transform", `translate(${this.width / 2},${this.height / 2})`), M2(this.svgEl), N2(this.svgEl), this.render();
      }
      render() {
        this.title && k2.title(this.svgEl, this.title, this.options.strokeColor);
        const t3 = new L4({parent: this.svgEl, title: "", items: [], position: {x: 0, y: 0, type: b2.positionType.downRight}, unxkcdify: this.options.unxkcdify, strokeColor: this.options.strokeColor, backgroundColor: this.options.backgroundColor}), e3 = 3.5 * (this.options.dotSize || 1), a3 = 6 * (this.options.dotSize || 1), r3 = Math.min(this.width, this.height) / 2 - _h, i3 = 2 * Math.PI / this.directionsCount, o3 = this.data.datasets.reduce((t4, e4) => t4.concat(e4.data), []), s3 = Math.max(...o3), n3 = Array(this.directionsCount).fill(s3), l3 = A2().domain([0, s3]).range([0, r3]), h3 = (t4, e4) => l3(t4) * Math.cos(i3 * e4 + Ga), d3 = (t4, e4) => l3(t4) * Math.sin(i3 * e4 + Ga), c3 = pb().x(h3).y(d3).curve($h), p3 = l3.ticks(this.options.ticksCount || 3), $3 = this.chart.append("g").attr("class", "xkcd-chart-radar-grid").attr("stroke-width", "1").attr("filter", this.filter);
        $3.selectAll(".xkcd-chart-radar-level").data(p3).enter().append("path").attr("class", "xkcd-chart-radar-level").attr("d", (t4) => c3(Array(this.directionsCount).fill(t4))).style("fill", "none").attr("stroke", this.options.strokeColor).attr("stroke-dasharray", "7,7"), $3.selectAll(".xkcd-chart-radar-line").data(n3).enter().append("line").attr("class", ".xkcd-chart-radar-line").attr("stroke", this.options.strokeColor).attr("x1", 0).attr("y1", 0).attr("x2", h3).attr("y2", d3), $3.selectAll(".xkcd-chart-radar-tick").data(p3).enter().append("text").attr("class", "xkcd-chart-radar-tick").attr("x", (t4) => h3(t4, 0)).attr("y", (t4) => d3(t4, 0)).style("font-size", "16").style("fill", this.options.strokeColor).attr("text-anchor", "end").attr("dx", "-.125em").attr("dy", ".35em").text((t4) => t4), this.options.showLabels && $3.selectAll(".xkcd-chart-radar-label").data(n3.map((t4) => 1.15 * t4)).enter().append("text").attr("class", "xkcd-chart-radar-label").style("font-size", "16").style("fill", this.options.strokeColor).attr("x", (t4, e4) => (r3 + 10) * Math.cos(i3 * e4 + Ga)).attr("y", (t4, e4) => (r3 + 10) * Math.sin(i3 * e4 + Ga)).attr("dy", ".35em").attr("text-anchor", (t4, e4, a4) => {
          let r4 = "start";
          return f2(a4[e4]).attr("x") < 0 && (r4 = "end"), r4;
        }).text((t4, e4) => this.data.labels[e4]);
        const g3 = this.chart.selectAll(".xkcd-chart-radar-group").data(this.data.datasets).enter().append("g").attr("class", "xkcd-chart-radar-group").attr("filter", this.filter).attr("stroke", (t4, e4) => this.options.dataColors[e4]).attr("fill", (t4, e4) => this.options.dataColors[e4]);
        if (g3.selectAll("circle").data((t4) => t4.data).enter().append("circle").attr("r", e3).attr("cx", h3).attr("cy", d3).attr("pointer-events", "all").on("mouseover", (e4, r4, i4) => {
          f2(i4[r4]).attr("r", a3);
          const o4 = h3(e4, r4) + this.width / 2, s4 = d3(e4, r4) + this.height / 2;
          let n4 = b2.positionType.downRight;
          o4 > this.width / 2 && s4 < this.height / 2 ? n4 = b2.positionType.downLeft : o4 > this.width / 2 && s4 > this.height / 2 ? n4 = b2.positionType.upLeft : o4 < this.width / 2 && s4 > this.height / 2 && (n4 = b2.positionType.upRight), t3.update({title: this.data.labels[r4], items: this.data.datasets.map((t4, e5) => ({color: this.options.dataColors[e5], text: `${t4.label || ""}: ${t4.data[r4]}`})), position: {x: o4, y: s4, type: n4}}), t3.show();
        }).on("mouseout", (a4, r4, i4) => {
          f2(i4[r4]).attr("r", e3), t3.hide();
        }), g3.selectAll("path").data((t4) => [t4.data]).enter().append("path").attr("d", c3).attr("pointer-events", "none").style("fill-opacity", ai), this.options.showLegend) {
          const t4 = this.data.datasets.map((t5, e5) => ({color: this.options.dataColors[e5], text: t5.label || ""})), e4 = this.svgEl.append("g").attr("transform", "translate(0, 30)");
          Z2(e4, {items: t4, position: this.options.legendPosition, unxkcdify: this.options.unxkcdify, parentWidth: this.width, parentHeight: this.height, backgroundColor: this.options.backgroundColor, strokeColor: this.options.strokeColor});
        }
      }
      update() {
      }
    }
    xb = {config: b2, Bar: ag, StackedBar: dg, Pie: ug, Line: Ag, XY: Xh, Radar: bi};
    if (typeof exports2 === "object" && typeof module2 !== "undefined") {
      module2.exports = xb;
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return xb;
      });
    }
  })();
});

// node_modules/chart.xkcd-react/build/index.js
var require_build = __commonJS((exports2, module2) => {
  !function(e2, t2) {
    if (typeof exports2 === "object" && typeof module2 === "object")
      module2.exports = t2(require("react"), require_dist());
    else if (typeof define === "function" && define.amd)
      define(["react", "chart.xkcd"], t2);
    else {
      var r2 = typeof exports2 === "object" ? t2(require("react"), require_dist()) : t2(e2.react, e2["chart.xkcd"]);
      for (var n2 in r2)
        (typeof exports2 === "object" ? exports2 : e2)[n2] = r2[n2];
    }
  }(window, function(e2, t2) {
    return function(e3) {
      var t3 = {};
      function r2(n2) {
        if (t3[n2])
          return t3[n2].exports;
        var c2 = t3[n2] = {i: n2, l: false, exports: {}};
        return e3[n2].call(c2.exports, c2, c2.exports, r2), c2.l = true, c2.exports;
      }
      return r2.m = e3, r2.c = t3, r2.d = function(e4, t4, n2) {
        r2.o(e4, t4) || Object.defineProperty(e4, t4, {enumerable: true, get: n2});
      }, r2.r = function(e4) {
        typeof Symbol !== "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e4, "__esModule", {value: true});
      }, r2.t = function(e4, t4) {
        if (1 & t4 && (e4 = r2(e4)), 8 & t4)
          return e4;
        if (4 & t4 && typeof e4 === "object" && e4 && e4.__esModule)
          return e4;
        var n2 = Object.create(null);
        if (r2.r(n2), Object.defineProperty(n2, "default", {enumerable: true, value: e4}), 2 & t4 && typeof e4 != "string")
          for (var c2 in e4)
            r2.d(n2, c2, function(t5) {
              return e4[t5];
            }.bind(null, c2));
        return n2;
      }, r2.n = function(e4) {
        var t4 = e4 && e4.__esModule ? function() {
          return e4.default;
        } : function() {
          return e4;
        };
        return r2.d(t4, "a", t4), t4;
      }, r2.o = function(e4, t4) {
        return Object.prototype.hasOwnProperty.call(e4, t4);
      }, r2.p = "/obiwankenoobi/chart.xkcd-react/", r2(r2.s = 2);
    }([function(t3, r2) {
      t3.exports = e2;
    }, function(e3, r2) {
      e3.exports = t2;
    }, function(e3, t3, r2) {
      e3.exports = r2(3);
    }, function(e3, t3, r2) {
      "use strict";
      r2.r(t3);
      var n2 = r2(1), c2 = r2.n(n2), u2 = r2(0), o2 = r2.n(u2), f2 = function(e4) {
        var t4 = e4.config, r3 = Object(u2.useRef)();
        return Object(u2.useEffect)(function() {
          r3.current && new c2.a.Bar(r3.current, t4);
        }), o2.a.createElement("svg", {ref: r3});
      }, i2 = function(e4) {
        var t4 = e4.config, r3 = Object(u2.useRef)();
        return Object(u2.useEffect)(function() {
          r3.current && new c2.a.Pie(r3.current, t4);
        }), o2.a.createElement("svg", {ref: r3});
      }, a2 = function(e4) {
        var t4 = e4.config, r3 = Object(u2.useRef)();
        return Object(u2.useEffect)(function() {
          r3.current && new c2.a.Line(r3.current, t4);
        }), o2.a.createElement("svg", {ref: r3});
      }, s2 = function(e4) {
        var t4 = e4.config, r3 = Object(u2.useRef)();
        return Object(u2.useEffect)(function() {
          r3.current && new c2.a.XY(r3.current, t4);
        }), o2.a.createElement("svg", {ref: r3});
      }, d2 = function(e4) {
        var t4 = e4.config, r3 = Object(u2.useRef)();
        return Object(u2.useEffect)(function() {
          r3.current && new c2.a.Radar(r3.current, t4);
        }), o2.a.createElement("svg", {ref: r3});
      };
      r2.d(t3, "Bar", function() {
        return f2;
      }), r2.d(t3, "Pie", function() {
        return i2;
      }), r2.d(t3, "Line", function() {
        return a2;
      }), r2.d(t3, "XY", function() {
        return s2;
      }), r2.d(t3, "Radar", function() {
        return d2;
      });
    }]);
  });
});

// src/chart.xkcd/chart-xkcd.tsx
var require_chart_xkcd = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    BarChartDescription: () => BarChartDescription,
    LineChartDescription: () => LineChartDescription,
    PieChartDescription: () => PieChartDescription,
    RadarChartDescription: () => RadarChartDescription,
    StackedBarChartDescription: () => StackedBarChartDescription,
    XYChartDescription: () => XYChartDescription
  });
  var import_chart = __toModule(require_dist());
  var import_chart2 = __toModule(require_build());
  var import_react20 = __toModule(require("react"));
  var PositionType;
  (function(PositionType2) {
    PositionType2[PositionType2["upLeft"] = 1] = "upLeft";
    PositionType2[PositionType2["upRight"] = 2] = "upRight";
    PositionType2[PositionType2["downLeft"] = 3] = "downLeft";
    PositionType2[PositionType2["downRight"] = 4] = "downRight";
  })(PositionType || (PositionType = {}));
  function LineChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      legendPosition,
      showLegend,
      strokeColor,
      backgroundColor,
      unkcdify,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Line, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          legendPosition,
          showLegend,
          strokeColor,
          backgroundColor,
          unkcdify,
          fontFamily
        }
      }
    });
  }
  var LineChartDescription = {
    name: "LineChart",
    title: "Line Chart",
    description: "The Line Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: LineChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"],
  datasets: [
    {
      label: "Plan",
      data: [30, 70, 200, 300, 500, 800, 1500, 2900, 5000, 8000],
    },
    {
      label: "Reality",
      data: [0, 1, 30, 70, 80, 100, 50, 80, 40, 150],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Title"},
      xLabel: {type: "string", default: "X"},
      yLabel: {type: "string", default: "Y"},
      yTickCount: {
        type: "number",
        default: "3",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  function BarChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      unxkcdify,
      strokeColor,
      backgroundColor,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Bar, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          unxkcdify,
          strokeColor,
          backgroundColor,
          fontFamily
        }
      }
    });
  }
  var BarChartDescription = {
    name: "BarChart",
    title: "Bar Chart",
    description: "The Bar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: BarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["github stars", "patrons"],
  datasets: [
    {
      data: [100, 2],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "github stars VS patron number"},
      xLabel: {type: "string", default: "X"},
      yLabel: {type: "string", default: "Y"},
      yTickCount: {
        type: "number",
        default: "2",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  function StackedBarChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      yTickCount,
      data,
      unxkcdify,
      strokeColor,
      backgroundColor,
      fontFamily,
      showLegend,
      legendPosition
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(StackedBar, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          yTickCount,
          unxkcdify,
          strokeColor,
          backgroundColor,
          fontFamily,
          showLegend,
          legendPosition
        }
      }
    });
  }
  var StackedBarChartDescription = {
    name: "StackedBarChart",
    title: "Stacked Bar Chart",
    description: "The Stacked Bar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: StackedBarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ['Jan', 'Feb', 'Mar', 'April', 'May'],
  datasets: [{
    label: 'Issues',
    data: [12, 19, 11, 29, 17],
  }, {
    label: 'PRs',
    data: [3, 5, 2, 4, 1],
  }, {
    label: 'Merges',
    data: [2, 3, 0, 1, 1],
  }],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Issues and PR Submissions"},
      xLabel: {type: "string", default: "Month"},
      yLabel: {type: "string", default: "Count"},
      yTickCount: {
        type: "number",
        default: "2",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  function PieChart(props) {
    const {title, innerRadius, data} = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Pie, {
      config: {
        title,
        data: eval(`(${data})`) || {},
        options: {
          innerRadius,
          legendPosition: import_chart.default.config.positionType.upRight
        }
      }
    });
  }
  var PieChartDescription = {
    name: "PieChart",
    title: "Pie Chart",
    description: "The Pie Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: PieChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ["a", "b", "e", "f", "g"],
  datasets: [
    {
      data: [500, 200, 80, 90, 100],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "What Tim made of"},
      innerRadius: {type: "number", default: 0.5},
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 1,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  function XYChart(props) {
    const {
      title,
      xLabel,
      yLabel,
      xTickCount,
      yTickCount,
      showLine,
      dotSize,
      data,
      showLegend,
      legendPosition,
      unkcdify,
      strokeColor,
      backgroundColor,
      fontFamily
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.XY, {
      config: {
        title,
        xLabel,
        yLabel,
        data: eval(`(${data})`) || {},
        options: {
          xTickCount,
          yTickCount,
          legendPosition,
          showLine,
          timeFormat: void 0,
          dotSize,
          showLegend,
          unkcdify,
          strokeColor,
          backgroundColor,
          fontFamily
        }
      }
    });
  }
  var XYChartDescription = {
    name: "XYChart",
    title: "XY Chart",
    description: "The XY Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: XYChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  datasets: [
    {
      label: "Pikachu",
      data: [
        { x: 3, y: 10 },
        { x: 4, y: 122 },
        { x: 10, y: 100 },
        { x: 1, y: 2 },
        { x: 2, y: 4 },
      ],
    },
    {
      label: "Squirtle",
      data: [
        { x: 3, y: 122 },
        { x: 4, y: 212 },
        { x: -3, y: 100 },
        { x: 1, y: 1 },
        { x: 1.5, y: 12 },
      ],
    },
  ],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Pokemon farms"},
      xLabel: {type: "string", default: "Coordinate"},
      yLabel: {type: "string", default: "Count"},
      showLine: {type: "boolean", default: false},
      dotSize: {type: "number", default: 1},
      xTickCount: {
        type: "number",
        default: "5",
        editor: {type: "Number", min: 0, max: 8}
      },
      yTickCount: {
        type: "number",
        default: "5",
        editor: {type: "Number", min: 0, max: 8}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 2,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  function RadarChart(props) {
    const {
      title,
      data,
      ticksCount,
      dotSize,
      legendPosition,
      showLegend,
      strokeColor,
      backgroundColor,
      unkcdify,
      fontFamily,
      showLabels
    } = props;
    return /* @__PURE__ */ import_react20.default.createElement(import_chart2.Radar, {
      config: {
        title,
        data: eval(`(${data})`) || {},
        options: {
          ticksCount,
          dotSize,
          legendPosition,
          showLegend,
          strokeColor,
          backgroundColor,
          unkcdify,
          fontFamily,
          showLabels
        }
      }
    });
  }
  var RadarChartDescription = {
    name: "RadarChart",
    title: "Radar Chart",
    description: "The Radar Chart Component ...",
    author: "Playful Software",
    icon: "...",
    preview: "...",
    collection: "chart.XKCD Kit",
    renderer: RadarChart,
    extends: "Play Kit/View",
    properties: {
      data: {
        type: "string",
        default: `{
  labels: ['c', 'h', 'a', 'r', 't'],
  datasets: [{
    label: 'ccharrrt',
    data: [2, 1, 1, 3, 1],
  }, {
    label: 'chhaart',
    data: [1, 2, 2, 1, 1],
  }],
}`,
        editor: {type: "MultilineString", fullWidthEditor: true}
      },
      title: {type: "string", default: "Letters in random words"},
      dotSize: {type: "number", default: 1},
      ticksCount: {
        type: "number",
        default: "3",
        editor: {type: "Number", min: 0, max: 10}
      },
      strokeColor: {type: "string", default: "black", editor: "Color"},
      backgroundColor: {type: "string", default: "white", editor: "Color"},
      fontFamily: {
        type: "string",
        editor: "FontFamily"
      },
      showLabels: {type: "boolean", default: false},
      showLegend: {type: "boolean", default: true},
      legendPosition: {
        type: "number",
        default: 2,
        editor: {
          type: "Option",
          options: [
            1,
            2,
            3,
            4
          ]
        }
      },
      unxkcdify: {type: "boolean", default: false},
      width: {type: "number", default: 400},
      height: {type: "number", default: 267}
    }
  };
  var StackedBar = ({config}) => {
    const ref = (0, import_react20.useRef)();
    (0, import_react20.useEffect)(() => {
      if (ref.current) {
        const myChart = new import_chart.default.StackedBar(ref.current, config);
      }
    });
    return /* @__PURE__ */ import_react20.default.createElement("svg", {
      ref
    });
  };
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS((exports2, module2) => {
  "use strict";
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  module2.exports = ReactPropTypesSecret;
});

// node_modules/prop-types/factoryWithThrowingShims.js
var require_factoryWithThrowingShims = __commonJS((exports2, module2) => {
  "use strict";
  var ReactPropTypesSecret = require_ReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  module2.exports = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      err.name = "Invariant Violation";
      throw err;
    }
    ;
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    ;
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS((exports2, module2) => {
  if (false) {
    ReactIs = null;
    throwOnDirectAccess = true;
    module2.exports = null(ReactIs.isElement, throwOnDirectAccess);
  } else {
    module2.exports = require_factoryWithThrowingShims()();
  }
  var ReactIs;
  var throwOnDirectAccess;
});

// node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS((exports2) => {
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";
  var b2 = typeof Symbol === "function" && Symbol.for;
  var c2 = b2 ? Symbol.for("react.element") : 60103;
  var d2 = b2 ? Symbol.for("react.portal") : 60106;
  var e2 = b2 ? Symbol.for("react.fragment") : 60107;
  var f2 = b2 ? Symbol.for("react.strict_mode") : 60108;
  var g2 = b2 ? Symbol.for("react.profiler") : 60114;
  var h2 = b2 ? Symbol.for("react.provider") : 60109;
  var k2 = b2 ? Symbol.for("react.context") : 60110;
  var l2 = b2 ? Symbol.for("react.async_mode") : 60111;
  var m2 = b2 ? Symbol.for("react.concurrent_mode") : 60111;
  var n2 = b2 ? Symbol.for("react.forward_ref") : 60112;
  var p2 = b2 ? Symbol.for("react.suspense") : 60113;
  var q2 = b2 ? Symbol.for("react.suspense_list") : 60120;
  var r2 = b2 ? Symbol.for("react.memo") : 60115;
  var t2 = b2 ? Symbol.for("react.lazy") : 60116;
  var v2 = b2 ? Symbol.for("react.block") : 60121;
  var w3 = b2 ? Symbol.for("react.fundamental") : 60117;
  var x2 = b2 ? Symbol.for("react.responder") : 60118;
  var y2 = b2 ? Symbol.for("react.scope") : 60119;
  function z2(a2) {
    if (typeof a2 === "object" && a2 !== null) {
      var u2 = a2.$$typeof;
      switch (u2) {
        case c2:
          switch (a2 = a2.type, a2) {
            case l2:
            case m2:
            case e2:
            case g2:
            case f2:
            case p2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case n2:
                case t2:
                case r2:
                case h2:
                  return a2;
                default:
                  return u2;
              }
          }
        case d2:
          return u2;
      }
    }
  }
  function A2(a2) {
    return z2(a2) === m2;
  }
  exports2.AsyncMode = l2;
  exports2.ConcurrentMode = m2;
  exports2.ContextConsumer = k2;
  exports2.ContextProvider = h2;
  exports2.Element = c2;
  exports2.ForwardRef = n2;
  exports2.Fragment = e2;
  exports2.Lazy = t2;
  exports2.Memo = r2;
  exports2.Portal = d2;
  exports2.Profiler = g2;
  exports2.StrictMode = f2;
  exports2.Suspense = p2;
  exports2.isAsyncMode = function(a2) {
    return A2(a2) || z2(a2) === l2;
  };
  exports2.isConcurrentMode = A2;
  exports2.isContextConsumer = function(a2) {
    return z2(a2) === k2;
  };
  exports2.isContextProvider = function(a2) {
    return z2(a2) === h2;
  };
  exports2.isElement = function(a2) {
    return typeof a2 === "object" && a2 !== null && a2.$$typeof === c2;
  };
  exports2.isForwardRef = function(a2) {
    return z2(a2) === n2;
  };
  exports2.isFragment = function(a2) {
    return z2(a2) === e2;
  };
  exports2.isLazy = function(a2) {
    return z2(a2) === t2;
  };
  exports2.isMemo = function(a2) {
    return z2(a2) === r2;
  };
  exports2.isPortal = function(a2) {
    return z2(a2) === d2;
  };
  exports2.isProfiler = function(a2) {
    return z2(a2) === g2;
  };
  exports2.isStrictMode = function(a2) {
    return z2(a2) === f2;
  };
  exports2.isSuspense = function(a2) {
    return z2(a2) === p2;
  };
  exports2.isValidElementType = function(a2) {
    return typeof a2 === "string" || typeof a2 === "function" || a2 === e2 || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q2 || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k2 || a2.$$typeof === n2 || a2.$$typeof === w3 || a2.$$typeof === x2 || a2.$$typeof === y2 || a2.$$typeof === v2);
  };
  exports2.typeOf = z2;
});

// node_modules/react-is/index.js
var require_react_is = __commonJS((exports2, module2) => {
  "use strict";
  if (true) {
    module2.exports = require_react_is_production_min();
  } else {
    module2.exports = null;
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS((exports2, module2) => {
  "use strict";
  var reactIs = require_react_is();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys2 = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i2 = 0; i2 < keys2.length; ++i2) {
        var key = keys2[i2];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  module2.exports = hoistNonReactStatics2;
});

// node_modules/react-display-name/lib/getDisplayName.js
var require_getDisplayName = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDisplayName2;
  function getDisplayName2(Component6) {
    return Component6.displayName || Component6.name || (typeof Component6 === "string" && Component6.length > 0 ? Component6 : "Unknown");
  }
});

// node_modules/symbol-observable/es/index.js
var require_es = __commonJS((exports2, module2) => {
  __markAsModule(exports2);
  __export(exports2, {
    default: () => es_default
  });
  var root;
  if (typeof self !== "undefined") {
    root = self;
  } else if (typeof window !== "undefined") {
    root = window;
  } else if (typeof global !== "undefined") {
    root = global;
  } else if (typeof module2 !== "undefined") {
    root = module2;
  } else {
    root = Function("return this")();
  }
  var result = symbolObservablePonyfill(root);
  var es_default = result;
});

// node_modules/react-input-autosize/lib/AutosizeInput.js
var require_AutosizeInput = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _extends3 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _createClass2 = function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _react = require("react");
  var _react2 = _interopRequireDefault(_react);
  var _propTypes = require_prop_types();
  var _propTypes2 = _interopRequireDefault(_propTypes);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _objectWithoutProperties2(obj, keys2) {
    var target = {};
    for (var i2 in obj) {
      if (keys2.indexOf(i2) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i2))
        continue;
      target[i2] = obj[i2];
    }
    return target;
  }
  function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn2(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  }
  function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, enumerable: false, writable: true, configurable: true}});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var sizerStyle = {
    position: "absolute",
    top: 0,
    left: 0,
    visibility: "hidden",
    height: 0,
    overflow: "scroll",
    whiteSpace: "pre"
  };
  var INPUT_PROPS_BLACKLIST = ["extraWidth", "injectStyles", "inputClassName", "inputRef", "inputStyle", "minWidth", "onAutosize", "placeholderIsMinWidth"];
  var cleanInputProps = function cleanInputProps2(inputProps) {
    INPUT_PROPS_BLACKLIST.forEach(function(field) {
      return delete inputProps[field];
    });
    return inputProps;
  };
  var copyStyles = function copyStyles2(styles, node2) {
    node2.style.fontSize = styles.fontSize;
    node2.style.fontFamily = styles.fontFamily;
    node2.style.fontWeight = styles.fontWeight;
    node2.style.fontStyle = styles.fontStyle;
    node2.style.letterSpacing = styles.letterSpacing;
    node2.style.textTransform = styles.textTransform;
  };
  var isIE = typeof window !== "undefined" && window.navigator ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent) : false;
  var generateId = function generateId2() {
    return isIE ? "_" + Math.random().toString(36).substr(2, 12) : void 0;
  };
  var AutosizeInput2 = function(_Component) {
    _inherits2(AutosizeInput3, _Component);
    _createClass2(AutosizeInput3, null, [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var id = props.id;
        return id !== state.prevId ? {inputId: id || generateId(), prevId: id} : null;
      }
    }]);
    function AutosizeInput3(props) {
      _classCallCheck2(this, AutosizeInput3);
      var _this = _possibleConstructorReturn2(this, (AutosizeInput3.__proto__ || Object.getPrototypeOf(AutosizeInput3)).call(this, props));
      _this.inputRef = function(el2) {
        _this.input = el2;
        if (typeof _this.props.inputRef === "function") {
          _this.props.inputRef(el2);
        }
      };
      _this.placeHolderSizerRef = function(el2) {
        _this.placeHolderSizer = el2;
      };
      _this.sizerRef = function(el2) {
        _this.sizer = el2;
      };
      _this.state = {
        inputWidth: props.minWidth,
        inputId: props.id || generateId(),
        prevId: props.id
      };
      return _this;
    }
    _createClass2(AutosizeInput3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.mounted = true;
        this.copyInputStyles();
        this.updateInputWidth();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        if (prevState.inputWidth !== this.state.inputWidth) {
          if (typeof this.props.onAutosize === "function") {
            this.props.onAutosize(this.state.inputWidth);
          }
        }
        this.updateInputWidth();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.mounted = false;
      }
    }, {
      key: "copyInputStyles",
      value: function copyInputStyles() {
        if (!this.mounted || !window.getComputedStyle) {
          return;
        }
        var inputStyles = this.input && window.getComputedStyle(this.input);
        if (!inputStyles) {
          return;
        }
        copyStyles(inputStyles, this.sizer);
        if (this.placeHolderSizer) {
          copyStyles(inputStyles, this.placeHolderSizer);
        }
      }
    }, {
      key: "updateInputWidth",
      value: function updateInputWidth() {
        if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === "undefined") {
          return;
        }
        var newInputWidth = void 0;
        if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
          newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
        } else {
          newInputWidth = this.sizer.scrollWidth + 2;
        }
        var extraWidth = this.props.type === "number" && this.props.extraWidth === void 0 ? 16 : parseInt(this.props.extraWidth) || 0;
        newInputWidth += extraWidth;
        if (newInputWidth < this.props.minWidth) {
          newInputWidth = this.props.minWidth;
        }
        if (newInputWidth !== this.state.inputWidth) {
          this.setState({
            inputWidth: newInputWidth
          });
        }
      }
    }, {
      key: "getInput",
      value: function getInput() {
        return this.input;
      }
    }, {
      key: "focus",
      value: function focus() {
        this.input.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.input.blur();
      }
    }, {
      key: "select",
      value: function select() {
        this.input.select();
      }
    }, {
      key: "renderStyles",
      value: function renderStyles() {
        var injectStyles = this.props.injectStyles;
        return isIE && injectStyles ? _react2.default.createElement("style", {dangerouslySetInnerHTML: {
          __html: "input#" + this.state.inputId + "::-ms-clear {display: none;}"
        }}) : null;
      }
    }, {
      key: "render",
      value: function render2() {
        var sizerValue = [this.props.defaultValue, this.props.value, ""].reduce(function(previousValue, currentValue) {
          if (previousValue !== null && previousValue !== void 0) {
            return previousValue;
          }
          return currentValue;
        });
        var wrapperStyle = _extends3({}, this.props.style);
        if (!wrapperStyle.display)
          wrapperStyle.display = "inline-block";
        var inputStyle3 = _extends3({
          boxSizing: "content-box",
          width: this.state.inputWidth + "px"
        }, this.props.inputStyle);
        var inputProps = _objectWithoutProperties2(this.props, []);
        cleanInputProps(inputProps);
        inputProps.className = this.props.inputClassName;
        inputProps.id = this.state.inputId;
        inputProps.style = inputStyle3;
        return _react2.default.createElement("div", {className: this.props.className, style: wrapperStyle}, this.renderStyles(), _react2.default.createElement("input", _extends3({}, inputProps, {ref: this.inputRef})), _react2.default.createElement("div", {ref: this.sizerRef, style: sizerStyle}, sizerValue), this.props.placeholder ? _react2.default.createElement("div", {ref: this.placeHolderSizerRef, style: sizerStyle}, this.props.placeholder) : null);
      }
    }]);
    return AutosizeInput3;
  }(_react.Component);
  AutosizeInput2.propTypes = {
    className: _propTypes2.default.string,
    defaultValue: _propTypes2.default.any,
    extraWidth: _propTypes2.default.oneOfType([
      _propTypes2.default.number,
      _propTypes2.default.string
    ]),
    id: _propTypes2.default.string,
    injectStyles: _propTypes2.default.bool,
    inputClassName: _propTypes2.default.string,
    inputRef: _propTypes2.default.func,
    inputStyle: _propTypes2.default.object,
    minWidth: _propTypes2.default.oneOfType([
      _propTypes2.default.number,
      _propTypes2.default.string
    ]),
    onAutosize: _propTypes2.default.func,
    onChange: _propTypes2.default.func,
    placeholder: _propTypes2.default.string,
    placeholderIsMinWidth: _propTypes2.default.bool,
    style: _propTypes2.default.object,
    value: _propTypes2.default.any
  };
  AutosizeInput2.defaultProps = {
    minWidth: 1,
    injectStyles: true
  };
  exports2.default = AutosizeInput2;
});

// src/warpspeed/WarpSpeed.js
var require_WarpSpeed = __commonJS((exports2, module2) => {
  (function(root, factory) {
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = factory();
    } else {
      root.warpspeed = factory();
    }
  })(typeof window.self !== "undefined" ? window.self : exports2, function() {
    (function() {
      var lastTime = 0;
      var vendors = ["ms", "moz", "webkit", "o"];
      for (var x2 = 0; x2 < vendors.length && !window.requestAnimationFrame; ++x2) {
        window.requestAnimationFrame = window[vendors[x2] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x2] + "CancelAnimationFrame"] || window[vendors[x2] + "CancelRequestAnimationFrame"];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = window.setTimeout(function() {
            callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      }
    })();
    function timeStamp() {
      if (window.performance.now)
        return window.performance.now();
      else
        return Date.now();
    }
    function isVisible(el2) {
      var r2 = el2.getBoundingClientRect();
      return r2.top + r2.height >= 0 && r2.left + r2.width >= 0 && r2.bottom - r2.height <= (window.innerHeight || document.documentElement.clientHeight) && r2.right - r2.width <= (window.innerWidth || document.documentElement.clientWidth);
    }
    function Star(x2, y2, z2) {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.size = 0.5 + Math.random();
    }
    function WarpSpeed2(targetId, config) {
      console.log(config);
      this.targetId = targetId;
      if (WarpSpeed2.RUNNING_INSTANCES === void 0)
        WarpSpeed2.RUNNING_INSTANCES = {};
      if (WarpSpeed2.RUNNING_INSTANCES[targetId]) {
        WarpSpeed2.RUNNING_INSTANCES[targetId].destroy();
      }
      config = config || {};
      if (typeof config === "string")
        try {
          config = JSON.parse(config);
        } catch (e2) {
          config = {};
        }
      this.SPEED = config.speed === void 0 || config.speed < 0 ? 0.7 : config.speed;
      this.TARGET_SPEED = config.targetSpeed === void 0 || config.targetSpeed < 0 ? this.SPEED : config.targetSpeed;
      this.SPEED_ADJ_FACTOR = config.speedAdjFactor === void 0 ? 0.03 : config.speedAdjFactor < 0 ? 0 : config.speedAdjFactor > 1 ? 1 : config.speedAdjFactor;
      this.DENSITY = config.density === void 0 || config.density <= 0 ? 0.7 : config.density;
      this.USE_CIRCLES = config.shape === void 0 ? true : config.shape === "circle";
      this.DEPTH_ALPHA = config.depthFade === void 0 ? true : config.depthFade;
      this.WARP_EFFECT = config.warpEffect === void 0 ? true : config.warpEffect;
      this.WARP_EFFECT_LENGTH = config.warpEffectLength === void 0 ? 5 : config.warpEffectLength < 0 ? 0 : config.warpEffectLength;
      this.STAR_SCALE = config.starSize === void 0 || config.starSize <= 0 ? 3 : config.starSize;
      this.BACKGROUND_COLOR = config.backgroundColor === void 0 ? "hsl(263,45%,7%)" : config.backgroundColor;
      var canvas = document.getElementById(this.targetId);
      canvas.width = 1;
      canvas.height = 1;
      var ctx = canvas.getContext("2d");
      ctx.fillStyle = this.BACKGROUND_COLOR;
      ctx.fillRect(0, 0, 1, 1);
      ctx.fillStyle = config.starColor === void 0 ? "#FFFFFF" : config.starColor;
      ctx.fillRect(0, 0, 1, 1);
      var color = ctx.getImageData(0, 0, 1, 1).data;
      this.STAR_R = color[0];
      this.STAR_G = color[1];
      this.STAR_B = color[2];
      this.prevW = -1;
      this.prevH = -1;
      this.stars = [];
      for (var i2 = 0; i2 < this.DENSITY * 1e3; i2++) {
        this.stars.push(new Star((Math.random() - 0.5) * 1e3, (Math.random() - 0.5) * 1e3, 1e3 * Math.random()));
      }
      this.lastMoveTS = timeStamp();
      this.drawRequest = null;
      this.LAST_RENDER_T = 0;
      WarpSpeed2.RUNNING_INSTANCES[targetId] = this;
      this.draw();
    }
    WarpSpeed2.prototype = {
      constructor: WarpSpeed2,
      draw: function() {
        var TIME = timeStamp();
        if (!document.getElementById(this.targetId)) {
          this.destroy();
          return;
        }
        this.move();
        var canvas = document.getElementById(this.targetId);
        if (!this.PAUSED && isVisible(canvas)) {
          if (this.prevW !== canvas.clientWidth || this.prevH !== canvas.clientHeight) {
            canvas.width = (canvas.clientWidth < 10 ? 10 : canvas.clientWidth) * (window.devicePixelRatio || 1);
            canvas.height = (canvas.clientHeight < 10 ? 10 : canvas.clientHeight) * (window.devicePixelRatio || 1);
          }
          this.size = (canvas.height < canvas.width ? canvas.height : canvas.width) / (10 / (this.STAR_SCALE <= 0 ? 0 : this.STAR_SCALE));
          if (this.WARP_EFFECT)
            this.maxLineWidth = this.size / 30;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = this.BACKGROUND_COLOR;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          var rgb = "rgb(" + this.STAR_R + "," + this.STAR_G + "," + this.STAR_B + ")", rgba = "rgba(" + this.STAR_R + "," + this.STAR_G + "," + this.STAR_B + ",";
          for (var i2 = 0; i2 < this.stars.length; i2++) {
            var s2 = this.stars[i2];
            var xOnDisplay = s2.x / s2.z, yOnDisplay = s2.y / s2.z;
            if (!this.WARP_EFFECT && (xOnDisplay < -0.5 || xOnDisplay > 0.5 || yOnDisplay < -0.5 || yOnDisplay > 0.5))
              continue;
            var size = s2.size * this.size / s2.z;
            if (size < 0.3)
              continue;
            if (this.DEPTH_ALPHA) {
              var alpha = (1e3 - s2.z) / 1e3;
              ctx.fillStyle = rgba + (alpha > 1 ? 1 : alpha) + ")";
            } else {
              ctx.fillStyle = rgb;
            }
            if (this.WARP_EFFECT) {
              ctx.beginPath();
              var x2OnDisplay = s2.x / (s2.z + this.WARP_EFFECT_LENGTH * this.SPEED), y2OnDisplay = s2.y / (s2.z + this.WARP_EFFECT_LENGTH * this.SPEED);
              if (x2OnDisplay < -0.5 || x2OnDisplay > 0.5 || y2OnDisplay < -0.5 || y2OnDisplay > 0.5)
                continue;
              ctx.moveTo(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2);
              ctx.lineTo(canvas.width * (x2OnDisplay + 0.5) - size / 2, canvas.height * (y2OnDisplay + 0.5) - size / 2);
              ctx.lineWidth = size > this.maxLineWidth ? this.maxLineWidth : size;
              if (this.USE_CIRCLES) {
                ctx.lineCap = "round";
              } else {
                ctx.lineCap = "butt";
              }
              ctx.strokeStyle = ctx.fillStyle;
              ctx.stroke();
            } else if (this.USE_CIRCLES) {
              ctx.beginPath();
              ctx.arc(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2, size / 2, 0, 2 * Math.PI);
              ctx.fill();
            } else {
              ctx.fillRect(canvas.width * (xOnDisplay + 0.5) - size / 2, canvas.height * (yOnDisplay + 0.5) - size / 2, size, size);
            }
          }
          this.prevW = canvas.clientWidth;
          this.prevH = canvas.clientHeight;
        }
        if (this.drawRequest !== -1)
          this.drawRequest = requestAnimationFrame(this.draw.bind(this));
        this.LAST_RENDER_T = timeStamp() - TIME;
      },
      move: function() {
        var t2 = timeStamp(), speedMulF = (t2 - this.lastMoveTS) / (1e3 / 60);
        this.lastMoveTS = t2;
        if (this.PAUSED)
          return;
        var speedAdjF = Math.pow(this.SPEED_ADJ_FACTOR < 0 ? 0 : this.SPEED_ADJ_FACTOR > 1 ? 1 : this.SPEED_ADJ_FACTOR, 1 / speedMulF);
        this.SPEED = this.TARGET_SPEED * speedAdjF + this.SPEED * (1 - speedAdjF);
        if (this.SPEED < 0)
          this.SPEED = 0;
        var speed = this.SPEED * speedMulF;
        for (var i2 = 0; i2 < this.stars.length; i2++) {
          var s2 = this.stars[i2];
          s2.z -= speed;
          while (s2.z < 1) {
            s2.z += 1e3;
            s2.x = (Math.random() - 0.5) * s2.z;
            s2.y = (Math.random() - 0.5) * s2.z;
          }
        }
      },
      destroy: function(targetId) {
        if (targetId) {
          if (WarpSpeed2.RUNNING_INSTANCES[targetId])
            WarpSpeed2.RUNNING_INSTANCES[targetId].destroy();
        } else {
          try {
            cancelAnimationFrame(this.drawRequest);
          } catch (e2) {
            this.drawRequest = -1;
          }
          WarpSpeed2.RUNNING_INSTANCES[this.targetId] = void 0;
        }
      },
      pause: function() {
        this.PAUSED = true;
      },
      resume: function() {
        this.PAUSED = false;
      }
    };
    WarpSpeed2.destroy = WarpSpeed2.prototype.destroy;
    return WarpSpeed2;
  });
});

// node_modules/leaflet/dist/leaflet-src.js
var require_leaflet_src = __commonJS((exports2, module2) => {
  /* @preserve
   * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
   * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
   */
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.L = {});
  })(exports2, function(exports3) {
    "use strict";
    var version2 = "1.7.1";
    function extend2(dest) {
      var i2, j2, len, src2;
      for (j2 = 1, len = arguments.length; j2 < len; j2++) {
        src2 = arguments[j2];
        for (i2 in src2) {
          dest[i2] = src2[i2];
        }
      }
      return dest;
    }
    var create7 = Object.create || function() {
      function F2() {
      }
      return function(proto) {
        F2.prototype = proto;
        return new F2();
      };
    }();
    function bind(fn, obj) {
      var slice2 = Array.prototype.slice;
      if (fn.bind) {
        return fn.bind.apply(fn, slice2.call(arguments, 1));
      }
      var args = slice2.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.length ? args.concat(slice2.call(arguments)) : arguments);
      };
    }
    var lastId = 0;
    function stamp(obj) {
      obj._leaflet_id = obj._leaflet_id || ++lastId;
      return obj._leaflet_id;
    }
    function throttle(fn, time, context) {
      var lock, args, wrapperFn, later;
      later = function() {
        lock = false;
        if (args) {
          wrapperFn.apply(context, args);
          args = false;
        }
      };
      wrapperFn = function() {
        if (lock) {
          args = arguments;
        } else {
          fn.apply(context, arguments);
          setTimeout(later, time);
          lock = true;
        }
      };
      return wrapperFn;
    }
    function wrapNum(x2, range, includeMax) {
      var max = range[1], min = range[0], d2 = max - min;
      return x2 === max && includeMax ? x2 : ((x2 - min) % d2 + d2) % d2 + min;
    }
    function falseFn() {
      return false;
    }
    function formatNum(num, digits) {
      var pow = Math.pow(10, digits === void 0 ? 6 : digits);
      return Math.round(num * pow) / pow;
    }
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function splitWords(str) {
      return trim2(str).split(/\s+/);
    }
    function setOptions2(obj, options2) {
      if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
        obj.options = obj.options ? create7(obj.options) : {};
      }
      for (var i2 in options2) {
        obj.options[i2] = options2[i2];
      }
      return obj.options;
    }
    function getParamString(obj, existingUrl, uppercase) {
      var params = [];
      for (var i2 in obj) {
        params.push(encodeURIComponent(uppercase ? i2.toUpperCase() : i2) + "=" + encodeURIComponent(obj[i2]));
      }
      return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params.join("&");
    }
    var templateRe = /\{ *([\w_-]+) *\}/g;
    function template(str, data2) {
      return str.replace(templateRe, function(str2, key) {
        var value = data2[key];
        if (value === void 0) {
          throw new Error("No value provided for variable " + str2);
        } else if (typeof value === "function") {
          value = value(data2);
        }
        return value;
      });
    }
    var isArray = Array.isArray || function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };
    function indexOf(array, el2) {
      for (var i2 = 0; i2 < array.length; i2++) {
        if (array[i2] === el2) {
          return i2;
        }
      }
      return -1;
    }
    var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    function getPrefixed(name2) {
      return window["webkit" + name2] || window["moz" + name2] || window["ms" + name2];
    }
    var lastTime = 0;
    function timeoutDefer(fn) {
      var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }
    var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
      window.clearTimeout(id);
    };
    function requestAnimFrame(fn, context, immediate) {
      if (immediate && requestFn === timeoutDefer) {
        fn.call(context);
      } else {
        return requestFn.call(window, bind(fn, context));
      }
    }
    function cancelAnimFrame(id) {
      if (id) {
        cancelFn.call(window, id);
      }
    }
    var Util = {
      extend: extend2,
      create: create7,
      bind,
      lastId,
      stamp,
      throttle,
      wrapNum,
      falseFn,
      formatNum,
      trim: trim2,
      splitWords,
      setOptions: setOptions2,
      getParamString,
      template,
      isArray,
      indexOf,
      emptyImageUrl,
      requestFn,
      cancelFn,
      requestAnimFrame,
      cancelAnimFrame
    };
    function Class() {
    }
    Class.extend = function(props) {
      var NewClass = function() {
        if (this.initialize) {
          this.initialize.apply(this, arguments);
        }
        this.callInitHooks();
      };
      var parentProto = NewClass.__super__ = this.prototype;
      var proto = create7(parentProto);
      proto.constructor = NewClass;
      NewClass.prototype = proto;
      for (var i2 in this) {
        if (Object.prototype.hasOwnProperty.call(this, i2) && i2 !== "prototype" && i2 !== "__super__") {
          NewClass[i2] = this[i2];
        }
      }
      if (props.statics) {
        extend2(NewClass, props.statics);
        delete props.statics;
      }
      if (props.includes) {
        checkDeprecatedMixinEvents(props.includes);
        extend2.apply(null, [proto].concat(props.includes));
        delete props.includes;
      }
      if (proto.options) {
        props.options = extend2(create7(proto.options), props.options);
      }
      extend2(proto, props);
      proto._initHooks = [];
      proto.callInitHooks = function() {
        if (this._initHooksCalled) {
          return;
        }
        if (parentProto.callInitHooks) {
          parentProto.callInitHooks.call(this);
        }
        this._initHooksCalled = true;
        for (var i3 = 0, len = proto._initHooks.length; i3 < len; i3++) {
          proto._initHooks[i3].call(this);
        }
      };
      return NewClass;
    };
    Class.include = function(props) {
      extend2(this.prototype, props);
      return this;
    };
    Class.mergeOptions = function(options2) {
      extend2(this.prototype.options, options2);
      return this;
    };
    Class.addInitHook = function(fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      var init = typeof fn === "function" ? fn : function() {
        this[fn].apply(this, args);
      };
      this.prototype._initHooks = this.prototype._initHooks || [];
      this.prototype._initHooks.push(init);
      return this;
    };
    function checkDeprecatedMixinEvents(includes) {
      if (typeof L === "undefined" || !L || !L.Mixin) {
        return;
      }
      includes = isArray(includes) ? includes : [includes];
      for (var i2 = 0; i2 < includes.length; i2++) {
        if (includes[i2] === L.Mixin.Events) {
          console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
    }
    var Events = {
      on: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type in types) {
            this._on(type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i2 = 0, len = types.length; i2 < len; i2++) {
            this._on(types[i2], fn, context);
          }
        }
        return this;
      },
      off: function(types, fn, context) {
        if (!types) {
          delete this._events;
        } else if (typeof types === "object") {
          for (var type in types) {
            this._off(type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i2 = 0, len = types.length; i2 < len; i2++) {
            this._off(types[i2], fn, context);
          }
        }
        return this;
      },
      _on: function(type, fn, context) {
        this._events = this._events || {};
        var typeListeners = this._events[type];
        if (!typeListeners) {
          typeListeners = [];
          this._events[type] = typeListeners;
        }
        if (context === this) {
          context = void 0;
        }
        var newListener = {fn, ctx: context}, listeners = typeListeners;
        for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
          if (listeners[i2].fn === fn && listeners[i2].ctx === context) {
            return;
          }
        }
        listeners.push(newListener);
      },
      _off: function(type, fn, context) {
        var listeners, i2, len;
        if (!this._events) {
          return;
        }
        listeners = this._events[type];
        if (!listeners) {
          return;
        }
        if (!fn) {
          for (i2 = 0, len = listeners.length; i2 < len; i2++) {
            listeners[i2].fn = falseFn;
          }
          delete this._events[type];
          return;
        }
        if (context === this) {
          context = void 0;
        }
        if (listeners) {
          for (i2 = 0, len = listeners.length; i2 < len; i2++) {
            var l2 = listeners[i2];
            if (l2.ctx !== context) {
              continue;
            }
            if (l2.fn === fn) {
              l2.fn = falseFn;
              if (this._firingCount) {
                this._events[type] = listeners = listeners.slice();
              }
              listeners.splice(i2, 1);
              return;
            }
          }
        }
      },
      fire: function(type, data2, propagate) {
        if (!this.listens(type, propagate)) {
          return this;
        }
        var event = extend2({}, data2, {
          type,
          target: this,
          sourceTarget: data2 && data2.sourceTarget || this
        });
        if (this._events) {
          var listeners = this._events[type];
          if (listeners) {
            this._firingCount = this._firingCount + 1 || 1;
            for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
              var l2 = listeners[i2];
              l2.fn.call(l2.ctx || this, event);
            }
            this._firingCount--;
          }
        }
        if (propagate) {
          this._propagateEvent(event);
        }
        return this;
      },
      listens: function(type, propagate) {
        var listeners = this._events && this._events[type];
        if (listeners && listeners.length) {
          return true;
        }
        if (propagate) {
          for (var id in this._eventParents) {
            if (this._eventParents[id].listens(type, propagate)) {
              return true;
            }
          }
        }
        return false;
      },
      once: function(types, fn, context) {
        if (typeof types === "object") {
          for (var type in types) {
            this.once(type, types[type], fn);
          }
          return this;
        }
        var handler = bind(function() {
          this.off(types, fn, context).off(types, handler, context);
        }, this);
        return this.on(types, fn, context).on(types, handler, context);
      },
      addEventParent: function(obj) {
        this._eventParents = this._eventParents || {};
        this._eventParents[stamp(obj)] = obj;
        return this;
      },
      removeEventParent: function(obj) {
        if (this._eventParents) {
          delete this._eventParents[stamp(obj)];
        }
        return this;
      },
      _propagateEvent: function(e2) {
        for (var id in this._eventParents) {
          this._eventParents[id].fire(e2.type, extend2({
            layer: e2.target,
            propagatedFrom: e2.target
          }, e2), true);
        }
      }
    };
    Events.addEventListener = Events.on;
    Events.removeEventListener = Events.clearAllEventListeners = Events.off;
    Events.addOneTimeEventListener = Events.once;
    Events.fireEvent = Events.fire;
    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events);
    function Point(x2, y2, round) {
      this.x = round ? Math.round(x2) : x2;
      this.y = round ? Math.round(y2) : y2;
    }
    var trunc = Math.trunc || function(v2) {
      return v2 > 0 ? Math.floor(v2) : Math.ceil(v2);
    };
    Point.prototype = {
      clone: function() {
        return new Point(this.x, this.y);
      },
      add: function(point) {
        return this.clone()._add(toPoint(point));
      },
      _add: function(point) {
        this.x += point.x;
        this.y += point.y;
        return this;
      },
      subtract: function(point) {
        return this.clone()._subtract(toPoint(point));
      },
      _subtract: function(point) {
        this.x -= point.x;
        this.y -= point.y;
        return this;
      },
      divideBy: function(num) {
        return this.clone()._divideBy(num);
      },
      _divideBy: function(num) {
        this.x /= num;
        this.y /= num;
        return this;
      },
      multiplyBy: function(num) {
        return this.clone()._multiplyBy(num);
      },
      _multiplyBy: function(num) {
        this.x *= num;
        this.y *= num;
        return this;
      },
      scaleBy: function(point) {
        return new Point(this.x * point.x, this.y * point.y);
      },
      unscaleBy: function(point) {
        return new Point(this.x / point.x, this.y / point.y);
      },
      round: function() {
        return this.clone()._round();
      },
      _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      floor: function() {
        return this.clone()._floor();
      },
      _floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        return this.clone()._ceil();
      },
      _ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      trunc: function() {
        return this.clone()._trunc();
      },
      _trunc: function() {
        this.x = trunc(this.x);
        this.y = trunc(this.y);
        return this;
      },
      distanceTo: function(point) {
        point = toPoint(point);
        var x2 = point.x - this.x, y2 = point.y - this.y;
        return Math.sqrt(x2 * x2 + y2 * y2);
      },
      equals: function(point) {
        point = toPoint(point);
        return point.x === this.x && point.y === this.y;
      },
      contains: function(point) {
        point = toPoint(point);
        return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
      },
      toString: function() {
        return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
      }
    };
    function toPoint(x2, y2, round) {
      if (x2 instanceof Point) {
        return x2;
      }
      if (isArray(x2)) {
        return new Point(x2[0], x2[1]);
      }
      if (x2 === void 0 || x2 === null) {
        return x2;
      }
      if (typeof x2 === "object" && "x" in x2 && "y" in x2) {
        return new Point(x2.x, x2.y);
      }
      return new Point(x2, y2, round);
    }
    function Bounds(a2, b2) {
      if (!a2) {
        return;
      }
      var points = b2 ? [a2, b2] : a2;
      for (var i2 = 0, len = points.length; i2 < len; i2++) {
        this.extend(points[i2]);
      }
    }
    Bounds.prototype = {
      extend: function(point) {
        point = toPoint(point);
        if (!this.min && !this.max) {
          this.min = point.clone();
          this.max = point.clone();
        } else {
          this.min.x = Math.min(point.x, this.min.x);
          this.max.x = Math.max(point.x, this.max.x);
          this.min.y = Math.min(point.y, this.min.y);
          this.max.y = Math.max(point.y, this.max.y);
        }
        return this;
      },
      getCenter: function(round) {
        return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
      },
      getBottomLeft: function() {
        return new Point(this.min.x, this.max.y);
      },
      getTopRight: function() {
        return new Point(this.max.x, this.min.y);
      },
      getTopLeft: function() {
        return this.min;
      },
      getBottomRight: function() {
        return this.max;
      },
      getSize: function() {
        return this.max.subtract(this.min);
      },
      contains: function(obj) {
        var min, max;
        if (typeof obj[0] === "number" || obj instanceof Point) {
          obj = toPoint(obj);
        } else {
          obj = toBounds(obj);
        }
        if (obj instanceof Bounds) {
          min = obj.min;
          max = obj.max;
        } else {
          min = max = obj;
        }
        return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
      },
      intersects: function(bounds) {
        bounds = toBounds(bounds);
        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
        return xIntersects && yIntersects;
      },
      overlaps: function(bounds) {
        bounds = toBounds(bounds);
        var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
        return xOverlaps && yOverlaps;
      },
      isValid: function() {
        return !!(this.min && this.max);
      }
    };
    function toBounds(a2, b2) {
      if (!a2 || a2 instanceof Bounds) {
        return a2;
      }
      return new Bounds(a2, b2);
    }
    function LatLngBounds(corner1, corner2) {
      if (!corner1) {
        return;
      }
      var latlngs = corner2 ? [corner1, corner2] : corner1;
      for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
        this.extend(latlngs[i2]);
      }
    }
    LatLngBounds.prototype = {
      extend: function(obj) {
        var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
        if (obj instanceof LatLng) {
          sw2 = obj;
          ne22 = obj;
        } else if (obj instanceof LatLngBounds) {
          sw2 = obj._southWest;
          ne22 = obj._northEast;
          if (!sw2 || !ne22) {
            return this;
          }
        } else {
          return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
        }
        if (!sw && !ne2) {
          this._southWest = new LatLng(sw2.lat, sw2.lng);
          this._northEast = new LatLng(ne22.lat, ne22.lng);
        } else {
          sw.lat = Math.min(sw2.lat, sw.lat);
          sw.lng = Math.min(sw2.lng, sw.lng);
          ne2.lat = Math.max(ne22.lat, ne2.lat);
          ne2.lng = Math.max(ne22.lng, ne2.lng);
        }
        return this;
      },
      pad: function(bufferRatio) {
        var sw = this._southWest, ne2 = this._northEast, heightBuffer = Math.abs(sw.lat - ne2.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne2.lng) * bufferRatio;
        return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne2.lat + heightBuffer, ne2.lng + widthBuffer));
      },
      getCenter: function() {
        return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
      },
      getSouthWest: function() {
        return this._southWest;
      },
      getNorthEast: function() {
        return this._northEast;
      },
      getNorthWest: function() {
        return new LatLng(this.getNorth(), this.getWest());
      },
      getSouthEast: function() {
        return new LatLng(this.getSouth(), this.getEast());
      },
      getWest: function() {
        return this._southWest.lng;
      },
      getSouth: function() {
        return this._southWest.lat;
      },
      getEast: function() {
        return this._northEast.lng;
      },
      getNorth: function() {
        return this._northEast.lat;
      },
      contains: function(obj) {
        if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
          obj = toLatLng(obj);
        } else {
          obj = toLatLngBounds(obj);
        }
        var sw = this._southWest, ne2 = this._northEast, sw2, ne22;
        if (obj instanceof LatLngBounds) {
          sw2 = obj.getSouthWest();
          ne22 = obj.getNorthEast();
        } else {
          sw2 = ne22 = obj;
        }
        return sw2.lat >= sw.lat && ne22.lat <= ne2.lat && sw2.lng >= sw.lng && ne22.lng <= ne2.lng;
      },
      intersects: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latIntersects = ne22.lat >= sw.lat && sw2.lat <= ne2.lat, lngIntersects = ne22.lng >= sw.lng && sw2.lng <= ne2.lng;
        return latIntersects && lngIntersects;
      },
      overlaps: function(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest, ne2 = this._northEast, sw2 = bounds.getSouthWest(), ne22 = bounds.getNorthEast(), latOverlaps = ne22.lat > sw.lat && sw2.lat < ne2.lat, lngOverlaps = ne22.lng > sw.lng && sw2.lng < ne2.lng;
        return latOverlaps && lngOverlaps;
      },
      toBBoxString: function() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
      },
      equals: function(bounds, maxMargin) {
        if (!bounds) {
          return false;
        }
        bounds = toLatLngBounds(bounds);
        return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
      },
      isValid: function() {
        return !!(this._southWest && this._northEast);
      }
    };
    function toLatLngBounds(a2, b2) {
      if (a2 instanceof LatLngBounds) {
        return a2;
      }
      return new LatLngBounds(a2, b2);
    }
    function LatLng(lat, lng, alt) {
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
      }
      this.lat = +lat;
      this.lng = +lng;
      if (alt !== void 0) {
        this.alt = +alt;
      }
    }
    LatLng.prototype = {
      equals: function(obj, maxMargin) {
        if (!obj) {
          return false;
        }
        obj = toLatLng(obj);
        var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
        return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
      },
      toString: function(precision) {
        return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
      },
      distanceTo: function(other) {
        return Earth.distance(this, toLatLng(other));
      },
      wrap: function() {
        return Earth.wrapLatLng(this);
      },
      toBounds: function(sizeInMeters) {
        var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
        return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
      },
      clone: function() {
        return new LatLng(this.lat, this.lng, this.alt);
      }
    };
    function toLatLng(a2, b2, c2) {
      if (a2 instanceof LatLng) {
        return a2;
      }
      if (isArray(a2) && typeof a2[0] !== "object") {
        if (a2.length === 3) {
          return new LatLng(a2[0], a2[1], a2[2]);
        }
        if (a2.length === 2) {
          return new LatLng(a2[0], a2[1]);
        }
        return null;
      }
      if (a2 === void 0 || a2 === null) {
        return a2;
      }
      if (typeof a2 === "object" && "lat" in a2) {
        return new LatLng(a2.lat, "lng" in a2 ? a2.lng : a2.lon, a2.alt);
      }
      if (b2 === void 0) {
        return null;
      }
      return new LatLng(a2, b2, c2);
    }
    var CRS = {
      latLngToPoint: function(latlng, zoom2) {
        var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
        return this.transformation._transform(projectedPoint, scale2);
      },
      pointToLatLng: function(point, zoom2) {
        var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale2);
        return this.projection.unproject(untransformedPoint);
      },
      project: function(latlng) {
        return this.projection.project(latlng);
      },
      unproject: function(point) {
        return this.projection.unproject(point);
      },
      scale: function(zoom2) {
        return 256 * Math.pow(2, zoom2);
      },
      zoom: function(scale2) {
        return Math.log(scale2 / 256) / Math.LN2;
      },
      getProjectedBounds: function(zoom2) {
        if (this.infinite) {
          return null;
        }
        var b2 = this.projection.bounds, s2 = this.scale(zoom2), min = this.transformation.transform(b2.min, s2), max = this.transformation.transform(b2.max, s2);
        return new Bounds(min, max);
      },
      infinite: false,
      wrapLatLng: function(latlng) {
        var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
        return new LatLng(lat, lng, alt);
      },
      wrapLatLngBounds: function(bounds) {
        var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
        if (latShift === 0 && lngShift === 0) {
          return bounds;
        }
        var sw = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne2.lat - latShift, ne2.lng - lngShift);
        return new LatLngBounds(newSw, newNe);
      }
    };
    var Earth = extend2({}, CRS, {
      wrapLng: [-180, 180],
      R: 6371e3,
      distance: function(latlng1, latlng2) {
        var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a2 = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c2 = 2 * Math.atan2(Math.sqrt(a2), Math.sqrt(1 - a2));
        return this.R * c2;
      }
    });
    var earthRadius = 6378137;
    var SphericalMercator = {
      R: earthRadius,
      MAX_LATITUDE: 85.0511287798,
      project: function(latlng) {
        var d2 = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d2);
        return new Point(this.R * latlng.lng * d2, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
      },
      unproject: function(point) {
        var d2 = 180 / Math.PI;
        return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d2, point.x * d2 / this.R);
      },
      bounds: function() {
        var d2 = earthRadius * Math.PI;
        return new Bounds([-d2, -d2], [d2, d2]);
      }()
    };
    function Transformation(a2, b2, c2, d2) {
      if (isArray(a2)) {
        this._a = a2[0];
        this._b = a2[1];
        this._c = a2[2];
        this._d = a2[3];
        return;
      }
      this._a = a2;
      this._b = b2;
      this._c = c2;
      this._d = d2;
    }
    Transformation.prototype = {
      transform: function(point, scale2) {
        return this._transform(point.clone(), scale2);
      },
      _transform: function(point, scale2) {
        scale2 = scale2 || 1;
        point.x = scale2 * (this._a * point.x + this._b);
        point.y = scale2 * (this._c * point.y + this._d);
        return point;
      },
      untransform: function(point, scale2) {
        scale2 = scale2 || 1;
        return new Point((point.x / scale2 - this._b) / this._a, (point.y / scale2 - this._d) / this._c);
      }
    };
    function toTransformation(a2, b2, c2, d2) {
      return new Transformation(a2, b2, c2, d2);
    }
    var EPSG3857 = extend2({}, Earth, {
      code: "EPSG:3857",
      projection: SphericalMercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG900913 = extend2({}, EPSG3857, {
      code: "EPSG:900913"
    });
    function svgCreate(name2) {
      return document.createElementNS("http://www.w3.org/2000/svg", name2);
    }
    function pointsToPath(rings, closed) {
      var str = "", i2, j2, len, len2, points, p2;
      for (i2 = 0, len = rings.length; i2 < len; i2++) {
        points = rings[i2];
        for (j2 = 0, len2 = points.length; j2 < len2; j2++) {
          p2 = points[j2];
          str += (j2 ? "L" : "M") + p2.x + " " + p2.y;
        }
        str += closed ? svg ? "z" : "x" : "";
      }
      return str || "M0 0";
    }
    var style$1 = document.documentElement.style;
    var ie2 = "ActiveXObject" in window;
    var ielt9 = ie2 && !document.addEventListener;
    var edge = "msLaunchUri" in navigator && !("documentMode" in document);
    var webkit = userAgentContains("webkit");
    var android = userAgentContains("android");
    var android23 = userAgentContains("android 2") || userAgentContains("android 3");
    var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
    var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
    var opera = !!window.opera;
    var chrome = !edge && userAgentContains("chrome");
    var gecko = userAgentContains("gecko") && !webkit && !opera && !ie2;
    var safari = !chrome && userAgentContains("safari");
    var phantom = userAgentContains("phantom");
    var opera12 = "OTransition" in style$1;
    var win = navigator.platform.indexOf("Win") === 0;
    var ie3d = ie2 && "transition" in style$1;
    var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
    var gecko3d = "MozPerspective" in style$1;
    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
    var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
    var mobileWebkit = mobile && webkit;
    var mobileWebkit3d = mobile && webkit3d;
    var msPointer = !window.PointerEvent && window.MSPointerEvent;
    var pointer = !!(window.PointerEvent || msPointer);
    var touch = !window.L_NO_TOUCH && (pointer || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch);
    var mobileOpera = mobile && opera;
    var mobileGecko = mobile && gecko;
    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
    var passiveEvents = function() {
      var supportsPassiveOption = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function() {
            supportsPassiveOption = true;
          }
        });
        window.addEventListener("testPassiveEventSupport", falseFn, opts);
        window.removeEventListener("testPassiveEventSupport", falseFn, opts);
      } catch (e2) {
      }
      return supportsPassiveOption;
    }();
    var canvas = function() {
      return !!document.createElement("canvas").getContext;
    }();
    var svg = !!(document.createElementNS && svgCreate("svg").createSVGRect);
    var vml = !svg && function() {
      try {
        var div = document.createElement("div");
        div.innerHTML = '<v:shape adj="1"/>';
        var shape = div.firstChild;
        shape.style.behavior = "url(#default#VML)";
        return shape && typeof shape.adj === "object";
      } catch (e2) {
        return false;
      }
    }();
    function userAgentContains(str) {
      return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }
    var Browser = {
      ie: ie2,
      ielt9,
      edge,
      webkit,
      android,
      android23,
      androidStock,
      opera,
      chrome,
      gecko,
      safari,
      phantom,
      opera12,
      win,
      ie3d,
      webkit3d,
      gecko3d,
      any3d,
      mobile,
      mobileWebkit,
      mobileWebkit3d,
      msPointer,
      pointer,
      touch,
      mobileOpera,
      mobileGecko,
      retina,
      passiveEvents,
      canvas,
      svg,
      vml
    };
    var POINTER_DOWN = msPointer ? "MSPointerDown" : "pointerdown";
    var POINTER_MOVE = msPointer ? "MSPointerMove" : "pointermove";
    var POINTER_UP = msPointer ? "MSPointerUp" : "pointerup";
    var POINTER_CANCEL = msPointer ? "MSPointerCancel" : "pointercancel";
    var _pointers = {};
    var _pointerDocListener = false;
    function addPointerListener(obj, type, handler, id) {
      if (type === "touchstart") {
        _addPointerStart(obj, handler, id);
      } else if (type === "touchmove") {
        _addPointerMove(obj, handler, id);
      } else if (type === "touchend") {
        _addPointerEnd(obj, handler, id);
      }
      return this;
    }
    function removePointerListener(obj, type, id) {
      var handler = obj["_leaflet_" + type + id];
      if (type === "touchstart") {
        obj.removeEventListener(POINTER_DOWN, handler, false);
      } else if (type === "touchmove") {
        obj.removeEventListener(POINTER_MOVE, handler, false);
      } else if (type === "touchend") {
        obj.removeEventListener(POINTER_UP, handler, false);
        obj.removeEventListener(POINTER_CANCEL, handler, false);
      }
      return this;
    }
    function _addPointerStart(obj, handler, id) {
      var onDown = bind(function(e2) {
        if (e2.MSPOINTER_TYPE_TOUCH && e2.pointerType === e2.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e2);
        }
        _handlePointer(e2, handler);
      });
      obj["_leaflet_touchstart" + id] = onDown;
      obj.addEventListener(POINTER_DOWN, onDown, false);
      if (!_pointerDocListener) {
        document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
        document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
        document.addEventListener(POINTER_UP, _globalPointerUp, true);
        document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
        _pointerDocListener = true;
      }
    }
    function _globalPointerDown(e2) {
      _pointers[e2.pointerId] = e2;
    }
    function _globalPointerMove(e2) {
      if (_pointers[e2.pointerId]) {
        _pointers[e2.pointerId] = e2;
      }
    }
    function _globalPointerUp(e2) {
      delete _pointers[e2.pointerId];
    }
    function _handlePointer(e2, handler) {
      e2.touches = [];
      for (var i2 in _pointers) {
        e2.touches.push(_pointers[i2]);
      }
      e2.changedTouches = [e2];
      handler(e2);
    }
    function _addPointerMove(obj, handler, id) {
      var onMove = function(e2) {
        if (e2.pointerType === (e2.MSPOINTER_TYPE_MOUSE || "mouse") && e2.buttons === 0) {
          return;
        }
        _handlePointer(e2, handler);
      };
      obj["_leaflet_touchmove" + id] = onMove;
      obj.addEventListener(POINTER_MOVE, onMove, false);
    }
    function _addPointerEnd(obj, handler, id) {
      var onUp = function(e2) {
        _handlePointer(e2, handler);
      };
      obj["_leaflet_touchend" + id] = onUp;
      obj.addEventListener(POINTER_UP, onUp, false);
      obj.addEventListener(POINTER_CANCEL, onUp, false);
    }
    var _touchstart = msPointer ? "MSPointerDown" : pointer ? "pointerdown" : "touchstart";
    var _touchend = msPointer ? "MSPointerUp" : pointer ? "pointerup" : "touchend";
    var _pre = "_leaflet_";
    function addDoubleTapListener(obj, handler, id) {
      var last, touch$$1, doubleTap = false, delay = 250;
      function onTouchStart(e2) {
        if (pointer) {
          if (!e2.isPrimary) {
            return;
          }
          if (e2.pointerType === "mouse") {
            return;
          }
        } else if (e2.touches.length > 1) {
          return;
        }
        var now3 = Date.now(), delta = now3 - (last || now3);
        touch$$1 = e2.touches ? e2.touches[0] : e2;
        doubleTap = delta > 0 && delta <= delay;
        last = now3;
      }
      function onTouchEnd(e2) {
        if (doubleTap && !touch$$1.cancelBubble) {
          if (pointer) {
            if (e2.pointerType === "mouse") {
              return;
            }
            var newTouch = {}, prop, i2;
            for (i2 in touch$$1) {
              prop = touch$$1[i2];
              newTouch[i2] = prop && prop.bind ? prop.bind(touch$$1) : prop;
            }
            touch$$1 = newTouch;
          }
          touch$$1.type = "dblclick";
          touch$$1.button = 0;
          handler(touch$$1);
          last = null;
        }
      }
      obj[_pre + _touchstart + id] = onTouchStart;
      obj[_pre + _touchend + id] = onTouchEnd;
      obj[_pre + "dblclick" + id] = handler;
      obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {passive: false} : false);
      obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {passive: false} : false);
      obj.addEventListener("dblclick", handler, false);
      return this;
    }
    function removeDoubleTapListener(obj, id) {
      var touchstart = obj[_pre + _touchstart + id], touchend = obj[_pre + _touchend + id], dblclick = obj[_pre + "dblclick" + id];
      obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {passive: false} : false);
      obj.removeEventListener(_touchend, touchend, passiveEvents ? {passive: false} : false);
      obj.removeEventListener("dblclick", dblclick, false);
      return this;
    }
    var TRANSFORM = testProp(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
    var TRANSITION = testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
    function get(id) {
      return typeof id === "string" ? document.getElementById(id) : id;
    }
    function getStyle(el2, style) {
      var value = el2.style[style] || el2.currentStyle && el2.currentStyle[style];
      if ((!value || value === "auto") && document.defaultView) {
        var css7 = document.defaultView.getComputedStyle(el2, null);
        value = css7 ? css7[style] : null;
      }
      return value === "auto" ? null : value;
    }
    function create$1(tagName, className, container) {
      var el2 = document.createElement(tagName);
      el2.className = className || "";
      if (container) {
        container.appendChild(el2);
      }
      return el2;
    }
    function remove(el2) {
      var parent = el2.parentNode;
      if (parent) {
        parent.removeChild(el2);
      }
    }
    function empty(el2) {
      while (el2.firstChild) {
        el2.removeChild(el2.firstChild);
      }
    }
    function toFront(el2) {
      var parent = el2.parentNode;
      if (parent && parent.lastChild !== el2) {
        parent.appendChild(el2);
      }
    }
    function toBack(el2) {
      var parent = el2.parentNode;
      if (parent && parent.firstChild !== el2) {
        parent.insertBefore(el2, parent.firstChild);
      }
    }
    function hasClass(el2, name2) {
      if (el2.classList !== void 0) {
        return el2.classList.contains(name2);
      }
      var className = getClass(el2);
      return className.length > 0 && new RegExp("(^|\\s)" + name2 + "(\\s|$)").test(className);
    }
    function addClass(el2, name2) {
      if (el2.classList !== void 0) {
        var classes = splitWords(name2);
        for (var i2 = 0, len = classes.length; i2 < len; i2++) {
          el2.classList.add(classes[i2]);
        }
      } else if (!hasClass(el2, name2)) {
        var className = getClass(el2);
        setClass(el2, (className ? className + " " : "") + name2);
      }
    }
    function removeClass(el2, name2) {
      if (el2.classList !== void 0) {
        el2.classList.remove(name2);
      } else {
        setClass(el2, trim2((" " + getClass(el2) + " ").replace(" " + name2 + " ", " ")));
      }
    }
    function setClass(el2, name2) {
      if (el2.className.baseVal === void 0) {
        el2.className = name2;
      } else {
        el2.className.baseVal = name2;
      }
    }
    function getClass(el2) {
      if (el2.correspondingElement) {
        el2 = el2.correspondingElement;
      }
      return el2.className.baseVal === void 0 ? el2.className : el2.className.baseVal;
    }
    function setOpacity(el2, value) {
      if ("opacity" in el2.style) {
        el2.style.opacity = value;
      } else if ("filter" in el2.style) {
        _setOpacityIE(el2, value);
      }
    }
    function _setOpacityIE(el2, value) {
      var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
      try {
        filter = el2.filters.item(filterName);
      } catch (e2) {
        if (value === 1) {
          return;
        }
      }
      value = Math.round(value * 100);
      if (filter) {
        filter.Enabled = value !== 100;
        filter.Opacity = value;
      } else {
        el2.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
      }
    }
    function testProp(props) {
      var style = document.documentElement.style;
      for (var i2 = 0; i2 < props.length; i2++) {
        if (props[i2] in style) {
          return props[i2];
        }
      }
      return false;
    }
    function setTransform(el2, offset, scale2) {
      var pos = offset || new Point(0, 0);
      el2.style[TRANSFORM] = (ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
    }
    function setPosition(el2, point) {
      el2._leaflet_pos = point;
      if (any3d) {
        setTransform(el2, point);
      } else {
        el2.style.left = point.x + "px";
        el2.style.top = point.y + "px";
      }
    }
    function getPosition(el2) {
      return el2._leaflet_pos || new Point(0, 0);
    }
    var disableTextSelection;
    var enableTextSelection;
    var _userSelect;
    if ("onselectstart" in document) {
      disableTextSelection = function() {
        on(window, "selectstart", preventDefault);
      };
      enableTextSelection = function() {
        off(window, "selectstart", preventDefault);
      };
    } else {
      var userSelectProperty = testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
      disableTextSelection = function() {
        if (userSelectProperty) {
          var style = document.documentElement.style;
          _userSelect = style[userSelectProperty];
          style[userSelectProperty] = "none";
        }
      };
      enableTextSelection = function() {
        if (userSelectProperty) {
          document.documentElement.style[userSelectProperty] = _userSelect;
          _userSelect = void 0;
        }
      };
    }
    function disableImageDrag() {
      on(window, "dragstart", preventDefault);
    }
    function enableImageDrag() {
      off(window, "dragstart", preventDefault);
    }
    var _outlineElement, _outlineStyle;
    function preventOutline(element) {
      while (element.tabIndex === -1) {
        element = element.parentNode;
      }
      if (!element.style) {
        return;
      }
      restoreOutline();
      _outlineElement = element;
      _outlineStyle = element.style.outline;
      element.style.outline = "none";
      on(window, "keydown", restoreOutline);
    }
    function restoreOutline() {
      if (!_outlineElement) {
        return;
      }
      _outlineElement.style.outline = _outlineStyle;
      _outlineElement = void 0;
      _outlineStyle = void 0;
      off(window, "keydown", restoreOutline);
    }
    function getSizedParentNode(element) {
      do {
        element = element.parentNode;
      } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
      return element;
    }
    function getScale(element) {
      var rect = element.getBoundingClientRect();
      return {
        x: rect.width / element.offsetWidth || 1,
        y: rect.height / element.offsetHeight || 1,
        boundingClientRect: rect
      };
    }
    var DomUtil = {
      TRANSFORM,
      TRANSITION,
      TRANSITION_END,
      get,
      getStyle,
      create: create$1,
      remove,
      empty,
      toFront,
      toBack,
      hasClass,
      addClass,
      removeClass,
      setClass,
      getClass,
      setOpacity,
      testProp,
      setTransform,
      setPosition,
      getPosition,
      disableTextSelection,
      enableTextSelection,
      disableImageDrag,
      enableImageDrag,
      preventOutline,
      restoreOutline,
      getSizedParentNode,
      getScale
    };
    function on(obj, types, fn, context) {
      if (typeof types === "object") {
        for (var type in types) {
          addOne(obj, type, types[type], fn);
        }
      } else {
        types = splitWords(types);
        for (var i2 = 0, len = types.length; i2 < len; i2++) {
          addOne(obj, types[i2], fn, context);
        }
      }
      return this;
    }
    var eventsKey = "_leaflet_events";
    function off(obj, types, fn, context) {
      if (typeof types === "object") {
        for (var type in types) {
          removeOne(obj, type, types[type], fn);
        }
      } else if (types) {
        types = splitWords(types);
        for (var i2 = 0, len = types.length; i2 < len; i2++) {
          removeOne(obj, types[i2], fn, context);
        }
      } else {
        for (var j2 in obj[eventsKey]) {
          removeOne(obj, j2, obj[eventsKey][j2]);
        }
        delete obj[eventsKey];
      }
      return this;
    }
    function browserFiresNativeDblClick() {
      if (pointer) {
        return !(edge || safari);
      }
    }
    var mouseSubst = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel" in window) && "mousewheel"
    };
    function addOne(obj, type, fn, context) {
      var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
      if (obj[eventsKey] && obj[eventsKey][id]) {
        return this;
      }
      var handler = function(e2) {
        return fn.call(context || obj, e2 || window.event);
      };
      var originalHandler = handler;
      if (pointer && type.indexOf("touch") === 0) {
        addPointerListener(obj, type, handler, id);
      } else if (touch && type === "dblclick" && !browserFiresNativeDblClick()) {
        addDoubleTapListener(obj, handler, id);
      } else if ("addEventListener" in obj) {
        if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
          obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {passive: false} : false);
        } else if (type === "mouseenter" || type === "mouseleave") {
          handler = function(e2) {
            e2 = e2 || window.event;
            if (isExternalTarget(obj, e2)) {
              originalHandler(e2);
            }
          };
          obj.addEventListener(mouseSubst[type], handler, false);
        } else {
          obj.addEventListener(type, originalHandler, false);
        }
      } else if ("attachEvent" in obj) {
        obj.attachEvent("on" + type, handler);
      }
      obj[eventsKey] = obj[eventsKey] || {};
      obj[eventsKey][id] = handler;
    }
    function removeOne(obj, type, fn, context) {
      var id = type + stamp(fn) + (context ? "_" + stamp(context) : ""), handler = obj[eventsKey] && obj[eventsKey][id];
      if (!handler) {
        return this;
      }
      if (pointer && type.indexOf("touch") === 0) {
        removePointerListener(obj, type, id);
      } else if (touch && type === "dblclick" && !browserFiresNativeDblClick()) {
        removeDoubleTapListener(obj, id);
      } else if ("removeEventListener" in obj) {
        obj.removeEventListener(mouseSubst[type] || type, handler, false);
      } else if ("detachEvent" in obj) {
        obj.detachEvent("on" + type, handler);
      }
      obj[eventsKey][id] = null;
    }
    function stopPropagation(e2) {
      if (e2.stopPropagation) {
        e2.stopPropagation();
      } else if (e2.originalEvent) {
        e2.originalEvent._stopped = true;
      } else {
        e2.cancelBubble = true;
      }
      skipped(e2);
      return this;
    }
    function disableScrollPropagation(el2) {
      addOne(el2, "wheel", stopPropagation);
      return this;
    }
    function disableClickPropagation(el2) {
      on(el2, "mousedown touchstart dblclick", stopPropagation);
      addOne(el2, "click", fakeStop);
      return this;
    }
    function preventDefault(e2) {
      if (e2.preventDefault) {
        e2.preventDefault();
      } else {
        e2.returnValue = false;
      }
      return this;
    }
    function stop(e2) {
      preventDefault(e2);
      stopPropagation(e2);
      return this;
    }
    function getMousePosition(e2, container) {
      if (!container) {
        return new Point(e2.clientX, e2.clientY);
      }
      var scale2 = getScale(container), offset = scale2.boundingClientRect;
      return new Point((e2.clientX - offset.left) / scale2.x - container.clientLeft, (e2.clientY - offset.top) / scale2.y - container.clientTop);
    }
    var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1;
    function getWheelDelta(e2) {
      return edge ? e2.wheelDeltaY / 2 : e2.deltaY && e2.deltaMode === 0 ? -e2.deltaY / wheelPxFactor : e2.deltaY && e2.deltaMode === 1 ? -e2.deltaY * 20 : e2.deltaY && e2.deltaMode === 2 ? -e2.deltaY * 60 : e2.deltaX || e2.deltaZ ? 0 : e2.wheelDelta ? (e2.wheelDeltaY || e2.wheelDelta) / 2 : e2.detail && Math.abs(e2.detail) < 32765 ? -e2.detail * 20 : e2.detail ? e2.detail / -32765 * 60 : 0;
    }
    var skipEvents = {};
    function fakeStop(e2) {
      skipEvents[e2.type] = true;
    }
    function skipped(e2) {
      var events = skipEvents[e2.type];
      skipEvents[e2.type] = false;
      return events;
    }
    function isExternalTarget(el2, e2) {
      var related = e2.relatedTarget;
      if (!related) {
        return true;
      }
      try {
        while (related && related !== el2) {
          related = related.parentNode;
        }
      } catch (err) {
        return false;
      }
      return related !== el2;
    }
    var DomEvent = {
      on,
      off,
      stopPropagation,
      disableScrollPropagation,
      disableClickPropagation,
      preventDefault,
      stop,
      getMousePosition,
      getWheelDelta,
      fakeStop,
      skipped,
      isExternalTarget,
      addListener: on,
      removeListener: off
    };
    var PosAnimation = Evented.extend({
      run: function(el2, newPos, duration, easeLinearity) {
        this.stop();
        this._el = el2;
        this._inProgress = true;
        this._duration = duration || 0.25;
        this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
        this._startPos = getPosition(el2);
        this._offset = newPos.subtract(this._startPos);
        this._startTime = +new Date();
        this.fire("start");
        this._animate();
      },
      stop: function() {
        if (!this._inProgress) {
          return;
        }
        this._step(true);
        this._complete();
      },
      _animate: function() {
        this._animId = requestAnimFrame(this._animate, this);
        this._step();
      },
      _step: function(round) {
        var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
        if (elapsed < duration) {
          this._runFrame(this._easeOut(elapsed / duration), round);
        } else {
          this._runFrame(1);
          this._complete();
        }
      },
      _runFrame: function(progress, round) {
        var pos = this._startPos.add(this._offset.multiplyBy(progress));
        if (round) {
          pos._round();
        }
        setPosition(this._el, pos);
        this.fire("step");
      },
      _complete: function() {
        cancelAnimFrame(this._animId);
        this._inProgress = false;
        this.fire("end");
      },
      _easeOut: function(t2) {
        return 1 - Math.pow(1 - t2, this._easeOutPower);
      }
    });
    var Map3 = Evented.extend({
      options: {
        crs: EPSG3857,
        center: void 0,
        zoom: void 0,
        minZoom: void 0,
        maxZoom: void 0,
        layers: [],
        maxBounds: void 0,
        renderer: void 0,
        zoomAnimation: true,
        zoomAnimationThreshold: 4,
        fadeAnimation: true,
        markerZoomAnimation: true,
        transform3DLimit: 8388608,
        zoomSnap: 1,
        zoomDelta: 1,
        trackResize: true
      },
      initialize: function(id, options2) {
        options2 = setOptions2(this, options2);
        this._handlers = [];
        this._layers = {};
        this._zoomBoundLayers = {};
        this._sizeChanged = true;
        this._initContainer(id);
        this._initLayout();
        this._onResize = bind(this._onResize, this);
        this._initEvents();
        if (options2.maxBounds) {
          this.setMaxBounds(options2.maxBounds);
        }
        if (options2.zoom !== void 0) {
          this._zoom = this._limitZoom(options2.zoom);
        }
        if (options2.center && options2.zoom !== void 0) {
          this.setView(toLatLng(options2.center), options2.zoom, {reset: true});
        }
        this.callInitHooks();
        this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation;
        if (this._zoomAnimated) {
          this._createAnimProxy();
          on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
        }
        this._addLayers(this.options.layers);
      },
      setView: function(center, zoom2, options2) {
        zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
        center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
        options2 = options2 || {};
        this._stop();
        if (this._loaded && !options2.reset && options2 !== true) {
          if (options2.animate !== void 0) {
            options2.zoom = extend2({animate: options2.animate}, options2.zoom);
            options2.pan = extend2({animate: options2.animate, duration: options2.duration}, options2.pan);
          }
          var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options2.zoom) : this._tryAnimatedPan(center, options2.pan);
          if (moved) {
            clearTimeout(this._sizeTimer);
            return this;
          }
        }
        this._resetView(center, zoom2);
        return this;
      },
      setZoom: function(zoom2, options2) {
        if (!this._loaded) {
          this._zoom = zoom2;
          return this;
        }
        return this.setView(this.getCenter(), zoom2, {zoom: options2});
      },
      zoomIn: function(delta, options2) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom + delta, options2);
      },
      zoomOut: function(delta, options2) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom - delta, options2);
      },
      setZoomAround: function(latlng, zoom2, options2) {
        var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
        return this.setView(newCenter, zoom2, {zoom: options2});
      },
      _getBoundsCenterZoom: function(bounds, options2) {
        options2 = options2 || {};
        bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
        var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
        zoom2 = typeof options2.maxZoom === "number" ? Math.min(options2.maxZoom, zoom2) : zoom2;
        if (zoom2 === Infinity) {
          return {
            center: bounds.getCenter(),
            zoom: zoom2
          };
        }
        var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
        return {
          center,
          zoom: zoom2
        };
      },
      fitBounds: function(bounds, options2) {
        bounds = toLatLngBounds(bounds);
        if (!bounds.isValid()) {
          throw new Error("Bounds are not valid.");
        }
        var target = this._getBoundsCenterZoom(bounds, options2);
        return this.setView(target.center, target.zoom, options2);
      },
      fitWorld: function(options2) {
        return this.fitBounds([[-90, -180], [90, 180]], options2);
      },
      panTo: function(center, options2) {
        return this.setView(center, this._zoom, {pan: options2});
      },
      panBy: function(offset, options2) {
        offset = toPoint(offset).round();
        options2 = options2 || {};
        if (!offset.x && !offset.y) {
          return this.fire("moveend");
        }
        if (options2.animate !== true && !this.getSize().contains(offset)) {
          this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
          return this;
        }
        if (!this._panAnim) {
          this._panAnim = new PosAnimation();
          this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this);
        }
        if (!options2.noMoveStart) {
          this.fire("movestart");
        }
        if (options2.animate !== false) {
          addClass(this._mapPane, "leaflet-pan-anim");
          var newPos = this._getMapPanePos().subtract(offset).round();
          this._panAnim.run(this._mapPane, newPos, options2.duration || 0.25, options2.easeLinearity);
        } else {
          this._rawPanBy(offset);
          this.fire("move").fire("moveend");
        }
        return this;
      },
      flyTo: function(targetCenter, targetZoom, options2) {
        options2 = options2 || {};
        if (options2.animate === false || !any3d) {
          return this.setView(targetCenter, targetZoom, options2);
        }
        this._stop();
        var from2 = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
        targetCenter = toLatLng(targetCenter);
        targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
        var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from2) || 1, rho = 1.42, rho2 = rho * rho;
        function r2(i2) {
          var s1 = i2 ? -1 : 1, s2 = i2 ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b2 = t1 / b1, sq = Math.sqrt(b2 * b2 + 1) - b2;
          var log = sq < 1e-9 ? -18 : Math.log(sq);
          return log;
        }
        function sinh(n2) {
          return (Math.exp(n2) - Math.exp(-n2)) / 2;
        }
        function cosh(n2) {
          return (Math.exp(n2) + Math.exp(-n2)) / 2;
        }
        function tanh(n2) {
          return sinh(n2) / cosh(n2);
        }
        var r0 = r2(0);
        function w3(s2) {
          return w0 * (cosh(r0) / cosh(r0 + rho * s2));
        }
        function u2(s2) {
          return w0 * (cosh(r0) * tanh(r0 + rho * s2) - sinh(r0)) / rho2;
        }
        function easeOut(t2) {
          return 1 - Math.pow(1 - t2, 1.5);
        }
        var start = Date.now(), S2 = (r2(1) - r0) / rho, duration = options2.duration ? 1e3 * options2.duration : 1e3 * S2 * 0.8;
        function frame() {
          var t2 = (Date.now() - start) / duration, s2 = easeOut(t2) * S2;
          if (t2 <= 1) {
            this._flyToFrame = requestAnimFrame(frame, this);
            this._move(this.unproject(from2.add(to.subtract(from2).multiplyBy(u2(s2) / u1)), startZoom), this.getScaleZoom(w0 / w3(s2), startZoom), {flyTo: true});
          } else {
            this._move(targetCenter, targetZoom)._moveEnd(true);
          }
        }
        this._moveStart(true, options2.noMoveStart);
        frame.call(this);
        return this;
      },
      flyToBounds: function(bounds, options2) {
        var target = this._getBoundsCenterZoom(bounds, options2);
        return this.flyTo(target.center, target.zoom, options2);
      },
      setMaxBounds: function(bounds) {
        bounds = toLatLngBounds(bounds);
        if (!bounds.isValid()) {
          this.options.maxBounds = null;
          return this.off("moveend", this._panInsideMaxBounds);
        } else if (this.options.maxBounds) {
          this.off("moveend", this._panInsideMaxBounds);
        }
        this.options.maxBounds = bounds;
        if (this._loaded) {
          this._panInsideMaxBounds();
        }
        return this.on("moveend", this._panInsideMaxBounds);
      },
      setMinZoom: function(zoom2) {
        var oldZoom = this.options.minZoom;
        this.options.minZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() < this.options.minZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      setMaxZoom: function(zoom2) {
        var oldZoom = this.options.maxZoom;
        this.options.maxZoom = zoom2;
        if (this._loaded && oldZoom !== zoom2) {
          this.fire("zoomlevelschange");
          if (this.getZoom() > this.options.maxZoom) {
            return this.setZoom(zoom2);
          }
        }
        return this;
      },
      panInsideBounds: function(bounds, options2) {
        this._enforcingBounds = true;
        var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
        if (!center.equals(newCenter)) {
          this.panTo(newCenter, options2);
        }
        this._enforcingBounds = false;
        return this;
      },
      panInside: function(latlng, options2) {
        options2 = options2 || {};
        var paddingTL = toPoint(options2.paddingTopLeft || options2.padding || [0, 0]), paddingBR = toPoint(options2.paddingBottomRight || options2.padding || [0, 0]), center = this.getCenter(), pixelCenter = this.project(center), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), halfPixelBounds = pixelBounds.getSize().divideBy(2), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);
        if (!paddedBounds.contains(pixelPoint)) {
          this._enforcingBounds = true;
          var diff = pixelCenter.subtract(pixelPoint), newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);
          if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
            newCenter.x = pixelCenter.x - diff.x;
            if (diff.x > 0) {
              newCenter.x += halfPixelBounds.x - paddingTL.x;
            } else {
              newCenter.x -= halfPixelBounds.x - paddingBR.x;
            }
          }
          if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
            newCenter.y = pixelCenter.y - diff.y;
            if (diff.y > 0) {
              newCenter.y += halfPixelBounds.y - paddingTL.y;
            } else {
              newCenter.y -= halfPixelBounds.y - paddingBR.y;
            }
          }
          this.panTo(this.unproject(newCenter), options2);
          this._enforcingBounds = false;
        }
        return this;
      },
      invalidateSize: function(options2) {
        if (!this._loaded) {
          return this;
        }
        options2 = extend2({
          animate: false,
          pan: true
        }, options2 === true ? {animate: true} : options2);
        var oldSize = this.getSize();
        this._sizeChanged = true;
        this._lastCenter = null;
        var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
        if (!offset.x && !offset.y) {
          return this;
        }
        if (options2.animate && options2.pan) {
          this.panBy(offset);
        } else {
          if (options2.pan) {
            this._rawPanBy(offset);
          }
          this.fire("move");
          if (options2.debounceMoveend) {
            clearTimeout(this._sizeTimer);
            this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
          } else {
            this.fire("moveend");
          }
        }
        return this.fire("resize", {
          oldSize,
          newSize
        });
      },
      stop: function() {
        this.setZoom(this._limitZoom(this._zoom));
        if (!this.options.zoomSnap) {
          this.fire("viewreset");
        }
        return this._stop();
      },
      locate: function(options2) {
        options2 = this._locateOptions = extend2({
          timeout: 1e4,
          watch: false
        }, options2);
        if (!("geolocation" in navigator)) {
          this._handleGeolocationError({
            code: 0,
            message: "Geolocation not supported."
          });
          return this;
        }
        var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
        if (options2.watch) {
          this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options2);
        } else {
          navigator.geolocation.getCurrentPosition(onResponse, onError, options2);
        }
        return this;
      },
      stopLocate: function() {
        if (navigator.geolocation && navigator.geolocation.clearWatch) {
          navigator.geolocation.clearWatch(this._locationWatchId);
        }
        if (this._locateOptions) {
          this._locateOptions.setView = false;
        }
        return this;
      },
      _handleGeolocationError: function(error) {
        var c2 = error.code, message = error.message || (c2 === 1 ? "permission denied" : c2 === 2 ? "position unavailable" : "timeout");
        if (this._locateOptions.setView && !this._loaded) {
          this.fitWorld();
        }
        this.fire("locationerror", {
          code: c2,
          message: "Geolocation error: " + message + "."
        });
      },
      _handleGeolocationResponse: function(pos) {
        var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options2 = this._locateOptions;
        if (options2.setView) {
          var zoom2 = this.getBoundsZoom(bounds);
          this.setView(latlng, options2.maxZoom ? Math.min(zoom2, options2.maxZoom) : zoom2);
        }
        var data2 = {
          latlng,
          bounds,
          timestamp: pos.timestamp
        };
        for (var i2 in pos.coords) {
          if (typeof pos.coords[i2] === "number") {
            data2[i2] = pos.coords[i2];
          }
        }
        this.fire("locationfound", data2);
      },
      addHandler: function(name2, HandlerClass) {
        if (!HandlerClass) {
          return this;
        }
        var handler = this[name2] = new HandlerClass(this);
        this._handlers.push(handler);
        if (this.options[name2]) {
          handler.enable();
        }
        return this;
      },
      remove: function() {
        this._initEvents(true);
        this.off("moveend", this._panInsideMaxBounds);
        if (this._containerId !== this._container._leaflet_id) {
          throw new Error("Map container is being reused by another instance");
        }
        try {
          delete this._container._leaflet_id;
          delete this._containerId;
        } catch (e2) {
          this._container._leaflet_id = void 0;
          this._containerId = void 0;
        }
        if (this._locationWatchId !== void 0) {
          this.stopLocate();
        }
        this._stop();
        remove(this._mapPane);
        if (this._clearControlPos) {
          this._clearControlPos();
        }
        if (this._resizeRequest) {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = null;
        }
        this._clearHandlers();
        if (this._loaded) {
          this.fire("unload");
        }
        var i2;
        for (i2 in this._layers) {
          this._layers[i2].remove();
        }
        for (i2 in this._panes) {
          remove(this._panes[i2]);
        }
        this._layers = [];
        this._panes = [];
        delete this._mapPane;
        delete this._renderer;
        return this;
      },
      createPane: function(name2, container) {
        var className = "leaflet-pane" + (name2 ? " leaflet-" + name2.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
        if (name2) {
          this._panes[name2] = pane;
        }
        return pane;
      },
      getCenter: function() {
        this._checkIfLoaded();
        if (this._lastCenter && !this._moved()) {
          return this._lastCenter;
        }
        return this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      getZoom: function() {
        return this._zoom;
      },
      getBounds: function() {
        var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne2 = this.unproject(bounds.getTopRight());
        return new LatLngBounds(sw, ne2);
      },
      getMinZoom: function() {
        return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      getMaxZoom: function() {
        return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
      },
      getBoundsZoom: function(bounds, inside, padding) {
        bounds = toLatLngBounds(bounds);
        padding = toPoint(padding || [0, 0]);
        var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se2 = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se2, zoom2), this.project(nw, zoom2)).getSize(), snap = any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
        zoom2 = this.getScaleZoom(scale2, zoom2);
        if (snap) {
          zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
          zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max, zoom2));
      },
      getSize: function() {
        if (!this._size || this._sizeChanged) {
          this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
          this._sizeChanged = false;
        }
        return this._size.clone();
      },
      getPixelBounds: function(center, zoom2) {
        var topLeftPoint = this._getTopLeftPoint(center, zoom2);
        return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
      },
      getPixelOrigin: function() {
        this._checkIfLoaded();
        return this._pixelOrigin;
      },
      getPixelWorldBounds: function(zoom2) {
        return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
      },
      getPane: function(pane) {
        return typeof pane === "string" ? this._panes[pane] : pane;
      },
      getPanes: function() {
        return this._panes;
      },
      getContainer: function() {
        return this._container;
      },
      getZoomScale: function(toZoom, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        return crs.scale(toZoom) / crs.scale(fromZoom);
      },
      getScaleZoom: function(scale2, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
        var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
        return isNaN(zoom2) ? Infinity : zoom2;
      },
      project: function(latlng, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
      },
      unproject: function(point, zoom2) {
        zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
        return this.options.crs.pointToLatLng(toPoint(point), zoom2);
      },
      layerPointToLatLng: function(point) {
        var projectedPoint = toPoint(point).add(this.getPixelOrigin());
        return this.unproject(projectedPoint);
      },
      latLngToLayerPoint: function(latlng) {
        var projectedPoint = this.project(toLatLng(latlng))._round();
        return projectedPoint._subtract(this.getPixelOrigin());
      },
      wrapLatLng: function(latlng) {
        return this.options.crs.wrapLatLng(toLatLng(latlng));
      },
      wrapLatLngBounds: function(latlng) {
        return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
      },
      distance: function(latlng1, latlng2) {
        return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
      },
      containerPointToLayerPoint: function(point) {
        return toPoint(point).subtract(this._getMapPanePos());
      },
      layerPointToContainerPoint: function(point) {
        return toPoint(point).add(this._getMapPanePos());
      },
      containerPointToLatLng: function(point) {
        var layerPoint = this.containerPointToLayerPoint(toPoint(point));
        return this.layerPointToLatLng(layerPoint);
      },
      latLngToContainerPoint: function(latlng) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
      },
      mouseEventToContainerPoint: function(e2) {
        return getMousePosition(e2, this._container);
      },
      mouseEventToLayerPoint: function(e2) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e2));
      },
      mouseEventToLatLng: function(e2) {
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(e2));
      },
      _initContainer: function(id) {
        var container = this._container = get(id);
        if (!container) {
          throw new Error("Map container not found.");
        } else if (container._leaflet_id) {
          throw new Error("Map container is already initialized.");
        }
        on(container, "scroll", this._onScroll, this);
        this._containerId = stamp(container);
      },
      _initLayout: function() {
        var container = this._container;
        this._fadeAnimated = this.options.fadeAnimation && any3d;
        addClass(container, "leaflet-container" + (touch ? " leaflet-touch" : "") + (retina ? " leaflet-retina" : "") + (ielt9 ? " leaflet-oldie" : "") + (safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
        var position2 = getStyle(container, "position");
        if (position2 !== "absolute" && position2 !== "relative" && position2 !== "fixed") {
          container.style.position = "relative";
        }
        this._initPanes();
        if (this._initControlPos) {
          this._initControlPos();
        }
      },
      _initPanes: function() {
        var panes = this._panes = {};
        this._paneRenderers = {};
        this._mapPane = this.createPane("mapPane", this._container);
        setPosition(this._mapPane, new Point(0, 0));
        this.createPane("tilePane");
        this.createPane("shadowPane");
        this.createPane("overlayPane");
        this.createPane("markerPane");
        this.createPane("tooltipPane");
        this.createPane("popupPane");
        if (!this.options.markerZoomAnimation) {
          addClass(panes.markerPane, "leaflet-zoom-hide");
          addClass(panes.shadowPane, "leaflet-zoom-hide");
        }
      },
      _resetView: function(center, zoom2) {
        setPosition(this._mapPane, new Point(0, 0));
        var loading2 = !this._loaded;
        this._loaded = true;
        zoom2 = this._limitZoom(zoom2);
        this.fire("viewprereset");
        var zoomChanged = this._zoom !== zoom2;
        this._moveStart(zoomChanged, false)._move(center, zoom2)._moveEnd(zoomChanged);
        this.fire("viewreset");
        if (loading2) {
          this.fire("load");
        }
      },
      _moveStart: function(zoomChanged, noMoveStart) {
        if (zoomChanged) {
          this.fire("zoomstart");
        }
        if (!noMoveStart) {
          this.fire("movestart");
        }
        return this;
      },
      _move: function(center, zoom2, data2) {
        if (zoom2 === void 0) {
          zoom2 = this._zoom;
        }
        var zoomChanged = this._zoom !== zoom2;
        this._zoom = zoom2;
        this._lastCenter = center;
        this._pixelOrigin = this._getNewPixelOrigin(center);
        if (zoomChanged || data2 && data2.pinch) {
          this.fire("zoom", data2);
        }
        return this.fire("move", data2);
      },
      _moveEnd: function(zoomChanged) {
        if (zoomChanged) {
          this.fire("zoomend");
        }
        return this.fire("moveend");
      },
      _stop: function() {
        cancelAnimFrame(this._flyToFrame);
        if (this._panAnim) {
          this._panAnim.stop();
        }
        return this;
      },
      _rawPanBy: function(offset) {
        setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
      },
      _getZoomSpan: function() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function() {
        if (!this._enforcingBounds) {
          this.panInsideBounds(this.options.maxBounds);
        }
      },
      _checkIfLoaded: function() {
        if (!this._loaded) {
          throw new Error("Set map center and zoom first.");
        }
      },
      _initEvents: function(remove$$1) {
        this._targets = {};
        this._targets[stamp(this._container)] = this;
        var onOff = remove$$1 ? off : on;
        onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
        if (this.options.trackResize) {
          onOff(window, "resize", this._onResize, this);
        }
        if (any3d && this.options.transform3DLimit) {
          (remove$$1 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        }
      },
      _onResize: function() {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = requestAnimFrame(function() {
          this.invalidateSize({debounceMoveend: true});
        }, this);
      },
      _onScroll: function() {
        this._container.scrollTop = 0;
        this._container.scrollLeft = 0;
      },
      _onMoveEnd: function() {
        var pos = this._getMapPanePos();
        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
          this._resetView(this.getCenter(), this.getZoom());
        }
      },
      _findEventTargets: function(e2, type) {
        var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src2 = e2.target || e2.srcElement, dragging = false;
        while (src2) {
          target = this._targets[stamp(src2)];
          if (target && (type === "click" || type === "preclick") && !e2._simulated && this._draggableMoved(target)) {
            dragging = true;
            break;
          }
          if (target && target.listens(type, true)) {
            if (isHover && !isExternalTarget(src2, e2)) {
              break;
            }
            targets.push(target);
            if (isHover) {
              break;
            }
          }
          if (src2 === this._container) {
            break;
          }
          src2 = src2.parentNode;
        }
        if (!targets.length && !dragging && !isHover && isExternalTarget(src2, e2)) {
          targets = [this];
        }
        return targets;
      },
      _handleDOMEvent: function(e2) {
        if (!this._loaded || skipped(e2)) {
          return;
        }
        var type = e2.type;
        if (type === "mousedown" || type === "keypress" || type === "keyup" || type === "keydown") {
          preventOutline(e2.target || e2.srcElement);
        }
        this._fireDOMEvent(e2, type);
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(e2, type, targets) {
        if (e2.type === "click") {
          var synth = extend2({}, e2);
          synth.type = "preclick";
          this._fireDOMEvent(synth, synth.type, targets);
        }
        if (e2._stopped) {
          return;
        }
        targets = (targets || []).concat(this._findEventTargets(e2, type));
        if (!targets.length) {
          return;
        }
        var target = targets[0];
        if (type === "contextmenu" && target.listens(type, true)) {
          preventDefault(e2);
        }
        var data2 = {
          originalEvent: e2
        };
        if (e2.type !== "keypress" && e2.type !== "keydown" && e2.type !== "keyup") {
          var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
          data2.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e2);
          data2.layerPoint = this.containerPointToLayerPoint(data2.containerPoint);
          data2.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data2.layerPoint);
        }
        for (var i2 = 0; i2 < targets.length; i2++) {
          targets[i2].fire(type, data2, true);
          if (data2.originalEvent._stopped || targets[i2].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
            return;
          }
        }
      },
      _draggableMoved: function(obj) {
        obj = obj.dragging && obj.dragging.enabled() ? obj : this;
        return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function() {
        for (var i2 = 0, len = this._handlers.length; i2 < len; i2++) {
          this._handlers[i2].disable();
        }
      },
      whenReady: function(callback, context) {
        if (this._loaded) {
          callback.call(context || this, {target: this});
        } else {
          this.on("load", callback, context);
        }
        return this;
      },
      _getMapPanePos: function() {
        return getPosition(this._mapPane) || new Point(0, 0);
      },
      _moved: function() {
        var pos = this._getMapPanePos();
        return pos && !pos.equals([0, 0]);
      },
      _getTopLeftPoint: function(center, zoom2) {
        var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
        return pixelOrigin.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function(center, zoom2) {
        var viewHalf = this.getSize()._divideBy(2);
        return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function(latlng, zoom2, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom2);
        return this.project(latlng, zoom2)._subtract(topLeft);
      },
      _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom2);
        return toBounds([
          this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
          this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
        ]);
      },
      _getCenterLayerPoint: function() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      _getCenterOffset: function(latlng) {
        return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
      },
      _limitCenter: function(center, zoom2, bounds) {
        if (!bounds) {
          return center;
        }
        var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
        if (offset.round().equals([0, 0])) {
          return center;
        }
        return this.unproject(centerPoint.add(offset), zoom2);
      },
      _limitOffset: function(offset, bounds) {
        if (!bounds) {
          return offset;
        }
        var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
        return offset.add(this._getBoundsOffset(newBounds, bounds));
      },
      _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
        var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom2), this.project(maxBounds.getSouthWest(), zoom2)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
        return new Point(dx, dy);
      },
      _rebound: function(left, right) {
        return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
      },
      _limitZoom: function(zoom2) {
        var min = this.getMinZoom(), max = this.getMaxZoom(), snap = any3d ? this.options.zoomSnap : 1;
        if (snap) {
          zoom2 = Math.round(zoom2 / snap) * snap;
        }
        return Math.max(min, Math.min(max, zoom2));
      },
      _onPanTransitionStep: function() {
        this.fire("move");
      },
      _onPanTransitionEnd: function() {
        removeClass(this._mapPane, "leaflet-pan-anim");
        this.fire("moveend");
      },
      _tryAnimatedPan: function(center, options2) {
        var offset = this._getCenterOffset(center)._trunc();
        if ((options2 && options2.animate) !== true && !this.getSize().contains(offset)) {
          return false;
        }
        this.panBy(offset, options2);
        return true;
      },
      _createAnimProxy: function() {
        var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
        this._panes.mapPane.appendChild(proxy);
        this.on("zoomanim", function(e2) {
          var prop = TRANSFORM, transform2 = this._proxy.style[prop];
          setTransform(this._proxy, this.project(e2.center, e2.zoom), this.getZoomScale(e2.zoom, 1));
          if (transform2 === this._proxy.style[prop] && this._animatingZoom) {
            this._onZoomTransitionEnd();
          }
        }, this);
        this.on("load moveend", this._animMoveEnd, this);
        this._on("unload", this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function() {
        remove(this._proxy);
        this.off("load moveend", this._animMoveEnd, this);
        delete this._proxy;
      },
      _animMoveEnd: function() {
        var c2 = this.getCenter(), z2 = this.getZoom();
        setTransform(this._proxy, this.project(c2, z2), this.getZoomScale(z2, 1));
      },
      _catchTransitionEnd: function(e2) {
        if (this._animatingZoom && e2.propertyName.indexOf("transform") >= 0) {
          this._onZoomTransitionEnd();
        }
      },
      _nothingToAnimate: function() {
        return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
      },
      _tryAnimatedZoom: function(center, zoom2, options2) {
        if (this._animatingZoom) {
          return true;
        }
        options2 = options2 || {};
        if (!this._zoomAnimated || options2.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
          return false;
        }
        var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
        if (options2.animate !== true && !this.getSize().contains(offset)) {
          return false;
        }
        requestAnimFrame(function() {
          this._moveStart(true, false)._animateZoom(center, zoom2, true);
        }, this);
        return true;
      },
      _animateZoom: function(center, zoom2, startAnim, noUpdate) {
        if (!this._mapPane) {
          return;
        }
        if (startAnim) {
          this._animatingZoom = true;
          this._animateToCenter = center;
          this._animateToZoom = zoom2;
          addClass(this._mapPane, "leaflet-zoom-anim");
        }
        this.fire("zoomanim", {
          center,
          zoom: zoom2,
          noUpdate
        });
        setTimeout(bind(this._onZoomTransitionEnd, this), 250);
      },
      _onZoomTransitionEnd: function() {
        if (!this._animatingZoom) {
          return;
        }
        if (this._mapPane) {
          removeClass(this._mapPane, "leaflet-zoom-anim");
        }
        this._animatingZoom = false;
        this._move(this._animateToCenter, this._animateToZoom);
        requestAnimFrame(function() {
          this._moveEnd(true);
        }, this);
      }
    });
    function createMap(id, options2) {
      return new Map3(id, options2);
    }
    var Control3 = Class.extend({
      options: {
        position: "topright"
      },
      initialize: function(options2) {
        setOptions2(this, options2);
      },
      getPosition: function() {
        return this.options.position;
      },
      setPosition: function(position2) {
        var map = this._map;
        if (map) {
          map.removeControl(this);
        }
        this.options.position = position2;
        if (map) {
          map.addControl(this);
        }
        return this;
      },
      getContainer: function() {
        return this._container;
      },
      addTo: function(map) {
        this.remove();
        this._map = map;
        var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
        addClass(container, "leaflet-control");
        if (pos.indexOf("bottom") !== -1) {
          corner.insertBefore(container, corner.firstChild);
        } else {
          corner.appendChild(container);
        }
        this._map.on("unload", this.remove, this);
        return this;
      },
      remove: function() {
        if (!this._map) {
          return this;
        }
        remove(this._container);
        if (this.onRemove) {
          this.onRemove(this._map);
        }
        this._map.off("unload", this.remove, this);
        this._map = null;
        return this;
      },
      _refocusOnMap: function(e2) {
        if (this._map && e2 && e2.screenX > 0 && e2.screenY > 0) {
          this._map.getContainer().focus();
        }
      }
    });
    var control = function(options2) {
      return new Control3(options2);
    };
    Map3.include({
      addControl: function(control2) {
        control2.addTo(this);
        return this;
      },
      removeControl: function(control2) {
        control2.remove();
        return this;
      },
      _initControlPos: function() {
        var corners = this._controlCorners = {}, l2 = "leaflet-", container = this._controlContainer = create$1("div", l2 + "control-container", this._container);
        function createCorner(vSide, hSide) {
          var className = l2 + vSide + " " + l2 + hSide;
          corners[vSide + hSide] = create$1("div", className, container);
        }
        createCorner("top", "left");
        createCorner("top", "right");
        createCorner("bottom", "left");
        createCorner("bottom", "right");
      },
      _clearControlPos: function() {
        for (var i2 in this._controlCorners) {
          remove(this._controlCorners[i2]);
        }
        remove(this._controlContainer);
        delete this._controlCorners;
        delete this._controlContainer;
      }
    });
    var Layers2 = Control3.extend({
      options: {
        collapsed: true,
        position: "topright",
        autoZIndex: true,
        hideSingleBase: false,
        sortLayers: false,
        sortFunction: function(layerA, layerB, nameA, nameB) {
          return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
        }
      },
      initialize: function(baseLayers, overlays, options2) {
        setOptions2(this, options2);
        this._layerControlInputs = [];
        this._layers = [];
        this._lastZIndex = 0;
        this._handlingClick = false;
        for (var i2 in baseLayers) {
          this._addLayer(baseLayers[i2], i2);
        }
        for (i2 in overlays) {
          this._addLayer(overlays[i2], i2, true);
        }
      },
      onAdd: function(map) {
        this._initLayout();
        this._update();
        this._map = map;
        map.on("zoomend", this._checkDisabledLayers, this);
        for (var i2 = 0; i2 < this._layers.length; i2++) {
          this._layers[i2].layer.on("add remove", this._onLayerChange, this);
        }
        return this._container;
      },
      addTo: function(map) {
        Control3.prototype.addTo.call(this, map);
        return this._expandIfNotCollapsed();
      },
      onRemove: function() {
        this._map.off("zoomend", this._checkDisabledLayers, this);
        for (var i2 = 0; i2 < this._layers.length; i2++) {
          this._layers[i2].layer.off("add remove", this._onLayerChange, this);
        }
      },
      addBaseLayer: function(layer, name2) {
        this._addLayer(layer, name2);
        return this._map ? this._update() : this;
      },
      addOverlay: function(layer, name2) {
        this._addLayer(layer, name2, true);
        return this._map ? this._update() : this;
      },
      removeLayer: function(layer) {
        layer.off("add remove", this._onLayerChange, this);
        var obj = this._getLayer(stamp(layer));
        if (obj) {
          this._layers.splice(this._layers.indexOf(obj), 1);
        }
        return this._map ? this._update() : this;
      },
      expand: function() {
        addClass(this._container, "leaflet-control-layers-expanded");
        this._section.style.height = null;
        var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
        if (acceptableHeight < this._section.clientHeight) {
          addClass(this._section, "leaflet-control-layers-scrollbar");
          this._section.style.height = acceptableHeight + "px";
        } else {
          removeClass(this._section, "leaflet-control-layers-scrollbar");
        }
        this._checkDisabledLayers();
        return this;
      },
      collapse: function() {
        removeClass(this._container, "leaflet-control-layers-expanded");
        return this;
      },
      _initLayout: function() {
        var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
        container.setAttribute("aria-haspopup", true);
        disableClickPropagation(container);
        disableScrollPropagation(container);
        var section = this._section = create$1("section", className + "-list");
        if (collapsed) {
          this._map.on("click", this.collapse, this);
          if (!android) {
            on(container, {
              mouseenter: this.expand,
              mouseleave: this.collapse
            }, this);
          }
        }
        var link2 = this._layersLink = create$1("a", className + "-toggle", container);
        link2.href = "#";
        link2.title = "Layers";
        if (touch) {
          on(link2, "click", stop);
          on(link2, "click", this.expand, this);
        } else {
          on(link2, "focus", this.expand, this);
        }
        if (!collapsed) {
          this.expand();
        }
        this._baseLayersList = create$1("div", className + "-base", section);
        this._separator = create$1("div", className + "-separator", section);
        this._overlaysList = create$1("div", className + "-overlays", section);
        container.appendChild(section);
      },
      _getLayer: function(id) {
        for (var i2 = 0; i2 < this._layers.length; i2++) {
          if (this._layers[i2] && stamp(this._layers[i2].layer) === id) {
            return this._layers[i2];
          }
        }
      },
      _addLayer: function(layer, name2, overlay) {
        if (this._map) {
          layer.on("add remove", this._onLayerChange, this);
        }
        this._layers.push({
          layer,
          name: name2,
          overlay
        });
        if (this.options.sortLayers) {
          this._layers.sort(bind(function(a2, b2) {
            return this.options.sortFunction(a2.layer, b2.layer, a2.name, b2.name);
          }, this));
        }
        if (this.options.autoZIndex && layer.setZIndex) {
          this._lastZIndex++;
          layer.setZIndex(this._lastZIndex);
        }
        this._expandIfNotCollapsed();
      },
      _update: function() {
        if (!this._container) {
          return this;
        }
        empty(this._baseLayersList);
        empty(this._overlaysList);
        this._layerControlInputs = [];
        var baseLayersPresent, overlaysPresent, i2, obj, baseLayersCount = 0;
        for (i2 = 0; i2 < this._layers.length; i2++) {
          obj = this._layers[i2];
          this._addItem(obj);
          overlaysPresent = overlaysPresent || obj.overlay;
          baseLayersPresent = baseLayersPresent || !obj.overlay;
          baseLayersCount += !obj.overlay ? 1 : 0;
        }
        if (this.options.hideSingleBase) {
          baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
          this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
        }
        this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
        return this;
      },
      _onLayerChange: function(e2) {
        if (!this._handlingClick) {
          this._update();
        }
        var obj = this._getLayer(stamp(e2.target));
        var type = obj.overlay ? e2.type === "add" ? "overlayadd" : "overlayremove" : e2.type === "add" ? "baselayerchange" : null;
        if (type) {
          this._map.fire(type, obj);
        }
      },
      _createRadioElement: function(name2, checked) {
        var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name2 + '"' + (checked ? ' checked="checked"' : "") + "/>";
        var radioFragment = document.createElement("div");
        radioFragment.innerHTML = radioHtml;
        return radioFragment.firstChild;
      },
      _addItem: function(obj) {
        var label = document.createElement("label"), checked = this._map.hasLayer(obj.layer), input;
        if (obj.overlay) {
          input = document.createElement("input");
          input.type = "checkbox";
          input.className = "leaflet-control-layers-selector";
          input.defaultChecked = checked;
        } else {
          input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
        }
        this._layerControlInputs.push(input);
        input.layerId = stamp(obj.layer);
        on(input, "click", this._onInputClick, this);
        var name2 = document.createElement("span");
        name2.innerHTML = " " + obj.name;
        var holder = document.createElement("div");
        label.appendChild(holder);
        holder.appendChild(input);
        holder.appendChild(name2);
        var container = obj.overlay ? this._overlaysList : this._baseLayersList;
        container.appendChild(label);
        this._checkDisabledLayers();
        return label;
      },
      _onInputClick: function() {
        var inputs = this._layerControlInputs, input, layer;
        var addedLayers = [], removedLayers = [];
        this._handlingClick = true;
        for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
          input = inputs[i2];
          layer = this._getLayer(input.layerId).layer;
          if (input.checked) {
            addedLayers.push(layer);
          } else if (!input.checked) {
            removedLayers.push(layer);
          }
        }
        for (i2 = 0; i2 < removedLayers.length; i2++) {
          if (this._map.hasLayer(removedLayers[i2])) {
            this._map.removeLayer(removedLayers[i2]);
          }
        }
        for (i2 = 0; i2 < addedLayers.length; i2++) {
          if (!this._map.hasLayer(addedLayers[i2])) {
            this._map.addLayer(addedLayers[i2]);
          }
        }
        this._handlingClick = false;
        this._refocusOnMap();
      },
      _checkDisabledLayers: function() {
        var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
        for (var i2 = inputs.length - 1; i2 >= 0; i2--) {
          input = inputs[i2];
          layer = this._getLayer(input.layerId).layer;
          input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
        }
      },
      _expandIfNotCollapsed: function() {
        if (this._map && !this.options.collapsed) {
          this.expand();
        }
        return this;
      },
      _expand: function() {
        return this.expand();
      },
      _collapse: function() {
        return this.collapse();
      }
    });
    var layers = function(baseLayers, overlays, options2) {
      return new Layers2(baseLayers, overlays, options2);
    };
    var Zoom = Control3.extend({
      options: {
        position: "topleft",
        zoomInText: "+",
        zoomInTitle: "Zoom in",
        zoomOutText: "&#x2212;",
        zoomOutTitle: "Zoom out"
      },
      onAdd: function(map) {
        var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options2 = this.options;
        this._zoomInButton = this._createButton(options2.zoomInText, options2.zoomInTitle, zoomName + "-in", container, this._zoomIn);
        this._zoomOutButton = this._createButton(options2.zoomOutText, options2.zoomOutTitle, zoomName + "-out", container, this._zoomOut);
        this._updateDisabled();
        map.on("zoomend zoomlevelschange", this._updateDisabled, this);
        return container;
      },
      onRemove: function(map) {
        map.off("zoomend zoomlevelschange", this._updateDisabled, this);
      },
      disable: function() {
        this._disabled = true;
        this._updateDisabled();
        return this;
      },
      enable: function() {
        this._disabled = false;
        this._updateDisabled();
        return this;
      },
      _zoomIn: function(e2) {
        if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
          this._map.zoomIn(this._map.options.zoomDelta * (e2.shiftKey ? 3 : 1));
        }
      },
      _zoomOut: function(e2) {
        if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
          this._map.zoomOut(this._map.options.zoomDelta * (e2.shiftKey ? 3 : 1));
        }
      },
      _createButton: function(html, title, className, container, fn) {
        var link2 = create$1("a", className, container);
        link2.innerHTML = html;
        link2.href = "#";
        link2.title = title;
        link2.setAttribute("role", "button");
        link2.setAttribute("aria-label", title);
        disableClickPropagation(link2);
        on(link2, "click", stop);
        on(link2, "click", fn, this);
        on(link2, "click", this._refocusOnMap, this);
        return link2;
      },
      _updateDisabled: function() {
        var map = this._map, className = "leaflet-disabled";
        removeClass(this._zoomInButton, className);
        removeClass(this._zoomOutButton, className);
        if (this._disabled || map._zoom === map.getMinZoom()) {
          addClass(this._zoomOutButton, className);
        }
        if (this._disabled || map._zoom === map.getMaxZoom()) {
          addClass(this._zoomInButton, className);
        }
      }
    });
    Map3.mergeOptions({
      zoomControl: true
    });
    Map3.addInitHook(function() {
      if (this.options.zoomControl) {
        this.zoomControl = new Zoom();
        this.addControl(this.zoomControl);
      }
    });
    var zoom = function(options2) {
      return new Zoom(options2);
    };
    var Scale = Control3.extend({
      options: {
        position: "bottomleft",
        maxWidth: 100,
        metric: true,
        imperial: true
      },
      onAdd: function(map) {
        var className = "leaflet-control-scale", container = create$1("div", className), options2 = this.options;
        this._addScales(options2, className + "-line", container);
        map.on(options2.updateWhenIdle ? "moveend" : "move", this._update, this);
        map.whenReady(this._update, this);
        return container;
      },
      onRemove: function(map) {
        map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
      },
      _addScales: function(options2, className, container) {
        if (options2.metric) {
          this._mScale = create$1("div", className, container);
        }
        if (options2.imperial) {
          this._iScale = create$1("div", className, container);
        }
      },
      _update: function() {
        var map = this._map, y2 = map.getSize().y / 2;
        var maxMeters = map.distance(map.containerPointToLatLng([0, y2]), map.containerPointToLatLng([this.options.maxWidth, y2]));
        this._updateScales(maxMeters);
      },
      _updateScales: function(maxMeters) {
        if (this.options.metric && maxMeters) {
          this._updateMetric(maxMeters);
        }
        if (this.options.imperial && maxMeters) {
          this._updateImperial(maxMeters);
        }
      },
      _updateMetric: function(maxMeters) {
        var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
        this._updateScale(this._mScale, label, meters / maxMeters);
      },
      _updateImperial: function(maxMeters) {
        var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
        if (maxFeet > 5280) {
          maxMiles = maxFeet / 5280;
          miles = this._getRoundNum(maxMiles);
          this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
        } else {
          feet = this._getRoundNum(maxFeet);
          this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
        }
      },
      _updateScale: function(scale2, text, ratio) {
        scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
        scale2.innerHTML = text;
      },
      _getRoundNum: function(num) {
        var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d2 = num / pow10;
        d2 = d2 >= 10 ? 10 : d2 >= 5 ? 5 : d2 >= 3 ? 3 : d2 >= 2 ? 2 : 1;
        return pow10 * d2;
      }
    });
    var scale = function(options2) {
      return new Scale(options2);
    };
    var Attribution = Control3.extend({
      options: {
        position: "bottomright",
        prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
      },
      initialize: function(options2) {
        setOptions2(this, options2);
        this._attributions = {};
      },
      onAdd: function(map) {
        map.attributionControl = this;
        this._container = create$1("div", "leaflet-control-attribution");
        disableClickPropagation(this._container);
        for (var i2 in map._layers) {
          if (map._layers[i2].getAttribution) {
            this.addAttribution(map._layers[i2].getAttribution());
          }
        }
        this._update();
        return this._container;
      },
      setPrefix: function(prefix3) {
        this.options.prefix = prefix3;
        this._update();
        return this;
      },
      addAttribution: function(text) {
        if (!text) {
          return this;
        }
        if (!this._attributions[text]) {
          this._attributions[text] = 0;
        }
        this._attributions[text]++;
        this._update();
        return this;
      },
      removeAttribution: function(text) {
        if (!text) {
          return this;
        }
        if (this._attributions[text]) {
          this._attributions[text]--;
          this._update();
        }
        return this;
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        var attribs = [];
        for (var i2 in this._attributions) {
          if (this._attributions[i2]) {
            attribs.push(i2);
          }
        }
        var prefixAndAttribs = [];
        if (this.options.prefix) {
          prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
          prefixAndAttribs.push(attribs.join(", "));
        }
        this._container.innerHTML = prefixAndAttribs.join(" | ");
      }
    });
    Map3.mergeOptions({
      attributionControl: true
    });
    Map3.addInitHook(function() {
      if (this.options.attributionControl) {
        new Attribution().addTo(this);
      }
    });
    var attribution = function(options2) {
      return new Attribution(options2);
    };
    Control3.Layers = Layers2;
    Control3.Zoom = Zoom;
    Control3.Scale = Scale;
    Control3.Attribution = Attribution;
    control.layers = layers;
    control.zoom = zoom;
    control.scale = scale;
    control.attribution = attribution;
    var Handler = Class.extend({
      initialize: function(map) {
        this._map = map;
      },
      enable: function() {
        if (this._enabled) {
          return this;
        }
        this._enabled = true;
        this.addHooks();
        return this;
      },
      disable: function() {
        if (!this._enabled) {
          return this;
        }
        this._enabled = false;
        this.removeHooks();
        return this;
      },
      enabled: function() {
        return !!this._enabled;
      }
    });
    Handler.addTo = function(map, name2) {
      map.addHandler(name2, this);
      return this;
    };
    var Mixin = {Events};
    var START = touch ? "touchstart mousedown" : "mousedown";
    var END = {
      mousedown: "mouseup",
      touchstart: "touchend",
      pointerdown: "touchend",
      MSPointerDown: "touchend"
    };
    var MOVE = {
      mousedown: "mousemove",
      touchstart: "touchmove",
      pointerdown: "touchmove",
      MSPointerDown: "touchmove"
    };
    var Draggable = Evented.extend({
      options: {
        clickTolerance: 3
      },
      initialize: function(element, dragStartTarget, preventOutline$$1, options2) {
        setOptions2(this, options2);
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._preventOutline = preventOutline$$1;
      },
      enable: function() {
        if (this._enabled) {
          return;
        }
        on(this._dragStartTarget, START, this._onDown, this);
        this._enabled = true;
      },
      disable: function() {
        if (!this._enabled) {
          return;
        }
        if (Draggable._dragging === this) {
          this.finishDrag();
        }
        off(this._dragStartTarget, START, this._onDown, this);
        this._enabled = false;
        this._moved = false;
      },
      _onDown: function(e2) {
        if (e2._simulated || !this._enabled) {
          return;
        }
        this._moved = false;
        if (hasClass(this._element, "leaflet-zoom-anim")) {
          return;
        }
        if (Draggable._dragging || e2.shiftKey || e2.which !== 1 && e2.button !== 1 && !e2.touches) {
          return;
        }
        Draggable._dragging = this;
        if (this._preventOutline) {
          preventOutline(this._element);
        }
        disableImageDrag();
        disableTextSelection();
        if (this._moving) {
          return;
        }
        this.fire("down");
        var first = e2.touches ? e2.touches[0] : e2, sizedParent = getSizedParentNode(this._element);
        this._startPoint = new Point(first.clientX, first.clientY);
        this._parentScale = getScale(sizedParent);
        on(document, MOVE[e2.type], this._onMove, this);
        on(document, END[e2.type], this._onUp, this);
      },
      _onMove: function(e2) {
        if (e2._simulated || !this._enabled) {
          return;
        }
        if (e2.touches && e2.touches.length > 1) {
          this._moved = true;
          return;
        }
        var first = e2.touches && e2.touches.length === 1 ? e2.touches[0] : e2, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
        if (!offset.x && !offset.y) {
          return;
        }
        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
          return;
        }
        offset.x /= this._parentScale.x;
        offset.y /= this._parentScale.y;
        preventDefault(e2);
        if (!this._moved) {
          this.fire("dragstart");
          this._moved = true;
          this._startPos = getPosition(this._element).subtract(offset);
          addClass(document.body, "leaflet-dragging");
          this._lastTarget = e2.target || e2.srcElement;
          if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
            this._lastTarget = this._lastTarget.correspondingUseElement;
          }
          addClass(this._lastTarget, "leaflet-drag-target");
        }
        this._newPos = this._startPos.add(offset);
        this._moving = true;
        cancelAnimFrame(this._animRequest);
        this._lastEvent = e2;
        this._animRequest = requestAnimFrame(this._updatePosition, this, true);
      },
      _updatePosition: function() {
        var e2 = {originalEvent: this._lastEvent};
        this.fire("predrag", e2);
        setPosition(this._element, this._newPos);
        this.fire("drag", e2);
      },
      _onUp: function(e2) {
        if (e2._simulated || !this._enabled) {
          return;
        }
        this.finishDrag();
      },
      finishDrag: function() {
        removeClass(document.body, "leaflet-dragging");
        if (this._lastTarget) {
          removeClass(this._lastTarget, "leaflet-drag-target");
          this._lastTarget = null;
        }
        for (var i2 in MOVE) {
          off(document, MOVE[i2], this._onMove, this);
          off(document, END[i2], this._onUp, this);
        }
        enableImageDrag();
        enableTextSelection();
        if (this._moved && this._moving) {
          cancelAnimFrame(this._animRequest);
          this.fire("dragend", {
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
        this._moving = false;
        Draggable._dragging = false;
      }
    });
    function simplify(points, tolerance) {
      if (!tolerance || !points.length) {
        return points.slice();
      }
      var sqTolerance = tolerance * tolerance;
      points = _reducePoints(points, sqTolerance);
      points = _simplifyDP(points, sqTolerance);
      return points;
    }
    function pointToSegmentDistance(p2, p1, p22) {
      return Math.sqrt(_sqClosestPointOnSegment(p2, p1, p22, true));
    }
    function closestPointOnSegment(p2, p1, p22) {
      return _sqClosestPointOnSegment(p2, p1, p22);
    }
    function _simplifyDP(points, sqTolerance) {
      var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
      markers[0] = markers[len - 1] = 1;
      _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
      var i2, newPoints = [];
      for (i2 = 0; i2 < len; i2++) {
        if (markers[i2]) {
          newPoints.push(points[i2]);
        }
      }
      return newPoints;
    }
    function _simplifyDPStep(points, markers, sqTolerance, first, last) {
      var maxSqDist = 0, index5, i2, sqDist;
      for (i2 = first + 1; i2 <= last - 1; i2++) {
        sqDist = _sqClosestPointOnSegment(points[i2], points[first], points[last], true);
        if (sqDist > maxSqDist) {
          index5 = i2;
          maxSqDist = sqDist;
        }
      }
      if (maxSqDist > sqTolerance) {
        markers[index5] = 1;
        _simplifyDPStep(points, markers, sqTolerance, first, index5);
        _simplifyDPStep(points, markers, sqTolerance, index5, last);
      }
    }
    function _reducePoints(points, sqTolerance) {
      var reducedPoints = [points[0]];
      for (var i2 = 1, prev2 = 0, len = points.length; i2 < len; i2++) {
        if (_sqDist(points[i2], points[prev2]) > sqTolerance) {
          reducedPoints.push(points[i2]);
          prev2 = i2;
        }
      }
      if (prev2 < len - 1) {
        reducedPoints.push(points[len - 1]);
      }
      return reducedPoints;
    }
    var _lastCode;
    function clipSegment(a2, b2, bounds, useLastCode, round) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a2, bounds), codeB = _getBitCode(b2, bounds), codeOut, p2, newCode;
      _lastCode = codeB;
      while (true) {
        if (!(codeA | codeB)) {
          return [a2, b2];
        }
        if (codeA & codeB) {
          return false;
        }
        codeOut = codeA || codeB;
        p2 = _getEdgeIntersection(a2, b2, codeOut, bounds, round);
        newCode = _getBitCode(p2, bounds);
        if (codeOut === codeA) {
          a2 = p2;
          codeA = newCode;
        } else {
          b2 = p2;
          codeB = newCode;
        }
      }
    }
    function _getEdgeIntersection(a2, b2, code, bounds, round) {
      var dx = b2.x - a2.x, dy = b2.y - a2.y, min = bounds.min, max = bounds.max, x2, y2;
      if (code & 8) {
        x2 = a2.x + dx * (max.y - a2.y) / dy;
        y2 = max.y;
      } else if (code & 4) {
        x2 = a2.x + dx * (min.y - a2.y) / dy;
        y2 = min.y;
      } else if (code & 2) {
        x2 = max.x;
        y2 = a2.y + dy * (max.x - a2.x) / dx;
      } else if (code & 1) {
        x2 = min.x;
        y2 = a2.y + dy * (min.x - a2.x) / dx;
      }
      return new Point(x2, y2, round);
    }
    function _getBitCode(p2, bounds) {
      var code = 0;
      if (p2.x < bounds.min.x) {
        code |= 1;
      } else if (p2.x > bounds.max.x) {
        code |= 2;
      }
      if (p2.y < bounds.min.y) {
        code |= 4;
      } else if (p2.y > bounds.max.y) {
        code |= 8;
      }
      return code;
    }
    function _sqDist(p1, p2) {
      var dx = p2.x - p1.x, dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    }
    function _sqClosestPointOnSegment(p2, p1, p22, sqDist) {
      var x2 = p1.x, y2 = p1.y, dx = p22.x - x2, dy = p22.y - y2, dot = dx * dx + dy * dy, t2;
      if (dot > 0) {
        t2 = ((p2.x - x2) * dx + (p2.y - y2) * dy) / dot;
        if (t2 > 1) {
          x2 = p22.x;
          y2 = p22.y;
        } else if (t2 > 0) {
          x2 += dx * t2;
          y2 += dy * t2;
        }
      }
      dx = p2.x - x2;
      dy = p2.y - y2;
      return sqDist ? dx * dx + dy * dy : new Point(x2, y2);
    }
    function isFlat(latlngs) {
      return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
    }
    function _flat(latlngs) {
      console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
      return isFlat(latlngs);
    }
    var LineUtil = {
      simplify,
      pointToSegmentDistance,
      closestPointOnSegment,
      clipSegment,
      _getEdgeIntersection,
      _getBitCode,
      _sqClosestPointOnSegment,
      isFlat,
      _flat
    };
    function clipPolygon(points, bounds, round) {
      var clippedPoints, edges = [1, 4, 2, 8], i2, j2, k2, a2, b2, len, edge2, p2;
      for (i2 = 0, len = points.length; i2 < len; i2++) {
        points[i2]._code = _getBitCode(points[i2], bounds);
      }
      for (k2 = 0; k2 < 4; k2++) {
        edge2 = edges[k2];
        clippedPoints = [];
        for (i2 = 0, len = points.length, j2 = len - 1; i2 < len; j2 = i2++) {
          a2 = points[i2];
          b2 = points[j2];
          if (!(a2._code & edge2)) {
            if (b2._code & edge2) {
              p2 = _getEdgeIntersection(b2, a2, edge2, bounds, round);
              p2._code = _getBitCode(p2, bounds);
              clippedPoints.push(p2);
            }
            clippedPoints.push(a2);
          } else if (!(b2._code & edge2)) {
            p2 = _getEdgeIntersection(b2, a2, edge2, bounds, round);
            p2._code = _getBitCode(p2, bounds);
            clippedPoints.push(p2);
          }
        }
        points = clippedPoints;
      }
      return points;
    }
    var PolyUtil = {
      clipPolygon
    };
    var LonLat = {
      project: function(latlng) {
        return new Point(latlng.lng, latlng.lat);
      },
      unproject: function(point) {
        return new LatLng(point.y, point.x);
      },
      bounds: new Bounds([-180, -90], [180, 90])
    };
    var Mercator = {
      R: 6378137,
      R_MINOR: 6356752314245179e-9,
      bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
      project: function(latlng) {
        var d2 = Math.PI / 180, r2 = this.R, y2 = latlng.lat * d2, tmp2 = this.R_MINOR / r2, e2 = Math.sqrt(1 - tmp2 * tmp2), con = e2 * Math.sin(y2);
        var ts = Math.tan(Math.PI / 4 - y2 / 2) / Math.pow((1 - con) / (1 + con), e2 / 2);
        y2 = -r2 * Math.log(Math.max(ts, 1e-10));
        return new Point(latlng.lng * d2 * r2, y2);
      },
      unproject: function(point) {
        var d2 = 180 / Math.PI, r2 = this.R, tmp2 = this.R_MINOR / r2, e2 = Math.sqrt(1 - tmp2 * tmp2), ts = Math.exp(-point.y / r2), phi = Math.PI / 2 - 2 * Math.atan(ts);
        for (var i2 = 0, dphi = 0.1, con; i2 < 15 && Math.abs(dphi) > 1e-7; i2++) {
          con = e2 * Math.sin(phi);
          con = Math.pow((1 - con) / (1 + con), e2 / 2);
          dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
          phi += dphi;
        }
        return new LatLng(phi * d2, point.x * d2 / r2);
      }
    };
    var index4 = {
      LonLat,
      Mercator,
      SphericalMercator
    };
    var EPSG3395 = extend2({}, Earth, {
      code: "EPSG:3395",
      projection: Mercator,
      transformation: function() {
        var scale2 = 0.5 / (Math.PI * Mercator.R);
        return toTransformation(scale2, 0.5, -scale2, 0.5);
      }()
    });
    var EPSG4326 = extend2({}, Earth, {
      code: "EPSG:4326",
      projection: LonLat,
      transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
    });
    var Simple = extend2({}, CRS, {
      projection: LonLat,
      transformation: toTransformation(1, 0, -1, 0),
      scale: function(zoom2) {
        return Math.pow(2, zoom2);
      },
      zoom: function(scale2) {
        return Math.log(scale2) / Math.LN2;
      },
      distance: function(latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
        return Math.sqrt(dx * dx + dy * dy);
      },
      infinite: true
    });
    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;
    var Layer = Evented.extend({
      options: {
        pane: "overlayPane",
        attribution: null,
        bubblingMouseEvents: true
      },
      addTo: function(map) {
        map.addLayer(this);
        return this;
      },
      remove: function() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      removeFrom: function(obj) {
        if (obj) {
          obj.removeLayer(this);
        }
        return this;
      },
      getPane: function(name2) {
        return this._map.getPane(name2 ? this.options[name2] || name2 : this.options.pane);
      },
      addInteractiveTarget: function(targetEl) {
        this._map._targets[stamp(targetEl)] = this;
        return this;
      },
      removeInteractiveTarget: function(targetEl) {
        delete this._map._targets[stamp(targetEl)];
        return this;
      },
      getAttribution: function() {
        return this.options.attribution;
      },
      _layerAdd: function(e2) {
        var map = e2.target;
        if (!map.hasLayer(this)) {
          return;
        }
        this._map = map;
        this._zoomAnimated = map._zoomAnimated;
        if (this.getEvents) {
          var events = this.getEvents();
          map.on(events, this);
          this.once("remove", function() {
            map.off(events, this);
          }, this);
        }
        this.onAdd(map);
        if (this.getAttribution && map.attributionControl) {
          map.attributionControl.addAttribution(this.getAttribution());
        }
        this.fire("add");
        map.fire("layeradd", {layer: this});
      }
    });
    Map3.include({
      addLayer: function(layer) {
        if (!layer._layerAdd) {
          throw new Error("The provided object is not a Layer.");
        }
        var id = stamp(layer);
        if (this._layers[id]) {
          return this;
        }
        this._layers[id] = layer;
        layer._mapToAdd = this;
        if (layer.beforeAdd) {
          layer.beforeAdd(this);
        }
        this.whenReady(layer._layerAdd, layer);
        return this;
      },
      removeLayer: function(layer) {
        var id = stamp(layer);
        if (!this._layers[id]) {
          return this;
        }
        if (this._loaded) {
          layer.onRemove(this);
        }
        if (layer.getAttribution && this.attributionControl) {
          this.attributionControl.removeAttribution(layer.getAttribution());
        }
        delete this._layers[id];
        if (this._loaded) {
          this.fire("layerremove", {layer});
          layer.fire("remove");
        }
        layer._map = layer._mapToAdd = null;
        return this;
      },
      hasLayer: function(layer) {
        return !!layer && stamp(layer) in this._layers;
      },
      eachLayer: function(method, context) {
        for (var i2 in this._layers) {
          method.call(context, this._layers[i2]);
        }
        return this;
      },
      _addLayers: function(layers2) {
        layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
        for (var i2 = 0, len = layers2.length; i2 < len; i2++) {
          this.addLayer(layers2[i2]);
        }
      },
      _addZoomLimit: function(layer) {
        if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
          this._zoomBoundLayers[stamp(layer)] = layer;
          this._updateZoomLevels();
        }
      },
      _removeZoomLimit: function(layer) {
        var id = stamp(layer);
        if (this._zoomBoundLayers[id]) {
          delete this._zoomBoundLayers[id];
          this._updateZoomLevels();
        }
      },
      _updateZoomLevels: function() {
        var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
        for (var i2 in this._zoomBoundLayers) {
          var options2 = this._zoomBoundLayers[i2].options;
          minZoom = options2.minZoom === void 0 ? minZoom : Math.min(minZoom, options2.minZoom);
          maxZoom = options2.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options2.maxZoom);
        }
        this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
        this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
        if (oldZoomSpan !== this._getZoomSpan()) {
          this.fire("zoomlevelschange");
        }
        if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
          this.setZoom(this._layersMaxZoom);
        }
        if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
          this.setZoom(this._layersMinZoom);
        }
      }
    });
    var LayerGroup = Layer.extend({
      initialize: function(layers2, options2) {
        setOptions2(this, options2);
        this._layers = {};
        var i2, len;
        if (layers2) {
          for (i2 = 0, len = layers2.length; i2 < len; i2++) {
            this.addLayer(layers2[i2]);
          }
        }
      },
      addLayer: function(layer) {
        var id = this.getLayerId(layer);
        this._layers[id] = layer;
        if (this._map) {
          this._map.addLayer(layer);
        }
        return this;
      },
      removeLayer: function(layer) {
        var id = layer in this._layers ? layer : this.getLayerId(layer);
        if (this._map && this._layers[id]) {
          this._map.removeLayer(this._layers[id]);
        }
        delete this._layers[id];
        return this;
      },
      hasLayer: function(layer) {
        if (!layer) {
          return false;
        }
        var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
        return layerId in this._layers;
      },
      clearLayers: function() {
        return this.eachLayer(this.removeLayer, this);
      },
      invoke: function(methodName) {
        var args = Array.prototype.slice.call(arguments, 1), i2, layer;
        for (i2 in this._layers) {
          layer = this._layers[i2];
          if (layer[methodName]) {
            layer[methodName].apply(layer, args);
          }
        }
        return this;
      },
      onAdd: function(map) {
        this.eachLayer(map.addLayer, map);
      },
      onRemove: function(map) {
        this.eachLayer(map.removeLayer, map);
      },
      eachLayer: function(method, context) {
        for (var i2 in this._layers) {
          method.call(context, this._layers[i2]);
        }
        return this;
      },
      getLayer: function(id) {
        return this._layers[id];
      },
      getLayers: function() {
        var layers2 = [];
        this.eachLayer(layers2.push, layers2);
        return layers2;
      },
      setZIndex: function(zIndex) {
        return this.invoke("setZIndex", zIndex);
      },
      getLayerId: function(layer) {
        return stamp(layer);
      }
    });
    var layerGroup = function(layers2, options2) {
      return new LayerGroup(layers2, options2);
    };
    var FeatureGroup = LayerGroup.extend({
      addLayer: function(layer) {
        if (this.hasLayer(layer)) {
          return this;
        }
        layer.addEventParent(this);
        LayerGroup.prototype.addLayer.call(this, layer);
        return this.fire("layeradd", {layer});
      },
      removeLayer: function(layer) {
        if (!this.hasLayer(layer)) {
          return this;
        }
        if (layer in this._layers) {
          layer = this._layers[layer];
        }
        layer.removeEventParent(this);
        LayerGroup.prototype.removeLayer.call(this, layer);
        return this.fire("layerremove", {layer});
      },
      setStyle: function(style) {
        return this.invoke("setStyle", style);
      },
      bringToFront: function() {
        return this.invoke("bringToFront");
      },
      bringToBack: function() {
        return this.invoke("bringToBack");
      },
      getBounds: function() {
        var bounds = new LatLngBounds();
        for (var id in this._layers) {
          var layer = this._layers[id];
          bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
        }
        return bounds;
      }
    });
    var featureGroup = function(layers2, options2) {
      return new FeatureGroup(layers2, options2);
    };
    var Icon = Class.extend({
      options: {
        popupAnchor: [0, 0],
        tooltipAnchor: [0, 0]
      },
      initialize: function(options2) {
        setOptions2(this, options2);
      },
      createIcon: function(oldIcon) {
        return this._createIcon("icon", oldIcon);
      },
      createShadow: function(oldIcon) {
        return this._createIcon("shadow", oldIcon);
      },
      _createIcon: function(name2, oldIcon) {
        var src2 = this._getIconUrl(name2);
        if (!src2) {
          if (name2 === "icon") {
            throw new Error("iconUrl not set in Icon options (see the docs).");
          }
          return null;
        }
        var img = this._createImg(src2, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
        this._setIconStyles(img, name2);
        return img;
      },
      _setIconStyles: function(img, name2) {
        var options2 = this.options;
        var sizeOption = options2[name2 + "Size"];
        if (typeof sizeOption === "number") {
          sizeOption = [sizeOption, sizeOption];
        }
        var size = toPoint(sizeOption), anchor = toPoint(name2 === "shadow" && options2.shadowAnchor || options2.iconAnchor || size && size.divideBy(2, true));
        img.className = "leaflet-marker-" + name2 + " " + (options2.className || "");
        if (anchor) {
          img.style.marginLeft = -anchor.x + "px";
          img.style.marginTop = -anchor.y + "px";
        }
        if (size) {
          img.style.width = size.x + "px";
          img.style.height = size.y + "px";
        }
      },
      _createImg: function(src2, el2) {
        el2 = el2 || document.createElement("img");
        el2.src = src2;
        return el2;
      },
      _getIconUrl: function(name2) {
        return retina && this.options[name2 + "RetinaUrl"] || this.options[name2 + "Url"];
      }
    });
    function icon(options2) {
      return new Icon(options2);
    }
    var IconDefault = Icon.extend({
      options: {
        iconUrl: "marker-icon.png",
        iconRetinaUrl: "marker-icon-2x.png",
        shadowUrl: "marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function(name2) {
        if (!IconDefault.imagePath) {
          IconDefault.imagePath = this._detectIconPath();
        }
        return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name2);
      },
      _detectIconPath: function() {
        var el2 = create$1("div", "leaflet-default-icon-path", document.body);
        var path = getStyle(el2, "background-image") || getStyle(el2, "backgroundImage");
        document.body.removeChild(el2);
        if (path === null || path.indexOf("url") !== 0) {
          path = "";
        } else {
          path = path.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "");
        }
        return path;
      }
    });
    var MarkerDrag = Handler.extend({
      initialize: function(marker2) {
        this._marker = marker2;
      },
      addHooks: function() {
        var icon2 = this._marker._icon;
        if (!this._draggable) {
          this._draggable = new Draggable(icon2, icon2, true);
        }
        this._draggable.on({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable();
        addClass(icon2, "leaflet-marker-draggable");
      },
      removeHooks: function() {
        this._draggable.off({
          dragstart: this._onDragStart,
          predrag: this._onPreDrag,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable();
        if (this._marker._icon) {
          removeClass(this._marker._icon, "leaflet-marker-draggable");
        }
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      _adjustPan: function(e2) {
        var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
        var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
        if (!panBounds.contains(iconPos)) {
          var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
          map.panBy(movement, {animate: false});
          this._draggable._newPos._add(movement);
          this._draggable._startPos._add(movement);
          setPosition(marker2._icon, this._draggable._newPos);
          this._onDrag(e2);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e2));
        }
      },
      _onDragStart: function() {
        this._oldLatLng = this._marker.getLatLng();
        this._marker.closePopup && this._marker.closePopup();
        this._marker.fire("movestart").fire("dragstart");
      },
      _onPreDrag: function(e2) {
        if (this._marker.options.autoPan) {
          cancelAnimFrame(this._panRequest);
          this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e2));
        }
      },
      _onDrag: function(e2) {
        var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
        if (shadow) {
          setPosition(shadow, iconPos);
        }
        marker2._latlng = latlng;
        e2.latlng = latlng;
        e2.oldLatLng = this._oldLatLng;
        marker2.fire("move", e2).fire("drag", e2);
      },
      _onDragEnd: function(e2) {
        cancelAnimFrame(this._panRequest);
        delete this._oldLatLng;
        this._marker.fire("moveend").fire("dragend", e2);
      }
    });
    var Marker2 = Layer.extend({
      options: {
        icon: new IconDefault(),
        interactive: true,
        keyboard: true,
        title: "",
        alt: "",
        zIndexOffset: 0,
        opacity: 1,
        riseOnHover: false,
        riseOffset: 250,
        pane: "markerPane",
        shadowPane: "shadowPane",
        bubblingMouseEvents: false,
        draggable: false,
        autoPan: false,
        autoPanPadding: [50, 50],
        autoPanSpeed: 10
      },
      initialize: function(latlng, options2) {
        setOptions2(this, options2);
        this._latlng = toLatLng(latlng);
      },
      onAdd: function(map) {
        this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
        if (this._zoomAnimated) {
          map.on("zoomanim", this._animateZoom, this);
        }
        this._initIcon();
        this.update();
      },
      onRemove: function(map) {
        if (this.dragging && this.dragging.enabled()) {
          this.options.draggable = true;
          this.dragging.removeHooks();
        }
        delete this.dragging;
        if (this._zoomAnimated) {
          map.off("zoomanim", this._animateZoom, this);
        }
        this._removeIcon();
        this._removeShadow();
      },
      getEvents: function() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      getLatLng: function() {
        return this._latlng;
      },
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng(latlng);
        this.update();
        return this.fire("move", {oldLatLng, latlng: this._latlng});
      },
      setZIndexOffset: function(offset) {
        this.options.zIndexOffset = offset;
        return this.update();
      },
      getIcon: function() {
        return this.options.icon;
      },
      setIcon: function(icon2) {
        this.options.icon = icon2;
        if (this._map) {
          this._initIcon();
          this.update();
        }
        if (this._popup) {
          this.bindPopup(this._popup, this._popup.options);
        }
        return this;
      },
      getElement: function() {
        return this._icon;
      },
      update: function() {
        if (this._icon && this._map) {
          var pos = this._map.latLngToLayerPoint(this._latlng).round();
          this._setPos(pos);
        }
        return this;
      },
      _initIcon: function() {
        var options2 = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        var icon2 = options2.icon.createIcon(this._icon), addIcon = false;
        if (icon2 !== this._icon) {
          if (this._icon) {
            this._removeIcon();
          }
          addIcon = true;
          if (options2.title) {
            icon2.title = options2.title;
          }
          if (icon2.tagName === "IMG") {
            icon2.alt = options2.alt || "";
          }
        }
        addClass(icon2, classToAdd);
        if (options2.keyboard) {
          icon2.tabIndex = "0";
        }
        this._icon = icon2;
        if (options2.riseOnHover) {
          this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        var newShadow = options2.icon.createShadow(this._shadow), addShadow = false;
        if (newShadow !== this._shadow) {
          this._removeShadow();
          addShadow = true;
        }
        if (newShadow) {
          addClass(newShadow, classToAdd);
          newShadow.alt = "";
        }
        this._shadow = newShadow;
        if (options2.opacity < 1) {
          this._updateOpacity();
        }
        if (addIcon) {
          this.getPane().appendChild(this._icon);
        }
        this._initInteraction();
        if (newShadow && addShadow) {
          this.getPane(options2.shadowPane).appendChild(this._shadow);
        }
      },
      _removeIcon: function() {
        if (this.options.riseOnHover) {
          this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }
        remove(this._icon);
        this.removeInteractiveTarget(this._icon);
        this._icon = null;
      },
      _removeShadow: function() {
        if (this._shadow) {
          remove(this._shadow);
        }
        this._shadow = null;
      },
      _setPos: function(pos) {
        if (this._icon) {
          setPosition(this._icon, pos);
        }
        if (this._shadow) {
          setPosition(this._shadow, pos);
        }
        this._zIndex = pos.y + this.options.zIndexOffset;
        this._resetZIndex();
      },
      _updateZIndex: function(offset) {
        if (this._icon) {
          this._icon.style.zIndex = this._zIndex + offset;
        }
      },
      _animateZoom: function(opt) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
        this._setPos(pos);
      },
      _initInteraction: function() {
        if (!this.options.interactive) {
          return;
        }
        addClass(this._icon, "leaflet-interactive");
        this.addInteractiveTarget(this._icon);
        if (MarkerDrag) {
          var draggable = this.options.draggable;
          if (this.dragging) {
            draggable = this.dragging.enabled();
            this.dragging.disable();
          }
          this.dragging = new MarkerDrag(this);
          if (draggable) {
            this.dragging.enable();
          }
        }
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._map) {
          this._updateOpacity();
        }
        return this;
      },
      _updateOpacity: function() {
        var opacity = this.options.opacity;
        if (this._icon) {
          setOpacity(this._icon, opacity);
        }
        if (this._shadow) {
          setOpacity(this._shadow, opacity);
        }
      },
      _bringToFront: function() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function() {
        this._updateZIndex(0);
      },
      _getPopupAnchor: function() {
        return this.options.icon.options.popupAnchor;
      },
      _getTooltipAnchor: function() {
        return this.options.icon.options.tooltipAnchor;
      }
    });
    function marker(latlng, options2) {
      return new Marker2(latlng, options2);
    }
    var Path2 = Layer.extend({
      options: {
        stroke: true,
        color: "#3388ff",
        weight: 3,
        opacity: 1,
        lineCap: "round",
        lineJoin: "round",
        dashArray: null,
        dashOffset: null,
        fill: false,
        fillColor: null,
        fillOpacity: 0.2,
        fillRule: "evenodd",
        interactive: true,
        bubblingMouseEvents: true
      },
      beforeAdd: function(map) {
        this._renderer = map.getRenderer(this);
      },
      onAdd: function() {
        this._renderer._initPath(this);
        this._reset();
        this._renderer._addPath(this);
      },
      onRemove: function() {
        this._renderer._removePath(this);
      },
      redraw: function() {
        if (this._map) {
          this._renderer._updatePath(this);
        }
        return this;
      },
      setStyle: function(style) {
        setOptions2(this, style);
        if (this._renderer) {
          this._renderer._updateStyle(this);
          if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight")) {
            this._updateBounds();
          }
        }
        return this;
      },
      bringToFront: function() {
        if (this._renderer) {
          this._renderer._bringToFront(this);
        }
        return this;
      },
      bringToBack: function() {
        if (this._renderer) {
          this._renderer._bringToBack(this);
        }
        return this;
      },
      getElement: function() {
        return this._path;
      },
      _reset: function() {
        this._project();
        this._update();
      },
      _clickTolerance: function() {
        return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
      }
    });
    var CircleMarker = Path2.extend({
      options: {
        fill: true,
        radius: 10
      },
      initialize: function(latlng, options2) {
        setOptions2(this, options2);
        this._latlng = toLatLng(latlng);
        this._radius = this.options.radius;
      },
      setLatLng: function(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng(latlng);
        this.redraw();
        return this.fire("move", {oldLatLng, latlng: this._latlng});
      },
      getLatLng: function() {
        return this._latlng;
      },
      setRadius: function(radius) {
        this.options.radius = this._radius = radius;
        return this.redraw();
      },
      getRadius: function() {
        return this._radius;
      },
      setStyle: function(options2) {
        var radius = options2 && options2.radius || this._radius;
        Path2.prototype.setStyle.call(this, options2);
        this.setRadius(radius);
        return this;
      },
      _project: function() {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._updateBounds();
      },
      _updateBounds: function() {
        var r2 = this._radius, r22 = this._radiusY || r2, w3 = this._clickTolerance(), p2 = [r2 + w3, r22 + w3];
        this._pxBounds = new Bounds(this._point.subtract(p2), this._point.add(p2));
      },
      _update: function() {
        if (this._map) {
          this._updatePath();
        }
      },
      _updatePath: function() {
        this._renderer._updateCircle(this);
      },
      _empty: function() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      _containsPoint: function(p2) {
        return p2.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    });
    function circleMarker(latlng, options2) {
      return new CircleMarker(latlng, options2);
    }
    var Circle = CircleMarker.extend({
      initialize: function(latlng, options2, legacyOptions) {
        if (typeof options2 === "number") {
          options2 = extend2({}, legacyOptions, {radius: options2});
        }
        setOptions2(this, options2);
        this._latlng = toLatLng(latlng);
        if (isNaN(this.options.radius)) {
          throw new Error("Circle radius cannot be NaN");
        }
        this._mRadius = this.options.radius;
      },
      setRadius: function(radius) {
        this._mRadius = radius;
        return this.redraw();
      },
      getRadius: function() {
        return this._mRadius;
      },
      getBounds: function() {
        var half = [this._radius, this._radiusY || this._radius];
        return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
      },
      setStyle: Path2.prototype.setStyle,
      _project: function() {
        var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
        if (crs.distance === Earth.distance) {
          var d2 = Math.PI / 180, latR = this._mRadius / Earth.R / d2, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p2 = top.add(bottom).divideBy(2), lat2 = map.unproject(p2).lat, lngR = Math.acos((Math.cos(latR * d2) - Math.sin(lat * d2) * Math.sin(lat2 * d2)) / (Math.cos(lat * d2) * Math.cos(lat2 * d2))) / d2;
          if (isNaN(lngR) || lngR === 0) {
            lngR = latR / Math.cos(Math.PI / 180 * lat);
          }
          this._point = p2.subtract(map.getPixelOrigin());
          this._radius = isNaN(lngR) ? 0 : p2.x - map.project([lat2, lng - lngR]).x;
          this._radiusY = p2.y - top.y;
        } else {
          var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = map.latLngToLayerPoint(this._latlng);
          this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
        }
        this._updateBounds();
      }
    });
    function circle(latlng, options2, legacyOptions) {
      return new Circle(latlng, options2, legacyOptions);
    }
    var Polyline = Path2.extend({
      options: {
        smoothFactor: 1,
        noClip: false
      },
      initialize: function(latlngs, options2) {
        setOptions2(this, options2);
        this._setLatLngs(latlngs);
      },
      getLatLngs: function() {
        return this._latlngs;
      },
      setLatLngs: function(latlngs) {
        this._setLatLngs(latlngs);
        return this.redraw();
      },
      isEmpty: function() {
        return !this._latlngs.length;
      },
      closestLayerPoint: function(p2) {
        var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p22;
        for (var j2 = 0, jLen = this._parts.length; j2 < jLen; j2++) {
          var points = this._parts[j2];
          for (var i2 = 1, len = points.length; i2 < len; i2++) {
            p1 = points[i2 - 1];
            p22 = points[i2];
            var sqDist = closest(p2, p1, p22, true);
            if (sqDist < minDistance) {
              minDistance = sqDist;
              minPoint = closest(p2, p1, p22);
            }
          }
        }
        if (minPoint) {
          minPoint.distance = Math.sqrt(minDistance);
        }
        return minPoint;
      },
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        var i2, halfDist, segDist, dist, p1, p2, ratio, points = this._rings[0], len = points.length;
        if (!len) {
          return null;
        }
        for (i2 = 0, halfDist = 0; i2 < len - 1; i2++) {
          halfDist += points[i2].distanceTo(points[i2 + 1]) / 2;
        }
        if (halfDist === 0) {
          return this._map.layerPointToLatLng(points[0]);
        }
        for (i2 = 0, dist = 0; i2 < len - 1; i2++) {
          p1 = points[i2];
          p2 = points[i2 + 1];
          segDist = p1.distanceTo(p2);
          dist += segDist;
          if (dist > halfDist) {
            ratio = (dist - halfDist) / segDist;
            return this._map.layerPointToLatLng([
              p2.x - ratio * (p2.x - p1.x),
              p2.y - ratio * (p2.y - p1.y)
            ]);
          }
        }
      },
      getBounds: function() {
        return this._bounds;
      },
      addLatLng: function(latlng, latlngs) {
        latlngs = latlngs || this._defaultShape();
        latlng = toLatLng(latlng);
        latlngs.push(latlng);
        this._bounds.extend(latlng);
        return this.redraw();
      },
      _setLatLngs: function(latlngs) {
        this._bounds = new LatLngBounds();
        this._latlngs = this._convertLatLngs(latlngs);
      },
      _defaultShape: function() {
        return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      _convertLatLngs: function(latlngs) {
        var result = [], flat = isFlat(latlngs);
        for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
          if (flat) {
            result[i2] = toLatLng(latlngs[i2]);
            this._bounds.extend(result[i2]);
          } else {
            result[i2] = this._convertLatLngs(latlngs[i2]);
          }
        }
        return result;
      },
      _project: function() {
        var pxBounds = new Bounds();
        this._rings = [];
        this._projectLatlngs(this._latlngs, this._rings, pxBounds);
        if (this._bounds.isValid() && pxBounds.isValid()) {
          this._rawPxBounds = pxBounds;
          this._updateBounds();
        }
      },
      _updateBounds: function() {
        var w3 = this._clickTolerance(), p2 = new Point(w3, w3);
        this._pxBounds = new Bounds([
          this._rawPxBounds.min.subtract(p2),
          this._rawPxBounds.max.add(p2)
        ]);
      },
      _projectLatlngs: function(latlngs, result, projectedBounds) {
        var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i2, ring;
        if (flat) {
          ring = [];
          for (i2 = 0; i2 < len; i2++) {
            ring[i2] = this._map.latLngToLayerPoint(latlngs[i2]);
            projectedBounds.extend(ring[i2]);
          }
          result.push(ring);
        } else {
          for (i2 = 0; i2 < len; i2++) {
            this._projectLatlngs(latlngs[i2], result, projectedBounds);
          }
        }
      },
      _clipPoints: function() {
        var bounds = this._renderer._bounds;
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        var parts = this._parts, i2, j2, k2, len, len2, segment, points;
        for (i2 = 0, k2 = 0, len = this._rings.length; i2 < len; i2++) {
          points = this._rings[i2];
          for (j2 = 0, len2 = points.length; j2 < len2 - 1; j2++) {
            segment = clipSegment(points[j2], points[j2 + 1], bounds, j2, true);
            if (!segment) {
              continue;
            }
            parts[k2] = parts[k2] || [];
            parts[k2].push(segment[0]);
            if (segment[1] !== points[j2 + 1] || j2 === len2 - 2) {
              parts[k2].push(segment[1]);
              k2++;
            }
          }
        }
      },
      _simplifyPoints: function() {
        var parts = this._parts, tolerance = this.options.smoothFactor;
        for (var i2 = 0, len = parts.length; i2 < len; i2++) {
          parts[i2] = simplify(parts[i2], tolerance);
        }
      },
      _update: function() {
        if (!this._map) {
          return;
        }
        this._clipPoints();
        this._simplifyPoints();
        this._updatePath();
      },
      _updatePath: function() {
        this._renderer._updatePoly(this);
      },
      _containsPoint: function(p2, closed) {
        var i2, j2, k2, len, len2, part, w3 = this._clickTolerance();
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
          part = this._parts[i2];
          for (j2 = 0, len2 = part.length, k2 = len2 - 1; j2 < len2; k2 = j2++) {
            if (!closed && j2 === 0) {
              continue;
            }
            if (pointToSegmentDistance(p2, part[k2], part[j2]) <= w3) {
              return true;
            }
          }
        }
        return false;
      }
    });
    function polyline(latlngs, options2) {
      return new Polyline(latlngs, options2);
    }
    Polyline._flat = _flat;
    var Polygon = Polyline.extend({
      options: {
        fill: true
      },
      isEmpty: function() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      getCenter: function() {
        if (!this._map) {
          throw new Error("Must add layer to map before using getCenter()");
        }
        var i2, j2, p1, p2, f2, area2, x2, y2, center, points = this._rings[0], len = points.length;
        if (!len) {
          return null;
        }
        area2 = x2 = y2 = 0;
        for (i2 = 0, j2 = len - 1; i2 < len; j2 = i2++) {
          p1 = points[i2];
          p2 = points[j2];
          f2 = p1.y * p2.x - p2.y * p1.x;
          x2 += (p1.x + p2.x) * f2;
          y2 += (p1.y + p2.y) * f2;
          area2 += f2 * 3;
        }
        if (area2 === 0) {
          center = points[0];
        } else {
          center = [x2 / area2, y2 / area2];
        }
        return this._map.layerPointToLatLng(center);
      },
      _convertLatLngs: function(latlngs) {
        var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
        if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
          result.pop();
        }
        return result;
      },
      _setLatLngs: function(latlngs) {
        Polyline.prototype._setLatLngs.call(this, latlngs);
        if (isFlat(this._latlngs)) {
          this._latlngs = [this._latlngs];
        }
      },
      _defaultShape: function() {
        return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function() {
        var bounds = this._renderer._bounds, w3 = this.options.weight, p2 = new Point(w3, w3);
        bounds = new Bounds(bounds.min.subtract(p2), bounds.max.add(p2));
        this._parts = [];
        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }
        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }
        for (var i2 = 0, len = this._rings.length, clipped; i2 < len; i2++) {
          clipped = clipPolygon(this._rings[i2], bounds, true);
          if (clipped.length) {
            this._parts.push(clipped);
          }
        }
      },
      _updatePath: function() {
        this._renderer._updatePoly(this, true);
      },
      _containsPoint: function(p2) {
        var inside = false, part, p1, p22, i2, j2, k2, len, len2;
        if (!this._pxBounds || !this._pxBounds.contains(p2)) {
          return false;
        }
        for (i2 = 0, len = this._parts.length; i2 < len; i2++) {
          part = this._parts[i2];
          for (j2 = 0, len2 = part.length, k2 = len2 - 1; j2 < len2; k2 = j2++) {
            p1 = part[j2];
            p22 = part[k2];
            if (p1.y > p2.y !== p22.y > p2.y && p2.x < (p22.x - p1.x) * (p2.y - p1.y) / (p22.y - p1.y) + p1.x) {
              inside = !inside;
            }
          }
        }
        return inside || Polyline.prototype._containsPoint.call(this, p2, true);
      }
    });
    function polygon(latlngs, options2) {
      return new Polygon(latlngs, options2);
    }
    var GeoJSON = FeatureGroup.extend({
      initialize: function(geojson, options2) {
        setOptions2(this, options2);
        this._layers = {};
        if (geojson) {
          this.addData(geojson);
        }
      },
      addData: function(geojson) {
        var features = isArray(geojson) ? geojson : geojson.features, i2, len, feature;
        if (features) {
          for (i2 = 0, len = features.length; i2 < len; i2++) {
            feature = features[i2];
            if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
              this.addData(feature);
            }
          }
          return this;
        }
        var options2 = this.options;
        if (options2.filter && !options2.filter(geojson)) {
          return this;
        }
        var layer = geometryToLayer(geojson, options2);
        if (!layer) {
          return this;
        }
        layer.feature = asFeature(geojson);
        layer.defaultOptions = layer.options;
        this.resetStyle(layer);
        if (options2.onEachFeature) {
          options2.onEachFeature(geojson, layer);
        }
        return this.addLayer(layer);
      },
      resetStyle: function(layer) {
        if (layer === void 0) {
          return this.eachLayer(this.resetStyle, this);
        }
        layer.options = extend2({}, layer.defaultOptions);
        this._setLayerStyle(layer, this.options.style);
        return this;
      },
      setStyle: function(style) {
        return this.eachLayer(function(layer) {
          this._setLayerStyle(layer, style);
        }, this);
      },
      _setLayerStyle: function(layer, style) {
        if (layer.setStyle) {
          if (typeof style === "function") {
            style = style(layer.feature);
          }
          layer.setStyle(style);
        }
      }
    });
    function geometryToLayer(geojson, options2) {
      var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options2 && options2.pointToLayer, _coordsToLatLng = options2 && options2.coordsToLatLng || coordsToLatLng, latlng, latlngs, i2, len;
      if (!coords && !geometry) {
        return null;
      }
      switch (geometry.type) {
        case "Point":
          latlng = _coordsToLatLng(coords);
          return _pointToLayer(pointToLayer, geojson, latlng, options2);
        case "MultiPoint":
          for (i2 = 0, len = coords.length; i2 < len; i2++) {
            latlng = _coordsToLatLng(coords[i2]);
            layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options2));
          }
          return new FeatureGroup(layers2);
        case "LineString":
        case "MultiLineString":
          latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
          return new Polyline(latlngs, options2);
        case "Polygon":
        case "MultiPolygon":
          latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
          return new Polygon(latlngs, options2);
        case "GeometryCollection":
          for (i2 = 0, len = geometry.geometries.length; i2 < len; i2++) {
            var layer = geometryToLayer({
              geometry: geometry.geometries[i2],
              type: "Feature",
              properties: geojson.properties
            }, options2);
            if (layer) {
              layers2.push(layer);
            }
          }
          return new FeatureGroup(layers2);
        default:
          throw new Error("Invalid GeoJSON object.");
      }
    }
    function _pointToLayer(pointToLayerFn, geojson, latlng, options2) {
      return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker2(latlng, options2 && options2.markersInheritOptions && options2);
    }
    function coordsToLatLng(coords) {
      return new LatLng(coords[1], coords[0], coords[2]);
    }
    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
      var latlngs = [];
      for (var i2 = 0, len = coords.length, latlng; i2 < len; i2++) {
        latlng = levelsDeep ? coordsToLatLngs(coords[i2], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i2]);
        latlngs.push(latlng);
      }
      return latlngs;
    }
    function latLngToCoords(latlng, precision) {
      precision = typeof precision === "number" ? precision : 6;
      return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
    }
    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
      var coords = [];
      for (var i2 = 0, len = latlngs.length; i2 < len; i2++) {
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i2], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i2], precision));
      }
      if (!levelsDeep && closed) {
        coords.push(coords[0]);
      }
      return coords;
    }
    function getFeature(layer, newGeometry) {
      return layer.feature ? extend2({}, layer.feature, {geometry: newGeometry}) : asFeature(newGeometry);
    }
    function asFeature(geojson) {
      if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
        return geojson;
      }
      return {
        type: "Feature",
        properties: {},
        geometry: geojson
      };
    }
    var PointToGeoJSON = {
      toGeoJSON: function(precision) {
        return getFeature(this, {
          type: "Point",
          coordinates: latLngToCoords(this.getLatLng(), precision)
        });
      }
    };
    Marker2.include(PointToGeoJSON);
    Circle.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON);
    Polyline.include({
      toGeoJSON: function(precision) {
        var multi = !isFlat(this._latlngs);
        var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "LineString",
          coordinates: coords
        });
      }
    });
    Polygon.include({
      toGeoJSON: function(precision) {
        var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
        var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
        if (!holes) {
          coords = [coords];
        }
        return getFeature(this, {
          type: (multi ? "Multi" : "") + "Polygon",
          coordinates: coords
        });
      }
    });
    LayerGroup.include({
      toMultiPoint: function(precision) {
        var coords = [];
        this.eachLayer(function(layer) {
          coords.push(layer.toGeoJSON(precision).geometry.coordinates);
        });
        return getFeature(this, {
          type: "MultiPoint",
          coordinates: coords
        });
      },
      toGeoJSON: function(precision) {
        var type = this.feature && this.feature.geometry && this.feature.geometry.type;
        if (type === "MultiPoint") {
          return this.toMultiPoint(precision);
        }
        var isGeometryCollection = type === "GeometryCollection", jsons = [];
        this.eachLayer(function(layer) {
          if (layer.toGeoJSON) {
            var json = layer.toGeoJSON(precision);
            if (isGeometryCollection) {
              jsons.push(json.geometry);
            } else {
              var feature = asFeature(json);
              if (feature.type === "FeatureCollection") {
                jsons.push.apply(jsons, feature.features);
              } else {
                jsons.push(feature);
              }
            }
          }
        });
        if (isGeometryCollection) {
          return getFeature(this, {
            geometries: jsons,
            type: "GeometryCollection"
          });
        }
        return {
          type: "FeatureCollection",
          features: jsons
        };
      }
    });
    function geoJSON(geojson, options2) {
      return new GeoJSON(geojson, options2);
    }
    var geoJson = geoJSON;
    var ImageOverlay = Layer.extend({
      options: {
        opacity: 1,
        alt: "",
        interactive: false,
        crossOrigin: false,
        errorOverlayUrl: "",
        zIndex: 1,
        className: ""
      },
      initialize: function(url, bounds, options2) {
        this._url = url;
        this._bounds = toLatLngBounds(bounds);
        setOptions2(this, options2);
      },
      onAdd: function() {
        if (!this._image) {
          this._initImage();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
        }
        if (this.options.interactive) {
          addClass(this._image, "leaflet-interactive");
          this.addInteractiveTarget(this._image);
        }
        this.getPane().appendChild(this._image);
        this._reset();
      },
      onRemove: function() {
        remove(this._image);
        if (this.options.interactive) {
          this.removeInteractiveTarget(this._image);
        }
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._image) {
          this._updateOpacity();
        }
        return this;
      },
      setStyle: function(styleOpts) {
        if (styleOpts.opacity) {
          this.setOpacity(styleOpts.opacity);
        }
        return this;
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._image);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._image);
        }
        return this;
      },
      setUrl: function(url) {
        this._url = url;
        if (this._image) {
          this._image.src = url;
        }
        return this;
      },
      setBounds: function(bounds) {
        this._bounds = toLatLngBounds(bounds);
        if (this._map) {
          this._reset();
        }
        return this;
      },
      getEvents: function() {
        var events = {
          zoom: this._reset,
          viewreset: this._reset
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      setZIndex: function(value) {
        this.options.zIndex = value;
        this._updateZIndex();
        return this;
      },
      getBounds: function() {
        return this._bounds;
      },
      getElement: function() {
        return this._image;
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "IMG";
        var img = this._image = wasElementSupplied ? this._url : create$1("img");
        addClass(img, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(img, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(img, this.options.className);
        }
        img.onselectstart = falseFn;
        img.onmousemove = falseFn;
        img.onload = bind(this.fire, this, "load");
        img.onerror = bind(this._overlayOnError, this, "error");
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        if (this.options.zIndex) {
          this._updateZIndex();
        }
        if (wasElementSupplied) {
          this._url = img.src;
          return;
        }
        img.src = this._url;
        img.alt = this.options.alt;
      },
      _animateZoom: function(e2) {
        var scale2 = this._map.getZoomScale(e2.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e2.zoom, e2.center).min;
        setTransform(this._image, offset, scale2);
      },
      _reset: function() {
        var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
        setPosition(image, bounds.min);
        image.style.width = size.x + "px";
        image.style.height = size.y + "px";
      },
      _updateOpacity: function() {
        setOpacity(this._image, this.options.opacity);
      },
      _updateZIndex: function() {
        if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._image.style.zIndex = this.options.zIndex;
        }
      },
      _overlayOnError: function() {
        this.fire("error");
        var errorUrl = this.options.errorOverlayUrl;
        if (errorUrl && this._url !== errorUrl) {
          this._url = errorUrl;
          this._image.src = errorUrl;
        }
      }
    });
    var imageOverlay = function(url, bounds, options2) {
      return new ImageOverlay(url, bounds, options2);
    };
    var VideoOverlay = ImageOverlay.extend({
      options: {
        autoplay: true,
        loop: true,
        keepAspectRatio: true,
        muted: false
      },
      _initImage: function() {
        var wasElementSupplied = this._url.tagName === "VIDEO";
        var vid = this._image = wasElementSupplied ? this._url : create$1("video");
        addClass(vid, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(vid, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(vid, this.options.className);
        }
        vid.onselectstart = falseFn;
        vid.onmousemove = falseFn;
        vid.onloadeddata = bind(this.fire, this, "load");
        if (wasElementSupplied) {
          var sourceElements = vid.getElementsByTagName("source");
          var sources = [];
          for (var j2 = 0; j2 < sourceElements.length; j2++) {
            sources.push(sourceElements[j2].src);
          }
          this._url = sourceElements.length > 0 ? sources : [vid.src];
          return;
        }
        if (!isArray(this._url)) {
          this._url = [this._url];
        }
        if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
          vid.style["objectFit"] = "fill";
        }
        vid.autoplay = !!this.options.autoplay;
        vid.loop = !!this.options.loop;
        vid.muted = !!this.options.muted;
        for (var i2 = 0; i2 < this._url.length; i2++) {
          var source = create$1("source");
          source.src = this._url[i2];
          vid.appendChild(source);
        }
      }
    });
    function videoOverlay(video, bounds, options2) {
      return new VideoOverlay(video, bounds, options2);
    }
    var SVGOverlay = ImageOverlay.extend({
      _initImage: function() {
        var el2 = this._image = this._url;
        addClass(el2, "leaflet-image-layer");
        if (this._zoomAnimated) {
          addClass(el2, "leaflet-zoom-animated");
        }
        if (this.options.className) {
          addClass(el2, this.options.className);
        }
        el2.onselectstart = falseFn;
        el2.onmousemove = falseFn;
      }
    });
    function svgOverlay(el2, bounds, options2) {
      return new SVGOverlay(el2, bounds, options2);
    }
    var DivOverlay = Layer.extend({
      options: {
        offset: [0, 7],
        className: "",
        pane: "popupPane"
      },
      initialize: function(options2, source) {
        setOptions2(this, options2);
        this._source = source;
      },
      onAdd: function(map) {
        this._zoomAnimated = map._zoomAnimated;
        if (!this._container) {
          this._initLayout();
        }
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
        }
        clearTimeout(this._removeTimeout);
        this.getPane().appendChild(this._container);
        this.update();
        if (map._fadeAnimated) {
          setOpacity(this._container, 1);
        }
        this.bringToFront();
      },
      onRemove: function(map) {
        if (map._fadeAnimated) {
          setOpacity(this._container, 0);
          this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
        } else {
          remove(this._container);
        }
      },
      getLatLng: function() {
        return this._latlng;
      },
      setLatLng: function(latlng) {
        this._latlng = toLatLng(latlng);
        if (this._map) {
          this._updatePosition();
          this._adjustPan();
        }
        return this;
      },
      getContent: function() {
        return this._content;
      },
      setContent: function(content) {
        this._content = content;
        this.update();
        return this;
      },
      getElement: function() {
        return this._container;
      },
      update: function() {
        if (!this._map) {
          return;
        }
        this._container.style.visibility = "hidden";
        this._updateContent();
        this._updateLayout();
        this._updatePosition();
        this._container.style.visibility = "";
        this._adjustPan();
      },
      getEvents: function() {
        var events = {
          zoom: this._updatePosition,
          viewreset: this._updatePosition
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      isOpen: function() {
        return !!this._map && this._map.hasLayer(this);
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
        }
        return this;
      },
      _prepareOpen: function(parent, layer, latlng) {
        if (!(layer instanceof Layer)) {
          latlng = layer;
          layer = parent;
        }
        if (layer instanceof FeatureGroup) {
          for (var id in parent._layers) {
            layer = parent._layers[id];
            break;
          }
        }
        if (!latlng) {
          if (layer.getCenter) {
            latlng = layer.getCenter();
          } else if (layer.getLatLng) {
            latlng = layer.getLatLng();
          } else {
            throw new Error("Unable to get source layer LatLng.");
          }
        }
        this._source = layer;
        this.update();
        return latlng;
      },
      _updateContent: function() {
        if (!this._content) {
          return;
        }
        var node2 = this._contentNode;
        var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
        if (typeof content === "string") {
          node2.innerHTML = content;
        } else {
          while (node2.hasChildNodes()) {
            node2.removeChild(node2.firstChild);
          }
          node2.appendChild(content);
        }
        this.fire("contentupdate");
      },
      _updatePosition: function() {
        if (!this._map) {
          return;
        }
        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (this._zoomAnimated) {
          setPosition(this._container, pos.add(anchor));
        } else {
          offset = offset.add(pos).add(anchor);
        }
        var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
        this._container.style.bottom = bottom + "px";
        this._container.style.left = left + "px";
      },
      _getAnchor: function() {
        return [0, 0];
      }
    });
    var Popup = DivOverlay.extend({
      options: {
        maxWidth: 300,
        minWidth: 50,
        maxHeight: null,
        autoPan: true,
        autoPanPaddingTopLeft: null,
        autoPanPaddingBottomRight: null,
        autoPanPadding: [5, 5],
        keepInView: false,
        closeButton: true,
        autoClose: true,
        closeOnEscapeKey: true,
        className: ""
      },
      openOn: function(map) {
        map.openPopup(this);
        return this;
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        map.fire("popupopen", {popup: this});
        if (this._source) {
          this._source.fire("popupopen", {popup: this}, true);
          if (!(this._source instanceof Path2)) {
            this._source.on("preclick", stopPropagation);
          }
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("popupclose", {popup: this});
        if (this._source) {
          this._source.fire("popupclose", {popup: this}, true);
          if (!(this._source instanceof Path2)) {
            this._source.off("preclick", stopPropagation);
          }
        }
      },
      getEvents: function() {
        var events = DivOverlay.prototype.getEvents.call(this);
        if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
          events.preclick = this._close;
        }
        if (this.options.keepInView) {
          events.moveend = this._adjustPan;
        }
        return events;
      },
      _close: function() {
        if (this._map) {
          this._map.closePopup(this);
        }
      },
      _initLayout: function() {
        var prefix3 = "leaflet-popup", container = this._container = create$1("div", prefix3 + " " + (this.options.className || "") + " leaflet-zoom-animated");
        var wrapper = this._wrapper = create$1("div", prefix3 + "-content-wrapper", container);
        this._contentNode = create$1("div", prefix3 + "-content", wrapper);
        disableClickPropagation(container);
        disableScrollPropagation(this._contentNode);
        on(container, "contextmenu", stopPropagation);
        this._tipContainer = create$1("div", prefix3 + "-tip-container", container);
        this._tip = create$1("div", prefix3 + "-tip", this._tipContainer);
        if (this.options.closeButton) {
          var closeButton = this._closeButton = create$1("a", prefix3 + "-close-button", container);
          closeButton.href = "#close";
          closeButton.innerHTML = "&#215;";
          on(closeButton, "click", this._onCloseButtonClick, this);
        }
      },
      _updateLayout: function() {
        var container = this._contentNode, style = container.style;
        style.width = "";
        style.whiteSpace = "nowrap";
        var width = container.offsetWidth;
        width = Math.min(width, this.options.maxWidth);
        width = Math.max(width, this.options.minWidth);
        style.width = width + 1 + "px";
        style.whiteSpace = "";
        style.height = "";
        var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
        if (maxHeight && height > maxHeight) {
          style.height = maxHeight + "px";
          addClass(container, scrolledClass);
        } else {
          removeClass(container, scrolledClass);
        }
        this._containerWidth = this._container.offsetWidth;
      },
      _animateZoom: function(e2) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e2.zoom, e2.center), anchor = this._getAnchor();
        setPosition(this._container, pos.add(anchor));
      },
      _adjustPan: function() {
        if (!this.options.autoPan) {
          return;
        }
        if (this._map._panAnim) {
          this._map._panAnim.stop();
        }
        var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
        layerPos._add(getPosition(this._container));
        var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
        if (containerPos.x + containerWidth + paddingBR.x > size.x) {
          dx = containerPos.x + containerWidth - size.x + paddingBR.x;
        }
        if (containerPos.x - dx - paddingTL.x < 0) {
          dx = containerPos.x - paddingTL.x;
        }
        if (containerPos.y + containerHeight + paddingBR.y > size.y) {
          dy = containerPos.y + containerHeight - size.y + paddingBR.y;
        }
        if (containerPos.y - dy - paddingTL.y < 0) {
          dy = containerPos.y - paddingTL.y;
        }
        if (dx || dy) {
          map.fire("autopanstart").panBy([dx, dy]);
        }
      },
      _onCloseButtonClick: function(e2) {
        this._close();
        stop(e2);
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
      }
    });
    var popup = function(options2, source) {
      return new Popup(options2, source);
    };
    Map3.mergeOptions({
      closePopupOnClick: true
    });
    Map3.include({
      openPopup: function(popup2, latlng, options2) {
        if (!(popup2 instanceof Popup)) {
          popup2 = new Popup(options2).setContent(popup2);
        }
        if (latlng) {
          popup2.setLatLng(latlng);
        }
        if (this.hasLayer(popup2)) {
          return this;
        }
        if (this._popup && this._popup.options.autoClose) {
          this.closePopup();
        }
        this._popup = popup2;
        return this.addLayer(popup2);
      },
      closePopup: function(popup2) {
        if (!popup2 || popup2 === this._popup) {
          popup2 = this._popup;
          this._popup = null;
        }
        if (popup2) {
          this.removeLayer(popup2);
        }
        return this;
      }
    });
    Layer.include({
      bindPopup: function(content, options2) {
        if (content instanceof Popup) {
          setOptions2(content, options2);
          this._popup = content;
          content._source = this;
        } else {
          if (!this._popup || options2) {
            this._popup = new Popup(options2, this);
          }
          this._popup.setContent(content);
        }
        if (!this._popupHandlersAdded) {
          this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = true;
        }
        return this;
      },
      unbindPopup: function() {
        if (this._popup) {
          this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          });
          this._popupHandlersAdded = false;
          this._popup = null;
        }
        return this;
      },
      openPopup: function(layer, latlng) {
        if (this._popup && this._map) {
          latlng = this._popup._prepareOpen(this, layer, latlng);
          this._map.openPopup(this._popup, latlng);
        }
        return this;
      },
      closePopup: function() {
        if (this._popup) {
          this._popup._close();
        }
        return this;
      },
      togglePopup: function(target) {
        if (this._popup) {
          if (this._popup._map) {
            this.closePopup();
          } else {
            this.openPopup(target);
          }
        }
        return this;
      },
      isPopupOpen: function() {
        return this._popup ? this._popup.isOpen() : false;
      },
      setPopupContent: function(content) {
        if (this._popup) {
          this._popup.setContent(content);
        }
        return this;
      },
      getPopup: function() {
        return this._popup;
      },
      _openPopup: function(e2) {
        var layer = e2.layer || e2.target;
        if (!this._popup) {
          return;
        }
        if (!this._map) {
          return;
        }
        stop(e2);
        if (layer instanceof Path2) {
          this.openPopup(e2.layer || e2.target, e2.latlng);
          return;
        }
        if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
          this.closePopup();
        } else {
          this.openPopup(layer, e2.latlng);
        }
      },
      _movePopup: function(e2) {
        this._popup.setLatLng(e2.latlng);
      },
      _onKeyPress: function(e2) {
        if (e2.originalEvent.keyCode === 13) {
          this._openPopup(e2);
        }
      }
    });
    var Tooltip = DivOverlay.extend({
      options: {
        pane: "tooltipPane",
        offset: [0, 0],
        direction: "auto",
        permanent: false,
        sticky: false,
        interactive: false,
        opacity: 0.9
      },
      onAdd: function(map) {
        DivOverlay.prototype.onAdd.call(this, map);
        this.setOpacity(this.options.opacity);
        map.fire("tooltipopen", {tooltip: this});
        if (this._source) {
          this._source.fire("tooltipopen", {tooltip: this}, true);
        }
      },
      onRemove: function(map) {
        DivOverlay.prototype.onRemove.call(this, map);
        map.fire("tooltipclose", {tooltip: this});
        if (this._source) {
          this._source.fire("tooltipclose", {tooltip: this}, true);
        }
      },
      getEvents: function() {
        var events = DivOverlay.prototype.getEvents.call(this);
        if (touch && !this.options.permanent) {
          events.preclick = this._close;
        }
        return events;
      },
      _close: function() {
        if (this._map) {
          this._map.closeTooltip(this);
        }
      },
      _initLayout: function() {
        var prefix3 = "leaflet-tooltip", className = prefix3 + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
        this._contentNode = this._container = create$1("div", className);
      },
      _updateLayout: function() {
      },
      _adjustPan: function() {
      },
      _setPosition: function(pos) {
        var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
        if (direction === "top") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight;
        } else if (direction === "bottom") {
          subX = tooltipWidth / 2;
          subY = 0;
        } else if (direction === "center") {
          subX = tooltipWidth / 2;
          subY = tooltipHeight / 2;
        } else if (direction === "right") {
          subX = 0;
          subY = tooltipHeight / 2;
        } else if (direction === "left") {
          subX = tooltipWidth;
          subY = tooltipHeight / 2;
        } else if (tooltipPoint.x < centerPoint.x) {
          direction = "right";
          subX = 0;
          subY = tooltipHeight / 2;
        } else {
          direction = "left";
          subX = tooltipWidth + (offset.x + anchor.x) * 2;
          subY = tooltipHeight / 2;
        }
        pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
        removeClass(container, "leaflet-tooltip-right");
        removeClass(container, "leaflet-tooltip-left");
        removeClass(container, "leaflet-tooltip-top");
        removeClass(container, "leaflet-tooltip-bottom");
        addClass(container, "leaflet-tooltip-" + direction);
        setPosition(container, pos);
      },
      _updatePosition: function() {
        var pos = this._map.latLngToLayerPoint(this._latlng);
        this._setPosition(pos);
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        if (this._container) {
          setOpacity(this._container, opacity);
        }
      },
      _animateZoom: function(e2) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, e2.zoom, e2.center);
        this._setPosition(pos);
      },
      _getAnchor: function() {
        return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
      }
    });
    var tooltip = function(options2, source) {
      return new Tooltip(options2, source);
    };
    Map3.include({
      openTooltip: function(tooltip2, latlng, options2) {
        if (!(tooltip2 instanceof Tooltip)) {
          tooltip2 = new Tooltip(options2).setContent(tooltip2);
        }
        if (latlng) {
          tooltip2.setLatLng(latlng);
        }
        if (this.hasLayer(tooltip2)) {
          return this;
        }
        return this.addLayer(tooltip2);
      },
      closeTooltip: function(tooltip2) {
        if (tooltip2) {
          this.removeLayer(tooltip2);
        }
        return this;
      }
    });
    Layer.include({
      bindTooltip: function(content, options2) {
        if (content instanceof Tooltip) {
          setOptions2(content, options2);
          this._tooltip = content;
          content._source = this;
        } else {
          if (!this._tooltip || options2) {
            this._tooltip = new Tooltip(options2, this);
          }
          this._tooltip.setContent(content);
        }
        this._initTooltipInteractions();
        if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
          this.openTooltip();
        }
        return this;
      },
      unbindTooltip: function() {
        if (this._tooltip) {
          this._initTooltipInteractions(true);
          this.closeTooltip();
          this._tooltip = null;
        }
        return this;
      },
      _initTooltipInteractions: function(remove$$1) {
        if (!remove$$1 && this._tooltipHandlersAdded) {
          return;
        }
        var onOff = remove$$1 ? "off" : "on", events = {
          remove: this.closeTooltip,
          move: this._moveTooltip
        };
        if (!this._tooltip.options.permanent) {
          events.mouseover = this._openTooltip;
          events.mouseout = this.closeTooltip;
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          if (touch) {
            events.click = this._openTooltip;
          }
        } else {
          events.add = this._openTooltip;
        }
        this[onOff](events);
        this._tooltipHandlersAdded = !remove$$1;
      },
      openTooltip: function(layer, latlng) {
        if (this._tooltip && this._map) {
          latlng = this._tooltip._prepareOpen(this, layer, latlng);
          this._map.openTooltip(this._tooltip, latlng);
          if (this._tooltip.options.interactive && this._tooltip._container) {
            addClass(this._tooltip._container, "leaflet-clickable");
            this.addInteractiveTarget(this._tooltip._container);
          }
        }
        return this;
      },
      closeTooltip: function() {
        if (this._tooltip) {
          this._tooltip._close();
          if (this._tooltip.options.interactive && this._tooltip._container) {
            removeClass(this._tooltip._container, "leaflet-clickable");
            this.removeInteractiveTarget(this._tooltip._container);
          }
        }
        return this;
      },
      toggleTooltip: function(target) {
        if (this._tooltip) {
          if (this._tooltip._map) {
            this.closeTooltip();
          } else {
            this.openTooltip(target);
          }
        }
        return this;
      },
      isTooltipOpen: function() {
        return this._tooltip.isOpen();
      },
      setTooltipContent: function(content) {
        if (this._tooltip) {
          this._tooltip.setContent(content);
        }
        return this;
      },
      getTooltip: function() {
        return this._tooltip;
      },
      _openTooltip: function(e2) {
        var layer = e2.layer || e2.target;
        if (!this._tooltip || !this._map) {
          return;
        }
        this.openTooltip(layer, this._tooltip.options.sticky ? e2.latlng : void 0);
      },
      _moveTooltip: function(e2) {
        var latlng = e2.latlng, containerPoint, layerPoint;
        if (this._tooltip.options.sticky && e2.originalEvent) {
          containerPoint = this._map.mouseEventToContainerPoint(e2.originalEvent);
          layerPoint = this._map.containerPointToLayerPoint(containerPoint);
          latlng = this._map.layerPointToLatLng(layerPoint);
        }
        this._tooltip.setLatLng(latlng);
      }
    });
    var DivIcon = Icon.extend({
      options: {
        iconSize: [12, 12],
        html: false,
        bgPos: null,
        className: "leaflet-div-icon"
      },
      createIcon: function(oldIcon) {
        var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options2 = this.options;
        if (options2.html instanceof Element) {
          empty(div);
          div.appendChild(options2.html);
        } else {
          div.innerHTML = options2.html !== false ? options2.html : "";
        }
        if (options2.bgPos) {
          var bgPos = toPoint(options2.bgPos);
          div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
        }
        this._setIconStyles(div, "icon");
        return div;
      },
      createShadow: function() {
        return null;
      }
    });
    function divIcon(options2) {
      return new DivIcon(options2);
    }
    Icon.Default = IconDefault;
    var GridLayer = Layer.extend({
      options: {
        tileSize: 256,
        opacity: 1,
        updateWhenIdle: mobile,
        updateWhenZooming: true,
        updateInterval: 200,
        zIndex: 1,
        bounds: null,
        minZoom: 0,
        maxZoom: void 0,
        maxNativeZoom: void 0,
        minNativeZoom: void 0,
        noWrap: false,
        pane: "tilePane",
        className: "",
        keepBuffer: 2
      },
      initialize: function(options2) {
        setOptions2(this, options2);
      },
      onAdd: function() {
        this._initContainer();
        this._levels = {};
        this._tiles = {};
        this._resetView();
        this._update();
      },
      beforeAdd: function(map) {
        map._addZoomLimit(this);
      },
      onRemove: function(map) {
        this._removeAllTiles();
        remove(this._container);
        map._removeZoomLimit(this);
        this._container = null;
        this._tileZoom = void 0;
      },
      bringToFront: function() {
        if (this._map) {
          toFront(this._container);
          this._setAutoZIndex(Math.max);
        }
        return this;
      },
      bringToBack: function() {
        if (this._map) {
          toBack(this._container);
          this._setAutoZIndex(Math.min);
        }
        return this;
      },
      getContainer: function() {
        return this._container;
      },
      setOpacity: function(opacity) {
        this.options.opacity = opacity;
        this._updateOpacity();
        return this;
      },
      setZIndex: function(zIndex) {
        this.options.zIndex = zIndex;
        this._updateZIndex();
        return this;
      },
      isLoading: function() {
        return this._loading;
      },
      redraw: function() {
        if (this._map) {
          this._removeAllTiles();
          this._update();
        }
        return this;
      },
      getEvents: function() {
        var events = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };
        if (!this.options.updateWhenIdle) {
          if (!this._onMove) {
            this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
          }
          events.move = this._onMove;
        }
        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }
        return events;
      },
      createTile: function() {
        return document.createElement("div");
      },
      getTileSize: function() {
        var s2 = this.options.tileSize;
        return s2 instanceof Point ? s2 : new Point(s2, s2);
      },
      _updateZIndex: function() {
        if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
          this._container.style.zIndex = this.options.zIndex;
        }
      },
      _setAutoZIndex: function(compare) {
        var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
        for (var i2 = 0, len = layers2.length, zIndex; i2 < len; i2++) {
          zIndex = layers2[i2].style.zIndex;
          if (layers2[i2] !== this._container && zIndex) {
            edgeZIndex = compare(edgeZIndex, +zIndex);
          }
        }
        if (isFinite(edgeZIndex)) {
          this.options.zIndex = edgeZIndex + compare(-1, 1);
          this._updateZIndex();
        }
      },
      _updateOpacity: function() {
        if (!this._map) {
          return;
        }
        if (ielt9) {
          return;
        }
        setOpacity(this._container, this.options.opacity);
        var now3 = +new Date(), nextFrame = false, willPrune = false;
        for (var key in this._tiles) {
          var tile = this._tiles[key];
          if (!tile.current || !tile.loaded) {
            continue;
          }
          var fade = Math.min(1, (now3 - tile.loaded) / 200);
          setOpacity(tile.el, fade);
          if (fade < 1) {
            nextFrame = true;
          } else {
            if (tile.active) {
              willPrune = true;
            } else {
              this._onOpaqueTile(tile);
            }
            tile.active = true;
          }
        }
        if (willPrune && !this._noPrune) {
          this._pruneTiles();
        }
        if (nextFrame) {
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        }
      },
      _onOpaqueTile: falseFn,
      _initContainer: function() {
        if (this._container) {
          return;
        }
        this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
        this._updateZIndex();
        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
        this.getPane().appendChild(this._container);
      },
      _updateLevels: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
        if (zoom2 === void 0) {
          return void 0;
        }
        for (var z2 in this._levels) {
          z2 = Number(z2);
          if (this._levels[z2].el.children.length || z2 === zoom2) {
            this._levels[z2].el.style.zIndex = maxZoom - Math.abs(zoom2 - z2);
            this._onUpdateLevel(z2);
          } else {
            remove(this._levels[z2].el);
            this._removeTilesAtZoom(z2);
            this._onRemoveLevel(z2);
            delete this._levels[z2];
          }
        }
        var level = this._levels[zoom2], map = this._map;
        if (!level) {
          level = this._levels[zoom2] = {};
          level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
          level.el.style.zIndex = maxZoom;
          level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
          level.zoom = zoom2;
          this._setZoomTransform(level, map.getCenter(), map.getZoom());
          falseFn(level.el.offsetWidth);
          this._onCreateLevel(level);
        }
        this._level = level;
        return level;
      },
      _onUpdateLevel: falseFn,
      _onRemoveLevel: falseFn,
      _onCreateLevel: falseFn,
      _pruneTiles: function() {
        if (!this._map) {
          return;
        }
        var key, tile;
        var zoom2 = this._map.getZoom();
        if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
          this._removeAllTiles();
          return;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          tile.retain = tile.current;
        }
        for (key in this._tiles) {
          tile = this._tiles[key];
          if (tile.current && !tile.active) {
            var coords = tile.coords;
            if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
              this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
            }
          }
        }
        for (key in this._tiles) {
          if (!this._tiles[key].retain) {
            this._removeTile(key);
          }
        }
      },
      _removeTilesAtZoom: function(zoom2) {
        for (var key in this._tiles) {
          if (this._tiles[key].coords.z !== zoom2) {
            continue;
          }
          this._removeTile(key);
        }
      },
      _removeAllTiles: function() {
        for (var key in this._tiles) {
          this._removeTile(key);
        }
      },
      _invalidateAll: function() {
        for (var z2 in this._levels) {
          remove(this._levels[z2].el);
          this._onRemoveLevel(Number(z2));
          delete this._levels[z2];
        }
        this._removeAllTiles();
        this._tileZoom = void 0;
      },
      _retainParent: function(x2, y2, z2, minZoom) {
        var x22 = Math.floor(x2 / 2), y22 = Math.floor(y2 / 2), z22 = z2 - 1, coords2 = new Point(+x22, +y22);
        coords2.z = +z22;
        var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
        if (tile && tile.active) {
          tile.retain = true;
          return true;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }
        if (z22 > minZoom) {
          return this._retainParent(x22, y22, z22, minZoom);
        }
        return false;
      },
      _retainChildren: function(x2, y2, z2, maxZoom) {
        for (var i2 = 2 * x2; i2 < 2 * x2 + 2; i2++) {
          for (var j2 = 2 * y2; j2 < 2 * y2 + 2; j2++) {
            var coords = new Point(i2, j2);
            coords.z = z2 + 1;
            var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
            if (tile && tile.active) {
              tile.retain = true;
              continue;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }
            if (z2 + 1 < maxZoom) {
              this._retainChildren(i2, j2, z2 + 1, maxZoom);
            }
          }
        }
      },
      _resetView: function(e2) {
        var animating = e2 && (e2.pinch || e2.flyTo);
        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
      },
      _animateZoom: function(e2) {
        this._setView(e2.center, e2.zoom, true, e2.noUpdate);
      },
      _clampZoom: function(zoom2) {
        var options2 = this.options;
        if (options2.minNativeZoom !== void 0 && zoom2 < options2.minNativeZoom) {
          return options2.minNativeZoom;
        }
        if (options2.maxNativeZoom !== void 0 && options2.maxNativeZoom < zoom2) {
          return options2.maxNativeZoom;
        }
        return zoom2;
      },
      _setView: function(center, zoom2, noPrune, noUpdate) {
        var tileZoom = Math.round(zoom2);
        if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
          tileZoom = void 0;
        } else {
          tileZoom = this._clampZoom(tileZoom);
        }
        var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
        if (!noUpdate || tileZoomChanged) {
          this._tileZoom = tileZoom;
          if (this._abortLoading) {
            this._abortLoading();
          }
          this._updateLevels();
          this._resetGrid();
          if (tileZoom !== void 0) {
            this._update(center);
          }
          if (!noPrune) {
            this._pruneTiles();
          }
          this._noPrune = !!noPrune;
        }
        this._setZoomTransforms(center, zoom2);
      },
      _setZoomTransforms: function(center, zoom2) {
        for (var i2 in this._levels) {
          this._setZoomTransform(this._levels[i2], center, zoom2);
        }
      },
      _setZoomTransform: function(level, center, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
        if (any3d) {
          setTransform(level.el, translate, scale2);
        } else {
          setPosition(level.el, translate);
        }
      },
      _resetGrid: function() {
        var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
        var bounds = this._map.getPixelWorldBounds(this._tileZoom);
        if (bounds) {
          this._globalTileRange = this._pxBoundsToTileRange(bounds);
        }
        this._wrapX = crs.wrapLng && !this.options.noWrap && [
          Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
          Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
        ];
        this._wrapY = crs.wrapLat && !this.options.noWrap && [
          Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
          Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
        ];
      },
      _onMoveEnd: function() {
        if (!this._map || this._map._animatingZoom) {
          return;
        }
        this._update();
      },
      _getTiledPixelBounds: function(center) {
        var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
        return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
      },
      _update: function(center) {
        var map = this._map;
        if (!map) {
          return;
        }
        var zoom2 = this._clampZoom(map.getZoom());
        if (center === void 0) {
          center = map.getCenter();
        }
        if (this._tileZoom === void 0) {
          return;
        }
        var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));
        if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
          throw new Error("Attempted to load an infinite number of tiles");
        }
        for (var key in this._tiles) {
          var c2 = this._tiles[key].coords;
          if (c2.z !== this._tileZoom || !noPruneRange.contains(new Point(c2.x, c2.y))) {
            this._tiles[key].current = false;
          }
        }
        if (Math.abs(zoom2 - this._tileZoom) > 1) {
          this._setView(center, zoom2);
          return;
        }
        for (var j2 = tileRange.min.y; j2 <= tileRange.max.y; j2++) {
          for (var i2 = tileRange.min.x; i2 <= tileRange.max.x; i2++) {
            var coords = new Point(i2, j2);
            coords.z = this._tileZoom;
            if (!this._isValidTile(coords)) {
              continue;
            }
            var tile = this._tiles[this._tileCoordsToKey(coords)];
            if (tile) {
              tile.current = true;
            } else {
              queue.push(coords);
            }
          }
        }
        queue.sort(function(a2, b2) {
          return a2.distanceTo(tileCenter) - b2.distanceTo(tileCenter);
        });
        if (queue.length !== 0) {
          if (!this._loading) {
            this._loading = true;
            this.fire("loading");
          }
          var fragment = document.createDocumentFragment();
          for (i2 = 0; i2 < queue.length; i2++) {
            this._addTile(queue[i2], fragment);
          }
          this._level.el.appendChild(fragment);
        }
      },
      _isValidTile: function(coords) {
        var crs = this._map.options.crs;
        if (!crs.infinite) {
          var bounds = this._globalTileRange;
          if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
            return false;
          }
        }
        if (!this.options.bounds) {
          return true;
        }
        var tileBounds = this._tileCoordsToBounds(coords);
        return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
      },
      _keyToBounds: function(key) {
        return this._tileCoordsToBounds(this._keyToTileCoords(key));
      },
      _tileCoordsToNwSe: function(coords) {
        var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se2 = map.unproject(sePoint, coords.z);
        return [nw, se2];
      },
      _tileCoordsToBounds: function(coords) {
        var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
        if (!this.options.noWrap) {
          bounds = this._map.wrapLatLngBounds(bounds);
        }
        return bounds;
      },
      _tileCoordsToKey: function(coords) {
        return coords.x + ":" + coords.y + ":" + coords.z;
      },
      _keyToTileCoords: function(key) {
        var k2 = key.split(":"), coords = new Point(+k2[0], +k2[1]);
        coords.z = +k2[2];
        return coords;
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        remove(tile.el);
        delete this._tiles[key];
        this.fire("tileunload", {
          tile: tile.el,
          coords: this._keyToTileCoords(key)
        });
      },
      _initTile: function(tile) {
        addClass(tile, "leaflet-tile");
        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + "px";
        tile.style.height = tileSize.y + "px";
        tile.onselectstart = falseFn;
        tile.onmousemove = falseFn;
        if (ielt9 && this.options.opacity < 1) {
          setOpacity(tile, this.options.opacity);
        }
        if (android && !android23) {
          tile.style.WebkitBackfaceVisibility = "hidden";
        }
      },
      _addTile: function(coords, container) {
        var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
        var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
        this._initTile(tile);
        if (this.createTile.length < 2) {
          requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
        }
        setPosition(tile, tilePos);
        this._tiles[key] = {
          el: tile,
          coords,
          current: true
        };
        container.appendChild(tile);
        this.fire("tileloadstart", {
          tile,
          coords
        });
      },
      _tileReady: function(coords, err, tile) {
        if (err) {
          this.fire("tileerror", {
            error: err,
            tile,
            coords
          });
        }
        var key = this._tileCoordsToKey(coords);
        tile = this._tiles[key];
        if (!tile) {
          return;
        }
        tile.loaded = +new Date();
        if (this._map._fadeAnimated) {
          setOpacity(tile.el, 0);
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        } else {
          tile.active = true;
          this._pruneTiles();
        }
        if (!err) {
          addClass(tile.el, "leaflet-tile-loaded");
          this.fire("tileload", {
            tile: tile.el,
            coords
          });
        }
        if (this._noTilesToLoad()) {
          this._loading = false;
          this.fire("load");
          if (ielt9 || !this._map._fadeAnimated) {
            requestAnimFrame(this._pruneTiles, this);
          } else {
            setTimeout(bind(this._pruneTiles, this), 250);
          }
        }
      },
      _getTilePos: function(coords) {
        return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function(coords) {
        var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
        newCoords.z = coords.z;
        return newCoords;
      },
      _pxBoundsToTileRange: function(bounds) {
        var tileSize = this.getTileSize();
        return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
      },
      _noTilesToLoad: function() {
        for (var key in this._tiles) {
          if (!this._tiles[key].loaded) {
            return false;
          }
        }
        return true;
      }
    });
    function gridLayer(options2) {
      return new GridLayer(options2);
    }
    var TileLayer2 = GridLayer.extend({
      options: {
        minZoom: 0,
        maxZoom: 18,
        subdomains: "abc",
        errorTileUrl: "",
        zoomOffset: 0,
        tms: false,
        zoomReverse: false,
        detectRetina: false,
        crossOrigin: false
      },
      initialize: function(url, options2) {
        this._url = url;
        options2 = setOptions2(this, options2);
        if (options2.detectRetina && retina && options2.maxZoom > 0) {
          options2.tileSize = Math.floor(options2.tileSize / 2);
          if (!options2.zoomReverse) {
            options2.zoomOffset++;
            options2.maxZoom--;
          } else {
            options2.zoomOffset--;
            options2.minZoom++;
          }
          options2.minZoom = Math.max(0, options2.minZoom);
        }
        if (typeof options2.subdomains === "string") {
          options2.subdomains = options2.subdomains.split("");
        }
        if (!android) {
          this.on("tileunload", this._onTileRemove);
        }
      },
      setUrl: function(url, noRedraw) {
        if (this._url === url && noRedraw === void 0) {
          noRedraw = true;
        }
        this._url = url;
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      },
      createTile: function(coords, done) {
        var tile = document.createElement("img");
        on(tile, "load", bind(this._tileOnLoad, this, done, tile));
        on(tile, "error", bind(this._tileOnError, this, done, tile));
        if (this.options.crossOrigin || this.options.crossOrigin === "") {
          tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
        }
        tile.alt = "";
        tile.setAttribute("role", "presentation");
        tile.src = this.getTileUrl(coords);
        return tile;
      },
      getTileUrl: function(coords) {
        var data2 = {
          r: retina ? "@2x" : "",
          s: this._getSubdomain(coords),
          x: coords.x,
          y: coords.y,
          z: this._getZoomForUrl()
        };
        if (this._map && !this._map.options.crs.infinite) {
          var invertedY = this._globalTileRange.max.y - coords.y;
          if (this.options.tms) {
            data2["y"] = invertedY;
          }
          data2["-y"] = invertedY;
        }
        return template(this._url, extend2(data2, this.options));
      },
      _tileOnLoad: function(done, tile) {
        if (ielt9) {
          setTimeout(bind(done, this, null, tile), 0);
        } else {
          done(null, tile);
        }
      },
      _tileOnError: function(done, tile, e2) {
        var errorUrl = this.options.errorTileUrl;
        if (errorUrl && tile.getAttribute("src") !== errorUrl) {
          tile.src = errorUrl;
        }
        done(e2, tile);
      },
      _onTileRemove: function(e2) {
        e2.tile.onload = null;
      },
      _getZoomForUrl: function() {
        var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
        if (zoomReverse) {
          zoom2 = maxZoom - zoom2;
        }
        return zoom2 + zoomOffset;
      },
      _getSubdomain: function(tilePoint) {
        var index5 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
        return this.options.subdomains[index5];
      },
      _abortLoading: function() {
        var i2, tile;
        for (i2 in this._tiles) {
          if (this._tiles[i2].coords.z !== this._tileZoom) {
            tile = this._tiles[i2].el;
            tile.onload = falseFn;
            tile.onerror = falseFn;
            if (!tile.complete) {
              tile.src = emptyImageUrl;
              remove(tile);
              delete this._tiles[i2];
            }
          }
        }
      },
      _removeTile: function(key) {
        var tile = this._tiles[key];
        if (!tile) {
          return;
        }
        if (!androidStock) {
          tile.el.setAttribute("src", emptyImageUrl);
        }
        return GridLayer.prototype._removeTile.call(this, key);
      },
      _tileReady: function(coords, err, tile) {
        if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
          return;
        }
        return GridLayer.prototype._tileReady.call(this, coords, err, tile);
      }
    });
    function tileLayer(url, options2) {
      return new TileLayer2(url, options2);
    }
    var TileLayerWMS = TileLayer2.extend({
      defaultWmsParams: {
        service: "WMS",
        request: "GetMap",
        layers: "",
        styles: "",
        format: "image/jpeg",
        transparent: false,
        version: "1.1.1"
      },
      options: {
        crs: null,
        uppercase: false
      },
      initialize: function(url, options2) {
        this._url = url;
        var wmsParams = extend2({}, this.defaultWmsParams);
        for (var i2 in options2) {
          if (!(i2 in this.options)) {
            wmsParams[i2] = options2[i2];
          }
        }
        options2 = setOptions2(this, options2);
        var realRetina = options2.detectRetina && retina ? 2 : 1;
        var tileSize = this.getTileSize();
        wmsParams.width = tileSize.x * realRetina;
        wmsParams.height = tileSize.y * realRetina;
        this.wmsParams = wmsParams;
      },
      onAdd: function(map) {
        this._crs = this.options.crs || map.options.crs;
        this._wmsVersion = parseFloat(this.wmsParams.version);
        var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
        this.wmsParams[projectionKey] = this._crs.code;
        TileLayer2.prototype.onAdd.call(this, map);
      },
      getTileUrl: function(coords) {
        var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer2.prototype.getTileUrl.call(this, coords);
        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
      },
      setParams: function(params, noRedraw) {
        extend2(this.wmsParams, params);
        if (!noRedraw) {
          this.redraw();
        }
        return this;
      }
    });
    function tileLayerWMS(url, options2) {
      return new TileLayerWMS(url, options2);
    }
    TileLayer2.WMS = TileLayerWMS;
    tileLayer.wms = tileLayerWMS;
    var Renderer2 = Layer.extend({
      options: {
        padding: 0.1,
        tolerance: 0
      },
      initialize: function(options2) {
        setOptions2(this, options2);
        stamp(this);
        this._layers = this._layers || {};
      },
      onAdd: function() {
        if (!this._container) {
          this._initContainer();
          if (this._zoomAnimated) {
            addClass(this._container, "leaflet-zoom-animated");
          }
        }
        this.getPane().appendChild(this._container);
        this._update();
        this.on("update", this._updatePaths, this);
      },
      onRemove: function() {
        this.off("update", this._updatePaths, this);
        this._destroyContainer();
      },
      getEvents: function() {
        var events = {
          viewreset: this._reset,
          zoom: this._onZoom,
          moveend: this._update,
          zoomend: this._onZoomEnd
        };
        if (this._zoomAnimated) {
          events.zoomanim = this._onAnimZoom;
        }
        return events;
      },
      _onAnimZoom: function(ev) {
        this._updateTransform(ev.center, ev.zoom);
      },
      _onZoom: function() {
        this._updateTransform(this._map.getCenter(), this._map.getZoom());
      },
      _updateTransform: function(center, zoom2) {
        var scale2 = this._map.getZoomScale(zoom2, this._zoom), position2 = getPosition(this._container), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), destCenterPoint = this._map.project(center, zoom2), centerOffset = destCenterPoint.subtract(currentCenterPoint), topLeftOffset = viewHalf.multiplyBy(-scale2).add(position2).add(viewHalf).subtract(centerOffset);
        if (any3d) {
          setTransform(this._container, topLeftOffset, scale2);
        } else {
          setPosition(this._container, topLeftOffset);
        }
      },
      _reset: function() {
        this._update();
        this._updateTransform(this._center, this._zoom);
        for (var id in this._layers) {
          this._layers[id]._reset();
        }
      },
      _onZoomEnd: function() {
        for (var id in this._layers) {
          this._layers[id]._project();
        }
      },
      _updatePaths: function() {
        for (var id in this._layers) {
          this._layers[id]._update();
        }
      },
      _update: function() {
        var p2 = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p2)).round();
        this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p2 * 2)).round());
        this._center = this._map.getCenter();
        this._zoom = this._map.getZoom();
      }
    });
    var Canvas3 = Renderer2.extend({
      getEvents: function() {
        var events = Renderer2.prototype.getEvents.call(this);
        events.viewprereset = this._onViewPreReset;
        return events;
      },
      _onViewPreReset: function() {
        this._postponeUpdatePaths = true;
      },
      onAdd: function() {
        Renderer2.prototype.onAdd.call(this);
        this._draw();
      },
      _initContainer: function() {
        var container = this._container = document.createElement("canvas");
        on(container, "mousemove", this._onMouseMove, this);
        on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
        on(container, "mouseout", this._handleMouseOut, this);
        this._ctx = container.getContext("2d");
      },
      _destroyContainer: function() {
        cancelAnimFrame(this._redrawRequest);
        delete this._ctx;
        remove(this._container);
        off(this._container);
        delete this._container;
      },
      _updatePaths: function() {
        if (this._postponeUpdatePaths) {
          return;
        }
        var layer;
        this._redrawBounds = null;
        for (var id in this._layers) {
          layer = this._layers[id];
          layer._update();
        }
        this._redraw();
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer2.prototype._update.call(this);
        var b2 = this._bounds, container = this._container, size = b2.getSize(), m2 = retina ? 2 : 1;
        setPosition(container, b2.min);
        container.width = m2 * size.x;
        container.height = m2 * size.y;
        container.style.width = size.x + "px";
        container.style.height = size.y + "px";
        if (retina) {
          this._ctx.scale(2, 2);
        }
        this._ctx.translate(-b2.min.x, -b2.min.y);
        this.fire("update");
      },
      _reset: function() {
        Renderer2.prototype._reset.call(this);
        if (this._postponeUpdatePaths) {
          this._postponeUpdatePaths = false;
          this._updatePaths();
        }
      },
      _initPath: function(layer) {
        this._updateDashArray(layer);
        this._layers[stamp(layer)] = layer;
        var order = layer._order = {
          layer,
          prev: this._drawLast,
          next: null
        };
        if (this._drawLast) {
          this._drawLast.next = order;
        }
        this._drawLast = order;
        this._drawFirst = this._drawFirst || this._drawLast;
      },
      _addPath: function(layer) {
        this._requestRedraw(layer);
      },
      _removePath: function(layer) {
        var order = layer._order;
        var next2 = order.next;
        var prev2 = order.prev;
        if (next2) {
          next2.prev = prev2;
        } else {
          this._drawLast = prev2;
        }
        if (prev2) {
          prev2.next = next2;
        } else {
          this._drawFirst = next2;
        }
        delete layer._order;
        delete this._layers[stamp(layer)];
        this._requestRedraw(layer);
      },
      _updatePath: function(layer) {
        this._extendRedrawBounds(layer);
        layer._project();
        layer._update();
        this._requestRedraw(layer);
      },
      _updateStyle: function(layer) {
        this._updateDashArray(layer);
        this._requestRedraw(layer);
      },
      _updateDashArray: function(layer) {
        if (typeof layer.options.dashArray === "string") {
          var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i2;
          for (i2 = 0; i2 < parts.length; i2++) {
            dashValue = Number(parts[i2]);
            if (isNaN(dashValue)) {
              return;
            }
            dashArray.push(dashValue);
          }
          layer.options._dashArray = dashArray;
        } else {
          layer.options._dashArray = layer.options.dashArray;
        }
      },
      _requestRedraw: function(layer) {
        if (!this._map) {
          return;
        }
        this._extendRedrawBounds(layer);
        this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
      },
      _extendRedrawBounds: function(layer) {
        if (layer._pxBounds) {
          var padding = (layer.options.weight || 0) + 1;
          this._redrawBounds = this._redrawBounds || new Bounds();
          this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
          this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
        }
      },
      _redraw: function() {
        this._redrawRequest = null;
        if (this._redrawBounds) {
          this._redrawBounds.min._floor();
          this._redrawBounds.max._ceil();
        }
        this._clear();
        this._draw();
        this._redrawBounds = null;
      },
      _clear: function() {
        var bounds = this._redrawBounds;
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
        } else {
          this._ctx.save();
          this._ctx.setTransform(1, 0, 0, 1, 0, 0);
          this._ctx.clearRect(0, 0, this._container.width, this._container.height);
          this._ctx.restore();
        }
      },
      _draw: function() {
        var layer, bounds = this._redrawBounds;
        this._ctx.save();
        if (bounds) {
          var size = bounds.getSize();
          this._ctx.beginPath();
          this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
          this._ctx.clip();
        }
        this._drawing = true;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
            layer._updatePath();
          }
        }
        this._drawing = false;
        this._ctx.restore();
      },
      _updatePoly: function(layer, closed) {
        if (!this._drawing) {
          return;
        }
        var i2, j2, len2, p2, parts = layer._parts, len = parts.length, ctx = this._ctx;
        if (!len) {
          return;
        }
        ctx.beginPath();
        for (i2 = 0; i2 < len; i2++) {
          for (j2 = 0, len2 = parts[i2].length; j2 < len2; j2++) {
            p2 = parts[i2][j2];
            ctx[j2 ? "lineTo" : "moveTo"](p2.x, p2.y);
          }
          if (closed) {
            ctx.closePath();
          }
        }
        this._fillStroke(ctx, layer);
      },
      _updateCircle: function(layer) {
        if (!this._drawing || layer._empty()) {
          return;
        }
        var p2 = layer._point, ctx = this._ctx, r2 = Math.max(Math.round(layer._radius), 1), s2 = (Math.max(Math.round(layer._radiusY), 1) || r2) / r2;
        if (s2 !== 1) {
          ctx.save();
          ctx.scale(1, s2);
        }
        ctx.beginPath();
        ctx.arc(p2.x, p2.y / s2, r2, 0, Math.PI * 2, false);
        if (s2 !== 1) {
          ctx.restore();
        }
        this._fillStroke(ctx, layer);
      },
      _fillStroke: function(ctx, layer) {
        var options2 = layer.options;
        if (options2.fill) {
          ctx.globalAlpha = options2.fillOpacity;
          ctx.fillStyle = options2.fillColor || options2.color;
          ctx.fill(options2.fillRule || "evenodd");
        }
        if (options2.stroke && options2.weight !== 0) {
          if (ctx.setLineDash) {
            ctx.setLineDash(layer.options && layer.options._dashArray || []);
          }
          ctx.globalAlpha = options2.opacity;
          ctx.lineWidth = options2.weight;
          ctx.strokeStyle = options2.color;
          ctx.lineCap = options2.lineCap;
          ctx.lineJoin = options2.lineJoin;
          ctx.stroke();
        }
      },
      _onClick: function(e2) {
        var point = this._map.mouseEventToLayerPoint(e2), layer, clickedLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point)) {
            if (!(e2.type === "click" || e2.type !== "preclick") || !this._map._draggableMoved(layer)) {
              clickedLayer = layer;
            }
          }
        }
        if (clickedLayer) {
          fakeStop(e2);
          this._fireEvent([clickedLayer], e2);
        }
      },
      _onMouseMove: function(e2) {
        if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
          return;
        }
        var point = this._map.mouseEventToLayerPoint(e2);
        this._handleMouseHover(e2, point);
      },
      _handleMouseOut: function(e2) {
        var layer = this._hoveredLayer;
        if (layer) {
          removeClass(this._container, "leaflet-interactive");
          this._fireEvent([layer], e2, "mouseout");
          this._hoveredLayer = null;
          this._mouseHoverThrottled = false;
        }
      },
      _handleMouseHover: function(e2, point) {
        if (this._mouseHoverThrottled) {
          return;
        }
        var layer, candidateHoveredLayer;
        for (var order = this._drawFirst; order; order = order.next) {
          layer = order.layer;
          if (layer.options.interactive && layer._containsPoint(point)) {
            candidateHoveredLayer = layer;
          }
        }
        if (candidateHoveredLayer !== this._hoveredLayer) {
          this._handleMouseOut(e2);
          if (candidateHoveredLayer) {
            addClass(this._container, "leaflet-interactive");
            this._fireEvent([candidateHoveredLayer], e2, "mouseover");
            this._hoveredLayer = candidateHoveredLayer;
          }
        }
        if (this._hoveredLayer) {
          this._fireEvent([this._hoveredLayer], e2);
        }
        this._mouseHoverThrottled = true;
        setTimeout(bind(function() {
          this._mouseHoverThrottled = false;
        }, this), 32);
      },
      _fireEvent: function(layers2, e2, type) {
        this._map._fireDOMEvent(e2, type || e2.type, layers2);
      },
      _bringToFront: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next2 = order.next;
        var prev2 = order.prev;
        if (next2) {
          next2.prev = prev2;
        } else {
          return;
        }
        if (prev2) {
          prev2.next = next2;
        } else if (next2) {
          this._drawFirst = next2;
        }
        order.prev = this._drawLast;
        this._drawLast.next = order;
        order.next = null;
        this._drawLast = order;
        this._requestRedraw(layer);
      },
      _bringToBack: function(layer) {
        var order = layer._order;
        if (!order) {
          return;
        }
        var next2 = order.next;
        var prev2 = order.prev;
        if (prev2) {
          prev2.next = next2;
        } else {
          return;
        }
        if (next2) {
          next2.prev = prev2;
        } else if (prev2) {
          this._drawLast = prev2;
        }
        order.prev = null;
        order.next = this._drawFirst;
        this._drawFirst.prev = order;
        this._drawFirst = order;
        this._requestRedraw(layer);
      }
    });
    function canvas$1(options2) {
      return canvas ? new Canvas3(options2) : null;
    }
    var vmlCreate = function() {
      try {
        document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
        return function(name2) {
          return document.createElement("<lvml:" + name2 + ' class="lvml">');
        };
      } catch (e2) {
        return function(name2) {
          return document.createElement("<" + name2 + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }
    }();
    var vmlMixin = {
      _initContainer: function() {
        this._container = create$1("div", "leaflet-vml-container");
      },
      _update: function() {
        if (this._map._animatingZoom) {
          return;
        }
        Renderer2.prototype._update.call(this);
        this.fire("update");
      },
      _initPath: function(layer) {
        var container = layer._container = vmlCreate("shape");
        addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
        container.coordsize = "1 1";
        layer._path = vmlCreate("path");
        container.appendChild(layer._path);
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        var container = layer._container;
        this._container.appendChild(container);
        if (layer.options.interactive) {
          layer.addInteractiveTarget(container);
        }
      },
      _removePath: function(layer) {
        var container = layer._container;
        remove(container);
        layer.removeInteractiveTarget(container);
        delete this._layers[stamp(layer)];
      },
      _updateStyle: function(layer) {
        var stroke = layer._stroke, fill = layer._fill, options2 = layer.options, container = layer._container;
        container.stroked = !!options2.stroke;
        container.filled = !!options2.fill;
        if (options2.stroke) {
          if (!stroke) {
            stroke = layer._stroke = vmlCreate("stroke");
          }
          container.appendChild(stroke);
          stroke.weight = options2.weight + "px";
          stroke.color = options2.color;
          stroke.opacity = options2.opacity;
          if (options2.dashArray) {
            stroke.dashStyle = isArray(options2.dashArray) ? options2.dashArray.join(" ") : options2.dashArray.replace(/( *, *)/g, " ");
          } else {
            stroke.dashStyle = "";
          }
          stroke.endcap = options2.lineCap.replace("butt", "flat");
          stroke.joinstyle = options2.lineJoin;
        } else if (stroke) {
          container.removeChild(stroke);
          layer._stroke = null;
        }
        if (options2.fill) {
          if (!fill) {
            fill = layer._fill = vmlCreate("fill");
          }
          container.appendChild(fill);
          fill.color = options2.fillColor || options2.color;
          fill.opacity = options2.fillOpacity;
        } else if (fill) {
          container.removeChild(fill);
          layer._fill = null;
        }
      },
      _updateCircle: function(layer) {
        var p2 = layer._point.round(), r2 = Math.round(layer._radius), r22 = Math.round(layer._radiusY || r2);
        this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p2.x + "," + p2.y + " " + r2 + "," + r22 + " 0," + 65535 * 360);
      },
      _setPath: function(layer, path) {
        layer._path.v = path;
      },
      _bringToFront: function(layer) {
        toFront(layer._container);
      },
      _bringToBack: function(layer) {
        toBack(layer._container);
      }
    };
    var create$2 = vml ? vmlCreate : svgCreate;
    var SVG = Renderer2.extend({
      getEvents: function() {
        var events = Renderer2.prototype.getEvents.call(this);
        events.zoomstart = this._onZoomStart;
        return events;
      },
      _initContainer: function() {
        this._container = create$2("svg");
        this._container.setAttribute("pointer-events", "none");
        this._rootGroup = create$2("g");
        this._container.appendChild(this._rootGroup);
      },
      _destroyContainer: function() {
        remove(this._container);
        off(this._container);
        delete this._container;
        delete this._rootGroup;
        delete this._svgSize;
      },
      _onZoomStart: function() {
        this._update();
      },
      _update: function() {
        if (this._map._animatingZoom && this._bounds) {
          return;
        }
        Renderer2.prototype._update.call(this);
        var b2 = this._bounds, size = b2.getSize(), container = this._container;
        if (!this._svgSize || !this._svgSize.equals(size)) {
          this._svgSize = size;
          container.setAttribute("width", size.x);
          container.setAttribute("height", size.y);
        }
        setPosition(container, b2.min);
        container.setAttribute("viewBox", [b2.min.x, b2.min.y, size.x, size.y].join(" "));
        this.fire("update");
      },
      _initPath: function(layer) {
        var path = layer._path = create$2("path");
        if (layer.options.className) {
          addClass(path, layer.options.className);
        }
        if (layer.options.interactive) {
          addClass(path, "leaflet-interactive");
        }
        this._updateStyle(layer);
        this._layers[stamp(layer)] = layer;
      },
      _addPath: function(layer) {
        if (!this._rootGroup) {
          this._initContainer();
        }
        this._rootGroup.appendChild(layer._path);
        layer.addInteractiveTarget(layer._path);
      },
      _removePath: function(layer) {
        remove(layer._path);
        layer.removeInteractiveTarget(layer._path);
        delete this._layers[stamp(layer)];
      },
      _updatePath: function(layer) {
        layer._project();
        layer._update();
      },
      _updateStyle: function(layer) {
        var path = layer._path, options2 = layer.options;
        if (!path) {
          return;
        }
        if (options2.stroke) {
          path.setAttribute("stroke", options2.color);
          path.setAttribute("stroke-opacity", options2.opacity);
          path.setAttribute("stroke-width", options2.weight);
          path.setAttribute("stroke-linecap", options2.lineCap);
          path.setAttribute("stroke-linejoin", options2.lineJoin);
          if (options2.dashArray) {
            path.setAttribute("stroke-dasharray", options2.dashArray);
          } else {
            path.removeAttribute("stroke-dasharray");
          }
          if (options2.dashOffset) {
            path.setAttribute("stroke-dashoffset", options2.dashOffset);
          } else {
            path.removeAttribute("stroke-dashoffset");
          }
        } else {
          path.setAttribute("stroke", "none");
        }
        if (options2.fill) {
          path.setAttribute("fill", options2.fillColor || options2.color);
          path.setAttribute("fill-opacity", options2.fillOpacity);
          path.setAttribute("fill-rule", options2.fillRule || "evenodd");
        } else {
          path.setAttribute("fill", "none");
        }
      },
      _updatePoly: function(layer, closed) {
        this._setPath(layer, pointsToPath(layer._parts, closed));
      },
      _updateCircle: function(layer) {
        var p2 = layer._point, r2 = Math.max(Math.round(layer._radius), 1), r22 = Math.max(Math.round(layer._radiusY), 1) || r2, arc = "a" + r2 + "," + r22 + " 0 1,0 ";
        var d2 = layer._empty() ? "M0 0" : "M" + (p2.x - r2) + "," + p2.y + arc + r2 * 2 + ",0 " + arc + -r2 * 2 + ",0 ";
        this._setPath(layer, d2);
      },
      _setPath: function(layer, path) {
        layer._path.setAttribute("d", path);
      },
      _bringToFront: function(layer) {
        toFront(layer._path);
      },
      _bringToBack: function(layer) {
        toBack(layer._path);
      }
    });
    if (vml) {
      SVG.include(vmlMixin);
    }
    function svg$1(options2) {
      return svg || vml ? new SVG(options2) : null;
    }
    Map3.include({
      getRenderer: function(layer) {
        var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
        if (!renderer) {
          renderer = this._renderer = this._createRenderer();
        }
        if (!this.hasLayer(renderer)) {
          this.addLayer(renderer);
        }
        return renderer;
      },
      _getPaneRenderer: function(name2) {
        if (name2 === "overlayPane" || name2 === void 0) {
          return false;
        }
        var renderer = this._paneRenderers[name2];
        if (renderer === void 0) {
          renderer = this._createRenderer({pane: name2});
          this._paneRenderers[name2] = renderer;
        }
        return renderer;
      },
      _createRenderer: function(options2) {
        return this.options.preferCanvas && canvas$1(options2) || svg$1(options2);
      }
    });
    var Rectangle = Polygon.extend({
      initialize: function(latLngBounds, options2) {
        Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options2);
      },
      setBounds: function(latLngBounds) {
        return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
      },
      _boundsToLatLngs: function(latLngBounds) {
        latLngBounds = toLatLngBounds(latLngBounds);
        return [
          latLngBounds.getSouthWest(),
          latLngBounds.getNorthWest(),
          latLngBounds.getNorthEast(),
          latLngBounds.getSouthEast()
        ];
      }
    });
    function rectangle(latLngBounds, options2) {
      return new Rectangle(latLngBounds, options2);
    }
    SVG.create = create$2;
    SVG.pointsToPath = pointsToPath;
    GeoJSON.geometryToLayer = geometryToLayer;
    GeoJSON.coordsToLatLng = coordsToLatLng;
    GeoJSON.coordsToLatLngs = coordsToLatLngs;
    GeoJSON.latLngToCoords = latLngToCoords;
    GeoJSON.latLngsToCoords = latLngsToCoords;
    GeoJSON.getFeature = getFeature;
    GeoJSON.asFeature = asFeature;
    Map3.mergeOptions({
      boxZoom: true
    });
    var BoxZoom = Handler.extend({
      initialize: function(map) {
        this._map = map;
        this._container = map._container;
        this._pane = map._panes.overlayPane;
        this._resetStateTimeout = 0;
        map.on("unload", this._destroy, this);
      },
      addHooks: function() {
        on(this._container, "mousedown", this._onMouseDown, this);
      },
      removeHooks: function() {
        off(this._container, "mousedown", this._onMouseDown, this);
      },
      moved: function() {
        return this._moved;
      },
      _destroy: function() {
        remove(this._pane);
        delete this._pane;
      },
      _resetState: function() {
        this._resetStateTimeout = 0;
        this._moved = false;
      },
      _clearDeferredResetState: function() {
        if (this._resetStateTimeout !== 0) {
          clearTimeout(this._resetStateTimeout);
          this._resetStateTimeout = 0;
        }
      },
      _onMouseDown: function(e2) {
        if (!e2.shiftKey || e2.which !== 1 && e2.button !== 1) {
          return false;
        }
        this._clearDeferredResetState();
        this._resetState();
        disableTextSelection();
        disableImageDrag();
        this._startPoint = this._map.mouseEventToContainerPoint(e2);
        on(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseMove: function(e2) {
        if (!this._moved) {
          this._moved = true;
          this._box = create$1("div", "leaflet-zoom-box", this._container);
          addClass(this._container, "leaflet-crosshair");
          this._map.fire("boxzoomstart");
        }
        this._point = this._map.mouseEventToContainerPoint(e2);
        var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
        setPosition(this._box, bounds.min);
        this._box.style.width = size.x + "px";
        this._box.style.height = size.y + "px";
      },
      _finish: function() {
        if (this._moved) {
          remove(this._box);
          removeClass(this._container, "leaflet-crosshair");
        }
        enableTextSelection();
        enableImageDrag();
        off(document, {
          contextmenu: stop,
          mousemove: this._onMouseMove,
          mouseup: this._onMouseUp,
          keydown: this._onKeyDown
        }, this);
      },
      _onMouseUp: function(e2) {
        if (e2.which !== 1 && e2.button !== 1) {
          return;
        }
        this._finish();
        if (!this._moved) {
          return;
        }
        this._clearDeferredResetState();
        this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
        var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
        this._map.fitBounds(bounds).fire("boxzoomend", {boxZoomBounds: bounds});
      },
      _onKeyDown: function(e2) {
        if (e2.keyCode === 27) {
          this._finish();
        }
      }
    });
    Map3.addInitHook("addHandler", "boxZoom", BoxZoom);
    Map3.mergeOptions({
      doubleClickZoom: true
    });
    var DoubleClickZoom = Handler.extend({
      addHooks: function() {
        this._map.on("dblclick", this._onDoubleClick, this);
      },
      removeHooks: function() {
        this._map.off("dblclick", this._onDoubleClick, this);
      },
      _onDoubleClick: function(e2) {
        var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e2.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
        if (map.options.doubleClickZoom === "center") {
          map.setZoom(zoom2);
        } else {
          map.setZoomAround(e2.containerPoint, zoom2);
        }
      }
    });
    Map3.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
    Map3.mergeOptions({
      dragging: true,
      inertia: !android23,
      inertiaDeceleration: 3400,
      inertiaMaxSpeed: Infinity,
      easeLinearity: 0.2,
      worldCopyJump: false,
      maxBoundsViscosity: 0
    });
    var Drag = Handler.extend({
      addHooks: function() {
        if (!this._draggable) {
          var map = this._map;
          this._draggable = new Draggable(map._mapPane, map._container);
          this._draggable.on({
            dragstart: this._onDragStart,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this);
          this._draggable.on("predrag", this._onPreDragLimit, this);
          if (map.options.worldCopyJump) {
            this._draggable.on("predrag", this._onPreDragWrap, this);
            map.on("zoomend", this._onZoomEnd, this);
            map.whenReady(this._onZoomEnd, this);
          }
        }
        addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
        this._draggable.enable();
        this._positions = [];
        this._times = [];
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-grab");
        removeClass(this._map._container, "leaflet-touch-drag");
        this._draggable.disable();
      },
      moved: function() {
        return this._draggable && this._draggable._moved;
      },
      moving: function() {
        return this._draggable && this._draggable._moving;
      },
      _onDragStart: function() {
        var map = this._map;
        map._stop();
        if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
          var bounds = toLatLngBounds(this._map.options.maxBounds);
          this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
          this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
        } else {
          this._offsetLimit = null;
        }
        map.fire("movestart").fire("dragstart");
        if (map.options.inertia) {
          this._positions = [];
          this._times = [];
        }
      },
      _onDrag: function(e2) {
        if (this._map.options.inertia) {
          var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
          this._positions.push(pos);
          this._times.push(time);
          this._prunePositions(time);
        }
        this._map.fire("move", e2).fire("drag", e2);
      },
      _prunePositions: function(time) {
        while (this._positions.length > 1 && time - this._times[0] > 50) {
          this._positions.shift();
          this._times.shift();
        }
      },
      _onZoomEnd: function() {
        var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
        this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
        this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
      },
      _viscousLimit: function(value, threshold) {
        return value - (value - threshold) * this._viscosity;
      },
      _onPreDragLimit: function() {
        if (!this._viscosity || !this._offsetLimit) {
          return;
        }
        var offset = this._draggable._newPos.subtract(this._draggable._startPos);
        var limit = this._offsetLimit;
        if (offset.x < limit.min.x) {
          offset.x = this._viscousLimit(offset.x, limit.min.x);
        }
        if (offset.y < limit.min.y) {
          offset.y = this._viscousLimit(offset.y, limit.min.y);
        }
        if (offset.x > limit.max.x) {
          offset.x = this._viscousLimit(offset.x, limit.max.x);
        }
        if (offset.y > limit.max.y) {
          offset.y = this._viscousLimit(offset.y, limit.max.y);
        }
        this._draggable._newPos = this._draggable._startPos.add(offset);
      },
      _onPreDragWrap: function() {
        var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x2 = this._draggable._newPos.x, newX1 = (x2 - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x2 + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
        this._draggable._absPos = this._draggable._newPos.clone();
        this._draggable._newPos.x = newX;
      },
      _onDragEnd: function(e2) {
        var map = this._map, options2 = map.options, noInertia = !options2.inertia || this._times.length < 2;
        map.fire("dragend", e2);
        if (noInertia) {
          map.fire("moveend");
        } else {
          this._prunePositions(+new Date());
          var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options2.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options2.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options2.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
          if (!offset.x && !offset.y) {
            map.fire("moveend");
          } else {
            offset = map._limitOffset(offset, map.options.maxBounds);
            requestAnimFrame(function() {
              map.panBy(offset, {
                duration: decelerationDuration,
                easeLinearity: ease,
                noMoveStart: true,
                animate: true
              });
            });
          }
        }
      }
    });
    Map3.addInitHook("addHandler", "dragging", Drag);
    Map3.mergeOptions({
      keyboard: true,
      keyboardPanDelta: 80
    });
    var Keyboard = Handler.extend({
      keyCodes: {
        left: [37],
        right: [39],
        down: [40],
        up: [38],
        zoomIn: [187, 107, 61, 171],
        zoomOut: [189, 109, 54, 173]
      },
      initialize: function(map) {
        this._map = map;
        this._setPanDelta(map.options.keyboardPanDelta);
        this._setZoomDelta(map.options.zoomDelta);
      },
      addHooks: function() {
        var container = this._map._container;
        if (container.tabIndex <= 0) {
          container.tabIndex = "0";
        }
        on(container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.on({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      removeHooks: function() {
        this._removeHooks();
        off(this._map._container, {
          focus: this._onFocus,
          blur: this._onBlur,
          mousedown: this._onMouseDown
        }, this);
        this._map.off({
          focus: this._addHooks,
          blur: this._removeHooks
        }, this);
      },
      _onMouseDown: function() {
        if (this._focused) {
          return;
        }
        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
        this._map._container.focus();
        window.scrollTo(left, top);
      },
      _onFocus: function() {
        this._focused = true;
        this._map.fire("focus");
      },
      _onBlur: function() {
        this._focused = false;
        this._map.fire("blur");
      },
      _setPanDelta: function(panDelta) {
        var keys2 = this._panKeys = {}, codes = this.keyCodes, i2, len;
        for (i2 = 0, len = codes.left.length; i2 < len; i2++) {
          keys2[codes.left[i2]] = [-1 * panDelta, 0];
        }
        for (i2 = 0, len = codes.right.length; i2 < len; i2++) {
          keys2[codes.right[i2]] = [panDelta, 0];
        }
        for (i2 = 0, len = codes.down.length; i2 < len; i2++) {
          keys2[codes.down[i2]] = [0, panDelta];
        }
        for (i2 = 0, len = codes.up.length; i2 < len; i2++) {
          keys2[codes.up[i2]] = [0, -1 * panDelta];
        }
      },
      _setZoomDelta: function(zoomDelta) {
        var keys2 = this._zoomKeys = {}, codes = this.keyCodes, i2, len;
        for (i2 = 0, len = codes.zoomIn.length; i2 < len; i2++) {
          keys2[codes.zoomIn[i2]] = zoomDelta;
        }
        for (i2 = 0, len = codes.zoomOut.length; i2 < len; i2++) {
          keys2[codes.zoomOut[i2]] = -zoomDelta;
        }
      },
      _addHooks: function() {
        on(document, "keydown", this._onKeyDown, this);
      },
      _removeHooks: function() {
        off(document, "keydown", this._onKeyDown, this);
      },
      _onKeyDown: function(e2) {
        if (e2.altKey || e2.ctrlKey || e2.metaKey) {
          return;
        }
        var key = e2.keyCode, map = this._map, offset;
        if (key in this._panKeys) {
          if (!map._panAnim || !map._panAnim._inProgress) {
            offset = this._panKeys[key];
            if (e2.shiftKey) {
              offset = toPoint(offset).multiplyBy(3);
            }
            map.panBy(offset);
            if (map.options.maxBounds) {
              map.panInsideBounds(map.options.maxBounds);
            }
          }
        } else if (key in this._zoomKeys) {
          map.setZoom(map.getZoom() + (e2.shiftKey ? 3 : 1) * this._zoomKeys[key]);
        } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
          map.closePopup();
        } else {
          return;
        }
        stop(e2);
      }
    });
    Map3.addInitHook("addHandler", "keyboard", Keyboard);
    Map3.mergeOptions({
      scrollWheelZoom: true,
      wheelDebounceTime: 40,
      wheelPxPerZoomLevel: 60
    });
    var ScrollWheelZoom = Handler.extend({
      addHooks: function() {
        on(this._map._container, "wheel", this._onWheelScroll, this);
        this._delta = 0;
      },
      removeHooks: function() {
        off(this._map._container, "wheel", this._onWheelScroll, this);
      },
      _onWheelScroll: function(e2) {
        var delta = getWheelDelta(e2);
        var debounce2 = this._map.options.wheelDebounceTime;
        this._delta += delta;
        this._lastMousePos = this._map.mouseEventToContainerPoint(e2);
        if (!this._startTime) {
          this._startTime = +new Date();
        }
        var left = Math.max(debounce2 - (+new Date() - this._startTime), 0);
        clearTimeout(this._timer);
        this._timer = setTimeout(bind(this._performZoom, this), left);
        stop(e2);
      },
      _performZoom: function() {
        var map = this._map, zoom2 = map.getZoom(), snap = this._map.options.zoomSnap || 0;
        map._stop();
        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
        this._delta = 0;
        this._startTime = null;
        if (!delta) {
          return;
        }
        if (map.options.scrollWheelZoom === "center") {
          map.setZoom(zoom2 + delta);
        } else {
          map.setZoomAround(this._lastMousePos, zoom2 + delta);
        }
      }
    });
    Map3.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
    Map3.mergeOptions({
      tap: true,
      tapTolerance: 15
    });
    var Tap = Handler.extend({
      addHooks: function() {
        on(this._map._container, "touchstart", this._onDown, this);
      },
      removeHooks: function() {
        off(this._map._container, "touchstart", this._onDown, this);
      },
      _onDown: function(e2) {
        if (!e2.touches) {
          return;
        }
        preventDefault(e2);
        this._fireClick = true;
        if (e2.touches.length > 1) {
          this._fireClick = false;
          clearTimeout(this._holdTimeout);
          return;
        }
        var first = e2.touches[0], el2 = first.target;
        this._startPos = this._newPos = new Point(first.clientX, first.clientY);
        if (el2.tagName && el2.tagName.toLowerCase() === "a") {
          addClass(el2, "leaflet-active");
        }
        this._holdTimeout = setTimeout(bind(function() {
          if (this._isTapValid()) {
            this._fireClick = false;
            this._onUp();
            this._simulateEvent("contextmenu", first);
          }
        }, this), 1e3);
        this._simulateEvent("mousedown", first);
        on(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this);
      },
      _onUp: function(e2) {
        clearTimeout(this._holdTimeout);
        off(document, {
          touchmove: this._onMove,
          touchend: this._onUp
        }, this);
        if (this._fireClick && e2 && e2.changedTouches) {
          var first = e2.changedTouches[0], el2 = first.target;
          if (el2 && el2.tagName && el2.tagName.toLowerCase() === "a") {
            removeClass(el2, "leaflet-active");
          }
          this._simulateEvent("mouseup", first);
          if (this._isTapValid()) {
            this._simulateEvent("click", first);
          }
        }
      },
      _isTapValid: function() {
        return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
      },
      _onMove: function(e2) {
        var first = e2.touches[0];
        this._newPos = new Point(first.clientX, first.clientY);
        this._simulateEvent("mousemove", first);
      },
      _simulateEvent: function(type, e2) {
        var simulatedEvent = document.createEvent("MouseEvents");
        simulatedEvent._simulated = true;
        e2.target._simulatedClick = true;
        simulatedEvent.initMouseEvent(type, true, true, window, 1, e2.screenX, e2.screenY, e2.clientX, e2.clientY, false, false, false, false, 0, null);
        e2.target.dispatchEvent(simulatedEvent);
      }
    });
    if (touch && (!pointer || safari)) {
      Map3.addInitHook("addHandler", "tap", Tap);
    }
    Map3.mergeOptions({
      touchZoom: touch && !android23,
      bounceAtZoomLimits: true
    });
    var TouchZoom = Handler.extend({
      addHooks: function() {
        addClass(this._map._container, "leaflet-touch-zoom");
        on(this._map._container, "touchstart", this._onTouchStart, this);
      },
      removeHooks: function() {
        removeClass(this._map._container, "leaflet-touch-zoom");
        off(this._map._container, "touchstart", this._onTouchStart, this);
      },
      _onTouchStart: function(e2) {
        var map = this._map;
        if (!e2.touches || e2.touches.length !== 2 || map._animatingZoom || this._zooming) {
          return;
        }
        var p1 = map.mouseEventToContainerPoint(e2.touches[0]), p2 = map.mouseEventToContainerPoint(e2.touches[1]);
        this._centerPoint = map.getSize()._divideBy(2);
        this._startLatLng = map.containerPointToLatLng(this._centerPoint);
        if (map.options.touchZoom !== "center") {
          this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
        }
        this._startDist = p1.distanceTo(p2);
        this._startZoom = map.getZoom();
        this._moved = false;
        this._zooming = true;
        map._stop();
        on(document, "touchmove", this._onTouchMove, this);
        on(document, "touchend", this._onTouchEnd, this);
        preventDefault(e2);
      },
      _onTouchMove: function(e2) {
        if (!e2.touches || e2.touches.length !== 2 || !this._zooming) {
          return;
        }
        var map = this._map, p1 = map.mouseEventToContainerPoint(e2.touches[0]), p2 = map.mouseEventToContainerPoint(e2.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
        this._zoom = map.getScaleZoom(scale2, this._startZoom);
        if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
          this._zoom = map._limitZoom(this._zoom);
        }
        if (map.options.touchZoom === "center") {
          this._center = this._startLatLng;
          if (scale2 === 1) {
            return;
          }
        } else {
          var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
          if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
            return;
          }
          this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
        }
        if (!this._moved) {
          map._moveStart(true, false);
          this._moved = true;
        }
        cancelAnimFrame(this._animRequest);
        var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
        this._animRequest = requestAnimFrame(moveFn, this, true);
        preventDefault(e2);
      },
      _onTouchEnd: function() {
        if (!this._moved || !this._zooming) {
          this._zooming = false;
          return;
        }
        this._zooming = false;
        cancelAnimFrame(this._animRequest);
        off(document, "touchmove", this._onTouchMove, this);
        off(document, "touchend", this._onTouchEnd, this);
        if (this._map.options.zoomAnimation) {
          this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
        } else {
          this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      }
    });
    Map3.addInitHook("addHandler", "touchZoom", TouchZoom);
    Map3.BoxZoom = BoxZoom;
    Map3.DoubleClickZoom = DoubleClickZoom;
    Map3.Drag = Drag;
    Map3.Keyboard = Keyboard;
    Map3.ScrollWheelZoom = ScrollWheelZoom;
    Map3.Tap = Tap;
    Map3.TouchZoom = TouchZoom;
    exports3.version = version2;
    exports3.Control = Control3;
    exports3.control = control;
    exports3.Browser = Browser;
    exports3.Evented = Evented;
    exports3.Mixin = Mixin;
    exports3.Util = Util;
    exports3.Class = Class;
    exports3.Handler = Handler;
    exports3.extend = extend2;
    exports3.bind = bind;
    exports3.stamp = stamp;
    exports3.setOptions = setOptions2;
    exports3.DomEvent = DomEvent;
    exports3.DomUtil = DomUtil;
    exports3.PosAnimation = PosAnimation;
    exports3.Draggable = Draggable;
    exports3.LineUtil = LineUtil;
    exports3.PolyUtil = PolyUtil;
    exports3.Point = Point;
    exports3.point = toPoint;
    exports3.Bounds = Bounds;
    exports3.bounds = toBounds;
    exports3.Transformation = Transformation;
    exports3.transformation = toTransformation;
    exports3.Projection = index4;
    exports3.LatLng = LatLng;
    exports3.latLng = toLatLng;
    exports3.LatLngBounds = LatLngBounds;
    exports3.latLngBounds = toLatLngBounds;
    exports3.CRS = CRS;
    exports3.GeoJSON = GeoJSON;
    exports3.geoJSON = geoJSON;
    exports3.geoJson = geoJson;
    exports3.Layer = Layer;
    exports3.LayerGroup = LayerGroup;
    exports3.layerGroup = layerGroup;
    exports3.FeatureGroup = FeatureGroup;
    exports3.featureGroup = featureGroup;
    exports3.ImageOverlay = ImageOverlay;
    exports3.imageOverlay = imageOverlay;
    exports3.VideoOverlay = VideoOverlay;
    exports3.videoOverlay = videoOverlay;
    exports3.SVGOverlay = SVGOverlay;
    exports3.svgOverlay = svgOverlay;
    exports3.DivOverlay = DivOverlay;
    exports3.Popup = Popup;
    exports3.popup = popup;
    exports3.Tooltip = Tooltip;
    exports3.tooltip = tooltip;
    exports3.Icon = Icon;
    exports3.icon = icon;
    exports3.DivIcon = DivIcon;
    exports3.divIcon = divIcon;
    exports3.Marker = Marker2;
    exports3.marker = marker;
    exports3.TileLayer = TileLayer2;
    exports3.tileLayer = tileLayer;
    exports3.GridLayer = GridLayer;
    exports3.gridLayer = gridLayer;
    exports3.SVG = SVG;
    exports3.svg = svg$1;
    exports3.Renderer = Renderer2;
    exports3.Canvas = Canvas3;
    exports3.canvas = canvas$1;
    exports3.Path = Path2;
    exports3.CircleMarker = CircleMarker;
    exports3.circleMarker = circleMarker;
    exports3.Circle = Circle;
    exports3.circle = circle;
    exports3.Polyline = Polyline;
    exports3.polyline = polyline;
    exports3.Polygon = Polygon;
    exports3.polygon = polygon;
    exports3.Rectangle = Rectangle;
    exports3.rectangle = rectangle;
    exports3.Map = Map3;
    exports3.map = createMap;
    var oldL = window.L;
    exports3.noConflict = function() {
      window.L = oldL;
      return this;
    };
    window.L = exports3;
  });
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  BarChartDescription: () => import_chart_xkcd.BarChartDescription,
  ClockDescription: () => ClockDescription,
  LineChartDescription: () => import_chart_xkcd.LineChartDescription,
  MapDescription: () => MapDescription,
  PieChartDescription: () => import_chart_xkcd.PieChartDescription,
  RadarChartDescription: () => import_chart_xkcd.RadarChartDescription,
  StackedBarChartDescription: () => import_chart_xkcd.StackedBarChartDescription,
  ThreeDescription: () => ThreeDescription,
  WarpSpeedDescription: () => WarpSpeedDescription,
  XKCDDescription: () => XKCDDescription,
  XYChartDescription: () => import_chart_xkcd.XYChartDescription,
  kit: () => kit
});

// src/r3f.tsx
var import_react3 = __toModule(require("react"));

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/three/build/three.module.js
var three_module_exports = {};
__export(three_module_exports, {
  ACESFilmicToneMapping: () => ACESFilmicToneMapping,
  AddEquation: () => AddEquation,
  AddOperation: () => AddOperation,
  AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
  AdditiveBlending: () => AdditiveBlending,
  AlphaFormat: () => AlphaFormat,
  AlwaysDepth: () => AlwaysDepth,
  AlwaysStencilFunc: () => AlwaysStencilFunc,
  AmbientLight: () => AmbientLight,
  AmbientLightProbe: () => AmbientLightProbe,
  AnimationClip: () => AnimationClip,
  AnimationLoader: () => AnimationLoader,
  AnimationMixer: () => AnimationMixer,
  AnimationObjectGroup: () => AnimationObjectGroup,
  AnimationUtils: () => AnimationUtils,
  ArcCurve: () => ArcCurve,
  ArrayCamera: () => ArrayCamera,
  ArrowHelper: () => ArrowHelper,
  Audio: () => Audio,
  AudioAnalyser: () => AudioAnalyser,
  AudioContext: () => AudioContext,
  AudioListener: () => AudioListener,
  AudioLoader: () => AudioLoader,
  AxesHelper: () => AxesHelper,
  AxisHelper: () => AxisHelper,
  BackSide: () => BackSide,
  BasicDepthPacking: () => BasicDepthPacking,
  BasicShadowMap: () => BasicShadowMap,
  BinaryTextureLoader: () => BinaryTextureLoader,
  Bone: () => Bone,
  BooleanKeyframeTrack: () => BooleanKeyframeTrack,
  BoundingBoxHelper: () => BoundingBoxHelper,
  Box2: () => Box2,
  Box3: () => Box3,
  Box3Helper: () => Box3Helper,
  BoxBufferGeometry: () => BoxGeometry,
  BoxGeometry: () => BoxGeometry,
  BoxHelper: () => BoxHelper,
  BufferAttribute: () => BufferAttribute,
  BufferGeometry: () => BufferGeometry,
  BufferGeometryLoader: () => BufferGeometryLoader,
  ByteType: () => ByteType,
  Cache: () => Cache,
  Camera: () => Camera,
  CameraHelper: () => CameraHelper,
  CanvasRenderer: () => CanvasRenderer,
  CanvasTexture: () => CanvasTexture,
  CatmullRomCurve3: () => CatmullRomCurve3,
  CineonToneMapping: () => CineonToneMapping,
  CircleBufferGeometry: () => CircleGeometry,
  CircleGeometry: () => CircleGeometry,
  ClampToEdgeWrapping: () => ClampToEdgeWrapping,
  Clock: () => Clock,
  Color: () => Color,
  ColorKeyframeTrack: () => ColorKeyframeTrack,
  CompressedTexture: () => CompressedTexture,
  CompressedTextureLoader: () => CompressedTextureLoader,
  ConeBufferGeometry: () => ConeGeometry,
  ConeGeometry: () => ConeGeometry,
  CubeCamera: () => CubeCamera,
  CubeReflectionMapping: () => CubeReflectionMapping,
  CubeRefractionMapping: () => CubeRefractionMapping,
  CubeTexture: () => CubeTexture,
  CubeTextureLoader: () => CubeTextureLoader,
  CubeUVReflectionMapping: () => CubeUVReflectionMapping,
  CubeUVRefractionMapping: () => CubeUVRefractionMapping,
  CubicBezierCurve: () => CubicBezierCurve,
  CubicBezierCurve3: () => CubicBezierCurve3,
  CubicInterpolant: () => CubicInterpolant,
  CullFaceBack: () => CullFaceBack,
  CullFaceFront: () => CullFaceFront,
  CullFaceFrontBack: () => CullFaceFrontBack,
  CullFaceNone: () => CullFaceNone,
  Curve: () => Curve,
  CurvePath: () => CurvePath,
  CustomBlending: () => CustomBlending,
  CustomToneMapping: () => CustomToneMapping,
  CylinderBufferGeometry: () => CylinderGeometry,
  CylinderGeometry: () => CylinderGeometry,
  Cylindrical: () => Cylindrical,
  DataTexture: () => DataTexture,
  DataTexture2DArray: () => DataTexture2DArray,
  DataTexture3D: () => DataTexture3D,
  DataTextureLoader: () => DataTextureLoader,
  DataUtils: () => DataUtils,
  DecrementStencilOp: () => DecrementStencilOp,
  DecrementWrapStencilOp: () => DecrementWrapStencilOp,
  DefaultLoadingManager: () => DefaultLoadingManager,
  DepthFormat: () => DepthFormat,
  DepthStencilFormat: () => DepthStencilFormat,
  DepthTexture: () => DepthTexture,
  DirectionalLight: () => DirectionalLight,
  DirectionalLightHelper: () => DirectionalLightHelper,
  DiscreteInterpolant: () => DiscreteInterpolant,
  DodecahedronBufferGeometry: () => DodecahedronGeometry,
  DodecahedronGeometry: () => DodecahedronGeometry,
  DoubleSide: () => DoubleSide,
  DstAlphaFactor: () => DstAlphaFactor,
  DstColorFactor: () => DstColorFactor,
  DynamicBufferAttribute: () => DynamicBufferAttribute,
  DynamicCopyUsage: () => DynamicCopyUsage,
  DynamicDrawUsage: () => DynamicDrawUsage,
  DynamicReadUsage: () => DynamicReadUsage,
  EdgesGeometry: () => EdgesGeometry,
  EdgesHelper: () => EdgesHelper,
  EllipseCurve: () => EllipseCurve,
  EqualDepth: () => EqualDepth,
  EqualStencilFunc: () => EqualStencilFunc,
  EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
  Euler: () => Euler,
  EventDispatcher: () => EventDispatcher,
  ExtrudeBufferGeometry: () => ExtrudeGeometry,
  ExtrudeGeometry: () => ExtrudeGeometry,
  FaceColors: () => FaceColors,
  FileLoader: () => FileLoader,
  FlatShading: () => FlatShading,
  Float16BufferAttribute: () => Float16BufferAttribute,
  Float32Attribute: () => Float32Attribute,
  Float32BufferAttribute: () => Float32BufferAttribute,
  Float64Attribute: () => Float64Attribute,
  Float64BufferAttribute: () => Float64BufferAttribute,
  FloatType: () => FloatType,
  Fog: () => Fog,
  FogExp2: () => FogExp2,
  Font: () => Font,
  FontLoader: () => FontLoader,
  FrontSide: () => FrontSide,
  Frustum: () => Frustum,
  GLBufferAttribute: () => GLBufferAttribute,
  GLSL1: () => GLSL1,
  GLSL3: () => GLSL3,
  GammaEncoding: () => GammaEncoding,
  GreaterDepth: () => GreaterDepth,
  GreaterEqualDepth: () => GreaterEqualDepth,
  GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
  GreaterStencilFunc: () => GreaterStencilFunc,
  GridHelper: () => GridHelper,
  Group: () => Group,
  HalfFloatType: () => HalfFloatType,
  HemisphereLight: () => HemisphereLight,
  HemisphereLightHelper: () => HemisphereLightHelper,
  HemisphereLightProbe: () => HemisphereLightProbe,
  IcosahedronBufferGeometry: () => IcosahedronGeometry,
  IcosahedronGeometry: () => IcosahedronGeometry,
  ImageBitmapLoader: () => ImageBitmapLoader,
  ImageLoader: () => ImageLoader,
  ImageUtils: () => ImageUtils,
  ImmediateRenderObject: () => ImmediateRenderObject,
  IncrementStencilOp: () => IncrementStencilOp,
  IncrementWrapStencilOp: () => IncrementWrapStencilOp,
  InstancedBufferAttribute: () => InstancedBufferAttribute,
  InstancedBufferGeometry: () => InstancedBufferGeometry,
  InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
  InstancedMesh: () => InstancedMesh,
  Int16Attribute: () => Int16Attribute,
  Int16BufferAttribute: () => Int16BufferAttribute,
  Int32Attribute: () => Int32Attribute,
  Int32BufferAttribute: () => Int32BufferAttribute,
  Int8Attribute: () => Int8Attribute,
  Int8BufferAttribute: () => Int8BufferAttribute,
  IntType: () => IntType,
  InterleavedBuffer: () => InterleavedBuffer,
  InterleavedBufferAttribute: () => InterleavedBufferAttribute,
  Interpolant: () => Interpolant,
  InterpolateDiscrete: () => InterpolateDiscrete,
  InterpolateLinear: () => InterpolateLinear,
  InterpolateSmooth: () => InterpolateSmooth,
  InvertStencilOp: () => InvertStencilOp,
  JSONLoader: () => JSONLoader,
  KeepStencilOp: () => KeepStencilOp,
  KeyframeTrack: () => KeyframeTrack,
  LOD: () => LOD,
  LatheBufferGeometry: () => LatheGeometry,
  LatheGeometry: () => LatheGeometry,
  Layers: () => Layers,
  LensFlare: () => LensFlare,
  LessDepth: () => LessDepth,
  LessEqualDepth: () => LessEqualDepth,
  LessEqualStencilFunc: () => LessEqualStencilFunc,
  LessStencilFunc: () => LessStencilFunc,
  Light: () => Light,
  LightProbe: () => LightProbe,
  Line: () => Line,
  Line3: () => Line3,
  LineBasicMaterial: () => LineBasicMaterial,
  LineCurve: () => LineCurve,
  LineCurve3: () => LineCurve3,
  LineDashedMaterial: () => LineDashedMaterial,
  LineLoop: () => LineLoop,
  LinePieces: () => LinePieces,
  LineSegments: () => LineSegments,
  LineStrip: () => LineStrip,
  LinearEncoding: () => LinearEncoding,
  LinearFilter: () => LinearFilter,
  LinearInterpolant: () => LinearInterpolant,
  LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
  LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
  LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
  LinearToneMapping: () => LinearToneMapping,
  Loader: () => Loader,
  LoaderUtils: () => LoaderUtils,
  LoadingManager: () => LoadingManager,
  LogLuvEncoding: () => LogLuvEncoding,
  LoopOnce: () => LoopOnce,
  LoopPingPong: () => LoopPingPong,
  LoopRepeat: () => LoopRepeat,
  LuminanceAlphaFormat: () => LuminanceAlphaFormat,
  LuminanceFormat: () => LuminanceFormat,
  MOUSE: () => MOUSE,
  Material: () => Material,
  MaterialLoader: () => MaterialLoader,
  Math: () => MathUtils,
  MathUtils: () => MathUtils,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  MaxEquation: () => MaxEquation,
  Mesh: () => Mesh,
  MeshBasicMaterial: () => MeshBasicMaterial,
  MeshDepthMaterial: () => MeshDepthMaterial,
  MeshDistanceMaterial: () => MeshDistanceMaterial,
  MeshFaceMaterial: () => MeshFaceMaterial,
  MeshLambertMaterial: () => MeshLambertMaterial,
  MeshMatcapMaterial: () => MeshMatcapMaterial,
  MeshNormalMaterial: () => MeshNormalMaterial,
  MeshPhongMaterial: () => MeshPhongMaterial,
  MeshPhysicalMaterial: () => MeshPhysicalMaterial,
  MeshStandardMaterial: () => MeshStandardMaterial,
  MeshToonMaterial: () => MeshToonMaterial,
  MinEquation: () => MinEquation,
  MirroredRepeatWrapping: () => MirroredRepeatWrapping,
  MixOperation: () => MixOperation,
  MultiMaterial: () => MultiMaterial,
  MultiplyBlending: () => MultiplyBlending,
  MultiplyOperation: () => MultiplyOperation,
  NearestFilter: () => NearestFilter,
  NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
  NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
  NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
  NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
  NeverDepth: () => NeverDepth,
  NeverStencilFunc: () => NeverStencilFunc,
  NoBlending: () => NoBlending,
  NoColors: () => NoColors,
  NoToneMapping: () => NoToneMapping,
  NormalAnimationBlendMode: () => NormalAnimationBlendMode,
  NormalBlending: () => NormalBlending,
  NotEqualDepth: () => NotEqualDepth,
  NotEqualStencilFunc: () => NotEqualStencilFunc,
  NumberKeyframeTrack: () => NumberKeyframeTrack,
  Object3D: () => Object3D,
  ObjectLoader: () => ObjectLoader,
  ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
  OctahedronBufferGeometry: () => OctahedronGeometry,
  OctahedronGeometry: () => OctahedronGeometry,
  OneFactor: () => OneFactor,
  OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
  OneMinusDstColorFactor: () => OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
  OrthographicCamera: () => OrthographicCamera,
  PCFShadowMap: () => PCFShadowMap,
  PCFSoftShadowMap: () => PCFSoftShadowMap,
  PMREMGenerator: () => PMREMGenerator,
  ParametricBufferGeometry: () => ParametricGeometry,
  ParametricGeometry: () => ParametricGeometry,
  Particle: () => Particle,
  ParticleBasicMaterial: () => ParticleBasicMaterial,
  ParticleSystem: () => ParticleSystem,
  ParticleSystemMaterial: () => ParticleSystemMaterial,
  Path: () => Path,
  PerspectiveCamera: () => PerspectiveCamera,
  Plane: () => Plane,
  PlaneBufferGeometry: () => PlaneGeometry,
  PlaneGeometry: () => PlaneGeometry,
  PlaneHelper: () => PlaneHelper,
  PointCloud: () => PointCloud,
  PointCloudMaterial: () => PointCloudMaterial,
  PointLight: () => PointLight,
  PointLightHelper: () => PointLightHelper,
  Points: () => Points,
  PointsMaterial: () => PointsMaterial,
  PolarGridHelper: () => PolarGridHelper,
  PolyhedronBufferGeometry: () => PolyhedronGeometry,
  PolyhedronGeometry: () => PolyhedronGeometry,
  PositionalAudio: () => PositionalAudio,
  PropertyBinding: () => PropertyBinding,
  PropertyMixer: () => PropertyMixer,
  QuadraticBezierCurve: () => QuadraticBezierCurve,
  QuadraticBezierCurve3: () => QuadraticBezierCurve3,
  Quaternion: () => Quaternion,
  QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
  QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
  REVISION: () => REVISION,
  RGBADepthPacking: () => RGBADepthPacking,
  RGBAFormat: () => RGBAFormat,
  RGBAIntegerFormat: () => RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format: () => RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
  RGBDEncoding: () => RGBDEncoding,
  RGBEEncoding: () => RGBEEncoding,
  RGBEFormat: () => RGBEFormat,
  RGBFormat: () => RGBFormat,
  RGBIntegerFormat: () => RGBIntegerFormat,
  RGBM16Encoding: () => RGBM16Encoding,
  RGBM7Encoding: () => RGBM7Encoding,
  RGB_ETC1_Format: () => RGB_ETC1_Format,
  RGB_ETC2_Format: () => RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
  RGFormat: () => RGFormat,
  RGIntegerFormat: () => RGIntegerFormat,
  RawShaderMaterial: () => RawShaderMaterial,
  Ray: () => Ray,
  Raycaster: () => Raycaster,
  RectAreaLight: () => RectAreaLight,
  RedFormat: () => RedFormat,
  RedIntegerFormat: () => RedIntegerFormat,
  ReinhardToneMapping: () => ReinhardToneMapping,
  RepeatWrapping: () => RepeatWrapping,
  ReplaceStencilOp: () => ReplaceStencilOp,
  ReverseSubtractEquation: () => ReverseSubtractEquation,
  RingBufferGeometry: () => RingGeometry,
  RingGeometry: () => RingGeometry,
  SRGB8_ALPHA8_ASTC_10x10_Format: () => SRGB8_ALPHA8_ASTC_10x10_Format,
  SRGB8_ALPHA8_ASTC_10x5_Format: () => SRGB8_ALPHA8_ASTC_10x5_Format,
  SRGB8_ALPHA8_ASTC_10x6_Format: () => SRGB8_ALPHA8_ASTC_10x6_Format,
  SRGB8_ALPHA8_ASTC_10x8_Format: () => SRGB8_ALPHA8_ASTC_10x8_Format,
  SRGB8_ALPHA8_ASTC_12x10_Format: () => SRGB8_ALPHA8_ASTC_12x10_Format,
  SRGB8_ALPHA8_ASTC_12x12_Format: () => SRGB8_ALPHA8_ASTC_12x12_Format,
  SRGB8_ALPHA8_ASTC_4x4_Format: () => SRGB8_ALPHA8_ASTC_4x4_Format,
  SRGB8_ALPHA8_ASTC_5x4_Format: () => SRGB8_ALPHA8_ASTC_5x4_Format,
  SRGB8_ALPHA8_ASTC_5x5_Format: () => SRGB8_ALPHA8_ASTC_5x5_Format,
  SRGB8_ALPHA8_ASTC_6x5_Format: () => SRGB8_ALPHA8_ASTC_6x5_Format,
  SRGB8_ALPHA8_ASTC_6x6_Format: () => SRGB8_ALPHA8_ASTC_6x6_Format,
  SRGB8_ALPHA8_ASTC_8x5_Format: () => SRGB8_ALPHA8_ASTC_8x5_Format,
  SRGB8_ALPHA8_ASTC_8x6_Format: () => SRGB8_ALPHA8_ASTC_8x6_Format,
  SRGB8_ALPHA8_ASTC_8x8_Format: () => SRGB8_ALPHA8_ASTC_8x8_Format,
  Scene: () => Scene,
  SceneUtils: () => SceneUtils,
  ShaderChunk: () => ShaderChunk,
  ShaderLib: () => ShaderLib,
  ShaderMaterial: () => ShaderMaterial,
  ShadowMaterial: () => ShadowMaterial,
  Shape: () => Shape,
  ShapeBufferGeometry: () => ShapeGeometry,
  ShapeGeometry: () => ShapeGeometry,
  ShapePath: () => ShapePath,
  ShapeUtils: () => ShapeUtils,
  ShortType: () => ShortType,
  Skeleton: () => Skeleton,
  SkeletonHelper: () => SkeletonHelper,
  SkinnedMesh: () => SkinnedMesh,
  SmoothShading: () => SmoothShading,
  Sphere: () => Sphere,
  SphereBufferGeometry: () => SphereGeometry,
  SphereGeometry: () => SphereGeometry,
  Spherical: () => Spherical,
  SphericalHarmonics3: () => SphericalHarmonics3,
  SplineCurve: () => SplineCurve,
  SpotLight: () => SpotLight,
  SpotLightHelper: () => SpotLightHelper,
  Sprite: () => Sprite,
  SpriteMaterial: () => SpriteMaterial,
  SrcAlphaFactor: () => SrcAlphaFactor,
  SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
  SrcColorFactor: () => SrcColorFactor,
  StaticCopyUsage: () => StaticCopyUsage,
  StaticDrawUsage: () => StaticDrawUsage,
  StaticReadUsage: () => StaticReadUsage,
  StereoCamera: () => StereoCamera,
  StreamCopyUsage: () => StreamCopyUsage,
  StreamDrawUsage: () => StreamDrawUsage,
  StreamReadUsage: () => StreamReadUsage,
  StringKeyframeTrack: () => StringKeyframeTrack,
  SubtractEquation: () => SubtractEquation,
  SubtractiveBlending: () => SubtractiveBlending,
  TOUCH: () => TOUCH,
  TangentSpaceNormalMap: () => TangentSpaceNormalMap,
  TetrahedronBufferGeometry: () => TetrahedronGeometry,
  TetrahedronGeometry: () => TetrahedronGeometry,
  TextBufferGeometry: () => TextGeometry,
  TextGeometry: () => TextGeometry,
  Texture: () => Texture,
  TextureLoader: () => TextureLoader,
  TorusBufferGeometry: () => TorusGeometry,
  TorusGeometry: () => TorusGeometry,
  TorusKnotBufferGeometry: () => TorusKnotGeometry,
  TorusKnotGeometry: () => TorusKnotGeometry,
  Triangle: () => Triangle,
  TriangleFanDrawMode: () => TriangleFanDrawMode,
  TriangleStripDrawMode: () => TriangleStripDrawMode,
  TrianglesDrawMode: () => TrianglesDrawMode,
  TubeBufferGeometry: () => TubeGeometry,
  TubeGeometry: () => TubeGeometry,
  UVMapping: () => UVMapping,
  Uint16Attribute: () => Uint16Attribute,
  Uint16BufferAttribute: () => Uint16BufferAttribute,
  Uint32Attribute: () => Uint32Attribute,
  Uint32BufferAttribute: () => Uint32BufferAttribute,
  Uint8Attribute: () => Uint8Attribute,
  Uint8BufferAttribute: () => Uint8BufferAttribute,
  Uint8ClampedAttribute: () => Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
  Uniform: () => Uniform,
  UniformsLib: () => UniformsLib,
  UniformsUtils: () => UniformsUtils,
  UnsignedByteType: () => UnsignedByteType,
  UnsignedInt248Type: () => UnsignedInt248Type,
  UnsignedIntType: () => UnsignedIntType,
  UnsignedShort4444Type: () => UnsignedShort4444Type,
  UnsignedShort5551Type: () => UnsignedShort5551Type,
  UnsignedShort565Type: () => UnsignedShort565Type,
  UnsignedShortType: () => UnsignedShortType,
  VSMShadowMap: () => VSMShadowMap,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  VectorKeyframeTrack: () => VectorKeyframeTrack,
  Vertex: () => Vertex,
  VertexColors: () => VertexColors,
  VideoTexture: () => VideoTexture,
  WebGL1Renderer: () => WebGL1Renderer,
  WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
  WebGLMultisampleRenderTarget: () => WebGLMultisampleRenderTarget,
  WebGLRenderTarget: () => WebGLRenderTarget,
  WebGLRenderTargetCube: () => WebGLRenderTargetCube,
  WebGLRenderer: () => WebGLRenderer,
  WebGLUtils: () => WebGLUtils,
  WireframeGeometry: () => WireframeGeometry,
  WireframeHelper: () => WireframeHelper,
  WrapAroundEnding: () => WrapAroundEnding,
  XHRLoader: () => XHRLoader,
  ZeroCurvatureEnding: () => ZeroCurvatureEnding,
  ZeroFactor: () => ZeroFactor,
  ZeroSlopeEnding: () => ZeroSlopeEnding,
  ZeroStencilOp: () => ZeroStencilOp,
  sRGBEncoding: () => sRGBEncoding
});
var REVISION = "126";
var MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2};
var TOUCH = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3};
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;
var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;
var GLSL1 = "100";
var GLSL3 = "300 es";
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index4 = listenerArray.indexOf(listener);
      if (index4 !== -1) {
        listenerArray.splice(index4, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
    }
  }
});
var _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
var _seed = 1234567;
var MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n2, m2) {
    return (n2 % m2 + m2) % m2;
  },
  mapLinear: function(x2, a1, a2, b1, b2) {
    return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
  },
  lerp: function(x2, y2, t2) {
    return (1 - t2) * x2 + t2 * y2;
  },
  damp: function(x2, y2, lambda, dt2) {
    return MathUtils.lerp(x2, y2, 1 - Math.exp(-lambda * dt2));
  },
  pingpong: function(x2, length2 = 1) {
    return length2 - Math.abs(MathUtils.euclideanModulo(x2, length2 * 2) - length2);
  },
  smoothstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  },
  smootherstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s2) {
    if (s2 !== void 0)
      _seed = s2 % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q2, a2, b2, c2, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b2 / 2);
    const s2 = sin(b2 / 2);
    const c13 = cos((a2 + c2) / 2);
    const s13 = sin((a2 + c2) / 2);
    const c1_3 = cos((a2 - c2) / 2);
    const s1_3 = sin((a2 - c2) / 2);
    const c3_1 = cos((c2 - a2) / 2);
    const s3_1 = sin((c2 - a2) / 2);
    switch (order) {
      case "XYX":
        q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
        break;
      case "YZY":
        q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
        break;
      case "YXY":
        q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
};
var Vector2 = class {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w3);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w3);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
};
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[3] *= s2;
    te2[6] *= s2;
    te2[1] *= s2;
    te2[4] *= s2;
    te2[7] *= s2;
    te2[2] *= s2;
    te2[5] *= s2;
    te2[8] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a2 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e2 = te2[4], f2 = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te2 = this.elements;
    te2[0] *= sx;
    te2[3] *= sx;
    te2[6] *= sx;
    te2[1] *= sy;
    te2[4] *= sy;
    te2[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te2 = this.elements;
    const a11 = te2[0], a12 = te2[3], a13 = te2[6];
    const a21 = te2[1], a22 = te2[4], a23 = te2[7];
    te2[0] = c2 * a11 + s2 * a21;
    te2[3] = c2 * a12 + s2 * a22;
    te2[6] = c2 * a13 + s2 * a23;
    te2[1] = -s2 * a11 + c2 * a21;
    te2[4] = -s2 * a12 + c2 * a22;
    te2[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te2 = this.elements;
    te2[0] += tx * te2[2];
    te2[3] += tx * te2[5];
    te2[6] += tx * te2[8];
    te2[1] += ty * te2[2];
    te2[4] += ty * te2[5];
    te2[7] += ty * te2[8];
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
Matrix3.prototype.isMatrix3 = true;
var _canvas;
var ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i2 = 0, l2 = image.length; i2 < l2; i2++) {
            if (image[i2].isDataTexture) {
              url.push(serializeImage(image[i2].image));
            } else {
              url.push(serializeImage(image[i2]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var Vector4 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w3 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w3;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w3) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w3) {
    this.w = w3;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w3);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w3);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w3 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w3;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w3;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w3;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w3;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    this.z = attribute.getZ(index4);
    this.w = attribute.getW(index4);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
};
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options2) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options2 = options2 || {};
    this.texture = new Texture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
    this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
    this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
};
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options2) {
    super(width, height, options2);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, w3 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w3;
  }
  static slerp(qa, qb, qm, t2) {
    return qm.copy(qa).slerp(qb, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w3) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w3;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    const EPS = 1e-6;
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < EPS) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0)
      return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p2);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    const x2 = this._x, y2 = this._y, z2 = this._z, w3 = this._w;
    let cosHalfTheta = w3 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w3;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w3 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w3 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index4) {
    this._x = attribute.getX(index4);
    this._y = attribute.getY(index4);
    this._z = attribute.getZ(index4);
    this._w = attribute.getW(index4);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index4, value) {
    switch (index4) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index4);
    }
    return this;
  }
  getComponent(index4) {
    switch (index4) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index4);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w3);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w3);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w3);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w3 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w3;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w3;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w3;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length2 = this.length();
    return this.divideScalar(length2 || 1).multiplyScalar(Math.max(min, Math.min(max, length2)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length2) {
    return this.normalize().multiplyScalar(length2);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w3);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index4) {
    return this.fromArray(m2.elements, index4 * 4);
  }
  setFromMatrix3Column(m2, index4) {
    return this.fromArray(m2.elements, index4 * 3);
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index4, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index4);
    this.y = attribute.getY(index4);
    this.z = attribute.getZ(index4);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
};
Vector3.prototype.isVector3 = true;
var _vector = /* @__PURE__ */ new Vector3();
var _quaternion = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
      const x2 = array[i2];
      const y2 = array[i2 + 1];
      const z2 = array[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box.copy(geometry.boundingBox);
      _box.applyMatrix4(object.matrixWorld);
      this.union(_box);
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$1);
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0.subVectors(triangle.a, _center);
    _v1.subVectors(triangle.b, _center);
    _v2.subVectors(triangle.c, _center);
    _f0.subVectors(_v1, _v0);
    _f1.subVectors(_v2, _v1);
    _f2.subVectors(_v0, _v2);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$1 = /* @__PURE__ */ new Vector3();
var _box = /* @__PURE__ */ new Box3();
var _v0 = /* @__PURE__ */ new Vector3();
var _v1 = /* @__PURE__ */ new Vector3();
var _v2 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$1 = /* @__PURE__ */ new Box3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$2 = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$2));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$2.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);
    const tca = _vector$2.dot(this.direction);
    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$2) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m2) {
    const te2 = this.elements, me2 = m2.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me2 = m2.elements;
    this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    const scaleX = 1 / _v1$1.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$1.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m2, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te2 = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae2 = a2 * e2, af = a2 * f2, be2 = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = -c2 * f2;
      te2[8] = d2;
      te2[1] = af + be2 * d2;
      te2[5] = ae2 - bf * d2;
      te2[9] = -b2 * c2;
      te2[2] = bf - ae2 * d2;
      te2[6] = be2 + af * d2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 + df * b2;
      te2[4] = de2 * b2 - cf;
      te2[8] = a2 * d2;
      te2[1] = a2 * f2;
      te2[5] = a2 * e2;
      te2[9] = -b2;
      te2[2] = cf * b2 - de2;
      te2[6] = df + ce2 * b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 - df * b2;
      te2[4] = -a2 * f2;
      te2[8] = de2 + cf * b2;
      te2[1] = cf + de2 * b2;
      te2[5] = a2 * e2;
      te2[9] = df - ce2 * b2;
      te2[2] = -a2 * d2;
      te2[6] = b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae2 = a2 * e2, af = a2 * f2, be2 = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = be2 * d2 - af;
      te2[8] = ae2 * d2 + bf;
      te2[1] = c2 * f2;
      te2[5] = bf * d2 + ae2;
      te2[9] = af * d2 - be2;
      te2[2] = -d2;
      te2[6] = b2 * c2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = bd - ac * f2;
      te2[8] = bc * f2 + ad;
      te2[1] = f2;
      te2[5] = a2 * e2;
      te2[9] = -b2 * e2;
      te2[2] = -d2 * e2;
      te2[6] = ad * f2 + bc;
      te2[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = -f2;
      te2[8] = d2 * e2;
      te2[1] = ac * f2 + bd;
      te2[5] = a2 * e2;
      te2[9] = ad * f2 - bc;
      te2[2] = bc * f2 - ad;
      te2[6] = b2 * e2;
      te2[10] = bd * f2 + ac;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[4] *= s2;
    te2[8] *= s2;
    te2[12] *= s2;
    te2[1] *= s2;
    te2[5] *= s2;
    te2[9] *= s2;
    te2[13] *= s2;
    te2[2] *= s2;
    te2[6] *= s2;
    te2[10] *= s2;
    te2[14] *= s2;
    te2[3] *= s2;
    te2[7] *= s2;
    te2[11] *= s2;
    te2[15] *= s2;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp2;
    tmp2 = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp2;
    tmp2 = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp2;
    tmp2 = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp2;
    tmp2 = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp2;
    tmp2 = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp2;
    tmp2 = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp2;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te2 = this.elements;
    if (x2.isVector3) {
      te2[12] = x2.x;
      te2[13] = x2.y;
      te2[14] = x2.z;
    } else {
      te2[12] = x2;
      te2[13] = y2;
      te2[14] = z2;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te2 = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te2[0] *= x2;
    te2[4] *= y2;
    te2[8] *= z2;
    te2[1] *= x2;
    te2[5] *= y2;
    te2[9] *= z2;
    te2[2] *= x2;
    te2[6] *= y2;
    te2[10] *= z2;
    te2[3] *= x2;
    te2[7] *= y2;
    te2[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x2, y2, z2) {
    this.set(1, y2, z2, 0, x2, 1, z2, 0, x2, y2, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position2, quaternion, scale) {
    const te2 = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w3 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w3 * x22, wy = w3 * y22, wz = w3 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position2.x;
    te2[13] = position2.y;
    te2[14] = position2.z;
    te2[15] = 1;
    return this;
  }
  decompose(position2, quaternion, scale) {
    const te2 = this.elements;
    let sx = _v1$1.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$1.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$1.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position2.x = te2[12];
    position2.y = te2[13];
    position2.z = te2[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te2 = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = a2;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = b2;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te2 = this.elements;
    const w3 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x2 = (right + left) * w3;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p2;
    te2[0] = 2 * w3;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x2;
    te2[1] = 0;
    te2[5] = 2 * h2;
    te2[9] = 0;
    te2[13] = -y2;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = -2 * p2;
    te2[14] = -z2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te2[i2] !== me2[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
};
Matrix4.prototype.isMatrix4 = true;
var _v1$1 = /* @__PURE__ */ new Vector3();
var _m1 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix4();
var _quaternion$1 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order, update) {
    const clamp = MathUtils.clamp;
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    order = order || this._order;
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v2, order) {
    return this.set(v2.x, v2.y, v2.z, order || this._order);
  }
  reorder(newOrder) {
    _quaternion$1.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$1, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
var _object3DId = 0;
var _v1$2 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position = new Vector3();
var _scale = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = {type: "added"};
var _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position2 = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position2
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q2) {
    this.quaternion.premultiply(q2);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  },
  setRotationFromQuaternion: function(q2) {
    this.quaternion.copy(q2);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index4 = this.children.indexOf(object);
    if (index4 !== -1) {
      object.parent = null;
      this.children.splice(index4, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name2) {
    return this.getObjectByProperty("name", name2);
  },
  getObjectByProperty: function(name2, value) {
    if (this[name2] === value)
      return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name2, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    }
    function serialize2(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize2(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize2(meta.shapes, shape);
          }
        } else {
          serialize2(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize2(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize2(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize2(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize2(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x2, y2, z2, w3) {
    this.normal.set(x2, y2, z2);
    this.constant = w3;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line2, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target = new Vector3();
    }
    const direction = line2.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line2.start) === 0) {
        return target.copy(line2.start);
      }
      return void 0;
    }
    const t2 = -(line2.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return void 0;
    }
    return target.copy(direction).multiplyScalar(t2).add(line2.start);
  }
  intersectsLine(line2) {
    const startSign = this.distanceToPoint(line2.start);
    const endSign = this.distanceToPoint(line2.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Plane.prototype.isPlane = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$1 = /* @__PURE__ */ new Vector3();
var _v3 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target = new Vector3();
    }
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$1.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$1);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$1);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target = new Vector3();
    }
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w3;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w3 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w3);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w3);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w3 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w3);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data2 = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data2.uuid = this.uuid;
    data2.type = this.type;
    if (this.name !== "")
      data2.name = this.name;
    if (this.color && this.color.isColor)
      data2.color = this.color.getHex();
    if (this.roughness !== void 0)
      data2.roughness = this.roughness;
    if (this.metalness !== void 0)
      data2.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data2.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data2.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data2.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data2.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data2.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data2.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data2.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data2.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data2.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data2.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data2.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data2.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data2.lightMap = this.lightMap.toJSON(meta).uuid;
      data2.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data2.aoMap = this.aoMap.toJSON(meta).uuid;
      data2.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data2.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data2.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data2.normalMap = this.normalMap.toJSON(meta).uuid;
      data2.normalMapType = this.normalMapType;
      data2.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data2.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data2.displacementScale = this.displacementScale;
      data2.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data2.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data2.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data2.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data2.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data2.envMap = this.envMap.toJSON(meta).uuid;
      data2.reflectivity = this.reflectivity;
      data2.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data2.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data2.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data2.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data2.size = this.size;
    if (this.sizeAttenuation !== void 0)
      data2.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data2.blending = this.blending;
    if (this.side !== FrontSide)
      data2.side = this.side;
    if (this.vertexColors)
      data2.vertexColors = true;
    if (this.opacity < 1)
      data2.opacity = this.opacity;
    if (this.transparent === true)
      data2.transparent = this.transparent;
    data2.depthFunc = this.depthFunc;
    data2.depthTest = this.depthTest;
    data2.depthWrite = this.depthWrite;
    data2.stencilWrite = this.stencilWrite;
    data2.stencilWriteMask = this.stencilWriteMask;
    data2.stencilFunc = this.stencilFunc;
    data2.stencilRef = this.stencilRef;
    data2.stencilFuncMask = this.stencilFuncMask;
    data2.stencilFail = this.stencilFail;
    data2.stencilZFail = this.stencilZFail;
    data2.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data2.rotation = this.rotation;
    if (this.polygonOffset === true)
      data2.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data2.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data2.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data2.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data2.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data2.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data2.scale = this.scale;
    if (this.dithering === true)
      data2.dithering = true;
    if (this.alphaTest > 0)
      data2.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data2.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data2.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data2.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data2.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data2.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data2.morphTargets = true;
    if (this.morphNormals === true)
      data2.morphNormals = true;
    if (this.skinning === true)
      data2.skinning = true;
    if (this.flatShading === true)
      data2.flatShading = this.flatShading;
    if (this.visible === false)
      data2.visible = false;
    if (this.toneMapped === false)
      data2.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data2.userData = this.userData;
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data3 = cache3[key];
        delete data3.metadata;
        values.push(data3);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data2.textures = textures;
      if (images.length > 0)
        data2.images = images;
    }
    return data2;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var _hslA = {h: 0, s: 0, l: 0};
var _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var Color = class {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l2) {
    h2 = MathUtils.euclideanModulo(h2, 1);
    s2 = MathUtils.clamp(s2, 0, 1);
    l2 = MathUtils.clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name2 = m2[1];
      const components2 = m2[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            const h2 = parseFloat(color[1]) / 360;
            const s2 = parseInt(color[2], 10) / 100;
            const l2 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = {h: 0, s: 0, l: 0};
    }
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s2 = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l2 = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index4) {
    this.r = attribute.getX(index4);
    this.g = attribute.getY(index4);
    this.b = attribute.getZ(index4);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$3 = new Vector3();
var _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index22) {
    index1 *= this.itemSize;
    index22 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index22 + i2];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors2) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = colors2.length; i2 < l2; i2++) {
      let color = colors2[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$3.fromBufferAttribute(this, i2);
        _vector$3.applyMatrix3(m2);
        this.setXYZ(i2, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$3.x = this.getX(i2);
      _vector$3.y = this.getY(i2);
      _vector$3.z = this.getZ(i2);
      _vector$3.applyMatrix4(m2);
      this.setXYZ(i2, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  applyNormalMatrix: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$3.x = this.getX(i2);
      _vector$3.y = this.getY(i2);
      _vector$3.z = this.getZ(i2);
      _vector$3.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  transformDirection: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$3.x = this.getX(i2);
      _vector$3.y = this.getY(i2);
      _vector$3.z = this.getZ(i2);
      _vector$3.transformDirection(m2);
      this.setXYZ(i2, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  getX: function(index4) {
    return this.array[index4 * this.itemSize];
  },
  setX: function(index4, x2) {
    this.array[index4 * this.itemSize] = x2;
    return this;
  },
  getY: function(index4) {
    return this.array[index4 * this.itemSize + 1];
  },
  setY: function(index4, y2) {
    this.array[index4 * this.itemSize + 1] = y2;
    return this;
  },
  getZ: function(index4) {
    return this.array[index4 * this.itemSize + 2];
  },
  setZ: function(index4, z2) {
    this.array[index4 * this.itemSize + 2] = z2;
    return this;
  },
  getW: function(index4) {
    return this.array[index4 * this.itemSize + 3];
  },
  setW: function(index4, w3) {
    this.array[index4 * this.itemSize + 3] = w3;
    return this;
  },
  setXY: function(index4, x2, y2) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x2;
    this.array[index4 + 1] = y2;
    return this;
  },
  setXYZ: function(index4, x2, y2, z2) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x2;
    this.array[index4 + 1] = y2;
    this.array[index4 + 2] = z2;
    return this;
  },
  setXYZW: function(index4, x2, y2, z2, w3) {
    index4 *= this.itemSize;
    this.array[index4 + 0] = x2;
    this.array[index4 + 1] = y2;
    this.array[index4 + 2] = z2;
    this.array[index4 + 3] = w3;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i2 = 1, l2 = array.length; i2 < l2; ++i2) {
    if (array[i2] > max)
      max = array[i2];
  }
  return max;
}
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
var _id = 0;
var _m1$2 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index4) {
    if (Array.isArray(index4)) {
      this.index = new (arrayMax(index4) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index4, 1);
    } else {
      this.index = index4;
    }
    return this;
  },
  getAttribute: function(name2) {
    return this.attributes[name2];
  },
  setAttribute: function(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  },
  deleteAttribute: function(name2) {
    delete this.attributes[name2];
    return this;
  },
  hasAttribute: function(name2) {
    return this.attributes[name2] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position2 = this.attributes.position;
    if (position2 !== void 0) {
      position2.applyMatrix4(matrix);
      position2.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function(x2, y2, z2) {
    _m1$2.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function(x2, y2, z2) {
    _m1$2.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position2 = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position2.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position2, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$4);
            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position2) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$4);
            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position2.count; i2 < il; i2++) {
        _vector$4.fromBufferAttribute(position2, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$4.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position2, j2);
              _vector$4.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index4 = this.index;
    const attributes = this.attributes;
    if (index4 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index4.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp22.crossVectors(n22, t2);
      const test = tmp22.dot(tan2[v2]);
      const w3 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w3;
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index4 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index4) {
        for (let i2 = 0, il = index4.count; i2 < il; i2 += 3) {
          const vA = index4.getX(i2 + 0);
          const vB = index4.getX(i2 + 1);
          const vC = index4.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length2 = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length2; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$4.fromBufferAttribute(normals, i2);
      _vector$4.normalize();
      normals.setXYZ(i2, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index4 = 0, index22 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        index4 = indices2[i2] * itemSize;
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index22++] = array[index4++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data2 = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data2.uuid = this.uuid;
    data2.type = this.type;
    if (this.name !== "")
      data2.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data2.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data2[key] = parameters[key];
      }
      return data2;
    }
    data2.data = {attributes: {}};
    const index4 = this.index;
    if (index4 !== null) {
      data2.data.index = {
        type: index4.array.constructor.name,
        array: Array.prototype.slice.call(index4.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data2.data);
      if (attribute.name !== "")
        attributeData.name = attribute.name;
      data2.data.attributes[key] = attributeData;
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        const attributeData = attribute.toJSON(data2.data);
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data2.data.morphAttributes = morphAttributes;
      data2.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data2.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data2.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data2;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data2 = {};
    this.name = source.name;
    const index4 = source.index;
    if (index4 !== null) {
      this.setIndex(index4.clone(data2));
    }
    const attributes = source.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data2));
    }
    const morphAttributes = source.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name2];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data2));
      }
      this.morphAttributes[name2] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const position2 = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index4 !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = index4.getX(j2);
              const b2 = index4.getX(j2 + 1);
              const c2 = index4.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index4.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = index4.getX(i2);
            const b2 = index4.getX(i2 + 1);
            const c2 = index4.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position2 !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position2.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position2, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
  _vA.fromBufferAttribute(position2, a2);
  _vB.fromBufferAttribute(position2, b2);
  _vC.fromBufferAttribute(position2, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);
        _morphB.addScaledVector(_tempB.sub(_vB), influence);
        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }
    _vA.add(_morphA);
    _vB.add(_morphB);
    _vC.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a2, _vA);
    object.boneTransform(b2, _vB);
    object.boneTransform(c2, _vC);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a2);
      _uvB.fromBufferAttribute(uv, b2);
      _uvC.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a2);
      _uvB.fromBufferAttribute(uv2, b2);
      _uvC.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w3, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w3] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w3] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
};
function cloneUniforms(src2) {
  const dst = {};
  for (const u2 in src2) {
    dst[u2] = {};
    for (const p2 in src2[u2]) {
      const property = src2[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
var UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data2 = Material.prototype.toJSON.call(this, meta);
  data2.glslVersion = this.glslVersion;
  data2.uniforms = {};
  for (const name2 in this.uniforms) {
    const uniform = this.uniforms[name2];
    const value = uniform.value;
    if (value && value.isTexture) {
      data2.uniforms[name2] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data2.uniforms[name2] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data2.uniforms[name2] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data2.uniforms[name2] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data2.uniforms[name2] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data2.uniforms[name2] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data2.uniforms[name2] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data2.uniforms[name2] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data2.defines = this.defines;
  data2.vertexShader = this.vertexShader;
  data2.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data2.extensions = extensions;
  return data2;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data2 = Object3D.prototype.toJSON.call(this, meta);
    data2.object.fov = this.fov;
    data2.object.zoom = this.zoom;
    data2.object.near = this.near;
    data2.object.far = this.far;
    data2.object.focus = this.focus;
    data2.object.aspect = this.aspect;
    if (this.view !== null)
      data2.object.view = Object.assign({}, this.view);
    data2.object.filmGauge = this.filmGauge;
    data2.object.filmOffset = this.filmOffset;
    return data2;
  }
});
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options2, dummy) {
    if (Number.isInteger(options2)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options2 = dummy;
    }
    super(size, size, options2);
    options2 = options2 || {};
    this.texture = new CubeTexture(void 0, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var DataTexture = class extends Texture {
  constructor(data2, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data2 || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
DataTexture.prototype.isDataTexture = true;
var _sphere$1 = /* @__PURE__ */ new Sphere();
var _vector$5 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me2 = m2.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);
    _sphere$1.radius = 0.7071067811865476;
    _sphere$1.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data2 = buffers.get(attribute);
    if (data2) {
      gl.deleteBuffer(data2.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data2 = buffers.get(attribute);
    if (data2 === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data2.version < attribute.version) {
      updateBuffer(data2.buffer, attribute, bufferType);
      data2.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
var UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render2(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      if (background.isWebGLCubeRenderTarget) {
        background = background.texture;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render2
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index4) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index4);
      if (updateBuffers)
        saveCache(geometry, index4);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index4 !== null) {
      attributes.update(index4, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index4 !== null) {
        gl.bindBuffer(34963, attributes.get(index4).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index4) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index4)
      return true;
    return false;
  }
  function saveCache(geometry, index4) {
    const cache3 = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data2 = {};
      data2.attribute = attribute;
      if (attribute.data) {
        data2.data = attribute.data;
      }
      cache3[key] = data2;
      attributesNum++;
    }
    currentState.attributes = cache3;
    currentState.attributesNum = attributesNum;
    currentState.index = index4;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index4, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index4, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index4, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data2 = geometryAttribute.data;
            const stride = data2.stride;
            const offset = geometryAttribute.offset;
            if (data2 && data2.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data2.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data2.meshPerAttribute * data2.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name2 === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name2 === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose2() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose: dispose2,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render2(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose2() {
    cubemaps = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name2);
    }
    extensions[name2] = extension;
    return extension;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name2) {
      const extension = getExtension(name2);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name2 in geometry.attributes) {
      attributes.remove(geometry.attributes[name2]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = morphAttributes[name2];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render2(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render2;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render2.calls++;
    switch (mode) {
      case 4:
        render2.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render2.lines += instanceCount * (count / 2);
        break;
      case 3:
        render2.lines += instanceCount * (count - 1);
        break;
      case 2:
        render2.lines += instanceCount * count;
        break;
      case 0:
        render2.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render2.frame++;
    render2.calls = 0;
    render2.triangles = 0;
    render2.points = 0;
    render2.lines = 0;
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length2 = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i2 = 0; i2 < length2; i2++) {
        influences[i2] = [i2, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i2 = 0; i2 < length2; i2++) {
      const influence = influences[i2];
      influence[0] = i2;
      influence[1] = objectInfluences[i2];
    }
    influences.sort(absNumericalSort);
    for (let i2 = 0; i2 < 8; i2++) {
      if (i2 < length2 && influences[i2][1]) {
        workInfluences[i2][0] = influences[i2][0];
        workInfluences[i2][1] = influences[i2][1];
      } else {
        workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i2][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      const influence = workInfluences[i2];
      const index4 = influence[0];
      const value = influence[1];
      if (index4 !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index4]) {
          geometry.setAttribute("morphTarget" + i2, morphTargets[index4]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index4]) {
          geometry.setAttribute("morphNormal" + i2, morphNormals[index4]);
        }
        morphInfluences[i2] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
          geometry.deleteAttribute("morphTarget" + i2);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
          geometry.deleteAttribute("morphNormal" + i2);
        }
        morphInfluences[i2] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose2() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose: dispose2
  };
}
var DataTexture2DArray = class extends Texture {
  constructor(data2 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data: data2, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture2DArray.prototype.isDataTexture2DArray = true;
var DataTexture3D = class extends Texture {
  constructor(data2 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data: data2, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache3 = this.cache;
  if (cache3[0] === v2)
    return;
  gl.uniform1f(this.addr, v2);
  cache3[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache3 = this.cache;
  if (v2.x !== void 0) {
    if (cache3[0] !== v2.x || cache3[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache3[0] = v2.x;
      cache3[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache3, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache3 = this.cache;
  if (v2.x !== void 0) {
    if (cache3[0] !== v2.x || cache3[1] !== v2.y || cache3[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache3[0] = v2.x;
      cache3[1] = v2.y;
      cache3[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache3[0] !== v2.r || cache3[1] !== v2.g || cache3[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache3[0] = v2.r;
      cache3[1] = v2.g;
      cache3[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache3, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache3 = this.cache;
  if (v2.x !== void 0) {
    if (cache3[0] !== v2.x || cache3[1] !== v2.y || cache3[2] !== v2.z || cache3[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache3[0] = v2.x;
      cache3[1] = v2.y;
      cache3[2] = v2.z;
      cache3[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache3, v2);
  }
}
function setValueM2(gl, v2) {
  const cache3 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache3, v2);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache3, elements);
  }
}
function setValueM3(gl, v2) {
  const cache3 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache3, v2);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache3, elements);
  }
}
function setValueM4(gl, v2) {
  const cache3 = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache3, v2))
      return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache3, v2);
  } else {
    if (arraysEqual(cache3, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache3, elements);
  }
}
function setValueT1(gl, v2, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl, v2, textures) {
  const cache3 = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache3[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache3[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueV1i(gl, v2) {
  const cache3 = this.cache;
  if (cache3[0] === v2)
    return;
  gl.uniform1i(this.addr, v2);
  cache3[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v2))
    return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache3, v2);
}
function setValueV3i(gl, v2) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v2))
    return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache3, v2);
}
function setValueV4i(gl, v2) {
  const cache3 = this.cache;
  if (arraysEqual(cache3, v2))
    return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache3, v2);
}
function setValueV1ui(gl, v2) {
  const cache3 = this.cache;
  if (cache3[0] === v2)
    return;
  gl.uniform1ui(this.addr, v2);
  cache3[0] = v2;
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data2);
}
function setValueV3fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data2);
}
function setValueV4fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data2);
}
function setValueM2Array(gl, v2) {
  const data2 = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data2);
}
function setValueM3Array(gl, v2) {
  const data2 = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data2);
}
function setValueM4Array(gl, v2) {
  const data2 = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data2);
}
function setValueT1Array(gl, v2, textures) {
  const n2 = v2.length;
  const units2 = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units2);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units2[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const n2 = v2.length;
  const units2 = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units2);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units2[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data2) {
  const cache3 = this.cache;
  if (data2 instanceof Float32Array && cache3.length !== data2.length) {
    this.cache = new Float32Array(data2.length);
  }
  copyArray(cache3, data2);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match2 = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match2[1];
    const idIsIndex = match2[2] === "]", subscript = match2[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next2 = map[id];
      if (next2 === void 0) {
        next2 = new StructuredUniform(id);
        addUniform(container, next2);
      }
      container = next2;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name2, value, textures) {
  const u2 = this.map[name2];
  if (u2 !== void 0)
    u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name2) {
  const v2 = object[name2];
  if (v2 !== void 0)
    this.setValue(gl, name2, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components2 = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components2[0] + "ToLinear" + components2[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components2 = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components2[0] + components2[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false)
      continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name2 = info.name;
    attributes[name2] = gl.getAttribLocation(program, name2);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match2, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match2, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match2, start, end, snippet);
}
function loopReplacer(match2, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array.push(name2);
        array.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array.push(parameters[parameterNames[i2]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose2() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose: dispose2
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.program !== b2.program) {
    return a2.program.id - b2.program.id;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose2() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache3 = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g2 += color.g * intensity;
        b2 += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache3.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache3.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache3.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index4 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index4];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index4] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index4 = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index4];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index4] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target, count) {
    const data2 = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data2);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units2) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units2) {
        gl.polygonOffset(factor, units2);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units2;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i2 = 0; i2 < 6; i2++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
      } else {
        cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i2 = 0; i2 < 6; i2++) {
        mipmaps = cubeImage[i2].mipmaps;
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            const mipmapImage = mipmap.image[i2].image;
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask2 = 16384;
        if (renderTarget.depthBuffer)
          mask2 |= 256;
        if (renderTarget.stencilBuffer)
          mask2 |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask2, 9728);
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p2) {
    let extension;
    if (p2 === UnsignedByteType)
      return 5121;
    if (p2 === UnsignedShort4444Type)
      return 32819;
    if (p2 === UnsignedShort5551Type)
      return 32820;
    if (p2 === UnsignedShort565Type)
      return 33635;
    if (p2 === ByteType)
      return 5120;
    if (p2 === ShortType)
      return 5122;
    if (p2 === UnsignedShortType)
      return 5123;
    if (p2 === IntType)
      return 5124;
    if (p2 === UnsignedIntType)
      return 5125;
    if (p2 === FloatType)
      return 5126;
    if (p2 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat)
      return 6406;
    if (p2 === RGBFormat)
      return 6407;
    if (p2 === RGBAFormat)
      return 6408;
    if (p2 === LuminanceFormat)
      return 6409;
    if (p2 === LuminanceAlphaFormat)
      return 6410;
    if (p2 === DepthFormat)
      return 6402;
    if (p2 === DepthStencilFormat)
      return 34041;
    if (p2 === RedFormat)
      return 6403;
    if (p2 === RedIntegerFormat)
      return 36244;
    if (p2 === RGFormat)
      return 33319;
    if (p2 === RGIntegerFormat)
      return 33320;
    if (p2 === RGBIntegerFormat)
      return 36248;
    if (p2 === RGBAIntegerFormat)
      return 36249;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p2 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p2 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {convert};
}
function ArrayCamera(array = []) {
  PerspectiveCamera.call(this);
  this.cameras = array;
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index4) {
    let controller = controllers[index4];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index4] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      inputSourcesMap.set(inputSources[i2], controllers[i2]);
    }
    for (let i2 = 0; i2 < event.removed.length; i2++) {
      const inputSource = event.removed[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i2 = 0; i2 < event.added.length; i2++) {
      const inputSource = event.added[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i2 = 0; i2 < cameras2.length; i2++) {
      updateCamera(cameras2[i2], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i2 = 0; i2 < views.length; i2++) {
        const view = views[i2];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i2];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i2 === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      const controller = controllers[i2];
      const inputSource = inputSources[i2];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  const _this = this;
  let _isContextLost = false;
  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target = new Color();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index4 = geometry.index;
    const position2 = geometry.attributes.position;
    if (index4 === null) {
      if (position2 === void 0 || position2.count === 0)
        return;
    } else if (index4.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index4 = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index4);
    let attribute;
    let renderer = bufferRenderer;
    if (index4 !== null) {
      attribute = attributes.get(index4);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index4 !== null ? index4.count : position2.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    const compiled = new WeakMap();
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (xr.isPresenting)
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j2 = 0, jl = cameras.length; j2 < jl; j2++) {
          const camera2 = cameras[j2];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function initMaterial(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let program = materialProperties.program;
    let programChange = true;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters2.uniforms;
      materialProperties.outputEncoding = parameters2.outputEncoding;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value && _currentRenderTarget === null)
      _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position2, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position2.x, position2.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position2, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position2.x, position2.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position2.x, position2.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position2.x, position2.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position2, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data: data2} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position2.x, position2.y, position2.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data2);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density) {
    this.name = "";
    this.color = new Color(color);
    this.density = density !== void 0 ? density : 25e-5;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near, far) {
    this.name = "";
    this.color = new Color(color);
    this.near = near !== void 0 ? near : 1;
    this.far = far !== void 0 ? far : 1e3;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    if (this.background !== null)
      data2.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data2.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data2.object.fog = this.fog.toJSON();
    return data2;
  }
};
Scene.prototype.isScene = true;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index22) {
    index1 *= this.stride;
    index22 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index22 + i2];
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  clone: function(data2) {
    if (data2.arrayBuffers === void 0) {
      data2.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data2.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data2.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data2) {
    if (data2.arrayBuffers === void 0) {
      data2.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data2.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
var _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index4, x2) {
    this.data.array[index4 * this.data.stride + this.offset] = x2;
    return this;
  },
  setY: function(index4, y2) {
    this.data.array[index4 * this.data.stride + this.offset + 1] = y2;
    return this;
  },
  setZ: function(index4, z2) {
    this.data.array[index4 * this.data.stride + this.offset + 2] = z2;
    return this;
  },
  setW: function(index4, w3) {
    this.data.array[index4 * this.data.stride + this.offset + 3] = w3;
    return this;
  },
  getX: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset];
  },
  getY: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 1];
  },
  getZ: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 2];
  },
  getW: function(index4) {
    return this.data.array[index4 * this.data.stride + this.offset + 3];
  },
  setXY: function(index4, x2, y2) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x2;
    this.data.array[index4 + 1] = y2;
    return this;
  },
  setXYZ: function(index4, x2, y2, z2) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x2;
    this.data.array[index4 + 1] = y2;
    this.data.array[index4 + 2] = z2;
    return this;
  },
  setXYZW: function(index4, x2, y2, z2, w3) {
    index4 = index4 * this.data.stride + this.offset;
    this.data.array[index4 + 0] = x2;
    this.data.array[index4 + 1] = y2;
    this.data.array[index4 + 2] = z2;
    this.data.array[index4 + 3] = w3;
    return this;
  },
  clone: function(data2) {
    if (data2 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index4 = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index4 + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data2.interleavedBuffers === void 0) {
        data2.interleavedBuffers = {};
      }
      if (data2.interleavedBuffers[this.data.uuid] === void 0) {
        data2.interleavedBuffers[this.data.uuid] = this.data.clone(data2);
      }
      return new InterleavedBufferAttribute(data2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data2) {
    if (data2 === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index4 = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index4 + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data2.interleavedBuffers === void 0) {
        data2.interleavedBuffers = {};
      }
      if (data2.interleavedBuffers[this.data.uuid] === void 0) {
        data2.interleavedBuffers[this.data.uuid] = this.data.toJSON(data2);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB$1.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$4 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      const level = levels[i2];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l2;
    for (l2 = 0; l2 < levels.length; l2++) {
      if (distance < levels[l2].distance) {
        break;
      }
    }
    levels.splice(l2, 0, {distance, object});
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i2, l2;
      for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
        if (distance < levels[i2].distance) {
          break;
        }
      }
      return levels[i2 - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);
      _v2$2.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i2, l2;
      for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
        if (distance >= levels[i2].distance) {
          levels[i2 - 1].object.visible = false;
          levels[i2].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i2 - 1;
      for (; i2 < l2; i2++) {
        levels[i2].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    if (this.autoUpdate === false)
      data2.object.autoUpdate = false;
    data2.object.levels = [];
    const levels = this.levels;
    for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      const level = levels[i2];
      data2.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data2;
  }
};
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$7 = new Vector3();
var _matrix$1 = new Matrix4();
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index4, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index4);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index4);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index4).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name2) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name2) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data2 = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data2.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data2.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data2.boneInverses.push(boneInverse.toArray());
    }
    return data2;
  }
};
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index4, color) {
    color.fromArray(this.instanceColor.array, index4 * 3);
  },
  getMatrixAt: function(index4, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index4 * 16);
  },
  raycast: function(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId2 = 0; instanceId2 < raycastTimes; instanceId2++) {
      this.getMatrixAt(instanceId2, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId2;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index4, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index4 * 3);
  },
  setMatrixAt: function(index4, matrix) {
    matrix.toArray(this.instanceMatrix.array, index4 * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
          _start.fromBufferAttribute(positionAttribute, i2 - 1);
          _end.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index4 !== null) {
        const indices = index4.array;
        for (let i2 = 0, l2 = indices.length - 1; i2 < l2; i2 += step) {
          const a2 = indices[i2];
          const b2 = indices[i2 + 1];
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i2 = 0, l2 = positionAttribute.count - 1; i2 < l2; i2 += step) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
var _start$1 = new Vector3();
var _end$1 = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i2);
          _end$1.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index4 = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index4 !== null) {
        const indices = index4.array;
        for (let i2 = 0, il = indices.length; i2 < il; i2++) {
          const a2 = indices[i2];
          _position$1.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$1, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2++) {
          _position$1.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$1, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys2 = Object.keys(morphAttributes);
      if (keys2.length > 0) {
        const morphAttribute = morphAttributes[keys2[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name2 = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name2] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index4, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$2.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index4,
      face: null,
      object
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {width, height};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
DepthTexture.prototype.isDepthTexture = true;
var CircleGeometry = class extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i2] / radius + 1) / 2;
      uv.y = (vertices[i2 + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i2 = 1; i2 <= segments; i2++) {
      indices.push(i2, i2 + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var CylinderGeometry = class extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index4 = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v2 = y2 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x2 = 0; x2 <= radialSegments; x2++) {
          const u2 = x2 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v2 * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index4++);
        }
        indexArray.push(indexRow);
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x2];
          const b2 = indexArray[y2 + 1][x2];
          const c2 = indexArray[y2 + 1][x2 + 1];
          const d2 = indexArray[y2][x2 + 1];
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index4;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x2 = 1; x2 <= radialSegments; x2++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index4++;
      }
      const centerIndexEnd = index4;
      for (let x2 = 0; x2 <= radialSegments; x2++) {
        const u2 = x2 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign2;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index4++;
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        const c2 = centerIndexStart + x2;
        const i2 = centerIndexEnd + x2;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
};
var ConeGeometry = class extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
};
var PolyhedronGeometry = class extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      for (let i2 = 0; i2 < indices.length; i2 += 3) {
        getVertexByIndex(indices[i2 + 0], a2);
        getVertexByIndex(indices[i2 + 1], b2);
        getVertexByIndex(indices[i2 + 2], c2);
        subdivideFace(a2, b2, c2, detail2);
      }
    }
    function subdivideFace(a2, b2, c2, detail2) {
      const cols = detail2 + 1;
      const v2 = [];
      for (let i2 = 0; i2 <= cols; i2++) {
        v2[i2] = [];
        const aj = a2.clone().lerp(c2, i2 / cols);
        const bj = b2.clone().lerp(c2, i2 / cols);
        const rows = cols - i2;
        for (let j2 = 0; j2 <= rows; j2++) {
          if (j2 === 0 && i2 === cols) {
            v2[i2][j2] = aj;
          } else {
            v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
          }
        }
      }
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
          const k2 = Math.floor(j2 / 2);
          if (j2 % 2 === 0) {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
            pushVertex(v2[i2][k2]);
          } else {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i2 + 0] = vertex.x;
        vertexBuffer[i2 + 1] = vertex.y;
        vertexBuffer[i2 + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex.x = vertexBuffer[i2 + 0];
        vertex.y = vertexBuffer[i2 + 1];
        vertex.z = vertexBuffer[i2 + 2];
        const u2 = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v2 = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u2, 1 - v2);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
        const x0 = uvBuffer[i2 + 0];
        const x1 = uvBuffer[i2 + 2];
        const x2 = uvBuffer[i2 + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i2 + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i2 + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i2 + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index4, vertex) {
      const stride = index4 * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
        a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
        b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
        c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
        uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
        uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
        uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
        centroid.copy(a2).add(b2).add(c2).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j2 + 0, a2, azi);
        correctUV(uvB, j2 + 2, b2, azi);
        correctUV(uvC, j2 + 4, c2, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
};
var DodecahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const r2 = 1 / t2;
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      0,
      -t2,
      0,
      -r2,
      t2,
      0,
      -r2,
      -t2,
      0,
      r2,
      t2,
      0,
      r2
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var _v0$2 = new Vector3();
var _v1$5 = new Vector3();
var _normal$1 = new Vector3();
var _triangle = new Triangle();
var EdgesGeometry = class extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      thresholdAngle
    };
    thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
    if (geometry.isGeometry === true) {
      console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const precisionPoints = 4;
    const precision = Math.pow(10, precisionPoints);
    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute("position");
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ["a", "b", "c"];
    const hashes = new Array(3);
    const edgeData = {};
    const vertices = [];
    for (let i2 = 0; i2 < indexCount; i2 += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i2);
        indexArr[1] = indexAttr.getX(i2 + 1);
        indexArr[2] = indexAttr.getX(i2 + 2);
      } else {
        indexArr[0] = i2;
        indexArr[1] = i2 + 1;
        indexArr[2] = i2 + 2;
      }
      const {a: a2, b: b2, c: c2} = _triangle;
      a2.fromBufferAttribute(positionAttr, indexArr[0]);
      b2.fromBufferAttribute(positionAttr, indexArr[1]);
      c2.fromBufferAttribute(positionAttr, indexArr[2]);
      _triangle.getNormal(_normal$1);
      hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
      hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
      hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      }
      for (let j2 = 0; j2 < 3; j2++) {
        const jNext = (j2 + 1) % 3;
        const vecHash0 = hashes[j2];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j2]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash2 = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;
        if (reverseHash in edgeData && edgeData[reverseHash]) {
          if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
            vertices.push(v0.x, v0.y, v0.z);
            vertices.push(v1.x, v1.y, v1.z);
          }
          edgeData[reverseHash] = null;
        } else if (!(hash2 in edgeData)) {
          edgeData[hash2] = {
            index0: indexArr[j2],
            index1: indexArr[jNext],
            normal: _normal$1.clone()
          };
        }
      }
    }
    for (const key in edgeData) {
      if (edgeData[key]) {
        const {index0, index1} = edgeData[key];
        _v0$2.fromBufferAttribute(positionAttr, index0);
        _v1$5.fromBufferAttribute(positionAttr, index1);
        vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
        vertices.push(_v1$5.x, _v1$5.y, _v1$5.z);
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
var Earcut = {
  triangulate: function(data2, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data2.length;
    let outerNode = linkedList(data2, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data2, holeIndices, outerNode, dim);
    if (data2.length > 80 * dim) {
      minX = maxX = data2[0];
      minY = maxY = data2[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data2[i2];
        y2 = data2[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data2, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data2, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data2[i2], data2[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev2, next2;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next2 = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next2.i / dim);
      removeNode(ear);
      ear = next2.next;
      stop = next2.next;
      continue;
    }
    ear = next2;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  let p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data2, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data2.length;
    list = linkedList(data2, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y)
            return p2;
          if (hy === p2.next.y)
            return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px3, py2) {
  return (cx - px3) * (ay - py2) - (ax - px3) * (cy - py2) >= 0 && (ax - px3) * (by - py2) - (bx - px3) * (ay - py2) >= 0 && (bx - px3) * (cy - py2) - (cx - px3) * (by - py2) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2, inside = false;
  const px3 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px3 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = new Node(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data2, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data2[j2] - data2[i2]) * (data2[i2 + 1] + data2[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
var ShapeUtils = {
  area: function(contour) {
    const n2 = contour.length;
    let a2 = 0;
    for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
      a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
    }
    return a2 * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(shapes, options2) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options2
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
      const steps = options2.steps !== void 0 ? options2.steps : 1;
      let depth = options2.depth !== void 0 ? options2.depth : 100;
      let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
      let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 6;
      let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 2;
      let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
      let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
      const extrudePath = options2.extrudePath;
      const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
      if (options2.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options2.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt2, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt2);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
        if (j2 === il)
          j2 = 0;
        if (k2 === il)
          k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
          if (j2 === il)
            j2 = 0;
          if (k2 === il)
            k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z2);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k2 = i2 - 1;
          if (k2 < 0)
            k2 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
            f4(a2, b2, c2, d2);
          }
        }
      }
      function v2(x2, y2, z2) {
        placeholder.push(x2);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a2, b2, c2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b2, c2, d2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index4) {
        verticesArray.push(placeholder[index4 * 3 + 0]);
        verticesArray.push(placeholder[index4 * 3 + 1]);
        verticesArray.push(placeholder[index4 * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data2 = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options2 = this.parameters.options;
    return toJSON(shapes, options2, data2);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON(shapes, options2, data2) {
  data2.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data2.shapes.push(shape.uuid);
    }
  } else {
    data2.shapes.push(shapes.uuid);
  }
  if (options2.extrudePath !== void 0)
    data2.options.extrudePath = options2.extrudePath.toJSON();
  return data2;
}
var IcosahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      0,
      0,
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      t2,
      0,
      -1,
      t2,
      0,
      1,
      -t2,
      0,
      -1,
      -t2,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var LatheGeometry = class extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const inverseSegments = 1 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let i2 = 0; i2 <= segments; i2++) {
      const phi = phiStart + i2 * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j2 = 0; j2 <= points.length - 1; j2++) {
        vertex.x = points[j2].x * sin;
        vertex.y = points[j2].y;
        vertex.z = points[j2].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i2 / segments;
        uv.y = j2 / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (let i2 = 0; i2 < segments; i2++) {
      for (let j2 = 0; j2 < points.length - 1; j2++) {
        const base = j2 + i2 * points.length;
        const a2 = base;
        const b2 = base + points.length;
        const c2 = base + points.length + 1;
        const d2 = base + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n3 = new Vector3();
      const base = segments * points.length * 3;
      for (let i2 = 0, j2 = 0; i2 < points.length; i2++, j2 += 3) {
        n1.x = normals[j2 + 0];
        n1.y = normals[j2 + 1];
        n1.z = normals[j2 + 2];
        n2.x = normals[base + j2 + 0];
        n2.y = normals[base + j2 + 1];
        n2.z = normals[base + j2 + 2];
        n3.addVectors(n1, n2).normalize();
        normals[j2 + 0] = normals[base + j2 + 0] = n3.x;
        normals[j2 + 1] = normals[base + j2 + 1] = n3.y;
        normals[j2 + 2] = normals[base + j2 + 2] = n3.z;
      }
    }
  }
};
var OctahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i2 = 0; i2 <= stacks; i2++) {
    const v2 = i2 / stacks;
    for (let j2 = 0; j2 <= slices; j2++) {
      const u2 = j2 / slices;
      func(u2, v2, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u2 - EPS >= 0) {
        func(u2 - EPS, v2, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u2 + EPS, v2, p1);
        pu.subVectors(p1, p0);
      }
      if (v2 - EPS >= 0) {
        func(u2, v2 - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u2, v2 + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u2, v2);
    }
  }
  for (let i2 = 0; i2 < stacks; i2++) {
    for (let j2 = 0; j2 < slices; j2++) {
      const a2 = i2 * sliceCount + j2;
      const b2 = i2 * sliceCount + j2 + 1;
      const c2 = (i2 + 1) * sliceCount + j2 + 1;
      const d2 = (i2 + 1) * sliceCount + j2;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
var RingGeometry = class extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let j2 = 0; j2 <= phiSegments; j2++) {
      for (let i2 = 0; i2 <= thetaSegments; i2++) {
        const segment = thetaStart + i2 / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j2 = 0; j2 < phiSegments; j2++) {
      const thetaSegmentLevel = j2 * (thetaSegments + 1);
      for (let i2 = 0; i2 < thetaSegments; i2++) {
        const segment = i2 + thetaSegmentLevel;
        const a2 = segment;
        const b2 = segment + thetaSegments + 1;
        const c2 = segment + thetaSegments + 2;
        const d2 = segment + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var ShapeGeometry = class extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex = shapeVertices[i2];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a2 = face[0] + indexOffset;
        const b2 = face[1] + indexOffset;
        const c2 = face[2] + indexOffset;
        indices.push(a2, b2, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data2 = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data2);
  }
};
function toJSON$1(shapes, data2) {
  data2.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data2.shapes.push(shape.uuid);
    }
  } else {
    data2.shapes.push(shapes.uuid);
  }
  return data2;
}
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index4 = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index4++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a2, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var TetrahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
var TextGeometry = class extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (!(font && font.isFont)) {
      console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
      return new BufferGeometry();
    }
    const shapes = font.generateShapes(text, parameters.size);
    parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
    if (parameters.bevelThickness === void 0)
      parameters.bevelThickness = 10;
    if (parameters.bevelSize === void 0)
      parameters.bevelSize = 8;
    if (parameters.bevelEnabled === void 0)
      parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = "TextGeometry";
  }
};
var TorusGeometry = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    for (let j2 = 0; j2 <= radialSegments; j2++) {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        const u2 = i2 / tubularSegments * arc;
        const v2 = j2 / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
        vertex.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
        vertex.z = tube * Math.sin(v2);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u2);
        center.y = radius * Math.sin(u2);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= radialSegments; j2++) {
      for (let i2 = 1; i2 <= tubularSegments; i2++) {
        const a2 = (tubularSegments + 1) * j2 + i2 - 1;
        const b2 = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
        const c2 = (tubularSegments + 1) * (j2 - 1) + i2;
        const d2 = (tubularSegments + 1) * j2 + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
var TorusKnotGeometry = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p2 = 2, q2 = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q: q2
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B2 = new Vector3();
    const T2 = new Vector3();
    const N2 = new Vector3();
    for (let i2 = 0; i2 <= tubularSegments; ++i2) {
      const u2 = i2 / tubularSegments * p2 * Math.PI * 2;
      calculatePositionOnCurve(u2, p2, q2, radius, P1);
      calculatePositionOnCurve(u2 + 0.01, p2, q2, radius, P2);
      T2.subVectors(P2, P1);
      N2.addVectors(P2, P1);
      B2.crossVectors(T2, N2);
      N2.crossVectors(B2, T2);
      B2.normalize();
      N2.normalize();
      for (let j2 = 0; j2 <= radialSegments; ++j2) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v2);
        const cy = tube * Math.sin(v2);
        vertex.x = P1.x + (cx * N2.x + cy * B2.x);
        vertex.y = P1.y + (cx * N2.y + cy * B2.y);
        vertex.z = P1.z + (cx * N2.z + cy * B2.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= tubularSegments; j2++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
        const b2 = (radialSegments + 1) * j2 + (i2 - 1);
        const c2 = (radialSegments + 1) * j2 + i2;
        const d2 = (radialSegments + 1) * (j2 - 1) + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u2, p3, q3, radius2, position2) {
      const cu = Math.cos(u2);
      const su = Math.sin(u2);
      const quOverP = q3 / p3 * u2;
      const cs = Math.cos(quOverP);
      position2.x = radius2 * (2 + cs) * 0.5 * cu;
      position2.y = radius2 * (2 + cs) * su * 0.5;
      position2.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
};
var TubeGeometry = class extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P2 = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i2 = 0; i2 < tubularSegments; i2++) {
        generateSegment(i2);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P2 = path.getPointAt(i2 / tubularSegments, P2);
      const N2 = frames.normals[i2];
      const B2 = frames.binormals[i2];
      for (let j2 = 0; j2 <= radialSegments; j2++) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const sin = Math.sin(v2);
        const cos = -Math.cos(v2);
        normal.x = cos * N2.x + sin * B2.x;
        normal.y = cos * N2.y + sin * B2.y;
        normal.z = cos * N2.z + sin * B2.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P2.x + radius * normal.x;
        vertex.y = P2.y + radius * normal.y;
        vertex.z = P2.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (let j2 = 1; j2 <= tubularSegments; j2++) {
        for (let i2 = 1; i2 <= radialSegments; i2++) {
          const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
          const b2 = (radialSegments + 1) * j2 + (i2 - 1);
          const c2 = (radialSegments + 1) * j2 + i2;
          const d2 = (radialSegments + 1) * (j2 - 1) + i2;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
        }
      }
    }
    function generateUVs() {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        for (let j2 = 0; j2 <= radialSegments; j2++) {
          uv.x = i2 / tubularSegments;
          uv.y = j2 / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data2 = BufferGeometry.prototype.toJSON.call(this);
    data2.path = this.parameters.path.toJSON();
    return data2;
  }
};
var WireframeGeometry = class extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = "WireframeGeometry";
    if (geometry.isGeometry === true) {
      console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return;
    }
    const vertices = [];
    const edge = [0, 0], edges = {};
    const vertex = new Vector3();
    if (geometry.index !== null) {
      const position2 = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;
      if (groups.length === 0) {
        groups = [{start: 0, count: indices.count, materialIndex: 0}];
      }
      for (let o2 = 0, ol = groups.length; o2 < ol; ++o2) {
        const group = groups[o2];
        const start = group.start;
        const count = group.count;
        for (let i2 = start, l2 = start + count; i2 < l2; i2 += 3) {
          for (let j2 = 0; j2 < 3; j2++) {
            const edge1 = indices.getX(i2 + j2);
            const edge2 = indices.getX(i2 + (j2 + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = {index1: edge[0], index2: edge[1]};
            }
          }
        }
      }
      for (const key in edges) {
        const e2 = edges[key];
        vertex.fromBufferAttribute(position2, e2.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position2, e2.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      const position2 = geometry.attributes.position;
      for (let i2 = 0, l2 = position2.count / 3; i2 < l2; i2++) {
        for (let j2 = 0; j2 < 3; j2++) {
          const index1 = 3 * i2 + j2;
          vertex.fromBufferAttribute(position2, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index22 = 3 * i2 + (j2 + 1) % 3;
          vertex.fromBufferAttribute(position2, index22);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
};
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry
});
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
ShadowMaterial.prototype.isShadowMaterial = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {TOON: ""};
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {MATCAP: ""};
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = {MATCAP: ""};
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var Materials = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
});
var AnimationUtils = {
  arraySlice: function(array, from2, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from2, to !== void 0 ? to : array.length));
    }
    return array.slice(from2, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name2, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name2;
    const tracks = [];
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      const track = clip.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame = track.times[j2] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j2]);
        for (let k2 = 0; k2 < valueSize; ++k2) {
          values.push(track.values[j2 * valueSize + k2]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      if (minStartTime > clip.tracks[i2].times[0]) {
        minStartTime = clip.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      clip.tracks[i2].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k2 = 0; k2 < valueEnd; ++k2) {
            targetTrack.values[valueStart + k2] -= referenceValue[k2];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index4) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index4 * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
var KeyframeTrack = class {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from2 = 0, to = nKeys - 1;
    while (from2 !== nKeys && times[from2] < startTime) {
      ++from2;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from2 !== 0 || to !== nKeys) {
      if (from2 >= to) {
        to = Math.max(to, 1);
        from2 = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from2, to);
      this.values = AnimationUtils.arraySlice(this.values, from2 * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name2, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name2) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform2) {
    urlModifier = transform2;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index4 = handlers.indexOf(regex);
    if (index4 !== -1) {
      handlers.splice(index4, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
      const regex = handlers[i2];
      const loader = handlers[i2 + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
var DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
var loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data2 = dataUriRegexResult[3];
      data2 = decodeURIComponent(data2);
      if (isBase64)
        data2 = atob(data2);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data2.length);
            for (let i2 = 0; i2 < data2.length; i2++) {
              view[i2] = data2.charCodeAt(i2);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data2, mimeType);
            break;
          case "json":
            response = JSON.parse(data2);
            break;
          default:
            response = data2;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
var AnimationLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const animations = [];
    for (let i2 = 0; i2 < json.length; i2++) {
      const clip = AnimationClip.parse(json[i2]);
      animations.push(clip);
    }
    return animations;
  }
};
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(url[i2], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i2] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i2 = 0, il = url.length; i2 < il; ++i2) {
        loadTexture(i2);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f2 = 0; f2 < faces; f2++) {
            images[f2] = {mipmaps: []};
            for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
              images[f2].mipmaps.push(texDatas.mipmaps[f2 * texDatas.mipmapCount + i2]);
              images[f2].format = texDatas.format;
              images[f2].width = texDatas.width;
              images[f2].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
};
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache3 = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache3.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache3.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache3;
    return cache3;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  },
  getTangent: function(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
      tangents[i2].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data2 = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data2.arcLengthDivisions = this.arcLengthDivisions;
    data2.type = this.type;
    return data2;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x2 = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x2 - this.aX;
      const ty = y2 - this.aY;
      x2 = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x2, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.aX = this.aX;
    data2.aY = this.aY;
    data2.xRadius = this.xRadius;
    data2.yRadius = this.yRadius;
    data2.aStartAngle = this.aStartAngle;
    data2.aEndAngle = this.aEndAngle;
    data2.aClockwise = this.aClockwise;
    data2.aRotation = this.aRotation;
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data2.points.push(point.toArray());
    }
    data2.closed = this.closed;
    data2.curveType = this.curveType;
    data2.tension = this.tension;
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  const k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v0 = this.v0.toArray();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    data2.v3 = this.v3.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v0 = this.v0.toArray();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    data2.v3 = this.v3.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v0 = this.v0.toArray();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.v0 = this.v0.toArray();
    data2.v1 = this.v1.toArray();
    data2.v2 = this.v2.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p2 = (points.length - 1) * t2;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data2.points.push(point.toArray());
    }
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t2) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2);
      }
      i2++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point = pts[j2];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.autoClose = this.autoClose;
    data2.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data2.curves.push(curve.toJSON());
    }
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x2, y2) {
    this.currentPoint.set(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
    this.curves.push(curve);
    this.currentPoint.set(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.currentPoint = this.currentPoint.toArray();
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.uuid = this.uuid;
    data2.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data2.holes.push(hole.toJSON());
    }
    return data2;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.color = this.color.getHex();
    data2.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data2.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data2.object.distance = this.distance;
    if (this.angle !== void 0)
      data2.object.angle = this.angle;
    if (this.decay !== void 0)
      data2.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data2.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data2.object.shadow = this.shadow.toJSON();
    return data2;
  }
};
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld);
    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
};
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.copy(camera.position);
    _lookTarget$1.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget$1);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z);
    _projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
  }
};
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
PointLight.prototype.isPointLight = true;
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data2 = Object3D.prototype.toJSON.call(this, meta);
    data2.object.zoom = this.zoom;
    data2.object.left = this.left;
    data2.object.right = this.right;
    data2.object.top = this.top;
    data2.object.bottom = this.bottom;
    data2.object.near = this.near;
    data2.object.far = this.far;
    if (this.view !== null)
      data2.object.view = Object.assign({}, this.view);
    return data2;
  }
};
OrthographicCamera.prototype.isOrthographicCamera = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.width = this.width;
    data2.object.height = this.height;
    return data2;
  }
};
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x2);
    target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array, offset + i2 * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array, offset + i2 * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
  }
};
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.sh = this.sh.toArray();
    return data2;
  }
};
LightProbe.prototype.isLightProbe = true;
var MaterialLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name2) {
      if (textures[name2] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name2);
      }
      return textures[name2];
    }
    const material = new Materials[json.type]();
    if (json.uuid !== void 0)
      material.uuid = json.uuid;
    if (json.name !== void 0)
      material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0)
      material.color.setHex(json.color);
    if (json.roughness !== void 0)
      material.roughness = json.roughness;
    if (json.metalness !== void 0)
      material.metalness = json.metalness;
    if (json.sheen !== void 0)
      material.sheen = new Color().setHex(json.sheen);
    if (json.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json.specular);
    if (json.shininess !== void 0)
      material.shininess = json.shininess;
    if (json.clearcoat !== void 0)
      material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.fog !== void 0)
      material.fog = json.fog;
    if (json.flatShading !== void 0)
      material.flatShading = json.flatShading;
    if (json.blending !== void 0)
      material.blending = json.blending;
    if (json.combine !== void 0)
      material.combine = json.combine;
    if (json.side !== void 0)
      material.side = json.side;
    if (json.opacity !== void 0)
      material.opacity = json.opacity;
    if (json.transparent !== void 0)
      material.transparent = json.transparent;
    if (json.alphaTest !== void 0)
      material.alphaTest = json.alphaTest;
    if (json.depthTest !== void 0)
      material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0)
      material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0)
      material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== void 0)
      material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== void 0)
      material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0)
      material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0)
      material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0)
      material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0)
      material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0)
      material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0)
      material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== void 0)
      material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0)
      material.rotation = json.rotation;
    if (json.linewidth !== 1)
      material.linewidth = json.linewidth;
    if (json.dashSize !== void 0)
      material.dashSize = json.dashSize;
    if (json.gapSize !== void 0)
      material.gapSize = json.gapSize;
    if (json.scale !== void 0)
      material.scale = json.scale;
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== void 0)
      material.skinning = json.skinning;
    if (json.morphTargets !== void 0)
      material.morphTargets = json.morphTargets;
    if (json.morphNormals !== void 0)
      material.morphNormals = json.morphNormals;
    if (json.dithering !== void 0)
      material.dithering = json.dithering;
    if (json.vertexTangents !== void 0)
      material.vertexTangents = json.vertexTangents;
    if (json.visible !== void 0)
      material.visible = json.visible;
    if (json.toneMapped !== void 0)
      material.toneMapped = json.toneMapped;
    if (json.userData !== void 0)
      material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name2 in json.uniforms) {
        const uniform = json.uniforms[name2];
        material.uniforms[name2] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name2].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name2].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name2].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name2].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name2].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name2].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name2].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name2].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0)
      material.defines = json.defines;
    if (json.vertexShader !== void 0)
      material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.shading !== void 0)
      material.flatShading = json.shading === 1;
    if (json.size !== void 0)
      material.size = json.size;
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0)
      material.map = getTexture(json.map);
    if (json.matcap !== void 0)
      material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0)
      material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0)
      material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0)
      material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== void 0)
      material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0)
      material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0)
      material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0)
      material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0)
      material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmission !== void 0)
      material.transmission = json.transmission;
    if (json.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json.transmissionMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i2 = 0, il = array.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  },
  extractUrlBase: function(url) {
    const index4 = url.lastIndexOf("/");
    if (index4 === -1)
      return "./";
    return url.substr(0, index4 + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data2 = BufferGeometry.prototype.toJSON.call(this);
    data2.instanceCount = this.instanceCount;
    data2.isInstancedBufferGeometry = true;
    return data2;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data2 = BufferAttribute.prototype.toJSON.call(this);
    data2.meshPerAttribute = this.meshPerAttribute;
    data2.isInstancedBufferAttribute = true;
    return data2;
  }
});
var BufferGeometryLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0)
        return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0)
        return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index4 = json.data.index;
    if (index4 !== void 0) {
      const typedArray = getTypedArray(index4.type, index4.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0)
        bufferAttribute.name = attribute.name;
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
          const attribute = attributeArray[i2];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i2 = 0, n2 = groups.length; i2 !== n2; ++i2) {
        const group = groups[i2];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name)
      geometry.name = json.name;
    if (json.userData)
      geometry.userData = json.userData;
    return geometry;
  }
};
var ObjectLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0)
          onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0)
        onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false)
        onLoad(object);
    }
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const shape = new Shape().fromJSON(json[i2]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone)
        bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const skeleton = new Skeleton().fromJSON(json[i2], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    let geometryShapes;
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        let geometry;
        const data2 = json[i2];
        switch (data2.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            geometry = new Geometries[data2.type](data2.width, data2.height, data2.widthSegments, data2.heightSegments);
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
            geometry = new Geometries[data2.type](data2.width, data2.height, data2.depth, data2.widthSegments, data2.heightSegments, data2.depthSegments);
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.segments, data2.thetaStart, data2.thetaLength);
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            geometry = new Geometries[data2.type](data2.radiusTop, data2.radiusBottom, data2.height, data2.radialSegments, data2.heightSegments, data2.openEnded, data2.thetaStart, data2.thetaLength);
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.height, data2.radialSegments, data2.heightSegments, data2.openEnded, data2.thetaStart, data2.thetaLength);
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.widthSegments, data2.heightSegments, data2.phiStart, data2.phiLength, data2.thetaStart, data2.thetaLength);
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            geometry = new Geometries[data2.type](data2.innerRadius, data2.outerRadius, data2.thetaSegments, data2.phiSegments, data2.thetaStart, data2.thetaLength);
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.tube, data2.radialSegments, data2.tubularSegments, data2.arc);
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            geometry = new Geometries[data2.type](data2.radius, data2.tube, data2.tubularSegments, data2.radialSegments, data2.p, data2.q);
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            geometry = new Geometries[data2.type](new Curves[data2.path.type]().fromJSON(data2.path), data2.tubularSegments, data2.radius, data2.radialSegments, data2.closed);
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            geometry = new Geometries[data2.type](data2.points, data2.segments, data2.phiStart, data2.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            geometry = new Geometries[data2.type](data2.vertices, data2.indices, data2.radius, data2.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            geometryShapes = [];
            for (let j2 = 0, jl = data2.shapes.length; j2 < jl; j2++) {
              const shape = shapes[data2.shapes[j2]];
              geometryShapes.push(shape);
            }
            geometry = new Geometries[data2.type](geometryShapes, data2.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            geometryShapes = [];
            for (let j2 = 0, jl = data2.shapes.length; j2 < jl; j2++) {
              const shape = shapes[data2.shapes[j2]];
              geometryShapes.push(shape);
            }
            const extrudePath = data2.options.extrudePath;
            if (extrudePath !== void 0) {
              data2.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            geometry = new Geometries[data2.type](geometryShapes, data2.options);
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data2);
            break;
          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data2.type + '"');
            continue;
        }
        geometry.uuid = data2.uuid;
        if (data2.name !== void 0)
          geometry.name = data2.name;
        if (geometry.isBufferGeometry === true && data2.userData !== void 0)
          geometry.userData = data2.userData;
        geometries[data2.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache3 = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const data2 = json[i2];
        if (data2.type === "MultiMaterial") {
          const array = [];
          for (let j2 = 0; j2 < data2.materials.length; j2++) {
            const material = data2.materials[j2];
            if (cache3[material.uuid] === void 0) {
              cache3[material.uuid] = loader.parse(material);
            }
            array.push(cache3[material.uuid]);
          }
          materials[data2.uuid] = array;
        } else {
          if (cache3[data2.uuid] === void 0) {
            cache3[data2.uuid] = loader.parse(data2);
          }
          materials[data2.uuid] = cache3[data2.uuid];
        }
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i2 = 0; i2 < json.length; i2++) {
        const data2 = json[i2];
        const clip = AnimationClip.parse(data2);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i2 = 0, il = json.length; i2 < il; i2++) {
        const image = json[i2];
        const url = image.url;
        if (Array.isArray(url)) {
          images[image.uuid] = [];
          for (let j2 = 0, jl = url.length; j2 < jl; j2++) {
            const currentUrl = url[j2];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          const deserializedImage = deserializeImage(image.url);
          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number")
        return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const data2 = json[i2];
        if (data2.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data2.uuid);
        }
        if (images[data2.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data2.image);
        }
        let texture;
        const image = images[data2.image];
        if (Array.isArray(image)) {
          texture = new CubeTexture(image);
          if (image.length === 6)
            texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture(image.data, image.width, image.height);
          } else {
            texture = new Texture(image);
          }
          if (image)
            texture.needsUpdate = true;
        }
        texture.uuid = data2.uuid;
        if (data2.name !== void 0)
          texture.name = data2.name;
        if (data2.mapping !== void 0)
          texture.mapping = parseConstant(data2.mapping, TEXTURE_MAPPING);
        if (data2.offset !== void 0)
          texture.offset.fromArray(data2.offset);
        if (data2.repeat !== void 0)
          texture.repeat.fromArray(data2.repeat);
        if (data2.center !== void 0)
          texture.center.fromArray(data2.center);
        if (data2.rotation !== void 0)
          texture.rotation = data2.rotation;
        if (data2.wrap !== void 0) {
          texture.wrapS = parseConstant(data2.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data2.wrap[1], TEXTURE_WRAPPING);
        }
        if (data2.format !== void 0)
          texture.format = data2.format;
        if (data2.type !== void 0)
          texture.type = data2.type;
        if (data2.encoding !== void 0)
          texture.encoding = data2.encoding;
        if (data2.minFilter !== void 0)
          texture.minFilter = parseConstant(data2.minFilter, TEXTURE_FILTER);
        if (data2.magFilter !== void 0)
          texture.magFilter = parseConstant(data2.magFilter, TEXTURE_FILTER);
        if (data2.anisotropy !== void 0)
          texture.anisotropy = data2.anisotropy;
        if (data2.flipY !== void 0)
          texture.flipY = data2.flipY;
        if (data2.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data2.premultiplyAlpha;
        if (data2.unpackAlignment !== void 0)
          texture.unpackAlignment = data2.unpackAlignment;
        textures[data2.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data2, geometries, materials, animations) {
    let object;
    function getGeometry(name2) {
      if (geometries[name2] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name2);
      }
      return geometries[name2];
    }
    function getMaterial(name2) {
      if (name2 === void 0)
        return void 0;
      if (Array.isArray(name2)) {
        const array = [];
        for (let i2 = 0, l2 = name2.length; i2 < l2; i2++) {
          const uuid = name2[i2];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name2] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name2);
      }
      return materials[name2];
    }
    let geometry, material;
    switch (data2.type) {
      case "Scene":
        object = new Scene();
        if (data2.background !== void 0) {
          if (Number.isInteger(data2.background)) {
            object.background = new Color(data2.background);
          }
        }
        if (data2.fog !== void 0) {
          if (data2.fog.type === "Fog") {
            object.fog = new Fog(data2.fog.color, data2.fog.near, data2.fog.far);
          } else if (data2.fog.type === "FogExp2") {
            object.fog = new FogExp2(data2.fog.color, data2.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data2.fov, data2.aspect, data2.near, data2.far);
        if (data2.focus !== void 0)
          object.focus = data2.focus;
        if (data2.zoom !== void 0)
          object.zoom = data2.zoom;
        if (data2.filmGauge !== void 0)
          object.filmGauge = data2.filmGauge;
        if (data2.filmOffset !== void 0)
          object.filmOffset = data2.filmOffset;
        if (data2.view !== void 0)
          object.view = Object.assign({}, data2.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data2.left, data2.right, data2.top, data2.bottom, data2.near, data2.far);
        if (data2.zoom !== void 0)
          object.zoom = data2.zoom;
        if (data2.view !== void 0)
          object.view = Object.assign({}, data2.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data2.color, data2.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data2.color, data2.intensity);
        break;
      case "PointLight":
        object = new PointLight(data2.color, data2.intensity, data2.distance, data2.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data2.color, data2.intensity, data2.width, data2.height);
        break;
      case "SpotLight":
        object = new SpotLight(data2.color, data2.intensity, data2.distance, data2.angle, data2.penumbra, data2.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data2.color, data2.groundColor, data2.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data2);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data2.geometry);
        material = getMaterial(data2.material);
        object = new SkinnedMesh(geometry, material);
        if (data2.bindMode !== void 0)
          object.bindMode = data2.bindMode;
        if (data2.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data2.bindMatrix);
        if (data2.skeleton !== void 0)
          object.skeleton = data2.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data2.geometry);
        material = getMaterial(data2.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data2.geometry);
        material = getMaterial(data2.material);
        const count = data2.count;
        const instanceMatrix = data2.instanceMatrix;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data2.geometry), getMaterial(data2.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data2.geometry), getMaterial(data2.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data2.geometry), getMaterial(data2.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data2.geometry), getMaterial(data2.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data2.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data2.uuid;
    if (data2.name !== void 0)
      object.name = data2.name;
    if (data2.matrix !== void 0) {
      object.matrix.fromArray(data2.matrix);
      if (data2.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data2.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data2.position !== void 0)
        object.position.fromArray(data2.position);
      if (data2.rotation !== void 0)
        object.rotation.fromArray(data2.rotation);
      if (data2.quaternion !== void 0)
        object.quaternion.fromArray(data2.quaternion);
      if (data2.scale !== void 0)
        object.scale.fromArray(data2.scale);
    }
    if (data2.castShadow !== void 0)
      object.castShadow = data2.castShadow;
    if (data2.receiveShadow !== void 0)
      object.receiveShadow = data2.receiveShadow;
    if (data2.shadow) {
      if (data2.shadow.bias !== void 0)
        object.shadow.bias = data2.shadow.bias;
      if (data2.shadow.normalBias !== void 0)
        object.shadow.normalBias = data2.shadow.normalBias;
      if (data2.shadow.radius !== void 0)
        object.shadow.radius = data2.shadow.radius;
      if (data2.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data2.shadow.mapSize);
      if (data2.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data2.shadow.camera);
    }
    if (data2.visible !== void 0)
      object.visible = data2.visible;
    if (data2.frustumCulled !== void 0)
      object.frustumCulled = data2.frustumCulled;
    if (data2.renderOrder !== void 0)
      object.renderOrder = data2.renderOrder;
    if (data2.userData !== void 0)
      object.userData = data2.userData;
    if (data2.layers !== void 0)
      object.layers.mask = data2.layers;
    if (data2.children !== void 0) {
      const children = data2.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        object.add(this.parseObject(children[i2], geometries, materials, animations));
      }
    }
    if (data2.animations !== void 0) {
      const objectAnimations = data2.animations;
      for (let i2 = 0; i2 < objectAnimations.length; i2++) {
        const uuid = objectAnimations[i2];
        object.animations.push(animations[uuid]);
      }
    }
    if (data2.type === "LOD") {
      if (data2.autoUpdate !== void 0)
        object.autoUpdate = data2.autoUpdate;
      const levels = data2.levels;
      for (let l2 = 0; l2 < levels.length; l2++) {
        const level = levels[l2];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0)
      return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
  setTexturePath(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
};
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options2) {
    this.options = options2;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError)
        onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x2, y2) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    this.currentPath.lineTo(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
        const tmpPath2 = inSubpaths[i2];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p2 = polyLen - 1, q2 = 0; q2 < polyLen; p2 = q2++) {
        let edgeLowPt = inPolygon[p2];
        let edgeHighPt = inPolygon[q2];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q2];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p2];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
      tmpPath = subPaths[i2];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
      tmpShape = newShapes[i2].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i2];
      for (let j2 = 0, jl = tmpHoles.length; j2 < jl; j2++) {
        tmpShape.holes.push(tmpHoles[j2].h);
      }
    }
    return shapes;
  }
};
var Font = class {
  constructor(data2) {
    this.type = "Font";
    this.data = data2;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p2 = 0, pl = paths.length; p2 < pl; p2++) {
      Array.prototype.push.apply(shapes, paths[p2].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data2) {
  const chars = Array.from(text);
  const scale = size / data2.resolution;
  const line_height = (data2.boundingBox.yMax - data2.boundingBox.yMin + data2.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars.length; i2++) {
    const char2 = chars[i2];
    if (char2 === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char2, scale, offsetX, offsetY, data2);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char2, scale, offsetX, offsetY, data2) {
  const glyph = data2.glyphs[char2] || data2.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char2 + '" does not exists in font family ' + data2.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x2, y2, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l2 = outline.length; i2 < l2; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x2 = outline[i2++] * scale + offsetX;
          y2 = outline[i2++] * scale + offsetY;
          path.moveTo(x2, y2);
          break;
        case "l":
          x2 = outline[i2++] * scale + offsetX;
          y2 = outline[i2++] * scale + offsetY;
          path.lineTo(x2, y2);
          break;
        case "q":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i2++] * scale + offsetX;
          cpy = outline[i2++] * scale + offsetY;
          cpx1 = outline[i2++] * scale + offsetX;
          cpy1 = outline[i2++] * scale + offsetY;
          cpx2 = outline[i2++] * scale + offsetX;
          cpy2 = outline[i2++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {offsetX: glyph.ha * scale, path};
}
Font.prototype.isFont = true;
var FontLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      let json;
      try {
        json = JSON.parse(text);
      } catch (e2) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json = JSON.parse(text.substring(65, text.length - 2));
      }
      const font = scope.parse(json);
      if (onLoad)
        onLoad(font);
    }, onProgress, onError);
  }
  parse(json) {
    return new Font(json);
  }
};
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var StereoCamera = class {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache3 = this._cache;
    const needsUpdate = cache3.focus !== camera.focus || cache3.fov !== camera.fov || cache3.aspect !== camera.aspect * this.aspect || cache3.near !== camera.near || cache3.far !== camera.far || cache3.zoom !== camera.zoom || cache3.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache3.focus = camera.focus;
      cache3.fov = camera.fov;
      cache3.aspect = camera.aspect * this.aspect;
      cache3.near = camera.near;
      cache3.far = camera.far;
      cache3.zoom = camera.zoom;
      cache3.eyeSep = this.eyeSep;
      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache3.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache3.near / cache3.focus;
      const ymax = cache3.near * Math.tan(MathUtils.DEG2RAD * cache3.fov * 0.5) / cache3.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache3.aspect + eyeSepOnProjection;
      xmax = ymax * cache3.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache3.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix);
      xmin = -ymax * cache3.aspect - eyeSepOnProjection;
      xmax = ymax * cache3.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache3.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
};
var Clock = class {
  constructor(autoStart) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
var _position$2 = /* @__PURE__ */ new Vector3();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var _scale$1 = /* @__PURE__ */ new Vector3();
var _orientation = /* @__PURE__ */ new Vector3();
var AudioListener = class extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
};
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var _position$3 = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _orientation$1 = /* @__PURE__ */ new Vector3();
var PositionalAudio = class extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false)
      return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data2 = this.getFrequencyData();
    for (let i2 = 0; i2 < data2.length; i2++) {
      value += data2[i2];
    }
    return value / data2.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[offset + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  },
  setValue: function(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
        buffer[offset++] = source[i2];
      }
    },
    function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      indices[arguments[i2].uuid] = i2;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object = arguments[i2], uuid = object.uuid;
      let index4 = indicesByUUID[uuid];
      if (index4 === void 0) {
        index4 = nObjects++;
        indicesByUUID[uuid] = index4;
        objects.push(object);
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          bindings[j2].push(new PropertyBinding(object, paths[j2], parsedPaths[j2]));
        }
      } else if (index4 < nCachedObjects) {
        knownObject = objects[index4];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index4;
        objects[index4] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index4];
          bindingsForPath[index4] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j2], parsedPaths[j2]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index4] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object = arguments[i2], uuid = object.uuid, index4 = indicesByUUID[uuid];
      if (index4 !== void 0 && index4 >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index4;
        objects[index4] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
          const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index4];
          bindingsForPath[index4] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
      const object = arguments[i2], uuid = object.uuid, index4 = indicesByUUID[uuid];
      if (index4 !== void 0) {
        delete indicesByUUID[uuid];
        if (index4 < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index4;
          objects[index4] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index4] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index4;
          }
          objects[index4] = lastObject;
          objects.pop();
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2];
            bindingsForPath[index4] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index4 = indicesByPath[path];
    const bindings = this._bindings;
    if (index4 !== void 0)
      return bindings[index4];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index4 = bindings.length;
    indicesByPath[path] = index4;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
      const object = objects[i2];
      bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index4 = indicesByPath[path];
    if (index4 !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index4;
      bindings[index4] = lastBindings;
      bindings.pop();
      parsedPaths[index4] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index4] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    times[1] = now3 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now3 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    values[0] = weightNow;
    times[1] = now3 + duration;
    values[1] = weightThen;
    return this;
  }
};
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index4 = action._cacheIndex;
    return index4 !== null && index4 < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions[i2].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data2) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data2);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data2) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data2);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      intersectObject(children[i2], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive = false, intersects2 = []) {
    for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
      intersectObject(objects[i2], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x2, y2, z2) {
    this.radius = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x2, z2);
      this.phi = Math.acos(MathUtils.clamp(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Cylindrical = class {
  constructor(radius = 1, theta = 0, y2 = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  set(radius, theta, y2) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x2, y2, z2) {
    this.radius = Math.sqrt(x2 * x2 + z2 * z2);
    this.theta = Math.atan2(x2, z2);
    this.y = y2;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$8 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target = new Vector2();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line2) {
    this.start.copy(line2.start);
    this.end.copy(line2.end);
    return this;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t2, target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t2 = startEnd_startP / startEnd2;
    if (clampToLine) {
      t2 = MathUtils.clamp(t2, 0, 1);
    }
    return t2;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t2 = this.closestPointToPointParameter(point, clampToLine);
    if (target === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line2) {
    return line2.start.equals(this.start) && line2.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$9 = /* @__PURE__ */ new Vector3();
var SpotLightHelper = class extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i2 = 0, j2 = 1, l2 = 32; i2 < l2; i2++, j2++) {
      const p1 = i2 / l2 * Math.PI * 2;
      const p2 = j2 / l2 * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({fog: false, toneMapped: false});
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$9);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix4();
var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors2 = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors2.push(color1.r, color1.g, color1.b);
        colors2.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position2 = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j2, _vector$a.x, _vector$a.y, _vector$a.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position2.setXYZ(j2 + 1, _vector$a.x, _vector$a.y, _vector$a.z);
        j2 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
var PointLightHelper = class extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
};
var _vector$b = /* @__PURE__ */ new Vector3();
var _color1 = /* @__PURE__ */ new Color();
var _color2 = /* @__PURE__ */ new Color();
var HemisphereLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});
    if (this.color === void 0)
      this.material.vertexColors = true;
    const position2 = geometry.getAttribute("position");
    const colors2 = new Float32Array(position2.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors2, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors2 = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i2 = 0, l2 = colors2.count; i2 < l2; i2++) {
        const color = i2 < l2 / 2 ? _color1 : _color2;
        colors2.setXYZ(i2, color.r, color.g, color.b);
      }
      colors2.needsUpdate = true;
    }
    mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
};
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors2 = [];
    for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
      vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
      vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
      const color = i2 === center ? color1 : color2;
      color.toArray(colors2, j2);
      j2 += 3;
      color.toArray(colors2, j2);
      j2 += 3;
      color.toArray(colors2, j2);
      j2 += 3;
      color.toArray(colors2, j2);
      j2 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "GridHelper";
  }
};
var PolarGridHelper = class extends LineSegments {
  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors2 = [];
    for (let i2 = 0; i2 <= radials; i2++) {
      const v2 = i2 / radials * (Math.PI * 2);
      const x2 = Math.sin(v2) * radius;
      const z2 = Math.cos(v2) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x2, 0, z2);
      const color = i2 & 1 ? color1 : color2;
      colors2.push(color.r, color.g, color.b);
      colors2.push(color.r, color.g, color.b);
    }
    for (let i2 = 0; i2 <= circles; i2++) {
      const color = i2 & 1 ? color1 : color2;
      const r2 = radius - radius / circles * i2;
      for (let j2 = 0; j2 < divisions; j2++) {
        let v2 = j2 / divisions * (Math.PI * 2);
        let x2 = Math.sin(v2) * r2;
        let z2 = Math.cos(v2) * r2;
        vertices.push(x2, 0, z2);
        colors2.push(color.r, color.g, color.b);
        v2 = (j2 + 1) / divisions * (Math.PI * 2);
        x2 = Math.sin(v2) * r2;
        z2 = Math.cos(v2) * r2;
        vertices.push(x2, 0, z2);
        colors2.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
};
var _v1$6 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var _v3$1 = /* @__PURE__ */ new Vector3();
var DirectionalLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === void 0)
      size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({fog: false, toneMapped: false});
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    _v1$6.setFromMatrixPosition(this.light.matrixWorld);
    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$1.subVectors(_v2$3, _v1$6);
    this.lightPlane.lookAt(_v2$3);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
  }
};
var _vector$c = /* @__PURE__ */ new Vector3();
var _camera = /* @__PURE__ */ new Camera();
var CameraHelper = class extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({color: 16777215, vertexColors: true, toneMapped: false});
    const vertices = [];
    const colors2 = [];
    const pointMap = {};
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a2, b2, color) {
      addPoint(a2, color);
      addPoint(b2, color);
    }
    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors2.push(color.r, color.g, color.b);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w3 = 1, h2 = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w3, -h2, -1);
    setPoint("n2", pointMap, geometry, _camera, w3, -h2, -1);
    setPoint("n3", pointMap, geometry, _camera, -w3, h2, -1);
    setPoint("n4", pointMap, geometry, _camera, w3, h2, -1);
    setPoint("f1", pointMap, geometry, _camera, -w3, -h2, 1);
    setPoint("f2", pointMap, geometry, _camera, w3, -h2, 1);
    setPoint("f3", pointMap, geometry, _camera, -w3, h2, 1);
    setPoint("f4", pointMap, geometry, _camera, w3, h2, 1);
    setPoint("u1", pointMap, geometry, _camera, w3 * 0.7, h2 * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w3 * 0.7, h2 * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w3, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w3, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w3, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w3, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
};
function setPoint(point, pointMap, geometry, camera, x2, y2, z2) {
  _vector$c.set(x2, y2, z2).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position2 = geometry.getAttribute("position");
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      position2.setXYZ(points[i2], _vector$c.x, _vector$c.y, _vector$c.z);
    }
  }
}
var _box$3 = /* @__PURE__ */ new Box3();
var BoxHelper = class extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box$3.setFromObject(this.object);
    }
    if (_box$3.isEmpty())
      return;
    const min = _box$3.min;
    const max = _box$3.max;
    const position2 = this.geometry.attributes.position;
    const array = position2.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position2.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }
};
var Box3Helper = class extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty())
      return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
};
var PlaneHelper = class extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color = hex;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({color, toneMapped: false}));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false})));
  }
  updateMatrixWorld(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8)
      scale = 1e-8;
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }
};
var _axis = /* @__PURE__ */ new Vector3();
var _lineGeometry;
var _coneGeometry;
var ArrowHelper = class extends Object3D {
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length2 = 1, color = 16776960, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({color, toneMapped: false}));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({color, toneMapped: false}));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length2, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length2, headLength = length2 * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length2 - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length2;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
};
var AxesHelper = class extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors2 = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "AxesHelper";
  }
};
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
var DataUtils = {
  toHalfFloat: function(val) {
    _floatView[0] = val;
    const x2 = _int32View[0];
    let bits = x2 >> 16 & 32768;
    let m2 = x2 >> 12 & 2047;
    const e2 = x2 >> 23 & 255;
    if (e2 < 103)
      return bits;
    if (e2 > 142) {
      bits |= 31744;
      bits |= (e2 == 255 ? 0 : 1) && x2 & 8388607;
      return bits;
    }
    if (e2 < 113) {
      m2 |= 2048;
      bits |= (m2 >> 114 - e2) + (m2 >> 113 - e2 & 1);
      return bits;
    }
    bits |= e2 - 112 << 10 | m2 >> 1;
    bits += m2 & 1;
    return bits;
  }
};
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var MAX_SAMPLES = 20;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var {_lodPlanes, _sizeLods, _sigmas} = /* @__PURE__ */ _createPlanes();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
function convertLinearToRGBE(color) {
  const maxComponent = Math.max(color.r, color.g, color.b);
  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
  color.multiplyScalar(Math.pow(2, -fExp));
  const alpha = (fExp + 128) / 255;
  return alpha;
}
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null)
      this._cubemapShader.dispose();
    if (this._equirectShader !== null)
      this._equirectShader.dispose();
    for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
      _lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background).convertSRGBToLinear();
        scene.background = null;
        const alpha = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = alpha;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const alpha = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = alpha;
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    if (!texture.isCubeTexture) {
      uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
    }
    uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
    uniforms["outputEncoding"].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
      const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 == 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = LOD_MAX - lodIn;
    blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _isLDR(texture) {
  if (texture === void 0 || texture.type !== UnsignedByteType)
    return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes2 = [];
  const _sizeLods2 = [];
  const _sigmas2 = [];
  let lod = LOD_MAX;
  for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods2.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
    } else if (i2 == 0) {
      sigma = 0;
    }
    _sigmas2.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position2 = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position2.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position2, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes2.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return {_lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2};
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {n: maxSamples},
    uniforms: {
      envMap: {value: null},
      samples: {value: 1},
      weights: {value: weights},
      latitudinal: {value: false},
      dTheta: {value: 0},
      mipInt: {value: 0},
      poleAxis: {value: poleAxis},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {value: null},
      texelSize: {value: texelSize},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {value: null},
      inputEncoding: {value: ENCODINGS[LinearEncoding]},
      outputEncoding: {value: ENCODINGS[LinearEncoding]}
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function _getEncodings() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
var LineStrip = 0;
var LinePieces = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
function MeshFaceMaterial(materials) {
  console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
  return materials;
}
function MultiMaterial(materials = []) {
  console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
  materials.isMultiMaterial = true;
  materials.materials = materials;
  materials.clone = function() {
    return materials.slice();
  };
  return materials;
}
function PointCloud(geometry, material) {
  console.warn("THREE.PointCloud has been renamed to THREE.Points.");
  return new Points(geometry, material);
}
function Particle(material) {
  console.warn("THREE.Particle has been renamed to THREE.Sprite.");
  return new Sprite(material);
}
function ParticleSystem(geometry, material) {
  console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
  return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
  console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
  console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
  console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
  return new PointsMaterial(parameters);
}
function Vertex(x2, y2, z2) {
  console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
  return new Vector3(x2, y2, z2);
}
function DynamicBufferAttribute(array, itemSize) {
  console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
  console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
  return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
  console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
  return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
  console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
  return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
  console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
  return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
  console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
  return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
  console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
  return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
  console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
  return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
  console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
  return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
  console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
  return new Float64BufferAttribute(array, itemSize);
}
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
function AxisHelper(size) {
  console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
  return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
  console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
  return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
  console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));
}
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(object, hex) {
  console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));
}
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
function XHRLoader(manager) {
  console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
  return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
  console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
  return new DataTextureLoader(manager);
}
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line2) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line2);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b2, c2, target);
};
Triangle.normal = function(a2, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b2, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options2) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options2);
};
Shape.prototype.makeGeometry = function(options2) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options2);
};
Vector2.prototype.fromAttribute = function(attribute, index4, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index4, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index4);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index4, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index4, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index4, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name2) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name2);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index4) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index4);
};
BufferGeometry.prototype.addAttribute = function(name2, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name2, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name2 === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name2, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name2) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name2);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
function WebGLRenderTargetCube(width, height, options2) {
  console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
  return new WebGLCubeRenderTarget(width, options2);
}
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(Audio.prototype, {
  load: {
    value: function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
var SceneUtils = {
  createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  },
  attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }
};
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/react-three-fiber/web.js
var import_react_reconciler = __toModule(require_react_reconciler());
var import_scheduler = __toModule(require_scheduler2());
var import_react2 = __toModule(require("react"));
var import_tiny_emitter = __toModule(require_tiny_emitter());

// node_modules/use-asset/dist/index.js
var import_fast_deep_equal = __toModule(require_fast_deep_equal());
var globalCache = [];
function handleAsset(fn, cache3, args, lifespan = 0, preload = false) {
  for (const entry2 of cache3) {
    if ((0, import_fast_deep_equal.default)(args, entry2.args)) {
      if (preload)
        return;
      if (entry2.error)
        throw entry2.error;
      if (entry2.response)
        return entry2.response;
      throw entry2.promise;
    }
  }
  const entry = {
    args,
    promise: fn(...args).then((response) => entry.response = response != null ? response : true).catch((e2) => entry.error = e2 != null ? e2 : "unknown error").then(() => {
      if (lifespan > 0) {
        setTimeout(() => {
          const index4 = cache3.indexOf(entry);
          if (index4 !== -1)
            cache3.splice(index4, 1);
        }, lifespan);
      }
    })
  };
  cache3.push(entry);
  if (!preload)
    throw entry.promise;
}
function clear(cache3, ...args) {
  if (args === void 0 || args.length === 0)
    cache3.splice(0, cache3.length);
  else {
    const entry = cache3.find((entry2) => (0, import_fast_deep_equal.default)(args, entry2.args));
    if (entry) {
      const index4 = cache3.indexOf(entry);
      if (index4 !== -1)
        cache3.splice(index4, 1);
    }
  }
}
function useAsset(fn, ...args) {
  return handleAsset(fn, globalCache, args, useAsset.lifespan);
}
useAsset.lifespan = 0;
useAsset.clear = (...args) => clear(globalCache, ...args);
useAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);
useAsset.peek = (...args) => {
  var _globalCache$find;
  return (_globalCache$find = globalCache.find((entry) => (0, import_fast_deep_equal.default)(args, entry.args))) == null ? void 0 : _globalCache$find.response;
};

// node_modules/react-use-measure/dist/web.js
var import_react = __toModule(require("react"));
var import_debounce = __toModule(require_debounce());
function useMeasure({
  debounce: debounce$1,
  scroll,
  polyfill
} = {
  debounce: 0,
  scroll: false
}) {
  const ResizeObserver = polyfill || (typeof window === "undefined" ? class ResizeObserver {
  } : window.ResizeObserver);
  if (!ResizeObserver) {
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  }
  const [bounds, set] = (0, import_react.useState)({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  });
  const state = (0, import_react.useRef)({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: bounds
  });
  const scrollDebounce = debounce$1 ? typeof debounce$1 === "number" ? debounce$1 : debounce$1.scroll : null;
  const resizeDebounce = debounce$1 ? typeof debounce$1 === "number" ? debounce$1 : debounce$1.resize : null;
  const mounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    mounted.current = true;
    return () => void (mounted.current = false);
  });
  const [forceRefresh, resizeChange, scrollChange] = (0, import_react.useMemo)(() => {
    const callback = () => {
      if (!state.current.element)
        return;
      const {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x: x2,
        y: y2
      } = state.current.element.getBoundingClientRect();
      const size = {
        left,
        top,
        width,
        height,
        bottom,
        right,
        x: x2,
        y: y2
      };
      Object.freeze(size);
      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size))
        set(state.current.lastBounds = size);
    };
    return [callback, resizeDebounce ? (0, import_debounce.debounce)(callback, resizeDebounce) : callback, scrollDebounce ? (0, import_debounce.debounce)(callback, scrollDebounce) : callback];
  }, [set, scrollDebounce, resizeDebounce]);
  function removeListeners() {
    if (state.current.scrollContainers) {
      state.current.scrollContainers.forEach((element) => element.removeEventListener("scroll", scrollChange, true));
      state.current.scrollContainers = null;
    }
    if (state.current.resizeObserver) {
      state.current.resizeObserver.disconnect();
      state.current.resizeObserver = null;
    }
  }
  function addListeners() {
    if (!state.current.element)
      return;
    state.current.resizeObserver = new ResizeObserver(scrollChange);
    state.current.resizeObserver.observe(state.current.element);
    if (scroll && state.current.scrollContainers) {
      state.current.scrollContainers.forEach((scrollContainer) => scrollContainer.addEventListener("scroll", scrollChange, {
        capture: true,
        passive: true
      }));
    }
  }
  const ref = (node2) => {
    if (!node2 || node2 === state.current.element)
      return;
    removeListeners();
    state.current.element = node2;
    state.current.scrollContainers = findScrollContainers(node2);
    addListeners();
  };
  useOnWindowScroll(scrollChange, Boolean(scroll));
  useOnWindowResize(resizeChange);
  (0, import_react.useEffect)(() => {
    removeListeners();
    addListeners();
  }, [scroll, scrollChange, resizeChange]);
  (0, import_react.useEffect)(() => removeListeners, []);
  return [ref, bounds, forceRefresh];
}
function useOnWindowResize(onWindowResize) {
  (0, import_react.useEffect)(() => {
    const cb = onWindowResize;
    window.addEventListener("resize", cb);
    return () => void window.removeEventListener("resize", cb);
  }, [onWindowResize]);
}
function useOnWindowScroll(onScroll, enabled) {
  (0, import_react.useEffect)(() => {
    if (enabled) {
      const cb = onScroll;
      window.addEventListener("scroll", cb, {
        capture: true,
        passive: true
      });
      return () => void window.removeEventListener("scroll", cb, true);
    }
  }, [onScroll, enabled]);
}
function findScrollContainers(element) {
  const result = [];
  if (!element || element === document.body)
    return result;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(element);
  if ([overflow, overflowX, overflowY].some((prop) => prop === "auto" || prop === "scroll"))
    result.push(element);
  return [...result, ...findScrollContainers(element.parentElement)];
}
var keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
var areBoundsEqual = (a2, b2) => keys.every((key) => a2[key] === b2[key]);
var web_default = useMeasure;

// node_modules/react-merge-refs/dist/react-merge-refs.esm.js
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var react_merge_refs_esm_default = mergeRefs;

// node_modules/react-three-fiber/web.js
var name = "react-three-fiber";
var version = "5.3.19";
var roots = new Map();
var emptyObject = {};
var is = {
  obj: (a2) => a2 === Object(a2) && !is.arr(a2),
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0,
  arr: (a2) => Array.isArray(a2),
  equ(a2, b2) {
    if (typeof a2 !== typeof b2 || !!a2 !== !!b2)
      return false;
    if (is.str(a2) || is.num(a2) || is.obj(a2))
      return a2 === b2;
    if (is.arr(a2) && a2 == b2)
      return true;
    let i2;
    for (i2 in a2)
      if (!(i2 in b2))
        return false;
    for (i2 in b2)
      if (a2[i2] !== b2[i2])
        return false;
    return is.und(i2) ? a2 === b2 : true;
  }
};
var globalEffects = [];
var globalAfterEffects = [];
var globalTailEffects = [];
function renderGl(state, timestamp, repeat = 0, runGlobalEffects = false) {
  let i2;
  if (runGlobalEffects) {
    for (i2 = 0; i2 < globalEffects.length; i2++) {
      globalEffects[i2](timestamp);
      repeat++;
    }
  }
  const delta = state.current.clock.getDelta();
  for (i2 = 0; i2 < state.current.subscribers.length; i2++) {
    state.current.subscribers[i2].ref.current(state.current, delta);
  }
  state.current.frames = Math.max(0, state.current.frames - 1);
  repeat += !state.current.invalidateFrameloop ? 1 : state.current.frames;
  if (!state.current.manual && state.current.gl.render)
    state.current.gl.render(state.current.scene, state.current.camera);
  if (runGlobalEffects) {
    for (i2 = 0; i2 < globalAfterEffects.length; i2++) {
      globalAfterEffects[i2](timestamp);
    }
  }
  return repeat;
}
var running = false;
function renderLoop(timestamp) {
  running = true;
  let repeat = 0;
  let i2;
  for (i2 = 0; i2 < globalEffects.length; i2++) {
    globalEffects[i2](timestamp);
    repeat++;
  }
  roots.forEach((root) => {
    const state = root.containerInfo.__state;
    if (state.current.active && state.current.ready && (!state.current.invalidateFrameloop || state.current.frames > 0)) {
      repeat = renderGl(state, timestamp, repeat);
    } else {
      repeat = 0;
    }
  });
  for (i2 = 0; i2 < globalAfterEffects.length; i2++) {
    globalAfterEffects[i2](timestamp);
  }
  if (repeat !== 0) {
    return requestAnimationFrame(renderLoop);
  } else {
    for (i2 = 0; i2 < globalTailEffects.length; i2++) {
      globalTailEffects[i2](timestamp);
    }
  }
  running = false;
}
function invalidate(state = true, frames = 1) {
  if (state === true) {
    roots.forEach((root) => {
      const state2 = root.containerInfo.__state;
      state2.current.frames = state2.current.ready ? state2.current.frames + frames : frames;
    });
  } else if (state && state.current) {
    if (state.current.vr)
      return;
    state.current.frames = state.current.ready ? state.current.frames + frames : frames;
  }
  if (!running) {
    running = true;
    requestAnimationFrame(renderLoop);
  }
}
var catalogue = {};
function applyProps(instance, newProps, oldProps = {}, accumulative = false) {
  const container = instance.__container;
  const sameProps = [];
  const handlers = [];
  let i2;
  let keys2 = Object.keys(newProps);
  for (i2 = 0; i2 < keys2.length; i2++) {
    if (is.equ(newProps[keys2[i2]], oldProps[keys2[i2]])) {
      sameProps.push(keys2[i2]);
    }
    if (is.fun(newProps[keys2[i2]]) && keys2[i2].startsWith("on")) {
      if (keys2[i2].includes("Pointer") || keys2[i2].includes("Click") || keys2[i2].includes("ContextMenu") || keys2[i2].includes("Wheel")) {
        handlers.push(keys2[i2]);
      }
    }
  }
  const leftOvers = [];
  keys2 = Object.keys(oldProps);
  if (accumulative) {
    for (i2 = 0; i2 < keys2.length; i2++) {
      if (newProps[keys2[i2]] === void 0) {
        leftOvers.push(keys2[i2]);
      }
    }
  }
  const toFilter = [...sameProps, "children", "key", "ref"];
  if (instance.__instance)
    toFilter.push("object");
  const filteredProps = {
    ...newProps
  };
  keys2 = Object.keys(filteredProps);
  for (i2 = 0; i2 < keys2.length; i2++) {
    if (toFilter.indexOf(keys2[i2]) > -1) {
      delete filteredProps[keys2[i2]];
    }
  }
  keys2 = Object.keys(leftOvers);
  for (i2 = 0; i2 < keys2.length; i2++) {
    if (keys2[i2] !== "children") {
      filteredProps[keys2[i2]] = void 0;
    }
  }
  const filteredPropsEntries = Object.entries(filteredProps);
  if (filteredPropsEntries.length > 0) {
    filteredPropsEntries.forEach(([key, value]) => {
      if (!handlers.includes(key)) {
        var _instance$__container, _instance$__container2;
        let root = instance;
        let target = root[key];
        if (key.includes("-")) {
          const entries = key.split("-");
          target = entries.reduce((acc, key2) => acc[key2], instance);
          if (!(target && target.set)) {
            const [name2, ...reverseEntries] = entries.reverse();
            root = reverseEntries.reverse().reduce((acc, key2) => acc[key2], instance);
            key = name2;
          }
        }
        const isColorManagement = (_instance$__container = instance.__container) == null ? void 0 : (_instance$__container2 = _instance$__container.__state) == null ? void 0 : _instance$__container2.current.colorManagement;
        if (target && target.set && (target.copy || target instanceof Layers)) {
          if (Array.isArray(value)) {
            target.set(...value);
          } else if (target.copy && value && value.constructor && target.constructor.name === value.constructor.name) {
            target.copy(value);
          } else if (value !== void 0) {
            target.set(value);
            if (isColorManagement && target instanceof Color) {
              target.convertSRGBToLinear();
            }
          }
        } else {
          root[key] = value;
          if (isColorManagement && root[key] instanceof Texture) {
            root[key].encoding = sRGBEncoding;
          }
        }
        invalidateInstance(instance);
      }
    });
    if (accumulative && container && instance.raycast && instance.__handlers) {
      instance.__handlers = void 0;
      const index4 = container.__interaction.indexOf(instance);
      if (index4 > -1)
        container.__interaction.splice(index4, 1);
    }
    if (handlers.length) {
      if (accumulative && container && instance.raycast)
        container.__interaction.push(instance);
      instance.__handlers = handlers.reduce((acc, key) => {
        acc[key.charAt(2).toLowerCase() + key.substr(3)] = newProps[key];
        return acc;
      }, {});
    }
    if (instance.parent)
      updateInstance(instance);
  }
}
function invalidateInstance(instance) {
  if (instance.__container && instance.__container.__state)
    invalidate(instance.__container.__state);
}
function updateInstance(instance) {
  if (instance.onUpdate)
    instance.onUpdate(instance);
}
function createInstance(type, {
  args = [],
  ...props
}, container, hostContext, internalInstanceHandle) {
  let name2 = `${type[0].toUpperCase()}${type.slice(1)}`;
  let instance;
  if (type === "primitive") {
    props = {
      dispose: null,
      ...props
    };
    instance = props.object;
    instance.__instance = true;
    instance.__dispose = instance.dispose;
  } else {
    const target = catalogue[name2] || three_module_exports[name2];
    if (!target) {
      throw `"${name2}" is not part of the THREE namespace! Did you forget to extend it? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;
    }
    instance = is.arr(args) ? new target(...args) : new target(args);
  }
  while (container.__container) {
    container = container.__container;
  }
  if (!roots.has(container)) {
    const fn = (node2) => {
      if (!node2.return)
        return node2.stateNode && node2.stateNode.containerInfo;
      else
        return fn(node2.return);
    };
    container = fn(internalInstanceHandle);
  }
  instance.__objects = [];
  instance.__container = container;
  if (name2.endsWith("Geometry")) {
    props = {
      attach: "geometry",
      ...props
    };
  } else if (name2.endsWith("Material")) {
    props = {
      attach: "material",
      ...props
    };
  }
  applyProps(instance, props, {});
  return instance;
}
function appendChild(parentInstance, child) {
  if (child) {
    if (child.isObject3D) {
      parentInstance.add(child);
    } else {
      parentInstance.__objects.push(child);
      child.parent = parentInstance;
      if (child.attachArray) {
        if (!is.arr(parentInstance[child.attachArray]))
          parentInstance[child.attachArray] = [];
        parentInstance[child.attachArray].push(child);
      } else if (child.attachObject) {
        if (!is.obj(parentInstance[child.attachObject[0]]))
          parentInstance[child.attachObject[0]] = {};
        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;
      } else if (child.attach) {
        parentInstance[child.attach] = child;
      }
    }
    updateInstance(child);
    invalidateInstance(child);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  if (child) {
    if (child.isObject3D) {
      child.parent = parentInstance;
      child.dispatchEvent({
        type: "added"
      });
      const restSiblings = parentInstance.children.filter((sibling) => sibling !== child);
      const index4 = restSiblings.indexOf(beforeChild);
      parentInstance.children = [...restSiblings.slice(0, index4), child, ...restSiblings.slice(index4)];
      updateInstance(child);
    } else {
      appendChild(parentInstance, child);
    }
    invalidateInstance(child);
  }
}
function removeRecursive(array, parent, clone = false) {
  if (array) {
    const target = clone ? [...array] : array;
    target.forEach((child) => removeChild(parent, child));
  }
}
function removeChild(parentInstance, child) {
  if (child) {
    if (child.isObject3D) {
      parentInstance.remove(child);
    } else {
      child.parent = null;
      if (parentInstance.__objects)
        parentInstance.__objects = parentInstance.__objects.filter((x2) => x2 !== child);
      if (child.attachArray) {
        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter((x2) => x2 !== child);
      } else if (child.attachObject) {
        delete parentInstance[child.attachObject[0]][child.attachObject[1]];
      } else if (child.attach) {
        parentInstance[child.attach] = null;
      }
    }
    if (child.__container)
      child.__container.__interaction = child.__container.__interaction.filter((x2) => x2 !== child);
    invalidateInstance(child);
    if (child.dispose !== null) {
      (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_IdlePriority, () => {
        removeRecursive(child.__objects, child);
        removeRecursive(child.children, child, true);
        if (child.dispose && child.type !== "Scene")
          child.dispose();
        else if (child.__dispose)
          child.__dispose();
        delete child.__container;
        delete child.__objects;
      });
    }
  }
}
function switchInstance(instance, type, newProps, fiber) {
  const parent = instance.parent;
  const newInstance = createInstance(type, newProps, instance.__container, null, fiber);
  removeChild(parent, instance);
  appendChild(parent, newInstance);
  [fiber, fiber.alternate].forEach((fiber2) => {
    if (fiber2 !== null) {
      fiber2.stateNode = newInstance;
      if (fiber2.ref) {
        if (is.fun(fiber2.ref))
          fiber2.ref(newInstance);
        else
          fiber2.ref.current = newInstance;
      }
    }
  });
}
var Renderer = (0, import_react_reconciler.default)({
  now: import_scheduler.unstable_now,
  createInstance,
  removeChild,
  appendChild,
  insertBefore,
  warnsIfNotActing: true,
  supportsMutation: true,
  isPrimaryRenderer: false,
  scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
  cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
  setTimeout: is.fun(setTimeout) ? setTimeout : void 0,
  clearTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
  noTimeout: -1,
  appendInitialChild: appendChild,
  appendChildToContainer: appendChild,
  removeChildFromContainer: removeChild,
  insertInContainerBefore: insertBefore,
  commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {
    if (instance.__instance && newProps.object && newProps.object !== instance) {
      switchInstance(instance, type, newProps, fiber);
    } else {
      const {
        args: argsNew = [],
        ...restNew
      } = newProps;
      const {
        args: argsOld = [],
        ...restOld
      } = oldProps;
      const hasNewArgs = argsNew.some((value, index4) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index4][key]) : value !== argsOld[index4]);
      if (hasNewArgs) {
        switchInstance(instance, type, newProps, fiber);
      } else {
        applyProps(instance, restNew, restOld, true);
      }
    }
  },
  hideInstance(instance) {
    if (instance.isObject3D) {
      instance.visible = false;
      invalidateInstance(instance);
    }
  },
  unhideInstance(instance, props) {
    if (instance.isObject3D && props.visible == null || props.visible) {
      instance.visible = true;
      invalidateInstance(instance);
    }
  },
  hideTextInstance() {
    throw new Error("Text is not allowed in the react-three-fibre tree. You may have extraneous whitespace between components.");
  },
  getPublicInstance(instance) {
    return instance;
  },
  getRootHostContext() {
    return emptyObject;
  },
  getChildHostContext() {
    return emptyObject;
  },
  createTextInstance() {
  },
  finalizeInitialChildren(instance) {
    return instance.__handlers;
  },
  commitMount(instance) {
    const container = instance.__container;
    if (container && instance.raycast && instance.__handlers)
      container.__interaction.push(instance);
  },
  prepareUpdate() {
    return emptyObject;
  },
  shouldDeprioritizeSubtree() {
    return false;
  },
  prepareForCommit() {
    return null;
  },
  preparePortalMount() {
    return null;
  },
  resetAfterCommit() {
  },
  shouldSetTextContent() {
    return false;
  },
  clearContainer() {
    return false;
  }
});
var hasSymbol = is.fun(Symbol) && Symbol.for;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
function render(element, container, state) {
  let root = roots.get(container);
  if (!root) {
    container.__state = state;
    let newRoot = root = Renderer.createContainer(container, state !== void 0 && state.current.concurrent ? 2 : 0, false, null);
    roots.set(container, newRoot);
  }
  Renderer.updateContainer(element, root, null, () => void 0);
  return Renderer.getPublicRootInstance(root);
}
function unmountComponentAtNode(container, callback) {
  const root = roots.get(container);
  if (root) {
    Renderer.updateContainer(null, root, null, () => {
      roots.delete(container);
      if (callback)
        callback(container);
    });
  }
}
Renderer.injectIntoDevTools({
  bundleType: true ? 0 : 1,
  findHostInstanceByFiber: () => null,
  version,
  rendererPackageName: name
});
function isOrthographicCamera(def) {
  return def.isOrthographicCamera;
}
function makeId(event) {
  return (event.eventObject || event.object).uuid + "/" + event.index;
}
var stateContext = /* @__PURE__ */ (0, import_react2.createContext)({});
var useCanvas = (props) => {
  const {
    children,
    gl,
    camera,
    orthographic,
    raycaster,
    size,
    pixelRatio,
    vr = false,
    concurrent = false,
    shadowMap = false,
    colorManagement = true,
    invalidateFrameloop = false,
    updateDefaultCamera = true,
    noEvents = false,
    onCreated,
    onPointerMissed,
    forceResize
  } = props;
  const [ready, setReady] = (0, import_react2.useState)(false);
  const [mouse] = (0, import_react2.useState)(() => new Vector2());
  const [defaultRaycaster] = (0, import_react2.useState)(() => {
    const ray = new Raycaster();
    if (raycaster) {
      const {
        filter,
        computeOffsets,
        ...raycasterProps
      } = raycaster;
      applyProps(ray, raycasterProps, {});
    }
    return ray;
  });
  const [defaultScene] = (0, import_react2.useState)(() => {
    const scene = new Scene();
    scene.__interaction = [];
    scene.__objects = [];
    return scene;
  });
  const [defaultCam, setDefaultCamera] = (0, import_react2.useState)(() => {
    const cam = orthographic ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3) : new PerspectiveCamera(75, 0, 0.1, 1e3);
    cam.position.z = 5;
    if (camera)
      applyProps(cam, camera, {});
    cam.lookAt(0, 0, 0);
    return cam;
  });
  const [clock] = (0, import_react2.useState)(() => new Clock());
  const state = (0, import_react2.useRef)({
    ready: false,
    active: true,
    manual: 0,
    colorManagement,
    vr,
    concurrent,
    noEvents,
    invalidateFrameloop: false,
    frames: 0,
    aspect: 0,
    subscribers: [],
    camera: defaultCam,
    scene: defaultScene,
    raycaster: defaultRaycaster,
    mouse,
    clock,
    gl,
    size,
    viewport: null,
    initialClick: [0, 0],
    initialHits: [],
    pointer: new import_tiny_emitter.TinyEmitter(),
    captured: void 0,
    events: void 0,
    subscribe: (ref, priority = 0) => {
      if (priority)
        state.current.manual++;
      state.current.subscribers.push({
        ref,
        priority
      });
      state.current.subscribers = state.current.subscribers.sort((a2, b2) => a2.priority - b2.priority);
      return () => {
        var _state$current;
        if ((_state$current = state.current) == null ? void 0 : _state$current.subscribers) {
          if (priority)
            state.current.manual--;
          state.current.subscribers = state.current.subscribers.filter((s2) => s2.ref !== ref);
        }
      };
    },
    setDefaultCamera: (camera2) => setDefaultCamera(camera2),
    invalidate: () => invalidate(state),
    intersect: (event = {}, prepare = true) => handlePointerMove(event, prepare),
    forceResize
  });
  const position2 = new Vector3();
  const getCurrentViewport = (0, import_react2.useCallback)((camera2 = state.current.camera, target = new Vector3(0, 0, 0)) => {
    const {
      width,
      height
    } = state.current.size;
    const distance = camera2.getWorldPosition(position2).distanceTo(target);
    if (isOrthographicCamera(camera2)) {
      return {
        width: width / camera2.zoom,
        height: height / camera2.zoom,
        factor: 1,
        distance
      };
    } else {
      const fov2 = camera2.fov * Math.PI / 180;
      const h2 = 2 * Math.tan(fov2 / 2) * distance;
      const w3 = h2 * (width / height);
      return {
        width: w3,
        height: h2,
        factor: width / w3,
        distance
      };
    }
  }, []);
  (0, import_react2.useMemo)(() => {
    state.current.ready = ready;
    state.current.size = size;
    state.current.camera = defaultCam;
    state.current.invalidateFrameloop = invalidateFrameloop;
    state.current.vr = vr;
    state.current.gl = gl;
    state.current.concurrent = concurrent;
    state.current.noEvents = noEvents;
    state.current.viewport = getCurrentViewport;
  }, [invalidateFrameloop, vr, concurrent, noEvents, ready, size, defaultCam, gl]);
  (0, import_react2.useMemo)(() => {
    state.current.aspect = size.width / size.height;
    Object.assign(state.current.viewport, getCurrentViewport());
    if (updateDefaultCamera) {
      if (isOrthographicCamera(defaultCam)) {
        defaultCam.left = size.width / -2;
        defaultCam.right = size.width / 2;
        defaultCam.top = size.height / 2;
        defaultCam.bottom = size.height / -2;
      } else {
        defaultCam.aspect = state.current.aspect;
      }
      defaultCam.updateProjectionMatrix();
      defaultCam.updateMatrixWorld();
    }
    gl.setSize(size.width, size.height);
    if (ready)
      invalidate(state);
  }, [defaultCam, gl, size, updateDefaultCamera, ready]);
  const sharedState = (0, import_react2.useRef)(null);
  (0, import_react2.useMemo)(() => {
    const {
      ready: ready2,
      manual,
      vr: vr2,
      noEvents: noEvents2,
      invalidateFrameloop: invalidateFrameloop2,
      frames,
      subscribers,
      captured,
      initialClick,
      initialHits,
      ...props2
    } = state.current;
    sharedState.current = props2;
  }, [size, defaultCam]);
  (0, import_react2.useLayoutEffect)(() => {
    if (pixelRatio) {
      if (Array.isArray(pixelRatio))
        gl.setPixelRatio(Math.max(Math.min(pixelRatio[0], window.devicePixelRatio), pixelRatio[1]));
      else
        gl.setPixelRatio(pixelRatio);
    }
  }, [gl, pixelRatio]);
  (0, import_react2.useLayoutEffect)(() => {
    if (shadowMap) {
      gl.shadowMap.enabled = true;
      if (typeof shadowMap === "object")
        Object.assign(gl.shadowMap, shadowMap);
      else
        gl.shadowMap.type = PCFSoftShadowMap;
    }
    if (colorManagement) {
      gl.toneMapping = ACESFilmicToneMapping;
      gl.outputEncoding = sRGBEncoding;
    }
  }, [shadowMap, colorManagement]);
  const hovered = (0, import_react2.useMemo)(() => new Map(), []);
  const temp = new Vector3();
  const prepareRay = (0, import_react2.useCallback)((event) => {
    const offsets = (raycaster == null ? void 0 : raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, sharedState.current)) || event.nativeEvent;
    if (offsets) {
      const {
        offsetX,
        offsetY
      } = offsets;
      const {
        width,
        height
      } = state.current.size;
      mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
      defaultRaycaster.setFromCamera(mouse, state.current.camera);
    }
  }, []);
  const intersect = (0, import_react2.useCallback)((filter) => {
    if (state.current.noEvents)
      return [];
    const seen = new Set();
    const hits = [];
    const eventsObjects = filter ? filter(state.current.scene.__interaction) : state.current.scene.__interaction;
    let intersects2 = defaultRaycaster.intersectObjects(eventsObjects, true).filter((item) => {
      const id = makeId(item);
      if (seen.has(id))
        return false;
      seen.add(id);
      return true;
    });
    if (raycaster && raycaster.filter && sharedState.current) {
      intersects2 = raycaster.filter(intersects2, sharedState.current);
    }
    for (const intersect2 of intersects2) {
      let eventObject = intersect2.object;
      while (eventObject) {
        const handlers = eventObject.__handlers;
        if (handlers)
          hits.push({
            ...intersect2,
            eventObject
          });
        eventObject = eventObject.parent;
      }
    }
    return hits;
  }, []);
  const calculateDistance = (0, import_react2.useCallback)((event) => {
    const dx = event.nativeEvent.offsetX - state.current.initialClick[0];
    const dy = event.nativeEvent.offsetY - state.current.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }, []);
  const handlePointerCancel = (0, import_react2.useCallback)((event, hits, prepare = true) => {
    state.current.pointer.emit("pointerCancel", event);
    if (prepare)
      prepareRay(event);
    Array.from(hovered.values()).forEach((hoveredObj) => {
      if (hits && (!hits.length || !hits.find((hit) => hit.object === hoveredObj.object && hit.index === hoveredObj.index))) {
        const eventObject = hoveredObj.eventObject;
        const handlers = eventObject.__handlers;
        hovered.delete(makeId(hoveredObj));
        if (handlers) {
          const data2 = {
            ...hoveredObj,
            intersections: hits || []
          };
          if (handlers.pointerOut)
            handlers.pointerOut({
              ...data2,
              type: "pointerout"
            });
          if (handlers.pointerLeave)
            handlers.pointerLeave({
              ...data2,
              type: "pointerleave"
            });
        }
      }
    });
  }, []);
  const getIntersects = (0, import_react2.useCallback)((event, filter) => {
    const intersections = intersect(filter);
    if (state.current.captured && event.type !== "click" && event.type !== "wheel") {
      state.current.captured.forEach((captured) => {
        if (!intersections.find((hit) => hit.eventObject === captured.eventObject))
          intersections.push(captured);
      });
    }
    return intersections;
  }, []);
  const handleIntersects = (0, import_react2.useCallback)((intersections, event, fn) => {
    if (intersections.length) {
      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(state.current.camera);
      const delta = event.type === "click" ? calculateDistance(event) : 0;
      const releasePointerCapture = (id) => event.target.releasePointerCapture(id);
      const localState = {
        stopped: false,
        captured: false
      };
      for (const hit of intersections) {
        const setPointerCapture = (id) => {
          if (!localState.captured) {
            localState.captured = true;
            state.current.captured = [];
          }
          if (state.current.captured) {
            state.current.captured.push(hit);
          }
          event.target.setPointerCapture(id);
        };
        const raycastEvent = {
          ...event,
          ...hit,
          intersections,
          stopped: localState.stopped,
          delta,
          unprojectedPoint,
          ray: defaultRaycaster.ray,
          camera: state.current.camera,
          stopPropagation: () => {
            const cap = state.current.captured;
            if (!cap || cap.find((h2) => h2.eventObject.id === hit.eventObject.id)) {
              raycastEvent.stopped = localState.stopped = true;
              if (hovered.size && Array.from(hovered.values()).find((i2) => i2.eventObject === hit.eventObject)) {
                const higher = intersections.slice(0, intersections.indexOf(hit));
                handlePointerCancel(raycastEvent, [...higher, hit]);
              }
            }
          },
          target: {
            ...event.target,
            setPointerCapture,
            releasePointerCapture
          },
          currentTarget: {
            ...event.currentTarget,
            setPointerCapture,
            releasePointerCapture
          },
          sourceEvent: event
        };
        fn(raycastEvent);
        if (localState.stopped === true)
          break;
      }
    }
    return intersections;
  }, []);
  const handlePointerMove = (0, import_react2.useCallback)((event, prepare = true) => {
    state.current.pointer.emit("pointerMove", event);
    if (prepare)
      prepareRay(event);
    const hits = getIntersects(event, (objects) => objects.filter((obj) => ["Move", "Over", "Enter", "Out", "Leave"].some((name2) => obj.__handlers["pointer" + name2])));
    handlePointerCancel(event, hits);
    handleIntersects(hits, event, (data2) => {
      const eventObject = data2.eventObject;
      const handlers = eventObject.__handlers;
      if (!handlers)
        return;
      if (handlers.pointerOver || handlers.pointerEnter || handlers.pointerOut || handlers.pointerLeave) {
        const id = makeId(data2);
        const hoveredItem = hovered.get(id);
        if (!hoveredItem) {
          hovered.set(id, data2);
          if (handlers.pointerOver)
            handlers.pointerOver({
              ...data2,
              type: "pointerover"
            });
          if (handlers.pointerEnter)
            handlers.pointerEnter({
              ...data2,
              type: "pointerenter"
            });
        } else if (hoveredItem.stopped) {
          data2.stopPropagation();
        }
      }
      if (handlers.pointerMove)
        handlers.pointerMove(data2);
    });
    return hits;
  }, []);
  const handlePointer = (0, import_react2.useCallback)((name2) => (event, prepare = true) => {
    state.current.pointer.emit(name2, event);
    if (prepare)
      prepareRay(event);
    const hits = getIntersects(event);
    handleIntersects(hits, event, (data2) => {
      const eventObject = data2.eventObject;
      const handlers = eventObject.__handlers;
      if (handlers && handlers[name2]) {
        if (name2 !== "click" && name2 !== "contextMenu" && name2 !== "doubleClick" || state.current.initialHits.includes(eventObject)) {
          handlers[name2](data2);
          pointerMissed(event, defaultScene.__interaction, (object) => object !== eventObject);
        }
      }
    });
    if (name2 === "pointerDown") {
      state.current.initialClick = [event.nativeEvent.offsetX, event.nativeEvent.offsetY];
      state.current.initialHits = hits.map((hit) => hit.eventObject);
    }
    if ((name2 === "click" || name2 === "contextMenu" || name2 === "doubleClick") && !hits.length) {
      if (calculateDistance(event) <= 2) {
        pointerMissed(event, defaultScene.__interaction);
        if (onPointerMissed)
          onPointerMissed();
      }
    }
  }, [onPointerMissed, calculateDistance, getIntersects, handleIntersects, prepareRay]);
  (0, import_react2.useMemo)(() => {
    state.current.events = {
      onClick: handlePointer("click"),
      onContextMenu: handlePointer("contextMenu"),
      onDoubleClick: handlePointer("doubleClick"),
      onWheel: handlePointer("wheel"),
      onPointerDown: handlePointer("pointerDown"),
      onPointerUp: handlePointer("pointerUp"),
      onPointerLeave: (e2) => handlePointerCancel(e2, []),
      onPointerMove: handlePointerMove,
      onGotPointerCaptureLegacy: (e2) => state.current.captured = intersect(),
      onLostPointerCapture: (e2) => (state.current.captured = void 0, handlePointerCancel(e2))
    };
  }, [handlePointer, intersect, handlePointerCancel, handlePointerMove]);
  const Canvas3 = (0, import_react2.useCallback)(function Canvas4(props2) {
    const activate = () => setReady(true);
    (0, import_react2.useLayoutEffect)(() => void gl.compile(defaultScene, defaultCam), []);
    (0, import_react2.useEffect)(() => {
      const result = onCreated && onCreated(state.current);
      if (result && result.then)
        result.then(activate);
      else
        activate();
    }, []);
    return props2.children;
  }, []);
  (0, import_react2.useLayoutEffect)(() => {
    render(/* @__PURE__ */ (0, import_react2.createElement)(Canvas3, null, /* @__PURE__ */ (0, import_react2.createElement)(stateContext.Provider, {
      value: sharedState.current
    }, typeof children === "function" ? children(state.current) : children)), defaultScene, state);
  }, [ready, children, sharedState.current]);
  (0, import_react2.useLayoutEffect)(() => {
    if (ready) {
      if (!state.current.vr) {
        if (state.current.frames === 0)
          invalidate(state);
      } else if ((gl.xr || gl.vr) && gl.setAnimationLoop) {
        (gl.xr || gl.vr).enabled = true;
        gl.setAnimationLoop((t2) => renderGl(state, t2, 0, true));
      } else {
        console.warn("the gl instance does not support VR!");
      }
    }
  }, [gl, ready, invalidateFrameloop]);
  (0, import_react2.useEffect)(() => () => {
    if (state.current.gl) {
      if (state.current.gl.renderLists)
        state.current.gl.renderLists.dispose();
      if (state.current.gl.forceContextLoss)
        state.current.gl.forceContextLoss();
      dispose(state.current.gl);
    }
    unmountComponentAtNode(state.current.scene, () => {
      dispose(state.current.raycaster);
      dispose(state.current.camera);
      dispose(state.current);
    });
  }, []);
  return state.current.events;
};
function pointerMissed(event, objects, filter = (object) => true) {
  objects.filter(filter).forEach((object) => {
    var _handlers$pointerMis, _handlers;
    return (_handlers$pointerMis = (_handlers = object.__handlers).pointerMissed) == null ? void 0 : _handlers$pointerMis.call(_handlers, event);
  });
}
function dispose(obj) {
  if (obj.dispose && obj.type !== "Scene")
    obj.dispose();
  for (const p2 in obj) {
    if (typeof p2 === "object" && p2.dispose)
      p2.dispose();
    delete obj[p2];
  }
}
function useContext(context) {
  let result = (0, import_react2.useContext)(context);
  if (!("subscribe" in result)) {
    throw new Error(`\u26A1\uFE0F react-three-fiber hooks can only be used within the Canvas component! https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#hooks`);
  }
  return result;
}
function useFrame(callback, renderPriority = 0) {
  const {
    subscribe
  } = useContext(stateContext);
  const ref = (0, import_react2.useRef)(callback);
  (0, import_react2.useLayoutEffect)(() => void (ref.current = callback), [callback]);
  (0, import_react2.useEffect)(() => {
    const unsubscribe = subscribe(ref, renderPriority);
    return () => unsubscribe();
  }, [renderPriority, subscribe]);
  return null;
}
function buildGraph(object) {
  const data2 = {
    nodes: {},
    materials: {}
  };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data2.nodes[obj.name] = obj;
      if (obj.material && !data2.materials[obj.material.name])
        data2.materials[obj.material.name] = obj.material;
    });
  }
  return data2;
}
function loadingFn(extensions, onProgress) {
  return function(Proto, ...input) {
    const loader = new Proto();
    if (extensions)
      extensions(loader);
    return Promise.all(input.map((input2) => new Promise((res, reject) => loader.load(input2, (data2) => {
      if (data2.scene)
        Object.assign(data2, buildGraph(data2.scene));
      res(data2);
    }, onProgress, (error) => {
      var _error$message;
      return reject((_error$message = error.message) != null ? _error$message : `failure loading ${input2}`);
    }))));
  };
}
function useLoader(Proto, input, extensions, onProgress) {
  const keys2 = Array.isArray(input) ? input : [input];
  const results = useAsset(loadingFn(extensions, onProgress), Proto, ...keys2);
  return Array.isArray(input) ? results : results[0];
}
useLoader.preload = function(Proto, input, extensions) {
  const keys2 = Array.isArray(input) ? input : [input];
  return useAsset.preload(loadingFn(extensions), Proto, ...keys2);
};
var defaultStyles = {
  position: "relative",
  width: "100%",
  height: "100%",
  overflow: "hidden"
};
function Content({
  children,
  setEvents,
  container,
  renderer,
  effects,
  ...props
}) {
  const [gl] = (0, import_react2.useState)(renderer);
  if (!gl)
    console.warn("No renderer created!");
  (0, import_react2.useEffect)(() => {
    if (effects)
      effects(gl, container);
  }, [container, effects, gl]);
  const events = useCanvas({
    ...props,
    children,
    gl
  });
  (0, import_react2.useEffect)(() => {
    setEvents(events);
  }, [events, setEvents]);
  return null;
}
var ResizeContainer = /* @__PURE__ */ import_react2.default.memo(function ResizeContainer2(props) {
  const {
    renderer,
    effects,
    children,
    vr,
    webgl1,
    concurrent,
    shadowMap,
    colorManagement,
    orthographic,
    invalidateFrameloop,
    updateDefaultCamera,
    noEvents,
    gl,
    camera,
    raycaster,
    pixelRatio,
    onCreated,
    onPointerMissed,
    preRender,
    resize,
    style,
    ...restSpread
  } = props;
  const containerRef = (0, import_react2.useRef)();
  const [{
    onGotPointerCaptureLegacy,
    ...events
  }, setEvents] = (0, import_react2.useState)({});
  const [bind, size, forceResize] = web_default({
    scroll: true,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...resize
  });
  const readyFlag = (0, import_react2.useRef)(false);
  const ready = (0, import_react2.useMemo)(() => readyFlag.current = readyFlag.current || !!size.width && !!size.height, [size]);
  const state = (0, import_react2.useMemo)(() => ({
    size,
    forceResize,
    setEvents,
    container: containerRef.current
  }), [forceResize, size]);
  if (typeof window === "undefined")
    return /* @__PURE__ */ import_react2.default.createElement("div", _extends({
      style: {
        ...defaultStyles,
        ...style
      }
    }, restSpread), preRender);
  return /* @__PURE__ */ import_react2.default.createElement("div", _extends({
    ref: react_merge_refs_esm_default([bind, containerRef]),
    style: {
      ...defaultStyles,
      ...style
    }
  }, events, restSpread), preRender, ready && /* @__PURE__ */ import_react2.default.createElement(Content, _extends({}, props, state)));
});
var Canvas = /* @__PURE__ */ import_react2.default.memo(function Canvas2({
  children,
  ...props
}) {
  const canvasRef = (0, import_react2.useRef)();
  const renderer = props.webgl1 ? WebGL1Renderer : WebGLRenderer;
  return /* @__PURE__ */ import_react2.default.createElement(ResizeContainer, _extends({}, props, {
    renderer: () => {
      if (canvasRef.current) {
        const params = {
          antialias: true,
          alpha: true,
          ...props.gl
        };
        const temp = new renderer({
          powerPreference: "high-performance",
          canvas: canvasRef.current,
          ...params
        });
        return temp;
      }
    },
    preRender: /* @__PURE__ */ import_react2.default.createElement("canvas", {
      ref: canvasRef,
      style: {
        display: "block"
      }
    })
  }), children);
});

// src/r3f.tsx
function Three(props) {
  const preserveDrawingBuffer = props.component.project.designMode;
  return /* @__PURE__ */ import_react3.default.createElement(Canvas, {
    gl: {preserveDrawingBuffer}
  }, /* @__PURE__ */ import_react3.default.createElement("ambientLight", null), /* @__PURE__ */ import_react3.default.createElement("pointLight", {
    position: [10, 10, 10]
  }), /* @__PURE__ */ import_react3.default.createElement(Box, {
    position: [-2.2, 0, 0]
  }), /* @__PURE__ */ import_react3.default.createElement(Box, {
    position: [2.2, 0, 0]
  }));
}
var ThreeDescription = {
  name: "Three",
  description: "The Three Component ...",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: Three,
  extends: "Play Kit/View",
  properties: {
    width: {type: "number", title: "Width", default: 400},
    height: {type: "number", title: "Height", default: 200}
  }
};
var Box = (props) => {
  const mesh = (0, import_react3.useRef)();
  const [hovered, setHover] = (0, import_react3.useState)(false);
  const [active, setActive] = (0, import_react3.useState)(false);
  useFrame(() => {
    if (mesh.current)
      mesh.current.rotation.x = mesh.current.rotation.y += 0.01;
  });
  return /* @__PURE__ */ import_react3.default.createElement("mesh", {
    ...props,
    ref: mesh,
    scale: active ? [2.5, 2.5, 2.5] : [2, 2, 2],
    onClick: (event) => setActive(!active),
    onPointerOver: (event) => setHover(true),
    onPointerOut: (event) => setHover(false)
  }, /* @__PURE__ */ import_react3.default.createElement("boxBufferGeometry", {
    args: [1, 1, 1]
  }), /* @__PURE__ */ import_react3.default.createElement("meshStandardMaterial", {
    color: hovered ? "hotpink" : "orange"
  }));
};

// src/xkcd.tsx
var import_react4 = __toModule(require("react"));
function XKCD(props) {
  const {comic, component} = props;
  const [source, setSource] = (0, import_react4.useState)();
  const [error, setError] = (0, import_react4.useState)();
  (0, import_react4.useEffect)(() => {
    fetch(`/cors?url=https://xkcd.com/${comic}/info.0.json`).then((response) => response.json()).then((json) => {
      setSource(json.img);
      component.response = json;
    }).catch((err) => {
      setSource(void 0);
      setError(err.toString());
    });
  }, [comic]);
  return /* @__PURE__ */ import_react4.default.createElement("div", {
    style: {width: "100%", height: "100%", position: "relative"}
  }, source && /* @__PURE__ */ import_react4.default.createElement("img", {
    src: `/cors?url=${source}`,
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      objectFit: "contain"
    }
  }), error && /* @__PURE__ */ import_react4.default.createElement("div", {
    style: {
      position: "absolute",
      width: "100%",
      height: "100%",
      display: "flex",
      alignContent: "center",
      alignItems: "center"
    }
  }, error));
}
var XKCDDescription = {
  name: "XKCD",
  description: "The XKCD Component .... Content copyright",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: XKCD,
  extends: "Play Kit/View",
  properties: {
    comic: {type: "number", default: 2293},
    width: {type: "number", default: 400},
    height: {type: "number", default: 400}
  }
};

// src/index.ts
var import_chart_xkcd = require_chart_xkcd();

// src/clock/clock.tsx
var import_react18 = __toModule(require("react"));

// node_modules/react-clock/dist/esm/Clock.js
var import_react7 = __toModule(require("react"));
var import_prop_types3 = __toModule(require_prop_types());

// node_modules/merge-class-names/dist/esm/index.js
function mergeClassNames() {
  return Array.prototype.slice.call(arguments).reduce(function(classList, arg) {
    return typeof arg === "string" || Array.isArray(arg) ? classList.concat(arg) : classList;
  }, []).filter(Boolean).join(" ");
}

// node_modules/@wojtekmaj/date-utils/dist/esm/index.js
function makeGetEdgeOfNeighbor(getPeriod, getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborInternal(date) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var previousPeriod = getPeriod(date) + offset;
    return getEdgeOfPeriod(previousPeriod);
  };
}
function makeGetEnd(getBeginOfNextPeriod) {
  return function makeGetEndInternal(date) {
    return new Date(getBeginOfNextPeriod(date).getTime() - 1);
  };
}
function makeGetRange(functions) {
  return function makeGetRangeInternal(date) {
    return functions.map(function(fn) {
      return fn(date);
    });
  };
}
function getYear(date) {
  if (date instanceof Date) {
    return date.getFullYear();
  }
  if (typeof date === "number") {
    return date;
  }
  var year = parseInt(date, 10);
  if (typeof date === "string" && !isNaN(year)) {
    return year;
  }
  throw new Error("Failed to get year from date: ".concat(date, "."));
}
function getMonth(date) {
  if (date instanceof Date) {
    return date.getMonth();
  }
  throw new Error("Failed to get month from date: ".concat(date, "."));
}
function getDate(date) {
  if (date instanceof Date) {
    return date.getDate();
  }
  throw new Error("Failed to get year from date: ".concat(date, "."));
}
function getHours(date) {
  if (date instanceof Date) {
    return date.getHours();
  }
  if (typeof date === "string") {
    var datePieces = date.split(":");
    if (datePieces.length >= 2) {
      var hoursString = datePieces[0];
      var hours = parseInt(hoursString, 10);
      if (!isNaN(hours)) {
        return hours;
      }
    }
  }
  throw new Error("Failed to get hours from date: ".concat(date, "."));
}
function getMinutes(date) {
  if (date instanceof Date) {
    return date.getMinutes();
  }
  if (typeof date === "string") {
    var datePieces = date.split(":");
    if (datePieces.length >= 2) {
      var minutesString = datePieces[1] || 0;
      var minutes = parseInt(minutesString, 10);
      if (!isNaN(minutes)) {
        return minutes;
      }
    }
  }
  throw new Error("Failed to get minutes from date: ".concat(date, "."));
}
function getSeconds(date) {
  if (date instanceof Date) {
    return date.getSeconds();
  }
  if (typeof date === "string") {
    var datePieces = date.split(":");
    if (datePieces.length >= 2) {
      var secondsString = datePieces[2] || 0;
      var seconds = parseInt(secondsString, 10);
      if (!isNaN(seconds)) {
        return seconds;
      }
    }
  }
  throw new Error("Failed to get seconds from date: ".concat(date, "."));
}
function getCenturyStart(date) {
  var year = getYear(date);
  var centuryStartYear = year + (-year + 1) % 100;
  var centuryStartDate = new Date();
  centuryStartDate.setFullYear(centuryStartYear, 0, 1);
  centuryStartDate.setHours(0, 0, 0, 0);
  return centuryStartDate;
}
var getPreviousCenturyStart = makeGetEdgeOfNeighbor(getYear, getCenturyStart, -100);
var getNextCenturyStart = makeGetEdgeOfNeighbor(getYear, getCenturyStart, 100);
var getCenturyEnd = makeGetEnd(getNextCenturyStart);
var getPreviousCenturyEnd = makeGetEdgeOfNeighbor(getYear, getCenturyEnd, -100);
var getNextCenturyEnd = makeGetEdgeOfNeighbor(getYear, getCenturyEnd, 100);
var getCenturyRange = makeGetRange([getCenturyStart, getCenturyEnd]);
function getDecadeStart(date) {
  var year = getYear(date);
  var decadeStartYear = year + (-year + 1) % 10;
  var decadeStartDate = new Date();
  decadeStartDate.setFullYear(decadeStartYear, 0, 1);
  decadeStartDate.setHours(0, 0, 0, 0);
  return decadeStartDate;
}
var getPreviousDecadeStart = makeGetEdgeOfNeighbor(getYear, getDecadeStart, -10);
var getNextDecadeStart = makeGetEdgeOfNeighbor(getYear, getDecadeStart, 10);
var getDecadeEnd = makeGetEnd(getNextDecadeStart);
var getPreviousDecadeEnd = makeGetEdgeOfNeighbor(getYear, getDecadeEnd, -10);
var getNextDecadeEnd = makeGetEdgeOfNeighbor(getYear, getDecadeEnd, 10);
var getDecadeRange = makeGetRange([getDecadeStart, getDecadeEnd]);
function getYearStart(date) {
  var year = getYear(date);
  var yearStartDate = new Date();
  yearStartDate.setFullYear(year, 0, 1);
  yearStartDate.setHours(0, 0, 0, 0);
  return yearStartDate;
}
var getPreviousYearStart = makeGetEdgeOfNeighbor(getYear, getYearStart, -1);
var getNextYearStart = makeGetEdgeOfNeighbor(getYear, getYearStart, 1);
var getYearEnd = makeGetEnd(getNextYearStart);
var getPreviousYearEnd = makeGetEdgeOfNeighbor(getYear, getYearEnd, -1);
var getNextYearEnd = makeGetEdgeOfNeighbor(getYear, getYearEnd, 1);
var getYearRange = makeGetRange([getYearStart, getYearEnd]);
function makeGetEdgeOfNeighborMonth(getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborMonthInternal(date) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var year = getYear(date);
    var month = getMonth(date) + offset;
    var previousPeriod = new Date();
    previousPeriod.setFullYear(year, month, 1);
    previousPeriod.setHours(0, 0, 0, 0);
    return getEdgeOfPeriod(previousPeriod);
  };
}
function getMonthStart(date) {
  var year = getYear(date);
  var month = getMonth(date);
  var monthStartDate = new Date();
  monthStartDate.setFullYear(year, month, 1);
  monthStartDate.setHours(0, 0, 0, 0);
  return monthStartDate;
}
var getPreviousMonthStart = makeGetEdgeOfNeighborMonth(getMonthStart, -1);
var getNextMonthStart = makeGetEdgeOfNeighborMonth(getMonthStart, 1);
var getMonthEnd = makeGetEnd(getNextMonthStart);
var getPreviousMonthEnd = makeGetEdgeOfNeighborMonth(getMonthEnd, -1);
var getNextMonthEnd = makeGetEdgeOfNeighborMonth(getMonthEnd, 1);
var getMonthRange = makeGetRange([getMonthStart, getMonthEnd]);
function makeGetEdgeOfNeighborDay(getEdgeOfPeriod, defaultOffset) {
  return function makeGetEdgeOfNeighborDayInternal(date) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultOffset;
    var year = getYear(date);
    var month = getMonth(date);
    var day = getDate(date) + offset;
    var previousPeriod = new Date();
    previousPeriod.setFullYear(year, month, day);
    previousPeriod.setHours(0, 0, 0, 0);
    return getEdgeOfPeriod(previousPeriod);
  };
}
function getDayStart(date) {
  var year = getYear(date);
  var month = getMonth(date);
  var day = getDate(date);
  var dayStartDate = new Date();
  dayStartDate.setFullYear(year, month, day);
  dayStartDate.setHours(0, 0, 0, 0);
  return dayStartDate;
}
var getPreviousDayStart = makeGetEdgeOfNeighborDay(getDayStart, -1);
var getNextDayStart = makeGetEdgeOfNeighborDay(getDayStart, 1);
var getDayEnd = makeGetEnd(getNextDayStart);
var getPreviousDayEnd = makeGetEdgeOfNeighborDay(getDayEnd, -1);
var getNextDayEnd = makeGetEdgeOfNeighborDay(getDayEnd, 1);
var getDayRange = makeGetRange([getDayStart, getDayEnd]);

// node_modules/react-clock/dist/esm/Hand.js
var import_react5 = __toModule(require("react"));
var import_prop_types = __toModule(require_prop_types());

// node_modules/react-clock/dist/esm/shared/utils.js
var isDefined = function isDefined2(variable) {
  return typeof variable !== "undefined";
};

// node_modules/react-clock/dist/esm/shared/propTypes.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var isNumberBetween = function isNumberBetween2(min, max) {
  return function(props, propName, componentName) {
    var value = props[propName];
    if (isDefined(value)) {
      if (typeof value !== "number") {
        return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(value), "` supplied to `").concat(componentName, "`, expected `number`."));
      }
      if (value < min || value > max) {
        return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(value), "` supplied to `").concat(componentName, "`, length must be between ").concat(min, " and ").concat(max, "."));
      }
    }
    return null;
  };
};
var isHandLength = isNumberBetween(0, 100);
var isOppositeHandLength = isNumberBetween(-100, 100);
var isHandWidth = function isHandWidth2(props, propName, componentName) {
  var width = props[propName];
  if (isDefined(width)) {
    if (typeof width !== "number") {
      return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(width), "` supplied to `").concat(componentName, "`, expected `number`."));
    }
    if (width < 0) {
      return new Error("Invalid prop `".concat(propName, "` of type `").concat(_typeof(width), "` supplied to `").concat(componentName, "`, width must be greater or equal to 0."));
    }
  }
  return null;
};
var isMarkLength = isHandLength;
var isMarkWidth = isHandWidth;

// node_modules/react-clock/dist/esm/Hand.js
function Hand(_ref3) {
  var _ref$angle = _ref3.angle, angle = _ref$angle === void 0 ? 0 : _ref$angle, name2 = _ref3.name, _ref$length = _ref3.length, length2 = _ref$length === void 0 ? 100 : _ref$length, _ref$oppositeLength = _ref3.oppositeLength, oppositeLength = _ref$oppositeLength === void 0 ? 10 : _ref$oppositeLength, _ref$width = _ref3.width, width = _ref$width === void 0 ? 1 : _ref$width;
  return /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "react-clock__hand react-clock__".concat(name2, "-hand"),
    style: {
      transform: "rotate(".concat(angle, "deg)")
    }
  }, /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "react-clock__hand__body react-clock__".concat(name2, "-hand__body"),
    style: {
      width: "".concat(width, "px"),
      top: "".concat(50 - length2 / 2, "%"),
      bottom: "".concat(50 - oppositeLength / 2, "%")
    }
  }));
}
Hand.propTypes = {
  angle: import_prop_types.default.number,
  length: isHandLength,
  name: import_prop_types.default.string.isRequired,
  oppositeLength: isHandLength,
  width: import_prop_types.default.number
};

// node_modules/react-clock/dist/esm/Mark.js
var import_react6 = __toModule(require("react"));
var import_prop_types2 = __toModule(require_prop_types());
function Mark(_ref3) {
  var _ref$angle = _ref3.angle, angle = _ref$angle === void 0 ? 0 : _ref$angle, _ref$length = _ref3.length, length2 = _ref$length === void 0 ? 10 : _ref$length, name2 = _ref3.name, _ref$width = _ref3.width, width = _ref$width === void 0 ? 1 : _ref$width, number = _ref3.number;
  return /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark react-clock__".concat(name2, "-mark"),
    style: {
      transform: "rotate(".concat(angle, "deg)")
    }
  }, /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark__body react-clock__".concat(name2, "-mark__body"),
    style: {
      width: "".concat(width, "px"),
      top: 0,
      bottom: "".concat(100 - length2 / 2, "%")
    }
  }), number && /* @__PURE__ */ import_react6.default.createElement("div", {
    className: "react-clock__mark__number",
    style: {
      transform: "rotate(-".concat(angle, "deg)"),
      top: "".concat(length2 / 2, "%")
    }
  }, number));
}
Mark.propTypes = {
  angle: import_prop_types2.default.number,
  length: isMarkLength,
  name: import_prop_types2.default.string.isRequired,
  number: import_prop_types2.default.number,
  width: isMarkWidth
};

// node_modules/react-clock/dist/esm/Clock.js
function Clock2(_ref3) {
  var className = _ref3.className, _ref$hourHandLength = _ref3.hourHandLength, hourHandLength = _ref$hourHandLength === void 0 ? 50 : _ref$hourHandLength, hourHandOppositeLength = _ref3.hourHandOppositeLength, _ref$hourHandWidth = _ref3.hourHandWidth, hourHandWidth = _ref$hourHandWidth === void 0 ? 4 : _ref$hourHandWidth, _ref$hourMarksLength = _ref3.hourMarksLength, hourMarksLength = _ref$hourMarksLength === void 0 ? 10 : _ref$hourMarksLength, _ref$hourMarksWidth = _ref3.hourMarksWidth, hourMarksWidth = _ref$hourMarksWidth === void 0 ? 3 : _ref$hourMarksWidth, _ref$minuteHandLength = _ref3.minuteHandLength, minuteHandLength = _ref$minuteHandLength === void 0 ? 70 : _ref$minuteHandLength, minuteHandOppositeLength = _ref3.minuteHandOppositeLength, _ref$minuteHandWidth = _ref3.minuteHandWidth, minuteHandWidth = _ref$minuteHandWidth === void 0 ? 2 : _ref$minuteHandWidth, _ref$minuteMarksLengt = _ref3.minuteMarksLength, minuteMarksLength = _ref$minuteMarksLengt === void 0 ? 6 : _ref$minuteMarksLengt, _ref$minuteMarksWidth = _ref3.minuteMarksWidth, minuteMarksWidth = _ref$minuteMarksWidth === void 0 ? 1 : _ref$minuteMarksWidth, _ref$renderHourMarks = _ref3.renderHourMarks, renderHourMarks = _ref$renderHourMarks === void 0 ? true : _ref$renderHourMarks, _ref$renderMinuteHand = _ref3.renderMinuteHand, renderMinuteHand = _ref$renderMinuteHand === void 0 ? true : _ref$renderMinuteHand, _ref$renderMinuteMark = _ref3.renderMinuteMarks, renderMinuteMarks = _ref$renderMinuteMark === void 0 ? true : _ref$renderMinuteMark, renderNumbers = _ref3.renderNumbers, _ref$renderSecondHand = _ref3.renderSecondHand, renderSecondHand = _ref$renderSecondHand === void 0 ? true : _ref$renderSecondHand, _ref$secondHandLength = _ref3.secondHandLength, secondHandLength = _ref$secondHandLength === void 0 ? 90 : _ref$secondHandLength, secondHandOppositeLength = _ref3.secondHandOppositeLength, _ref$secondHandWidth = _ref3.secondHandWidth, secondHandWidth = _ref$secondHandWidth === void 0 ? 1 : _ref$secondHandWidth, _ref$size = _ref3.size, size = _ref$size === void 0 ? 150 : _ref$size, value = _ref3.value;
  function renderMinuteMarksFn() {
    if (!renderMinuteMarks) {
      return null;
    }
    var minuteMarks = [];
    for (var i2 = 1; i2 <= 60; i2 += 1) {
      var isHourMark = renderHourMarks && !(i2 % 5);
      if (!isHourMark) {
        minuteMarks.push(/* @__PURE__ */ import_react7.default.createElement(Mark, {
          key: "minute_".concat(i2),
          angle: i2 * 6,
          length: minuteMarksLength,
          name: "minute",
          width: minuteMarksWidth
        }));
      }
    }
    return minuteMarks;
  }
  function renderHourMarksFn() {
    if (!renderHourMarks) {
      return null;
    }
    var hourMarks = [];
    for (var i2 = 1; i2 <= 12; i2 += 1) {
      hourMarks.push(/* @__PURE__ */ import_react7.default.createElement(Mark, {
        key: "hour_".concat(i2),
        angle: i2 * 30,
        length: hourMarksLength,
        name: "hour",
        number: renderNumbers ? i2 : null,
        width: hourMarksWidth
      }));
    }
    return hourMarks;
  }
  function renderFace() {
    return /* @__PURE__ */ import_react7.default.createElement("div", {
      className: "react-clock__face"
    }, renderMinuteMarksFn(), renderHourMarksFn());
  }
  function renderHourHandFn() {
    var angle = value ? getHours(value) * 30 + getMinutes(value) / 2 + getSeconds(value) / 600 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: hourHandLength,
      name: "hour",
      oppositeLength: hourHandOppositeLength,
      width: hourHandWidth
    });
  }
  function renderMinuteHandFn() {
    if (!renderMinuteHand) {
      return null;
    }
    var angle = value ? getHours(value) * 360 + getMinutes(value) * 6 + getSeconds(value) / 10 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: minuteHandLength,
      name: "minute",
      oppositeLength: minuteHandOppositeLength,
      width: minuteHandWidth
    });
  }
  function renderSecondHandFn() {
    if (!renderSecondHand) {
      return null;
    }
    var angle = value ? getMinutes(value) * 360 + getSeconds(value) * 6 : 0;
    return /* @__PURE__ */ import_react7.default.createElement(Hand, {
      angle,
      length: secondHandLength,
      name: "second",
      oppositeLength: secondHandOppositeLength,
      width: secondHandWidth
    });
  }
  return /* @__PURE__ */ import_react7.default.createElement("time", {
    className: mergeClassNames("react-clock", className),
    dateTime: value instanceof Date ? value.toISOString() : value,
    style: {
      width: "".concat(size, "px"),
      height: "".concat(size, "px")
    }
  }, renderFace(), renderHourHandFn(), renderMinuteHandFn(), renderSecondHandFn());
}
Clock2.propTypes = {
  className: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.arrayOf(import_prop_types3.default.string)]),
  hourHandLength: isHandLength,
  hourHandOppositeLength: isOppositeHandLength,
  hourHandWidth: isHandWidth,
  hourMarksLength: isMarkLength,
  hourMarksWidth: isMarkWidth,
  minuteHandLength: isHandLength,
  minuteHandOppositeLength: isOppositeHandLength,
  minuteHandWidth: isHandWidth,
  minuteMarksLength: isMarkLength,
  minuteMarksWidth: isMarkWidth,
  renderHourMarks: import_prop_types3.default.bool,
  renderMinuteHand: import_prop_types3.default.bool,
  renderMinuteMarks: import_prop_types3.default.bool,
  renderNumbers: import_prop_types3.default.bool,
  renderSecondHand: import_prop_types3.default.bool,
  secondHandLength: isHandLength,
  secondHandOppositeLength: isOppositeHandLength,
  secondHandWidth: isHandWidth,
  size: import_prop_types3.default.number,
  value: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.instanceOf(Date)])
};

// node_modules/react-clock/dist/esm/index.js
var esm_default = Clock2;

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/react-jss/dist/react-jss.esm.js
var import_react9 = __toModule(require("react"));
var import_hoist_non_react_statics2 = __toModule(require_hoist_non_react_statics_cjs());

// node_modules/theming/dist/theming.esm.js
var import_react8 = __toModule(require("react"));

// node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction = true;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x2) {
    }
  }
}
var tiny_warning_esm_default = warning;

// node_modules/theming/dist/theming.esm.js
var import_prop_types4 = __toModule(require_prop_types());
var import_hoist_non_react_statics = __toModule(require_hoist_non_react_statics_cjs());
var import_react_display_name = __toModule(require_getDisplayName());
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function createThemeProvider(context) {
  var ThemeProvider2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose2(ThemeProvider3, _React$Component);
    function ThemeProvider3() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "cachedTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "lastOuterTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "lastTheme", void 0);
      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "renderProvider", function(outerTheme) {
        var children = _this.props.children;
        return import_react8.default.createElement(context.Provider, {
          value: _this.getTheme(outerTheme)
        }, children);
      });
      return _this;
    }
    var _proto = ThemeProvider3.prototype;
    _proto.getTheme = function getTheme(outerTheme) {
      if (this.props.theme !== this.lastTheme || outerTheme !== this.lastOuterTheme || !this.cachedTheme) {
        this.lastOuterTheme = outerTheme;
        this.lastTheme = this.props.theme;
        if (typeof this.lastTheme === "function") {
          var theme = this.props.theme;
          this.cachedTheme = theme(outerTheme);
          false ? tiny_warning_esm_default(isObject(this.cachedTheme), "[ThemeProvider] Please return an object from your theme function") : void 0;
        } else {
          var _theme = this.props.theme;
          false ? tiny_warning_esm_default(isObject(_theme), "[ThemeProvider] Please make your theme prop a plain object") : void 0;
          this.cachedTheme = outerTheme ? _extends2({}, outerTheme, _theme) : _theme;
        }
      }
      return this.cachedTheme;
    };
    _proto.render = function render2() {
      var children = this.props.children;
      if (!children) {
        return null;
      }
      return import_react8.default.createElement(context.Consumer, null, this.renderProvider);
    };
    return ThemeProvider3;
  }(import_react8.default.Component);
  if (false) {
    ThemeProvider2.propTypes = {
      children: import_prop_types4.default.node,
      theme: import_prop_types4.default.oneOfType([import_prop_types4.default.shape({}), import_prop_types4.default.func]).isRequired
    };
  }
  return ThemeProvider2;
}
function createWithTheme(context) {
  return function hoc(Component6) {
    var withTheme2 = import_react8.default.forwardRef(function(props, ref) {
      return import_react8.default.createElement(context.Consumer, null, function(theme) {
        false ? tiny_warning_esm_default(isObject(theme), "[theming] Please use withTheme only with the ThemeProvider") : void 0;
        return import_react8.default.createElement(Component6, _extends2({
          theme,
          ref
        }, props));
      });
    });
    if (false) {
      withTheme2.displayName = "WithTheme(" + (0, import_react_display_name.default)(Component6) + ")";
    }
    (0, import_hoist_non_react_statics.default)(withTheme2, Component6);
    return withTheme2;
  };
}
function createUseTheme(context) {
  var useTheme2 = function useTheme3() {
    var theme = import_react8.default.useContext(context);
    false ? tiny_warning_esm_default(isObject(theme), "[theming] Please use useTheme only with the ThemeProvider") : void 0;
    return theme;
  };
  return useTheme2;
}
function createTheming(context) {
  return {
    context,
    withTheme: createWithTheme(context),
    useTheme: createUseTheme(context),
    ThemeProvider: createThemeProvider(context)
  };
}
var ThemeContext = (0, import_react8.createContext)();
var _createTheming = createTheming(ThemeContext);
var withTheme = _createTheming.withTheme;
var ThemeProvider = _createTheming.ThemeProvider;
var useTheme = _createTheming.useTheme;

// node_modules/is-in-browser/dist/module.js
var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = (typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof2(document)) === "object" && document.nodeType === 9;
var module_default = isBrowser;

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/jss/dist/jss.esm.js
var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== "object")
    return style;
  if (Array.isArray(style))
    return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor)
    return style;
  var newStyle = {};
  for (var name2 in style) {
    newStyle[name2] = cloneStyle(style[name2]);
  }
  return newStyle;
}
function createRule(name2, decl, options2) {
  if (name2 === void 0) {
    name2 = "unnamed";
  }
  var jss3 = options2.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss3.plugins.onCreateRule(name2, declCopy, options2);
  if (rule)
    return rule;
  if (name2[0] === "@") {
    false ? tiny_warning_esm_default(false, "[JSS] Unknown rule " + name2) : void 0;
  }
  return null;
}
var join = function join2(value, by) {
  var result = "";
  for (var i2 = 0; i2 < value.length; i2++) {
    if (value[i2] === "!important")
      break;
    if (result)
      result += by;
    result += value[i2];
  }
  return result;
};
var toCssValue = function toCssValue2(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }
  if (!Array.isArray(value))
    return value;
  var cssValue = "";
  if (Array.isArray(value[0])) {
    for (var i2 = 0; i2 < value.length; i2++) {
      if (value[i2] === "!important")
        break;
      if (cssValue)
        cssValue += ", ";
      cssValue += join(value[i2], " ");
    }
  } else
    cssValue = join(value, ", ");
  if (!ignoreImportant && value[value.length - 1] === "!important") {
    cssValue += " !important";
  }
  return cssValue;
};
function indentStr(str, indent) {
  var result = "";
  for (var index4 = 0; index4 < indent; index4++) {
    result += "  ";
  }
  return result + str;
}
function toCss(selector, style, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var result = "";
  if (!style)
    return result;
  var _options = options2, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector)
    indent++;
  if (fallbacks) {
    if (Array.isArray(fallbacks)) {
      for (var index4 = 0; index4 < fallbacks.length; index4++) {
        var fallback = fallbacks[index4];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            if (result)
              result += "\n";
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];
        if (_value != null) {
          if (result)
            result += "\n";
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }
  for (var _prop2 in style) {
    var _value2 = style[_prop2];
    if (_value2 != null && _prop2 !== "fallbacks") {
      if (result)
        result += "\n";
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  }
  if (!result && !options2.allowEmpty)
    return result;
  if (!selector)
    return result;
  indent--;
  if (result)
    result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr("}", indent);
}
var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== "undefined" && CSS.escape;
var escape2 = function(str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, "\\$1");
};
var BaseStyleRule = /* @__PURE__ */ function() {
  function BaseStyleRule2(key, style, options2) {
    this.type = "style";
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options2.sheet, Renderer2 = options2.Renderer;
    this.key = key;
    this.options = options2;
    this.style = style;
    if (sheet)
      this.renderer = sheet.renderer;
    else if (Renderer2)
      this.renderer = new Renderer2();
  }
  var _proto = BaseStyleRule2.prototype;
  _proto.prop = function prop(name2, value, options2) {
    if (value === void 0)
      return this.style[name2];
    var force = options2 ? options2.force : false;
    if (!force && this.style[name2] === value)
      return this;
    var newValue = value;
    if (!options2 || options2.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name2, this);
    }
    var isEmpty = newValue == null || newValue === false;
    var isDefined3 = name2 in this.style;
    if (isEmpty && !isDefined3 && !force)
      return this;
    var remove = isEmpty && isDefined3;
    if (remove)
      delete this.style[name2];
    else
      this.style[name2] = newValue;
    if (this.renderable && this.renderer) {
      if (remove)
        this.renderer.removeProperty(this.renderable, name2);
      else
        this.renderer.setProperty(this.renderable, name2, newValue);
      return this;
    }
    var sheet = this.options.sheet;
    if (sheet && sheet.attached) {
      false ? tiny_warning_esm_default(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : void 0;
    }
    return this;
  };
  return BaseStyleRule2;
}();
var StyleRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(StyleRule2, _BaseStyleRule);
  function StyleRule2(key, style, options2) {
    var _this;
    _this = _BaseStyleRule.call(this, key, style, options2) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options2.selector, scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized2(_assertThisInitialized2(_this)), sheet);
      _this.selectorText = "." + escape2(_this.id);
    }
    return _this;
  }
  var _proto2 = StyleRule2.prototype;
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;
    if (renderer) {
      var json = this.toJSON();
      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }
    return this;
  };
  _proto2.toJSON = function toJSON2() {
    var json = {};
    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== "object")
        json[prop] = value;
      else if (Array.isArray(value))
        json[prop] = toCssValue(value);
    }
    return json;
  };
  _proto2.toString = function toString(options2) {
    var sheet = this.options.sheet;
    var link2 = sheet ? sheet.options.link : false;
    var opts = link2 ? _extends({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.selectorText, this.style, opts);
  };
  _createClass(StyleRule2, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText)
        return;
      this.selectorText = selector;
      var renderer = this.renderer, renderable = this.renderable;
      if (!renderable || !renderer)
        return;
      var hasChanged = renderer.setSelector(renderable, selector);
      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    },
    get: function get() {
      return this.selectorText;
    }
  }]);
  return StyleRule2;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name2, style, options2) {
    if (name2[0] === "@" || options2.parent && options2.parent.type === "keyframes") {
      return null;
    }
    return new StyleRule(name2, style, options2);
  }
};
var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
var ConditionalRule = /* @__PURE__ */ function() {
  function ConditionalRule2(key, styles, options2) {
    this.type = "conditional";
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : "unknown";
    this.query = options2.name || "@" + this.at;
    this.options = options2;
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var name2 in styles) {
      this.rules.add(name2, styles[name2]);
    }
    this.rules.process();
  }
  var _proto = ConditionalRule2.prototype;
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.addRule = function addRule(name2, style, options2) {
    var rule = this.rules.add(name2, style, options2);
    if (!rule)
      return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.toString = function toString(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions;
    }
    if (options2.indent == null)
      options2.indent = defaultToStringOptions.indent;
    if (options2.children == null)
      options2.children = defaultToStringOptions.children;
    if (options2.children === false) {
      return this.query + " {}";
    }
    var children = this.rules.toString(options2);
    return children ? this.query + " {\n" + children + "\n}" : "";
  };
  return ConditionalRule2;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule2(key, styles, options2) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options2) : null;
  }
};
var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
var KeyframesRule = /* @__PURE__ */ function() {
  function KeyframesRule2(key, frames, options2) {
    this.type = "keyframes";
    this.at = "@keyframes";
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);
    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = "noname";
      false ? tiny_warning_esm_default(false, "[JSS] Bad keyframes name " + key) : void 0;
    }
    this.key = this.type + "-" + this.name;
    this.options = options2;
    var scoped = options2.scoped, sheet = options2.sheet, generateId = options2.generateId;
    this.id = scoped === false ? this.name : escape2(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var name2 in frames) {
      this.rules.add(name2, frames[name2], _extends({}, options2, {
        parent: this
      }));
    }
    this.rules.process();
  }
  var _proto = KeyframesRule2.prototype;
  _proto.toString = function toString(options2) {
    if (options2 === void 0) {
      options2 = defaultToStringOptions$1;
    }
    if (options2.indent == null)
      options2.indent = defaultToStringOptions$1.indent;
    if (options2.children == null)
      options2.children = defaultToStringOptions$1.children;
    if (options2.children === false) {
      return this.at + " " + this.id + " {}";
    }
    var children = this.rules.toString(options2);
    if (children)
      children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };
  return KeyframesRule2;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;
var findReferencedKeyframe = function findReferencedKeyframe2(val, keyframes3) {
  if (typeof val === "string") {
    return val.replace(refRegExp, function(match2, name2) {
      if (name2 in keyframes3) {
        return keyframes3[name2];
      }
      false ? tiny_warning_esm_default(false, '[JSS] Referenced keyframes rule "' + name2 + '" is not defined.') : void 0;
      return match2;
    });
  }
  return val;
};
var replaceRef = function replaceRef2(style, prop, keyframes3) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes3);
  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};
var plugin = {
  onCreateRule: function onCreateRule3(key, frames, options2) {
    return typeof key === "string" && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options2) : null;
  },
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== "style" || !sheet)
      return style;
    if ("animation-name" in style)
      replaceRef(style, "animation-name", sheet.keyframes);
    if ("animation" in style)
      replaceRef(style, "animation", sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;
    if (!sheet) {
      return val;
    }
    switch (prop) {
      case "animation":
        return findReferencedKeyframe(val, sheet.keyframes);
      case "animation-name":
        return findReferencedKeyframe(val, sheet.keyframes);
      default:
        return val;
    }
  }
};
var KeyframeRule = /* @__PURE__ */ function(_BaseStyleRule) {
  _inheritsLoose(KeyframeRule2, _BaseStyleRule);
  function KeyframeRule2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }
  var _proto = KeyframeRule2.prototype;
  _proto.toString = function toString(options2) {
    var sheet = this.options.sheet;
    var link2 = sheet ? sheet.options.link : false;
    var opts = link2 ? _extends({}, options2, {
      allowEmpty: true
    }) : options2;
    return toCss(this.key, this.style, opts);
  };
  return KeyframeRule2;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule4(key, style, options2) {
    if (options2.parent && options2.parent.type === "keyframes") {
      return new KeyframeRule(key, style, options2);
    }
    return null;
  }
};
var FontFaceRule = /* @__PURE__ */ function() {
  function FontFaceRule2(key, style, options2) {
    this.type = "font-face";
    this.at = "@font-face";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options2;
  }
  var _proto = FontFaceRule2.prototype;
  _proto.toString = function toString(options2) {
    if (Array.isArray(this.style)) {
      var str = "";
      for (var index4 = 0; index4 < this.style.length; index4++) {
        str += toCss(this.at, this.style[index4]);
        if (this.style[index4 + 1])
          str += "\n";
      }
      return str;
    }
    return toCss(this.at, this.style, options2);
  };
  return FontFaceRule2;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule5(key, style, options2) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options2) : null;
  }
};
var ViewportRule = /* @__PURE__ */ function() {
  function ViewportRule2(key, style, options2) {
    this.type = "viewport";
    this.at = "@viewport";
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options2;
  }
  var _proto = ViewportRule2.prototype;
  _proto.toString = function toString(options2) {
    return toCss(this.key, this.style, options2);
  };
  return ViewportRule2;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule6(key, style, options2) {
    return key === "@viewport" || key === "@-ms-viewport" ? new ViewportRule(key, style, options2) : null;
  }
};
var SimpleRule = /* @__PURE__ */ function() {
  function SimpleRule2(key, value, options2) {
    this.type = "simple";
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options2;
  }
  var _proto = SimpleRule2.prototype;
  _proto.toString = function toString(options2) {
    if (Array.isArray(this.value)) {
      var str = "";
      for (var index4 = 0; index4 < this.value.length; index4++) {
        str += this.key + " " + this.value[index4] + ";";
        if (this.value[index4 + 1])
          str += "\n";
      }
      return str;
    }
    return this.key + " " + this.value + ";";
  };
  return SimpleRule2;
}();
var keysMap = {
  "@charset": true,
  "@import": true,
  "@namespace": true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule7(key, value, options2) {
    return key in keysMap ? new SimpleRule(key, value, options2) : null;
  }
};
var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
};
var RuleList = /* @__PURE__ */ function() {
  function RuleList2(options2) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options2;
    this.classes = options2.classes;
    this.keyframes = options2.keyframes;
  }
  var _proto = RuleList2.prototype;
  _proto.add = function add(name2, decl, ruleOptions) {
    var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss3 = _this$options.jss, Renderer2 = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;
    var options2 = _extends({
      classes: this.classes,
      parent,
      sheet,
      jss: jss3,
      Renderer: Renderer2,
      generateId,
      scoped,
      name: name2,
      keyframes: this.keyframes,
      selector: void 0
    }, ruleOptions);
    var key = name2;
    if (name2 in this.raw) {
      key = name2 + "-d" + this.counter++;
    }
    this.raw[key] = decl;
    if (key in this.classes) {
      options2.selector = "." + escape2(this.classes[key]);
    }
    var rule = createRule(key, decl, options2);
    if (!rule)
      return null;
    this.register(rule);
    var index4 = options2.index === void 0 ? this.index.length : options2.index;
    this.index.splice(index4, 0, rule);
    return rule;
  };
  _proto.get = function get(name2) {
    return this.map[name2];
  };
  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  };
  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  };
  _proto.process = function process2() {
    var plugins3 = this.options.jss.plugins;
    this.index.slice(0).forEach(plugins3.onProcessRule, plugins3);
  };
  _proto.register = function register(rule) {
    this.map[rule.key] = rule;
    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id)
        this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  };
  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];
    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  };
  _proto.update = function update() {
    var name2;
    var data2;
    var options2;
    if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "string") {
      name2 = arguments.length <= 0 ? void 0 : arguments[0];
      data2 = arguments.length <= 1 ? void 0 : arguments[1];
      options2 = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      data2 = arguments.length <= 0 ? void 0 : arguments[0];
      options2 = arguments.length <= 1 ? void 0 : arguments[1];
      name2 = null;
    }
    if (name2) {
      this.updateOne(this.map[name2], data2, options2);
    } else {
      for (var index4 = 0; index4 < this.index.length; index4++) {
        this.updateOne(this.index[index4], data2, options2);
      }
    }
  };
  _proto.updateOne = function updateOne(rule, data2, options2) {
    if (options2 === void 0) {
      options2 = defaultUpdateOptions;
    }
    var _this$options2 = this.options, plugins3 = _this$options2.jss.plugins, sheet = _this$options2.sheet;
    if (rule.rules instanceof RuleList2) {
      rule.rules.update(data2, options2);
      return;
    }
    var styleRule = rule;
    var style = styleRule.style;
    plugins3.onUpdate(data2, rule, sheet, options2);
    if (options2.process && style && style !== styleRule.style) {
      plugins3.onProcessStyle(styleRule.style, styleRule, sheet);
      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop];
        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      }
      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop];
        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  };
  _proto.toString = function toString(options2) {
    var str = "";
    var sheet = this.options.sheet;
    var link2 = sheet ? sheet.options.link : false;
    for (var index4 = 0; index4 < this.index.length; index4++) {
      var rule = this.index[index4];
      var css7 = rule.toString(options2);
      if (!css7 && !link2)
        continue;
      if (str)
        str += "\n";
      str += css7;
    }
    return str;
  };
  return RuleList2;
}();
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet3(styles, options2) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options2, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });
    if (options2.Renderer) {
      this.renderer = new options2.Renderer(this);
    }
    this.rules = new RuleList(this.options);
    for (var name2 in styles) {
      this.rules.add(name2, styles[name2]);
    }
    this.rules.process();
  }
  var _proto = StyleSheet3.prototype;
  _proto.attach = function attach() {
    if (this.attached)
      return this;
    if (this.renderer)
      this.renderer.attach();
    this.attached = true;
    if (!this.deployed)
      this.deploy();
    return this;
  };
  _proto.detach = function detach() {
    if (!this.attached)
      return this;
    if (this.renderer)
      this.renderer.detach();
    this.attached = false;
    return this;
  };
  _proto.addRule = function addRule(name2, decl, options2) {
    var queue = this.queue;
    if (this.attached && !queue)
      this.queue = [];
    var rule = this.rules.add(name2, decl, options2);
    if (!rule)
      return null;
    this.options.jss.plugins.onProcessRule(rule);
    if (this.attached) {
      if (!this.deployed)
        return rule;
      if (queue)
        queue.push(rule);
      else {
        this.insertRule(rule);
        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = void 0;
        }
      }
      return rule;
    }
    this.deployed = false;
    return rule;
  };
  _proto.insertRule = function insertRule2(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  };
  _proto.addRules = function addRules(styles, options2) {
    var added = [];
    for (var name2 in styles) {
      var rule = this.addRule(name2, styles[name2], options2);
      if (rule)
        added.push(rule);
    }
    return added;
  };
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.deleteRule = function deleteRule(name2) {
    var rule = typeof name2 === "object" ? name2 : this.rules.get(name2);
    if (!rule || this.attached && !rule.renderable) {
      return false;
    }
    this.rules.remove(rule);
    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }
    return true;
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.deploy = function deploy() {
    if (this.renderer)
      this.renderer.deploy();
    this.deployed = true;
    return this;
  };
  _proto.update = function update() {
    var _this$rules;
    (_this$rules = this.rules).update.apply(_this$rules, arguments);
    return this;
  };
  _proto.updateOne = function updateOne(rule, data2, options2) {
    this.rules.updateOne(rule, data2, options2);
    return this;
  };
  _proto.toString = function toString(options2) {
    return this.rules.toString(options2);
  };
  return StyleSheet3;
}();
var PluginsRegistry = /* @__PURE__ */ function() {
  function PluginsRegistry2() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }
  var _proto = PluginsRegistry2.prototype;
  _proto.onCreateRule = function onCreateRule8(name2, decl, options2) {
    for (var i2 = 0; i2 < this.registry.onCreateRule.length; i2++) {
      var rule = this.registry.onCreateRule[i2](name2, decl, options2);
      if (rule)
        return rule;
    }
    return null;
  };
  _proto.onProcessRule = function onProcessRule3(rule) {
    if (rule.isProcessed)
      return;
    var sheet = rule.options.sheet;
    for (var i2 = 0; i2 < this.registry.onProcessRule.length; i2++) {
      this.registry.onProcessRule[i2](rule, sheet);
    }
    if (rule.style)
      this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  };
  _proto.onProcessStyle = function onProcessStyle2(style, rule, sheet) {
    for (var i2 = 0; i2 < this.registry.onProcessStyle.length; i2++) {
      rule.style = this.registry.onProcessStyle[i2](rule.style, rule, sheet);
    }
  };
  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i2 = 0; i2 < this.registry.onProcessSheet.length; i2++) {
      this.registry.onProcessSheet[i2](sheet);
    }
  };
  _proto.onUpdate = function onUpdate(data2, rule, sheet, options2) {
    for (var i2 = 0; i2 < this.registry.onUpdate.length; i2++) {
      this.registry.onUpdate[i2](data2, rule, sheet, options2);
    }
  };
  _proto.onChangeValue = function onChangeValue2(value, prop, rule) {
    var processedValue = value;
    for (var i2 = 0; i2 < this.registry.onChangeValue.length; i2++) {
      processedValue = this.registry.onChangeValue[i2](processedValue, prop, rule);
    }
    return processedValue;
  };
  _proto.use = function use(newPlugin, options2) {
    if (options2 === void 0) {
      options2 = {
        queue: "external"
      };
    }
    var plugins3 = this.plugins[options2.queue];
    if (plugins3.indexOf(newPlugin) !== -1) {
      return;
    }
    plugins3.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry2, plugin2) {
      for (var name2 in plugin2) {
        if (name2 in registry2) {
          registry2[name2].push(plugin2[name2]);
        } else {
          false ? tiny_warning_esm_default(false, '[JSS] Unknown hook "' + name2 + '".') : void 0;
        }
      }
      return registry2;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };
  return PluginsRegistry2;
}();
var SheetsRegistry = /* @__PURE__ */ function() {
  function SheetsRegistry2() {
    this.registry = [];
  }
  var _proto = SheetsRegistry2.prototype;
  _proto.add = function add(sheet) {
    var registry2 = this.registry;
    var index4 = sheet.options.index;
    if (registry2.indexOf(sheet) !== -1)
      return;
    if (registry2.length === 0 || index4 >= this.index) {
      registry2.push(sheet);
      return;
    }
    for (var i2 = 0; i2 < registry2.length; i2++) {
      if (registry2[i2].options.index > index4) {
        registry2.splice(i2, 0, sheet);
        return;
      }
    }
  };
  _proto.reset = function reset() {
    this.registry = [];
  };
  _proto.remove = function remove(sheet) {
    var index4 = this.registry.indexOf(sheet);
    this.registry.splice(index4, 1);
  };
  _proto.toString = function toString(_temp) {
    var _ref3 = _temp === void 0 ? {} : _temp, attached = _ref3.attached, options2 = _objectWithoutPropertiesLoose(_ref3, ["attached"]);
    var css7 = "";
    for (var i2 = 0; i2 < this.registry.length; i2++) {
      var sheet = this.registry[i2];
      if (attached != null && sheet.attached !== attached) {
        continue;
      }
      if (css7)
        css7 += "\n";
      css7 += sheet.toString(options2);
    }
    return css7;
  };
  _createClass(SheetsRegistry2, [{
    key: "index",
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);
  return SheetsRegistry2;
}();
var registry = new SheetsRegistry();
var globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
var ns = "2f1acc6c3a606b082e5eef5e54414ffb";
if (globalThis$1[ns] == null)
  globalThis$1[ns] = 0;
var moduleId = globalThis$1[ns]++;
var maxRules = 1e10;
var createGenerateId = function createGenerateId2(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var ruleCounter = 0;
  return function(rule, sheet) {
    ruleCounter += 1;
    if (ruleCounter > maxRules) {
      false ? tiny_warning_esm_default(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : void 0;
    }
    var jssId = "";
    var prefix3 = "";
    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix3 = sheet.options.classNamePrefix;
      }
      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }
    if (options2.minify) {
      return "" + (prefix3 || "c") + moduleId + jssId + ruleCounter;
    }
    return prefix3 + rule.key + "-" + moduleId + (jssId ? "-" + jssId : "") + "-" + ruleCounter;
  };
};
var memoize = function memoize2(fn) {
  var value;
  return function() {
    if (!value)
      value = fn();
    return value;
  };
};
var getPropertyValue = function getPropertyValue2(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    return "";
  }
};
var setProperty = function setProperty2(cssRule, prop, value) {
  try {
    var cssValue = value;
    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);
      if (value[value.length - 1] === "!important") {
        cssRule.style.setProperty(prop, cssValue, "important");
        return true;
      }
    }
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    return false;
  }
  return true;
};
var removeProperty = function removeProperty2(cssRule, prop) {
  try {
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    false ? tiny_warning_esm_default(false, '[JSS] DOMException "' + err.message + '" was thrown. Tried to remove property "' + prop + '".') : void 0;
  }
};
var setSelector = function setSelector2(cssRule, selectorText) {
  cssRule.selectorText = selectorText;
  return cssRule.selectorText === selectorText;
};
var getHead = memoize(function() {
  return document.querySelector("head");
});
function findHigherSheet(registry2, options2) {
  for (var i2 = 0; i2 < registry2.length; i2++) {
    var sheet = registry2[i2];
    if (sheet.attached && sheet.options.index > options2.index && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findHighestSheet(registry2, options2) {
  for (var i2 = registry2.length - 1; i2 >= 0; i2--) {
    var sheet = registry2[i2];
    if (sheet.attached && sheet.options.insertionPoint === options2.insertionPoint) {
      return sheet;
    }
  }
  return null;
}
function findCommentNode(text) {
  var head = getHead();
  for (var i2 = 0; i2 < head.childNodes.length; i2++) {
    var node2 = head.childNodes[i2];
    if (node2.nodeType === 8 && node2.nodeValue.trim() === text) {
      return node2;
    }
  }
  return null;
}
function findPrevNode(options2) {
  var registry$1 = registry.registry;
  if (registry$1.length > 0) {
    var sheet = findHigherSheet(registry$1, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    }
    sheet = findHighestSheet(registry$1, options2);
    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  }
  var insertionPoint = options2.insertionPoint;
  if (insertionPoint && typeof insertionPoint === "string") {
    var comment2 = findCommentNode(insertionPoint);
    if (comment2) {
      return {
        parent: comment2.parentNode,
        node: comment2.nextSibling
      };
    }
    false ? tiny_warning_esm_default(false, '[JSS] Insertion point "' + insertionPoint + '" not found.') : void 0;
  }
  return false;
}
function insertStyle(style, options2) {
  var insertionPoint = options2.insertionPoint;
  var nextNode = findPrevNode(options2);
  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  }
  if (insertionPoint && typeof insertionPoint.nodeType === "number") {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode)
      parentNode.insertBefore(style, insertionPointElement.nextSibling);
    else
      false ? tiny_warning_esm_default(false, "[JSS] Insertion point is not in the DOM.") : void 0;
    return;
  }
  getHead().appendChild(style);
}
var getNonce = memoize(function() {
  var node2 = document.querySelector('meta[property="csp-nonce"]');
  return node2 ? node2.getAttribute("content") : null;
});
var _insertRule = function insertRule(container, rule, index4) {
  try {
    if ("insertRule" in container) {
      var c2 = container;
      c2.insertRule(rule, index4);
    } else if ("appendRule" in container) {
      var _c = container;
      _c.appendRule(rule);
    }
  } catch (err) {
    false ? tiny_warning_esm_default(false, "[JSS] " + err.message) : void 0;
    return false;
  }
  return container.cssRules[index4];
};
var getValidRuleInsertionIndex = function getValidRuleInsertionIndex2(container, index4) {
  var maxIndex = container.cssRules.length;
  if (index4 === void 0 || index4 > maxIndex) {
    return maxIndex;
  }
  return index4;
};
var createStyle = function createStyle2() {
  var el2 = document.createElement("style");
  el2.textContent = "\n";
  return el2;
};
var DomRenderer = /* @__PURE__ */ function() {
  function DomRenderer2(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    this.cssRules = [];
    if (sheet)
      registry.add(sheet);
    this.sheet = sheet;
    var _ref3 = this.sheet ? this.sheet.options : {}, media = _ref3.media, meta = _ref3.meta, element = _ref3.element;
    this.element = element || createStyle();
    this.element.setAttribute("data-jss", "");
    if (media)
      this.element.setAttribute("media", media);
    if (meta)
      this.element.setAttribute("data-meta", meta);
    var nonce = getNonce();
    if (nonce)
      this.element.setAttribute("nonce", nonce);
  }
  var _proto = DomRenderer2.prototype;
  _proto.attach = function attach() {
    if (this.element.parentNode || !this.sheet)
      return;
    insertStyle(this.element, this.sheet.options);
    var deployed = Boolean(this.sheet && this.sheet.deployed);
    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  };
  _proto.detach = function detach() {
    if (!this.sheet)
      return;
    var parentNode = this.element.parentNode;
    if (parentNode)
      parentNode.removeChild(this.element);
    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = "\n";
    }
  };
  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet)
      return;
    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }
    this.element.textContent = "\n" + sheet.toString() + "\n";
  };
  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i2 = 0; i2 < rules.index.length; i2++) {
      this.insertRule(rules.index[i2], i2, nativeParent);
    }
  };
  _proto.insertRule = function insertRule2(rule, index4, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }
    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;
      if (rule.type === "conditional" || rule.type === "keyframes") {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index4);
        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);
        if (latestNativeParent === false) {
          return false;
        }
        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }
      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }
    var ruleStr = rule.toString();
    if (!ruleStr)
      return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index4);
    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);
    if (nativeRule === false) {
      return false;
    }
    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };
  _proto.refCssRule = function refCssRule(rule, index4, cssRule) {
    rule.renderable = cssRule;
    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules[index4] = cssRule;
    }
  };
  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index4 = this.indexOf(cssRule);
    if (index4 === -1)
      return false;
    sheet.deleteRule(index4);
    this.cssRules.splice(index4, 1);
    return true;
  };
  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  };
  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index4 = this.indexOf(cssRule);
    if (index4 === -1)
      return false;
    this.element.sheet.deleteRule(index4);
    this.cssRules.splice(index4, 1);
    return this.insertRule(rule, index4);
  };
  _proto.getRules = function getRules3() {
    return this.element.sheet.cssRules;
  };
  return DomRenderer2;
}();
var instanceCounter = 0;
var Jss = /* @__PURE__ */ function() {
  function Jss2(options2) {
    this.id = instanceCounter++;
    this.version = "10.6.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId,
      Renderer: module_default ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });
    for (var i2 = 0; i2 < plugins.length; i2++) {
      this.plugins.use(plugins[i2], {
        queue: "internal"
      });
    }
    this.setup(options2);
  }
  var _proto = Jss2.prototype;
  _proto.setup = function setup(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (options2.createGenerateId) {
      this.options.createGenerateId = options2.createGenerateId;
    }
    if (options2.id) {
      this.options.id = _extends({}, this.options.id, options2.id);
    }
    if (options2.createGenerateId || options2.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }
    if (options2.insertionPoint != null)
      this.options.insertionPoint = options2.insertionPoint;
    if ("Renderer" in options2) {
      this.options.Renderer = options2.Renderer;
    }
    if (options2.plugins)
      this.use.apply(this, options2.plugins);
    return this;
  };
  _proto.createStyleSheet = function createStyleSheet3(styles, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    var _options = options2, index4 = _options.index;
    if (typeof index4 !== "number") {
      index4 = registry.index === 0 ? 0 : registry.index + 1;
    }
    var sheet = new StyleSheet(styles, _extends({}, options2, {
      jss: this,
      generateId: options2.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index4
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  };
  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    registry.remove(sheet);
    return this;
  };
  _proto.createRule = function createRule$1(name2, style, options2) {
    if (style === void 0) {
      style = {};
    }
    if (options2 === void 0) {
      options2 = {};
    }
    if (typeof name2 === "object") {
      return this.createRule(void 0, name2, style);
    }
    var ruleOptions = _extends({}, options2, {
      name: name2,
      jss: this,
      Renderer: this.options.Renderer
    });
    if (!ruleOptions.generateId)
      ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes)
      ruleOptions.classes = {};
    if (!ruleOptions.keyframes)
      ruleOptions.keyframes = {};
    var rule = createRule(name2, style, ruleOptions);
    if (rule)
      this.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.use = function use() {
    var _this = this;
    for (var _len = arguments.length, plugins3 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins3[_key] = arguments[_key];
    }
    plugins3.forEach(function(plugin2) {
      _this.plugins.use(plugin2);
    });
    return this;
  };
  return Jss2;
}();
function getDynamicStyles(styles) {
  var to = null;
  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;
    if (type === "function") {
      if (!to)
        to = {};
      to[key] = value;
    } else if (type === "object" && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);
      if (extracted) {
        if (!to)
          to = {};
        to[key] = extracted;
      }
    }
  }
  return to;
}
var SheetsManager = /* @__PURE__ */ function() {
  function SheetsManager2() {
    this.length = 0;
    this.sheets = new WeakMap();
  }
  var _proto = SheetsManager2.prototype;
  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };
  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key))
      return;
    this.length++;
    this.sheets.set(key, {
      sheet,
      refs: 0
    });
  };
  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);
    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }
      entry.refs++;
      return entry.sheet;
    }
    tiny_warning_esm_default(false, "[JSS] SheetsManager: can't find sheet to manage");
    return void 0;
  };
  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);
    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0)
          entry.sheet.detach();
      }
    } else {
      tiny_warning_esm_default(false, "SheetsManager: can't find sheet to unmanage");
    }
  };
  _createClass(SheetsManager2, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);
  return SheetsManager2;
}();
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */
var hasCSSTOMSupport = typeof CSS === "object" && CSS != null && "number" in CSS;
var create = function create2(options2) {
  return new Jss(options2);
};
var jss = create();
var jss_esm_default = jss;

// node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js
var now2 = Date.now();
var fnValuesNs = "fnValues" + now2;
var fnRuleNs = "fnStyle" + ++now2;
var functionPlugin = function functionPlugin2() {
  return {
    onCreateRule: function onCreateRule8(name2, decl, options2) {
      if (typeof decl !== "function")
        return null;
      var rule = createRule(name2, {}, options2);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle2(style, rule) {
      if (fnValuesNs in rule || fnRuleNs in rule)
        return style;
      var fnValues = {};
      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== "function")
          continue;
        delete style[prop];
        fnValues[prop] = value;
      }
      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data2, rule, sheet, options2) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs];
      if (fnRule) {
        styleRule.style = fnRule(data2) || {};
        if (false) {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === "function") {
              false ? tiny_warning_esm_default(false, "[JSS] Function values inside function rules are not supported.") : void 0;
              break;
            }
          }
        }
      }
      var fnValues = styleRule[fnValuesNs];
      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data2), options2);
        }
      }
    }
  };
};
var jss_plugin_rule_value_function_esm_default = functionPlugin;

// node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root) {
  var result;
  var Symbol2 = root.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      result = Symbol2("observable");
      Symbol2.observable = result;
    }
  } else {
    result = "@@observable";
  }
  return result;
}

// node_modules/jss-plugin-rule-value-observable/dist/jss-plugin-rule-value-observable.esm.js
var import_symbol_observable = __toModule(require_es());
var isObservable = function isObservable2(value) {
  return value && value[import_symbol_observable.default] && value === value[import_symbol_observable.default]();
};
var observablePlugin = function observablePlugin2(updateOptions) {
  return {
    onCreateRule: function onCreateRule8(name2, decl, options2) {
      if (!isObservable(decl))
        return null;
      var style$ = decl;
      var rule = createRule(name2, {}, options2);
      style$.subscribe(function(style) {
        for (var prop in style) {
          rule.prop(prop, style[prop], updateOptions);
        }
      });
      return rule;
    },
    onProcessRule: function onProcessRule3(rule) {
      if (rule && rule.type !== "style")
        return;
      var styleRule = rule;
      var style = styleRule.style;
      var _loop = function _loop2(prop2) {
        var value = style[prop2];
        if (!isObservable(value))
          return "continue";
        delete style[prop2];
        value.subscribe({
          next: function next2(nextValue) {
            styleRule.prop(prop2, nextValue, updateOptions);
          }
        });
      };
      for (var prop in style) {
        var _ret = _loop(prop);
        if (_ret === "continue")
          continue;
      }
    }
  };
};
var jss_plugin_rule_value_observable_esm_default = observablePlugin;

// node_modules/jss-plugin-template/dist/jss-plugin-template.esm.js
var semiWithNl = /;\n/;
var parse = function parse2(cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);
  for (var i2 = 0; i2 < split.length; i2++) {
    var decl = (split[i2] || "").trim();
    if (!decl)
      continue;
    var colonIndex = decl.indexOf(":");
    if (colonIndex === -1) {
      false ? tiny_warning_esm_default(false, '[JSS] Malformed CSS string "' + decl + '"') : void 0;
      continue;
    }
    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }
  return style;
};
var onProcessRule = function onProcessRule2(rule) {
  if (typeof rule.style === "string") {
    rule.style = parse(rule.style);
  }
};
function templatePlugin() {
  return {
    onProcessRule
  };
}
var jss_plugin_template_esm_default = templatePlugin;

// node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js
var at = "@global";
var atPrefix = "@global ";
var GlobalContainerRule = /* @__PURE__ */ function() {
  function GlobalContainerRule2(key, styles, options2) {
    this.type = "global";
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options2;
    this.rules = new RuleList(_extends({}, options2, {
      parent: this
    }));
    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }
    this.rules.process();
  }
  var _proto = GlobalContainerRule2.prototype;
  _proto.getRule = function getRule(name2) {
    return this.rules.get(name2);
  };
  _proto.addRule = function addRule(name2, style, options2) {
    var rule = this.rules.add(name2, style, options2);
    if (rule)
      this.options.jss.plugins.onProcessRule(rule);
    return rule;
  };
  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  };
  _proto.toString = function toString() {
    return this.rules.toString();
  };
  return GlobalContainerRule2;
}();
var GlobalPrefixedRule = /* @__PURE__ */ function() {
  function GlobalPrefixedRule2(key, style, options2) {
    this.type = "global";
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options2;
    var selector = key.substr(atPrefix.length);
    this.rule = options2.jss.createRule(selector, style, _extends({}, options2, {
      parent: this
    }));
  }
  var _proto2 = GlobalPrefixedRule2.prototype;
  _proto2.toString = function toString(options2) {
    return this.rule ? this.rule.toString(options2) : "";
  };
  return GlobalPrefixedRule2;
}();
var separatorRegExp = /\s*,\s*/g;
function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = "";
  for (var i2 = 0; i2 < parts.length; i2++) {
    scoped += scope + " " + parts[i2].trim();
    if (parts[i2 + 1])
      scoped += ", ";
  }
  return scoped;
}
function handleNestedGlobalContainerRule(rule, sheet) {
  var options2 = rule.options, style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules)
    return;
  for (var name2 in rules) {
    sheet.addRule(name2, rules[name2], _extends({}, options2, {
      selector: addScope(name2, rule.selector)
    }));
  }
  delete style[at];
}
function handlePrefixedGlobalRule(rule, sheet) {
  var options2 = rule.options, style = rule.style;
  for (var prop in style) {
    if (prop[0] !== "@" || prop.substr(0, at.length) !== at)
      continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], _extends({}, options2, {
      selector
    }));
    delete style[prop];
  }
}
function jssGlobal() {
  function onCreateRule8(name2, styles, options2) {
    if (!name2)
      return null;
    if (name2 === at) {
      return new GlobalContainerRule(name2, styles, options2);
    }
    if (name2[0] === "@" && name2.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name2, styles, options2);
    }
    var parent = options2.parent;
    if (parent) {
      if (parent.type === "global" || parent.options.parent && parent.options.parent.type === "global") {
        options2.scoped = false;
      }
    }
    if (options2.scoped === false) {
      options2.selector = name2;
    }
    return null;
  }
  function onProcessRule3(rule, sheet) {
    if (rule.type !== "style" || !sheet)
      return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }
  return {
    onCreateRule: onCreateRule8,
    onProcessRule: onProcessRule3
  };
}
var jss_plugin_global_esm_default = jssGlobal;

// node_modules/jss-plugin-extend/dist/jss-plugin-extend.esm.js
var isObject = function isObject2(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
};
var valueNs = "extendCurrValue" + Date.now();
function mergeExtend(style, rule, sheet, newStyle) {
  var extendType = typeof style.extend;
  if (extendType === "string") {
    if (!sheet)
      return;
    var refRule = sheet.getRule(style.extend);
    if (!refRule)
      return;
    if (refRule === rule) {
      false ? tiny_warning_esm_default(false, "[JSS] A rule tries to extend itself \n" + rule.toString()) : void 0;
      return;
    }
    var parent = refRule.options.parent;
    if (parent) {
      var originalStyle = parent.rules.raw[style.extend];
      extend(originalStyle, rule, sheet, newStyle);
    }
    return;
  }
  if (Array.isArray(style.extend)) {
    for (var index4 = 0; index4 < style.extend.length; index4++) {
      var singleExtend = style.extend[index4];
      var singleStyle = typeof singleExtend === "string" ? _extends({}, style, {
        extend: singleExtend
      }) : style.extend[index4];
      extend(singleStyle, rule, sheet, newStyle);
    }
    return;
  }
  for (var prop in style.extend) {
    if (prop === "extend") {
      extend(style.extend.extend, rule, sheet, newStyle);
      continue;
    }
    if (isObject(style.extend[prop])) {
      if (!(prop in newStyle))
        newStyle[prop] = {};
      extend(style.extend[prop], rule, sheet, newStyle[prop]);
      continue;
    }
    newStyle[prop] = style.extend[prop];
  }
}
function mergeRest(style, rule, sheet, newStyle) {
  for (var prop in style) {
    if (prop === "extend")
      continue;
    if (isObject(newStyle[prop]) && isObject(style[prop])) {
      extend(style[prop], rule, sheet, newStyle[prop]);
      continue;
    }
    if (isObject(style[prop])) {
      newStyle[prop] = extend(style[prop], rule, sheet);
      continue;
    }
    newStyle[prop] = style[prop];
  }
}
function extend(style, rule, sheet, newStyle) {
  if (newStyle === void 0) {
    newStyle = {};
  }
  mergeExtend(style, rule, sheet, newStyle);
  mergeRest(style, rule, sheet, newStyle);
  return newStyle;
}
function jssExtend() {
  function onProcessStyle2(style, rule, sheet) {
    if ("extend" in style)
      return extend(style, rule, sheet);
    return style;
  }
  function onChangeValue2(value, prop, rule) {
    if (prop !== "extend")
      return value;
    if (value == null || value === false) {
      for (var key in rule[valueNs]) {
        rule.prop(key, null);
      }
      rule[valueNs] = null;
      return null;
    }
    if (typeof value === "object") {
      for (var _key in value) {
        rule.prop(_key, value[_key]);
      }
      rule[valueNs] = value;
    }
    return null;
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_extend_esm_default = jssExtend;

// node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js
var separatorRegExp2 = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp2 = /\$([\w-]+)/g;
function jssNested() {
  function getReplaceRef(container, sheet) {
    return function(match2, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);
      if (rule) {
        rule = rule;
        return rule.selector;
      }
      false ? tiny_warning_esm_default(false, '[JSS] Could not find the referenced rule "' + key + '" in "' + (container.options.meta || container.toString()) + '".') : void 0;
      return key;
    };
  }
  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp2);
    var nestedSelectors = nestedProp.split(separatorRegExp2);
    var result = "";
    for (var i2 = 0; i2 < parentSelectors.length; i2++) {
      var parent = parentSelectors[i2];
      for (var j2 = 0; j2 < nestedSelectors.length; j2++) {
        var nested = nestedSelectors[j2];
        if (result)
          result += ", ";
        result += nested.indexOf("&") !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }
    return result;
  }
  function getOptions(rule, container, prevOptions) {
    if (prevOptions)
      return _extends({}, prevOptions, {
        index: prevOptions.index + 1
      });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === void 0 ? 1 : nestingLevel + 1;
    var options2 = _extends({}, rule.options, {
      nestingLevel,
      index: container.indexOf(rule) + 1
    });
    delete options2.name;
    return options2;
  }
  function onProcessStyle2(style, rule, sheet) {
    if (rule.type !== "style")
      return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options2;
    var replaceRef3;
    for (var prop in style) {
      var isNested = prop.indexOf("&") !== -1;
      var isNestedConditional = prop[0] === "@";
      if (!isNested && !isNestedConditional)
        continue;
      options2 = getOptions(styleRule, container, options2);
      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector);
        if (!replaceRef3)
          replaceRef3 = getReplaceRef(container, sheet);
        selector = selector.replace(refRegExp2, replaceRef3);
        container.addRule(selector, style[prop], _extends({}, options2, {
          selector
        }));
      } else if (isNestedConditional) {
        container.addRule(prop, {}, options2).addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }
      delete style[prop];
    }
    return style;
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_nested_esm_default = jssNested;

// node_modules/jss-plugin-compose/dist/jss-plugin-compose.esm.js
function registerClass(rule, className) {
  if (!className)
    return true;
  if (Array.isArray(className)) {
    for (var index4 = 0; index4 < className.length; index4++) {
      var isSetted = registerClass(rule, className[index4]);
      if (!isSetted)
        return false;
    }
    return true;
  }
  if (className.indexOf(" ") > -1) {
    return registerClass(rule, className.split(" "));
  }
  var _ref3 = rule.options, parent = _ref3.parent;
  if (className[0] === "$") {
    var refRule = parent.getRule(className.substr(1));
    if (!refRule) {
      false ? tiny_warning_esm_default(false, "[JSS] Referenced rule is not defined. \n" + rule.toString()) : void 0;
      return false;
    }
    if (refRule === rule) {
      false ? tiny_warning_esm_default(false, "[JSS] Cyclic composition detected. \n" + rule.toString()) : void 0;
      return false;
    }
    parent.classes[rule.key] += " " + parent.classes[refRule.key];
    return true;
  }
  parent.classes[rule.key] += " " + className;
  return true;
}
function jssCompose() {
  function onProcessStyle2(style, rule) {
    if (!("composes" in style))
      return style;
    registerClass(rule, style.composes);
    delete style.composes;
    return style;
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_compose_esm_default = jssCompose;

// node_modules/hyphenate-style-name/index.js
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};
function toHyphenLower(match2) {
  return "-" + match2.toLowerCase();
}
function hyphenateStyleName(name2) {
  if (cache.hasOwnProperty(name2)) {
    return cache[name2];
  }
  var hName = name2.replace(uppercasePattern, toHyphenLower);
  return cache[name2] = msPattern.test(hName) ? "-" + hName : hName;
}
var hyphenate_style_name_default = hyphenateStyleName;

// node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js
function convertCase(style) {
  var converted = {};
  for (var prop in style) {
    var key = prop.indexOf("--") === 0 ? prop : hyphenate_style_name_default(prop);
    converted[key] = style[prop];
  }
  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks))
      converted.fallbacks = style.fallbacks.map(convertCase);
    else
      converted.fallbacks = convertCase(style.fallbacks);
  }
  return converted;
}
function camelCase() {
  function onProcessStyle2(style) {
    if (Array.isArray(style)) {
      for (var index4 = 0; index4 < style.length; index4++) {
        style[index4] = convertCase(style[index4]);
      }
      return style;
    }
    return convertCase(style);
  }
  function onChangeValue2(value, prop, rule) {
    if (prop.indexOf("--") === 0) {
      return value;
    }
    var hyphenatedProp = hyphenate_style_name_default(prop);
    if (prop === hyphenatedProp)
      return value;
    rule.prop(hyphenatedProp, value);
    return null;
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_camel_case_esm_default = camelCase;

// node_modules/jss-plugin-default-unit/dist/jss-plugin-default-unit.esm.js
var px2 = hasCSSTOMSupport && CSS ? CSS.px : "px";
var ms = hasCSSTOMSupport && CSS ? CSS.ms : "ms";
var percent = hasCSSTOMSupport && CSS ? CSS.percent : "%";
var defaultUnits = {
  "animation-delay": ms,
  "animation-duration": ms,
  "background-position": px2,
  "background-position-x": px2,
  "background-position-y": px2,
  "background-size": px2,
  border: px2,
  "border-bottom": px2,
  "border-bottom-left-radius": px2,
  "border-bottom-right-radius": px2,
  "border-bottom-width": px2,
  "border-left": px2,
  "border-left-width": px2,
  "border-radius": px2,
  "border-right": px2,
  "border-right-width": px2,
  "border-top": px2,
  "border-top-left-radius": px2,
  "border-top-right-radius": px2,
  "border-top-width": px2,
  "border-width": px2,
  "border-block": px2,
  "border-block-end": px2,
  "border-block-end-width": px2,
  "border-block-start": px2,
  "border-block-start-width": px2,
  "border-block-width": px2,
  "border-inline": px2,
  "border-inline-end": px2,
  "border-inline-end-width": px2,
  "border-inline-start": px2,
  "border-inline-start-width": px2,
  "border-inline-width": px2,
  "border-start-start-radius": px2,
  "border-start-end-radius": px2,
  "border-end-start-radius": px2,
  "border-end-end-radius": px2,
  margin: px2,
  "margin-bottom": px2,
  "margin-left": px2,
  "margin-right": px2,
  "margin-top": px2,
  "margin-block": px2,
  "margin-block-end": px2,
  "margin-block-start": px2,
  "margin-inline": px2,
  "margin-inline-end": px2,
  "margin-inline-start": px2,
  padding: px2,
  "padding-bottom": px2,
  "padding-left": px2,
  "padding-right": px2,
  "padding-top": px2,
  "padding-block": px2,
  "padding-block-end": px2,
  "padding-block-start": px2,
  "padding-inline": px2,
  "padding-inline-end": px2,
  "padding-inline-start": px2,
  "mask-position-x": px2,
  "mask-position-y": px2,
  "mask-size": px2,
  height: px2,
  width: px2,
  "min-height": px2,
  "max-height": px2,
  "min-width": px2,
  "max-width": px2,
  bottom: px2,
  left: px2,
  top: px2,
  right: px2,
  inset: px2,
  "inset-block": px2,
  "inset-block-end": px2,
  "inset-block-start": px2,
  "inset-inline": px2,
  "inset-inline-end": px2,
  "inset-inline-start": px2,
  "box-shadow": px2,
  "text-shadow": px2,
  "column-gap": px2,
  "column-rule": px2,
  "column-rule-width": px2,
  "column-width": px2,
  "font-size": px2,
  "font-size-delta": px2,
  "letter-spacing": px2,
  "text-decoration-thickness": px2,
  "text-indent": px2,
  "text-stroke": px2,
  "text-stroke-width": px2,
  "word-spacing": px2,
  motion: px2,
  "motion-offset": px2,
  outline: px2,
  "outline-offset": px2,
  "outline-width": px2,
  perspective: px2,
  "perspective-origin-x": percent,
  "perspective-origin-y": percent,
  "transform-origin": percent,
  "transform-origin-x": percent,
  "transform-origin-y": percent,
  "transform-origin-z": percent,
  "transition-delay": ms,
  "transition-duration": ms,
  "vertical-align": px2,
  "flex-basis": px2,
  "shape-margin": px2,
  size: px2,
  gap: px2,
  grid: px2,
  "grid-gap": px2,
  "row-gap": px2,
  "grid-row-gap": px2,
  "grid-column-gap": px2,
  "grid-template-rows": px2,
  "grid-template-columns": px2,
  "grid-auto-rows": px2,
  "grid-auto-columns": px2,
  "box-shadow-x": px2,
  "box-shadow-y": px2,
  "box-shadow-blur": px2,
  "box-shadow-spread": px2,
  "font-line-height": px2,
  "text-shadow-x": px2,
  "text-shadow-y": px2,
  "text-shadow-blur": px2
};
function addCamelCasedVersion(obj) {
  var regExp2 = /(-[a-z])/g;
  var replace2 = function replace3(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp2, replace2)] = obj[_key];
  }
  return newObj;
}
var units = addCamelCasedVersion(defaultUnits);
function iterate(prop, value, options2) {
  if (value == null)
    return value;
  if (Array.isArray(value)) {
    for (var i2 = 0; i2 < value.length; i2++) {
      value[i2] = iterate(prop, value[i2], options2);
    }
  } else if (typeof value === "object") {
    if (prop === "fallbacks") {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options2);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options2);
      }
    }
  } else if (typeof value === "number" && isNaN(value) === false) {
    var unit = options2[prop] || units[prop];
    if (unit && !(value === 0 && unit === px2)) {
      return typeof unit === "function" ? unit(value).toString() : "" + value + unit;
    }
    return value.toString();
  }
  return value;
}
function defaultUnit(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var camelCasedOptions = addCamelCasedVersion(options2);
  function onProcessStyle2(style, rule) {
    if (rule.type !== "style")
      return style;
    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }
    return style;
  }
  function onChangeValue2(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }
  return {
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_default_unit_esm_default = defaultUnit;

// node_modules/jss-plugin-expand/dist/jss-plugin-expand.esm.js
var propArray = {
  "background-size": true,
  "background-position": true,
  border: true,
  "border-bottom": true,
  "border-left": true,
  "border-top": true,
  "border-right": true,
  "border-radius": true,
  "border-image": true,
  "border-width": true,
  "border-style": true,
  "border-color": true,
  "box-shadow": true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  "transform-origin": true,
  transform: true,
  transition: true
};
var propArrayInObj = {
  position: true,
  size: true
};
var propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  "border-top": {
    width: null,
    style: null,
    color: null
  },
  "border-right": {
    width: null,
    style: null,
    color: null
  },
  "border-bottom": {
    width: null,
    style: null,
    color: null
  },
  "border-left": {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  "list-style": {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    "timing-function": null,
    timingFunction: null,
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    "timing-function": null,
    timingFunction: null,
    delay: null,
    "iteration-count": null,
    iterationCount: null,
    direction: null,
    "fill-mode": null,
    fillMode: null,
    "play-state": null,
    playState: null
  },
  "box-shadow": {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  "text-shadow": {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }
};
var customPropObj = {
  border: {
    radius: "border-radius",
    image: "border-image",
    width: "border-width",
    style: "border-style",
    color: "border-color"
  },
  "border-bottom": {
    width: "border-bottom-width",
    style: "border-bottom-style",
    color: "border-bottom-color"
  },
  "border-top": {
    width: "border-top-width",
    style: "border-top-style",
    color: "border-top-color"
  },
  "border-left": {
    width: "border-left-width",
    style: "border-left-style",
    color: "border-left-color"
  },
  "border-right": {
    width: "border-right-width",
    style: "border-right-style",
    color: "border-right-color"
  },
  background: {
    size: "background-size",
    image: "background-image"
  },
  font: {
    style: "font-style",
    variant: "font-variant",
    weight: "font-weight",
    stretch: "font-stretch",
    size: "font-size",
    family: "font-family",
    lineHeight: "line-height",
    "line-height": "line-height"
  },
  flex: {
    grow: "flex-grow",
    basis: "flex-basis",
    direction: "flex-direction",
    wrap: "flex-wrap",
    flow: "flex-flow",
    shrink: "flex-shrink"
  },
  align: {
    self: "align-self",
    items: "align-items",
    content: "align-content"
  },
  grid: {
    "template-columns": "grid-template-columns",
    templateColumns: "grid-template-columns",
    "template-rows": "grid-template-rows",
    templateRows: "grid-template-rows",
    "template-areas": "grid-template-areas",
    templateAreas: "grid-template-areas",
    template: "grid-template",
    "auto-columns": "grid-auto-columns",
    autoColumns: "grid-auto-columns",
    "auto-rows": "grid-auto-rows",
    autoRows: "grid-auto-rows",
    "auto-flow": "grid-auto-flow",
    autoFlow: "grid-auto-flow",
    row: "grid-row",
    column: "grid-column",
    "row-start": "grid-row-start",
    rowStart: "grid-row-start",
    "row-end": "grid-row-end",
    rowEnd: "grid-row-end",
    "column-start": "grid-column-start",
    columnStart: "grid-column-start",
    "column-end": "grid-column-end",
    columnEnd: "grid-column-end",
    area: "grid-area",
    gap: "grid-gap",
    "row-gap": "grid-row-gap",
    rowGap: "grid-row-gap",
    "column-gap": "grid-column-gap",
    columnGap: "grid-column-gap"
  }
};
function mapValuesByProp(value, prop, rule) {
  return value.map(function(item) {
    return objectToArray(item, prop, rule, false, true);
  });
}
function processArray(value, prop, scheme, rule) {
  if (scheme[prop] == null)
    return value;
  if (value.length === 0)
    return [];
  if (Array.isArray(value[0]))
    return processArray(value[0], prop, scheme, rule);
  if (typeof value[0] === "object") {
    return mapValuesByProp(value, prop, rule);
  }
  return [value];
}
function objectToArray(value, prop, rule, isFallback, isInArray) {
  if (!(propObj[prop] || customPropObj[prop]))
    return [];
  var result = [];
  if (customPropObj[prop]) {
    value = customPropsToStyle(value, rule, customPropObj[prop], isFallback);
  }
  if (Object.keys(value).length) {
    for (var baseProp in propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(" "));
        } else
          result.push(value[baseProp]);
        continue;
      }
      if (propObj[prop][baseProp] != null) {
        result.push(propObj[prop][baseProp]);
      }
    }
  }
  if (!result.length || isInArray)
    return result;
  return [result];
}
function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop];
    if (typeof value[prop] !== "undefined" && (isFallback || !rule.prop(propName))) {
      var _styleDetector;
      var appendedValue = styleDetector((_styleDetector = {}, _styleDetector[propName] = value[prop], _styleDetector), rule)[propName];
      if (isFallback)
        rule.style.fallbacks[propName] = appendedValue;
      else
        rule.style[propName] = appendedValue;
    }
    delete value[prop];
  }
  return value;
}
function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];
    if (Array.isArray(value)) {
      if (!Array.isArray(value[0])) {
        if (prop === "fallbacks") {
          for (var index4 = 0; index4 < style.fallbacks.length; index4++) {
            style.fallbacks[index4] = styleDetector(style.fallbacks[index4], rule, true);
          }
          continue;
        }
        style[prop] = processArray(value, prop, propArray, rule);
        if (!style[prop].length)
          delete style[prop];
      }
    } else if (typeof value === "object") {
      if (prop === "fallbacks") {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }
      style[prop] = objectToArray(value, prop, rule, isFallback);
      if (!style[prop].length)
        delete style[prop];
    } else if (style[prop] === "")
      delete style[prop];
  }
  return style;
}
function jssExpand() {
  function onProcessStyle2(style, rule) {
    if (!style || rule.type !== "style")
      return style;
    if (Array.isArray(style)) {
      for (var index4 = 0; index4 < style.length; index4++) {
        style[index4] = styleDetector(style[index4], rule);
      }
      return style;
    }
    return styleDetector(style, rule);
  }
  return {
    onProcessStyle: onProcessStyle2
  };
}
var jss_plugin_expand_esm_default = jssExpand;

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

// node_modules/css-vendor/dist/css-vendor.esm.js
var js = "";
var css = "";
var vendor = "";
var browser = "";
var isTouch = module_default && "ontouchstart" in document.documentElement;
if (module_default) {
  jsCssMap = {
    Moz: "-moz-",
    ms: "-ms-",
    O: "-o-",
    Webkit: "-webkit-"
  };
  _document$createEleme = document.createElement("p"), style = _document$createEleme.style;
  testProp = "Transform";
  for (key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
  if (js === "Webkit" && "msHyphens" in style) {
    js = "ms";
    css = jsCssMap.ms;
    browser = "edge";
  }
  if (js === "Webkit" && "-apple-trailing-word" in style) {
    vendor = "apple";
  }
}
var jsCssMap;
var _document$createEleme;
var style;
var testProp;
var key;
var prefix = {
  js,
  css,
  vendor,
  browser,
  isTouch
};
function supportedKeyframes(key) {
  if (key[1] === "-")
    return key;
  if (prefix.js === "ms")
    return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
}
var appearence = {
  noPrefill: ["appearance"],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== "appearance")
      return false;
    if (prefix.js === "ms")
      return "-webkit-" + prop;
    return prefix.css + prop;
  }
};
var colorAdjust = {
  noPrefill: ["color-adjust"],
  supportedProperty: function supportedProperty2(prop) {
    if (prop !== "color-adjust")
      return false;
    if (prefix.js === "Webkit")
      return prefix.css + "print-" + prop;
    return prop;
  }
};
var regExp = /[-\s]+(.)?/g;
function toUpper(match2, c2) {
  return c2 ? c2.toUpperCase() : "";
}
function camelize(str) {
  return str.replace(regExp, toUpper);
}
function pascalize(str) {
  return camelize("-" + str);
}
var mask = {
  noPrefill: ["mask"],
  supportedProperty: function supportedProperty3(prop, style) {
    if (!/^mask/.test(prop))
      return false;
    if (prefix.js === "Webkit") {
      var longhand = "mask-image";
      if (camelize(longhand) in style) {
        return prop;
      }
      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }
    return prop;
  }
};
var textOrientation = {
  noPrefill: ["text-orientation"],
  supportedProperty: function supportedProperty4(prop) {
    if (prop !== "text-orientation")
      return false;
    if (prefix.vendor === "apple" && !prefix.isTouch) {
      return prefix.css + prop;
    }
    return prop;
  }
};
var transform = {
  noPrefill: ["transform"],
  supportedProperty: function supportedProperty5(prop, style, options2) {
    if (prop !== "transform")
      return false;
    if (options2.transform) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var transition = {
  noPrefill: ["transition"],
  supportedProperty: function supportedProperty6(prop, style, options2) {
    if (prop !== "transition")
      return false;
    if (options2.transition) {
      return prop;
    }
    return prefix.css + prop;
  }
};
var writingMode = {
  noPrefill: ["writing-mode"],
  supportedProperty: function supportedProperty7(prop) {
    if (prop !== "writing-mode")
      return false;
    if (prefix.js === "Webkit" || prefix.js === "ms" && prefix.browser !== "edge") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var userSelect = {
  noPrefill: ["user-select"],
  supportedProperty: function supportedProperty8(prop) {
    if (prop !== "user-select")
      return false;
    if (prefix.js === "Moz" || prefix.js === "ms" || prefix.vendor === "apple") {
      return prefix.css + prop;
    }
    return prop;
  }
};
var breakPropsOld = {
  supportedProperty: function supportedProperty9(prop, style) {
    if (!/^break-/.test(prop))
      return false;
    if (prefix.js === "Webkit") {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }
    if (prefix.js === "Moz") {
      var _jsProp = "page" + pascalize(prop);
      return _jsProp in style ? "page-" + prop : false;
    }
    return false;
  }
};
var inlineLogicalOld = {
  supportedProperty: function supportedProperty10(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop))
      return false;
    if (prefix.js === "Moz")
      return prop;
    var newProp = prop.replace("-inline", "");
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var unprefixed = {
  supportedProperty: function supportedProperty11(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};
var prefixed = {
  supportedProperty: function supportedProperty12(prop, style) {
    var pascalized = pascalize(prop);
    if (prop[0] === "-")
      return prop;
    if (prop[0] === "-" && prop[1] === "-")
      return prop;
    if (prefix.js + pascalized in style)
      return prefix.css + prop;
    if (prefix.js !== "Webkit" && "Webkit" + pascalized in style)
      return "-webkit-" + prop;
    return false;
  }
};
var scrollSnap = {
  supportedProperty: function supportedProperty13(prop) {
    if (prop.substring(0, 11) !== "scroll-snap")
      return false;
    if (prefix.js === "ms") {
      return "" + prefix.css + prop;
    }
    return prop;
  }
};
var overscrollBehavior = {
  supportedProperty: function supportedProperty14(prop) {
    if (prop !== "overscroll-behavior")
      return false;
    if (prefix.js === "ms") {
      return prefix.css + "scroll-chaining";
    }
    return prop;
  }
};
var propMap = {
  "flex-grow": "flex-positive",
  "flex-shrink": "flex-negative",
  "flex-basis": "flex-preferred-size",
  "justify-content": "flex-pack",
  order: "flex-order",
  "align-items": "flex-align",
  "align-content": "flex-line-pack"
};
var flex2012 = {
  supportedProperty: function supportedProperty15(prop, style) {
    var newProp = propMap[prop];
    if (!newProp)
      return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var propMap$1 = {
  flex: "box-flex",
  "flex-grow": "box-flex",
  "flex-direction": ["box-orient", "box-direction"],
  order: "box-ordinal-group",
  "align-items": "box-align",
  "flex-flow": ["box-orient", "box-direction"],
  "justify-content": "box-pack"
};
var propKeys = Object.keys(propMap$1);
var prefixCss = function prefixCss2(p2) {
  return prefix.css + p2;
};
var flex2009 = {
  supportedProperty: function supportedProperty16(prop, style, _ref3) {
    var multiple = _ref3.multiple;
    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];
      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }
      if (!multiple)
        return false;
      for (var i2 = 0; i2 < newProp.length; i2++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }
      return newProp.map(prefixCss);
    }
    return false;
  }
};
var plugins2 = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins2.filter(function(p2) {
  return p2.supportedProperty;
}).map(function(p2) {
  return p2.supportedProperty;
});
var noPrefill = plugins2.filter(function(p2) {
  return p2.noPrefill;
}).reduce(function(a2, p2) {
  a2.push.apply(a2, _toConsumableArray(p2.noPrefill));
  return a2;
}, []);
var el;
var cache2 = {};
if (module_default) {
  el = document.createElement("p");
  computed = window.getComputedStyle(document.documentElement, "");
  for (key$1 in computed) {
    if (!isNaN(key$1))
      cache2[computed[key$1]] = computed[key$1];
  }
  noPrefill.forEach(function(x2) {
    return delete cache2[x2];
  });
}
var computed;
var key$1;
function supportedProperty17(prop, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  if (!el)
    return prop;
  if (cache2[prop] != null) {
    return cache2[prop];
  }
  if (prop === "transition" || prop === "transform") {
    options2[prop] = prop in el.style;
  }
  for (var i2 = 0; i2 < propertyDetectors.length; i2++) {
    cache2[prop] = propertyDetectors[i2](prop, el.style, options2);
    if (cache2[prop])
      break;
  }
  try {
    el.style[prop] = "";
  } catch (err) {
    return false;
  }
  return cache2[prop];
}
var cache$1 = {};
var transitionProperties = {
  transition: 1,
  "transition-property": 1,
  "-webkit-transition": 1,
  "-webkit-transition-property": 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
function prefixTransitionCallback(match2, p1, p2) {
  if (p1 === "var")
    return "var";
  if (p1 === "all")
    return "all";
  if (p2 === "all")
    return ", all";
  var prefixedValue = p1 ? supportedProperty17(p1) : ", " + supportedProperty17(p2);
  if (!prefixedValue)
    return p1 || p2;
  return prefixedValue;
}
if (module_default)
  el$1 = document.createElement("p");
function supportedValue(property, value) {
  var prefixedValue = value;
  if (!el$1 || property === "content")
    return value;
  if (typeof prefixedValue !== "string" || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  }
  var cacheKey = property + prefixedValue;
  if (cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  }
  try {
    el$1.style[property] = prefixedValue;
  } catch (err) {
    cache$1[cacheKey] = false;
    return false;
  }
  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === "") {
    prefixedValue = prefix.css + prefixedValue;
    if (prefixedValue === "-ms-flex")
      el$1.style[property] = "-ms-flexbox";
    el$1.style[property] = prefixedValue;
    if (el$1.style[property] === "") {
      cache$1[cacheKey] = false;
      return false;
    }
  }
  el$1.style[property] = "";
  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}

// node_modules/jss-plugin-vendor-prefixer/dist/jss-plugin-vendor-prefixer.esm.js
function jssVendorPrefixer() {
  function onProcessRule3(rule) {
    if (rule.type === "keyframes") {
      var atRule = rule;
      atRule.at = supportedKeyframes(atRule.at);
    }
  }
  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];
      if (prop === "fallbacks" && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }
      var changeProp = false;
      var supportedProp = supportedProperty17(prop);
      if (supportedProp && supportedProp !== prop)
        changeProp = true;
      var changeValue = false;
      var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));
      if (supportedValue$1 && supportedValue$1 !== value)
        changeValue = true;
      if (changeProp || changeValue) {
        if (changeProp)
          delete style[prop];
        style[supportedProp || prop] = supportedValue$1 || value;
      }
    }
    return style;
  }
  function onProcessStyle2(style, rule) {
    if (rule.type !== "style")
      return style;
    return prefixStyle(style);
  }
  function onChangeValue2(value, prop) {
    return supportedValue(prop, toCssValue(value)) || value;
  }
  return {
    onProcessRule: onProcessRule3,
    onProcessStyle: onProcessStyle2,
    onChangeValue: onChangeValue2
  };
}
var jss_plugin_vendor_prefixer_esm_default = jssVendorPrefixer;

// node_modules/jss-plugin-props-sort/dist/jss-plugin-props-sort.esm.js
function jssPropsSort() {
  var sort = function sort2(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }
    return prop0.length - prop1.length;
  };
  return {
    onProcessStyle: function onProcessStyle2(style, rule) {
      if (rule.type !== "style")
        return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);
      for (var i2 = 0; i2 < props.length; i2++) {
        newStyle[props[i2]] = style[props[i2]];
      }
      return newStyle;
    }
  };
}
var jss_plugin_props_sort_esm_default = jssPropsSort;

// node_modules/jss-preset-default/dist/jss-preset-default.esm.js
var create3 = function create4(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    plugins: [jss_plugin_rule_value_function_esm_default(), jss_plugin_rule_value_observable_esm_default(options2.observable), jss_plugin_template_esm_default(), jss_plugin_global_esm_default(), jss_plugin_extend_esm_default(), jss_plugin_nested_esm_default(), jss_plugin_compose_esm_default(), jss_plugin_camel_case_esm_default(), jss_plugin_default_unit_esm_default(options2.defaultUnit), jss_plugin_expand_esm_default(), jss_plugin_vendor_prefixer_esm_default(), jss_plugin_props_sort_esm_default()]
  };
};
var jss_preset_default_esm_default = create3;

// node_modules/react-jss/dist/react-jss.esm.js
var import_prop_types5 = __toModule(require_prop_types());

// node_modules/shallow-equal/dist/index.esm.js
function shallowEqualObjects(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}

// node_modules/@emotion/is-prop-valid/node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize3(fn) {
  var cache3 = {};
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var memoize_browser_esm_default = memoize3;

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var index = memoize_browser_esm_default(function(prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
});

// node_modules/css-jss/dist/css-jss.esm.js
var MAX_RULES_PER_SHEET = 1e4;
var defaultJss = create(jss_preset_default_esm_default());
var createCss = function createCss2(jss3) {
  if (jss3 === void 0) {
    jss3 = defaultJss;
  }
  var cache3 = new Map();
  var ruleIndex = 0;
  var sheet;
  var getSheet = function getSheet2() {
    if (!sheet || sheet.rules.index.length > MAX_RULES_PER_SHEET) {
      sheet = jss3.createStyleSheet().attach();
    }
    return sheet;
  };
  function css7() {
    var args = arguments;
    var argsStr = JSON.stringify(args);
    var cached = cache3.get(argsStr);
    if (cached)
      return cached.className;
    var flatArgs = [];
    for (var argIndex in args) {
      var arg = args[argIndex];
      if (!Array.isArray(arg)) {
        flatArgs.push(arg);
        continue;
      }
      for (var innerArgIndex = 0; innerArgIndex < arg.length; innerArgIndex++) {
        flatArgs.push(arg[innerArgIndex]);
      }
    }
    var mergedStyle = {};
    var labels = [];
    for (var i2 = 0; i2 < flatArgs.length; i2++) {
      var style = flatArgs[i2];
      if (!style)
        continue;
      var styleObject = style;
      if (typeof style === "string") {
        var _cached = cache3.get(style);
        if (_cached) {
          if (_cached.labels.length)
            labels.push.apply(labels, _cached.labels);
          styleObject = _cached.style;
        }
      }
      if (styleObject.label && labels.indexOf(styleObject.label) === -1)
        labels.push(styleObject.label);
      Object.assign(mergedStyle, styleObject);
    }
    delete mergedStyle.label;
    var label = labels.length === 0 ? "css" : labels.join("-");
    var key = label + "-" + ruleIndex++;
    getSheet().addRule(key, mergedStyle);
    var className = getSheet().classes[key];
    var cacheValue = {
      style: mergedStyle,
      labels,
      className
    };
    cache3.set(argsStr, cacheValue);
    cache3.set(className, cacheValue);
    return className;
  }
  css7.getSheet = getSheet;
  return css7;
};
var css2 = createCss();
var css_jss_esm_default = css2;

// node_modules/react-jss/dist/react-jss.esm.js
var JssContext = (0, import_react9.createContext)({
  classNamePrefix: "",
  disableStylesGeneration: false
});
var index2 = Number.MIN_SAFE_INTEGER || -1e9;
var getSheetIndex = function getSheetIndex2() {
  return index2++;
};
var defaultManagers = new Map();
var getManager = function getManager2(context, managerId) {
  if (context.managers) {
    if (!context.managers[managerId]) {
      context.managers[managerId] = new SheetsManager();
    }
    return context.managers[managerId];
  }
  var manager = defaultManagers.get(managerId);
  if (!manager) {
    manager = new SheetsManager();
    defaultManagers.set(managerId, manager);
  }
  return manager;
};
var manageSheet = function manageSheet2(options2) {
  var sheet = options2.sheet, context = options2.context, index4 = options2.index, theme = options2.theme;
  if (!sheet) {
    return;
  }
  var manager = getManager(context, index4);
  manager.manage(theme);
  if (context.registry) {
    context.registry.add(sheet);
  }
};
var unmanageSheet = function unmanageSheet2(options2) {
  if (!options2.sheet) {
    return;
  }
  var manager = getManager(options2.context, options2.index);
  manager.unmanage(options2.theme);
};
var jss2 = create(jss_preset_default_esm_default());
var sheetsMeta = new WeakMap();
var getMeta = function getMeta2(sheet) {
  return sheetsMeta.get(sheet);
};
var addMeta = function addMeta2(sheet, meta) {
  sheetsMeta.set(sheet, meta);
};
var getStyles = function getStyles2(options2) {
  var styles = options2.styles;
  if (typeof styles !== "function") {
    return styles;
  }
  false ? tiny_warning_esm_default(styles.length !== 0, "[JSS] <" + (options2.name || "Hook") + ` />'s styles function doesn't rely on the "theme" argument. We recommend declaring styles as an object instead.`) : void 0;
  return styles(options2.theme);
};
function getSheetOptions(options2, link2) {
  var minify;
  if (options2.context.id && options2.context.id.minify != null) {
    minify = options2.context.id.minify;
  }
  var classNamePrefix = options2.context.classNamePrefix || "";
  if (options2.name && !minify) {
    classNamePrefix += options2.name.replace(/\s/g, "-") + "-";
  }
  var meta = "";
  if (options2.name)
    meta = options2.name + ", ";
  meta += typeof options2.styles === "function" ? "Themed" : "Unthemed";
  return _extends({}, options2.sheetOptions, {
    index: options2.index,
    meta,
    classNamePrefix,
    link: link2,
    generateId: options2.sheetOptions.generateId || options2.context.generateId
  });
}
var createStyleSheet = function createStyleSheet2(options2) {
  if (options2.context.disableStylesGeneration) {
    return void 0;
  }
  var manager = getManager(options2.context, options2.index);
  var existingSheet = manager.get(options2.theme);
  if (existingSheet) {
    return existingSheet;
  }
  var jss$1 = options2.context.jss || jss2;
  var styles = getStyles(options2);
  var dynamicStyles = getDynamicStyles(styles);
  var sheet = jss$1.createStyleSheet(styles, getSheetOptions(options2, dynamicStyles !== null));
  addMeta(sheet, {
    dynamicStyles,
    styles
  });
  manager.add(options2.theme, sheet);
  return sheet;
};
var removeDynamicRules = function removeDynamicRules2(sheet, rules) {
  for (var key in rules) {
    sheet.deleteRule(rules[key]);
  }
};
var updateDynamicRules = function updateDynamicRules2(data2, sheet, rules) {
  for (var key in rules) {
    sheet.updateOne(rules[key], data2);
  }
};
var addDynamicRules = function addDynamicRules2(sheet, data2) {
  var meta = getMeta(sheet);
  if (!meta) {
    return void 0;
  }
  var rules = {};
  for (var key in meta.dynamicStyles) {
    var initialRuleCount = sheet.rules.index.length;
    var originalRule = sheet.addRule(key, meta.dynamicStyles[key]);
    for (var i2 = initialRuleCount; i2 < sheet.rules.index.length; i2++) {
      var rule = sheet.rules.index[i2];
      sheet.updateOne(rule, data2);
      rules[originalRule === rule ? key : rule.key] = rule;
    }
  }
  return rules;
};
var getSheetClasses = function getSheetClasses2(sheet, dynamicRules) {
  if (!dynamicRules) {
    return sheet.classes;
  }
  var classes = {};
  var meta = getMeta(sheet);
  if (!meta) {
    return sheet.classes;
  }
  for (var key in meta.styles) {
    classes[key] = sheet.classes[key];
    if (key in dynamicRules) {
      classes[key] += " " + sheet.classes[dynamicRules[key].key];
    }
  }
  return classes;
};
var useEffectOrLayoutEffect = module_default ? import_react9.useLayoutEffect : import_react9.useEffect;
var noTheme$1 = {};
var createUseStyles = function createUseStyles2(styles, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$index = _options.index, index4 = _options$index === void 0 ? getSheetIndex() : _options$index, theming = _options.theming, name2 = _options.name, sheetOptions = _objectWithoutPropertiesLoose(_options, ["index", "theming", "name"]);
  var ThemeContext$1 = theming && theming.context || ThemeContext;
  var useTheme2 = typeof styles === "function" ? function() {
    return (0, import_react9.useContext)(ThemeContext$1) || noTheme$1;
  } : function() {
    return noTheme$1;
  };
  return function useStyles2(data2) {
    var isFirstMount = (0, import_react9.useRef)(true);
    var context = (0, import_react9.useContext)(JssContext);
    var theme = useTheme2();
    var _React$useMemo = (0, import_react9.useMemo)(function() {
      var newSheet = createStyleSheet({
        context,
        styles,
        name: name2,
        theme,
        index: index4,
        sheetOptions
      });
      var newDynamicRules = newSheet ? addDynamicRules(newSheet, data2) : null;
      if (newSheet) {
        manageSheet({
          index: index4,
          context,
          sheet: newSheet,
          theme
        });
      }
      return [newSheet, newDynamicRules];
    }, [context, theme]), sheet = _React$useMemo[0], dynamicRules = _React$useMemo[1];
    useEffectOrLayoutEffect(function() {
      if (sheet && dynamicRules && !isFirstMount.current) {
        updateDynamicRules(data2, sheet, dynamicRules);
      }
    }, [data2]);
    useEffectOrLayoutEffect(function() {
      return function() {
        if (sheet) {
          unmanageSheet({
            index: index4,
            context,
            sheet,
            theme
          });
        }
        if (sheet && dynamicRules) {
          removeDynamicRules(sheet, dynamicRules);
        }
      };
    }, [sheet]);
    var classes = sheet && dynamicRules ? getSheetClasses(sheet, dynamicRules) : {};
    (0, import_react9.useDebugValue)(classes);
    (0, import_react9.useDebugValue)(theme === noTheme$1 ? "No theme" : theme);
    (0, import_react9.useEffect)(function() {
      isFirstMount.current = false;
    });
    return classes;
  };
};
var initialContext = {};
var JssProvider = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(JssProvider2, _React$Component);
  function JssProvider2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.managers = {};
    _this.createContext = function(parentContext, prevContext) {
      if (prevContext === void 0) {
        prevContext = initialContext;
      }
      var _this$props = _this.props, registry2 = _this$props.registry, classNamePrefix = _this$props.classNamePrefix, jss3 = _this$props.jss, generateId = _this$props.generateId, disableStylesGeneration = _this$props.disableStylesGeneration, media = _this$props.media, id = _this$props.id;
      var context = _extends({}, parentContext);
      if (registry2) {
        context.registry = registry2;
        if (registry2 !== _this.registry) {
          _this.managers = {};
          _this.registry = registry2;
        }
      }
      context.managers = _this.managers;
      if (id !== void 0) {
        context.id = id;
      }
      if (generateId !== void 0) {
        context.generateId = generateId;
      } else if (!context.generateId || !prevContext || context.id !== prevContext.id) {
        context.generateId = createGenerateId(context.id);
      }
      if (classNamePrefix) {
        context.classNamePrefix = (context.classNamePrefix || "") + classNamePrefix;
      }
      if (media !== void 0) {
        context.media = media;
      }
      if (jss3) {
        context.jss = jss3;
      }
      if (disableStylesGeneration !== void 0) {
        context.disableStylesGeneration = disableStylesGeneration;
      }
      if (prevContext && shallowEqualObjects(prevContext, context)) {
        return prevContext;
      }
      return context;
    };
    _this.prevContext = void 0;
    _this.generateId = void 0;
    _this.registry = void 0;
    _this.renderProvider = function(parentContext) {
      var children = _this.props.children;
      var context = _this.createContext(parentContext, _this.prevContext);
      _this.prevContext = context;
      return (0, import_react9.createElement)(JssContext.Provider, {
        value: context
      }, children);
    };
    return _this;
  }
  var _proto = JssProvider2.prototype;
  _proto.render = function render2() {
    return (0, import_react9.createElement)(JssContext.Consumer, null, this.renderProvider);
  };
  return JssProvider2;
}(import_react9.Component);
JssProvider.propTypes = {
  registry: import_prop_types5.default.instanceOf(SheetsRegistry),
  jss: import_prop_types5.default.instanceOf(jss_esm_default.constructor),
  generateId: import_prop_types5.default.func,
  classNamePrefix: import_prop_types5.default.string,
  disableStylesGeneration: import_prop_types5.default.bool,
  children: import_prop_types5.default.node.isRequired,
  media: import_prop_types5.default.string,
  id: import_prop_types5.default.shape({
    minify: import_prop_types5.default.bool
  })
};
var shouldForwardPropSymbol = Symbol("react-jss-styled");
var create5 = function create6(css7) {
  if (css7 === void 0) {
    css7 = css_jss_esm_default;
  }
  return function createElement6(type, props) {
    var args = arguments;
    if (props && props.css) {
      var className = css7(props.css);
      var newProps = Object.assign({}, props);
      newProps.className = props.className ? props.className + " " + className : className;
      delete newProps.css;
      args[1] = newProps;
    }
    return import_react9.createElement.apply(void 0, args);
  };
};
var createElement2 = create5();

// node_modules/react-timezone-select/dist/index.js
var React11 = __toModule(require("react"));

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_react11 = __toModule(require("react"));

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet2 = /* @__PURE__ */ function() {
  function StyleSheet3(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        before = _this.prepend ? _this.container.firstChild : _this.before;
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.before = null;
  }
  var _proto = StyleSheet3.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (false) {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
        if (false) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (false) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet3;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
function hash(value, length2) {
  return (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index4) {
  return value.charCodeAt(index4) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return {value, root, parent, type, props, children, line, column, length: length2, return: ""};
}
function copy(value, root, type) {
  return node(value, root.root, root.parent, type, root.props, root.children, 0);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index4, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index4, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        return delimiter(type === 34 || type === 39 ? type : character);
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index4) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index4, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index4) {
  while (!token(peek()))
    next();
  return slice(index4, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse3(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index4 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 34:
      case 39:
      case 91:
      case 40:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index4++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index4, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse3(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse3(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse3(characters2, reference, reference, reference, [""], children, length2, points, children);
                }
        }
        index4 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index4++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index4, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index4; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Prefixer.js
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index4, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index4, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index4, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index4, children, callback) {
  if (!element.return)
    switch (element.type) {
      case DECLARATION:
        element.return = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(replace(element.value, "@", "@" + WEBKIT), element, "")], callback);
      case RULESET:
        if (element.length)
          return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy(replace(value, /:(read-\w+)/, ":" + MOZ + "$1"), element, "")], callback);
              case "::placeholder":
                return serialize([
                  copy(replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1"), element, ""),
                  copy(replace(value, /:(plac\w+)/, ":" + MOZ + "$1"), element, ""),
                  copy(replace(value, /:(plac\w+)/, MS + "input-$1"), element, "")
                ], callback);
            }
            return "";
          });
    }
}

// node_modules/@emotion/memoize/dist/emotion-memoize.browser.esm.js
function memoize4(fn) {
  var cache3 = Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0)
      cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var emotion_memoize_browser_esm_default = memoize4;

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var toRules = function toRules2(parsed, points) {
  var index4 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index4] = 1;
        }
        parsed[index4] += identifier(position - 1);
        break;
      case 2:
        parsed[index4] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index4] = peek() === 58 ? "&\f" : "";
          points[index4] = parsed[index4].length;
          break;
        }
      default:
        parsed[index4] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || !element.length) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (false) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  if (false) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion]"), function(node2) {
      var attrib = node2.getAttribute("data-emotion").split(" ");
      if (attrib[0] !== key) {
        return;
      }
      for (var i2 = 1; i2 < attrib.length; i2++) {
        inserted[attrib[i2]] = true;
      }
      nodesToHydrate.push(node2);
    });
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (false) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache3.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, false ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (false) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache3.inserted[serialized.name] = true;
      }
    };
  }
  var cache3 = {
    key,
    sheet: new StyleSheet2({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache3.sheet.hydrate(nodesToHydrate);
  return cache3;
};
var emotion_cache_browser_esm_default = createCache;

// node_modules/@emotion/react/dist/emotion-element-4fbd89c5.browser.esm.js
var import_react10 = __toModule(require("react"));

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser2 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var insertStyles = function insertStyles2(cache3, serialized, isStringTag) {
  var className = cache3.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser2 === false) && cache3.registered[className] === void 0) {
    cache3.registered[className] = serialized.styles;
  }
  if (cache3.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      var maybeStyles = cache3.insert(serialized === current ? "." + className : "", current, cache3.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/hash.browser.esm.js
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var hash_browser_esm_default = murmur2;

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ emotion_memoize_browser_esm_default(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitless_browser_esm_default[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (false) {
  contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern2 = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern2, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern2;
var hyphenPattern;
var hyphenatedCache;
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (false) {
      throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        if (false) {
          styles += interpolation.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (false) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (false) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error("Component selectors can only be used in conjunction with @emotion/babel-plugin.");
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (false) {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (false) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (false) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      if (false) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i2];
    }
  }
  var sourceMap;
  if (false) {
    styles = styles.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = hash_browser_esm_default(styles) + identifierName;
  if (false) {
    return {
      name: name2,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name: name2,
    styles,
    next: cursor
  };
};

// node_modules/@emotion/react/dist/emotion-element-4fbd89c5.browser.esm.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ (0, import_react10.createContext)(typeof HTMLElement !== "undefined" ? /* @__PURE__ */ emotion_cache_browser_esm_default({
  key: "css"
}) : null);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ (0, import_react10.forwardRef)(function(props, ref) {
    var cache3 = (0, import_react10.useContext)(EmotionCacheContext);
    return func(props, cache3, ref);
  });
};
var ThemeContext2 = /* @__PURE__ */ (0, import_react10.createContext)({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (false) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  if (false) {
    var error = new Error();
    if (error.stack) {
      var match2 = error.stack.match(/at (?:Object\.|Module\.|)(?:jsx|createEmotionProps).*\n\s+at (?:Object\.|)([A-Z][A-Za-z0-9$]+) /);
      if (!match2) {
        match2 = error.stack.match(/.*\n([A-Z][A-Za-z0-9$]+)@/);
      }
      if (match2) {
        newProps[labelPropName] = sanitizeIdentifier(match2[1]);
      }
    }
  }
  return newProps;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache3, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache3.registered[cssProp] !== void 0) {
    cssProp = cache3.registered[cssProp];
  }
  var type = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache3.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, typeof cssProp === "function" || Array.isArray(cssProp) ? (0, import_react10.useContext)(ThemeContext2) : void 0);
  if (false) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  var rules = insertStyles(cache3, serialized, typeof type === "string");
  className += cache3.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  var ele = /* @__PURE__ */ (0, import_react10.createElement)(type, newProps);
  return ele;
});
if (false) {
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var import_hoist_non_react_statics3 = __toModule(require_hoist_non_react_statics_cjs());
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return import_react11.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i2 = 2; i2 < argsLength; i2++) {
    createElementArgArray[i2] = args[i2];
  }
  return import_react11.createElement.apply(null, createElementArgArray);
};
if (false) {
  Global.displayName = "EmotionGlobal";
}
function css3() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css3.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i2 = 0;
  var cls = "";
  for (; i2 < len; i2++) {
    var arg = args[i2];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (false) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css7, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css7(registeredStyles);
}
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache3) {
  var hasRendered = false;
  var css7 = function css8() {
    if (hasRendered && false) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache3.registered);
    {
      insertStyles(cache3, serialized, false);
    }
    return cache3.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && false) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache3.registered, css7, classnames(args));
  };
  var content = {
    css: css7,
    cx,
    theme: (0, import_react11.useContext)(ThemeContext2)
  };
  var ele = props.children(content);
  hasRendered = true;
  return ele;
});
if (false) {
  ClassNames.displayName = "EmotionClassNames";
}
if (false) {
  isBrowser3 = true;
  isJest = typeof jest !== "undefined";
  if (isBrowser3 && !isJest) {
    globalContext = isBrowser3 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isJest;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof4(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof4(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}

// node_modules/react-select/dist/index-4bd03571.esm.js
var import_react_input_autosize = __toModule(require_AutosizeInput());

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/react-select/dist/index-4bd03571.esm.js
var import_react13 = __toModule(require("react"));
var import_react_dom = __toModule(require("react-dom"));
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized3(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var noop = function noop2() {
};
function applyPrefixToName(prefix3, name2) {
  if (!name2) {
    return prefix3;
  } else if (name2[0] === "-") {
    return prefix3 + name2;
  } else {
    return prefix3 + "__" + name2;
  }
}
function classNames(prefix3, state, className) {
  var arr = [className];
  if (state && prefix3) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix3, key)));
      }
    }
  }
  return arr.filter(function(i2) {
    return i2;
  }).map(function(i2) {
    return String(i2).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (Array.isArray(value))
    return value.filter(Boolean);
  if (_typeof3(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"]);
  return _objectSpread2({}, innerProps);
};
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
function getScrollTop(el2) {
  if (isDocumentElement(el2)) {
    return window.pageYOffset;
  }
  return el2.scrollTop;
}
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  var docEl = document.documentElement;
  if (style.position === "fixed")
    return docEl;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return docEl;
}
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e2) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop, options);
  w.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function getMenuPlacement(_ref3) {
  var maxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, placement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, theme = _ref3.theme;
  var spacing2 = theme.spacing;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = window.innerHeight;
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (placement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (placement === "auto" || isFixedPosition) {
        var _constrainedHeight = maxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - spacing2.controlHeight, maxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (placement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = maxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(placement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref23) {
  var _ref3;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _ref3 = {
    label: "menu"
  }, _defineProperty2(_ref3, alignToControl(placement), "100%"), _defineProperty2(_ref3, "backgroundColor", colors2.neutral0), _defineProperty2(_ref3, "borderRadius", borderRadius2), _defineProperty2(_ref3, "boxShadow", "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)"), _defineProperty2(_ref3, "marginBottom", spacing2.menuGutter), _defineProperty2(_ref3, "marginTop", spacing2.menuGutter), _defineProperty2(_ref3, "position", "absolute"), _defineProperty2(_ref3, "width", "100%"), _defineProperty2(_ref3, "zIndex", 1), _ref3;
};
var PortalPlacementContext = /* @__PURE__ */ (0, import_react13.createContext)({
  getPortalPlacement: null
});
var MenuPlacer = /* @__PURE__ */ function(_Component) {
  _inherits(MenuPlacer2, _Component);
  var _super = _createSuper(MenuPlacer2);
  function MenuPlacer2() {
    var _this;
    _classCallCheck(this, MenuPlacer2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      maxHeight: _this.props.maxMenuHeight,
      placement: null
    };
    _this.getPlacement = function(ref) {
      var _this$props = _this.props, minMenuHeight = _this$props.minMenuHeight, maxMenuHeight = _this$props.maxMenuHeight, menuPlacement = _this$props.menuPlacement, menuPosition = _this$props.menuPosition, menuShouldScrollIntoView = _this$props.menuShouldScrollIntoView, theme = _this$props.theme;
      if (!ref)
        return;
      var isFixedPosition = menuPosition === "fixed";
      var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
      var state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl: ref,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll,
        isFixedPosition,
        theme
      });
      var getPortalPlacement = _this.context.getPortalPlacement;
      if (getPortalPlacement)
        getPortalPlacement(state);
      _this.setState(state);
    };
    _this.getUpdatedProps = function() {
      var menuPlacement = _this.props.menuPlacement;
      var placement = _this.state.placement || coercePlacement(menuPlacement);
      return _objectSpread2(_objectSpread2({}, _this.props), {}, {
        placement,
        maxHeight: _this.state.maxHeight
      });
    };
    return _this;
  }
  _createClass(MenuPlacer2, [{
    key: "render",
    value: function render2() {
      var children = this.props.children;
      return children({
        ref: this.getPlacement,
        placerProps: this.getUpdatedProps()
      });
    }
  }]);
  return MenuPlacer2;
}(import_react13.Component);
MenuPlacer.contextType = PortalPlacementContext;
var Menu = function Menu2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("menu", props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var menuListCSS = function menuListCSS2(_ref4) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return {
    maxHeight,
    overflowY: "auto",
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2,
    position: "relative",
    WebkitOverflowScrolling: "touch"
  };
};
var MenuList = function MenuList2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({
    css: getStyles3("menuList", props),
    className: cx({
      "menu-list": true,
      "menu-list--is-multi": isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px"),
    textAlign: "center"
  };
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("noOptionsMessage", props),
    className: cx({
      "menu-notice": true,
      "menu-notice--no-options": true
    }, className)
  }, innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: "No options"
};
var LoadingMessage = function LoadingMessage2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("loadingMessage", props),
    className: cx({
      "menu-notice": true,
      "menu-notice--loading": true
    }, className)
  }, innerProps), children);
};
LoadingMessage.defaultProps = {
  children: "Loading..."
};
var menuPortalCSS = function menuPortalCSS2(_ref6) {
  var rect = _ref6.rect, offset = _ref6.offset, position2 = _ref6.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = /* @__PURE__ */ function(_Component2) {
  _inherits(MenuPortal2, _Component2);
  var _super2 = _createSuper(MenuPortal2);
  function MenuPortal2() {
    var _this2;
    _classCallCheck(this, MenuPortal2);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _this2.state = {
      placement: null
    };
    _this2.getPortalPlacement = function(_ref7) {
      var placement = _ref7.placement;
      var initialPlacement = coercePlacement(_this2.props.menuPlacement);
      if (placement !== initialPlacement) {
        _this2.setState({
          placement
        });
      }
    };
    return _this2;
  }
  _createClass(MenuPortal2, [{
    key: "render",
    value: function render2() {
      var _this$props2 = this.props, appendTo = _this$props2.appendTo, children = _this$props2.children, className = _this$props2.className, controlElement = _this$props2.controlElement, cx = _this$props2.cx, innerProps = _this$props2.innerProps, menuPlacement = _this$props2.menuPlacement, position2 = _this$props2.menuPosition, getStyles3 = _this$props2.getStyles;
      var isFixed = position2 === "fixed";
      if (!appendTo && !isFixed || !controlElement) {
        return null;
      }
      var placement = this.state.placement || coercePlacement(menuPlacement);
      var rect = getBoundingClientObj(controlElement);
      var scrollDistance = isFixed ? 0 : window.pageYOffset;
      var offset = rect[placement] + scrollDistance;
      var state = {
        offset,
        position: position2,
        rect
      };
      var menuWrapper = jsx("div", _extends({
        css: getStyles3("menuPortal", state),
        className: cx({
          "menu-portal": true
        }, className)
      }, innerProps), children);
      return jsx(PortalPlacementContext.Provider, {
        value: {
          getPortalPlacement: this.getPortalPlacement
        }
      }, appendTo ? /* @__PURE__ */ (0, import_react_dom.createPortal)(menuWrapper, appendTo) : menuWrapper);
    }
  }]);
  return MenuPortal2;
}(import_react13.Component);
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : null,
    pointerEvents: isDisabled ? "none" : null,
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({
    css: getStyles3("container", props),
    className: cx({
      "--is-disabled": isDisabled,
      "--is-rtl": isRtl
    }, className)
  }, innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23) {
  var spacing2 = _ref23.theme.spacing;
  return {
    alignItems: "center",
    display: "flex",
    flex: 1,
    flexWrap: "wrap",
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px"),
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  };
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, innerProps = props.innerProps, isMulti = props.isMulti, getStyles3 = props.getStyles, hasValue = props.hasValue;
  return jsx("div", _extends({
    css: getStyles3("valueContainer", props),
    className: cx({
      "value-container": true,
      "value-container--is-multi": isMulti,
      "value-container--has-value": hasValue
    }, className)
  }, innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, className = props.className, cx = props.cx, innerProps = props.innerProps, getStyles3 = props.getStyles;
  return jsx("div", _extends({
    css: getStyles3("indicatorsContainer", props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};
var _templateObject;
var _ref2 = true ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0JJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBDb21tb25Qcm9wcywgVGhlbWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBJY29uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IFN2ZyA9ICh7IHNpemUsIC4uLnByb3BzIH06IHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk0xNC4zNDggMTQuODQ5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwbC0yLjY1MS0zLjAzMC0yLjY1MSAzLjAyOWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMC0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOSAwLTEuNjk3bDIuNzU4LTMuMTUtMi43NTktMy4xNTJjLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI4IDAtMS42OTdzMS4yMjgtMC40NjkgMS42OTcgMGwyLjY1MiAzLjAzMSAyLjY1MS0zLjAzMWMwLjQ2OS0wLjQ2OSAxLjIyOC0wLjQ2OSAxLjY5NyAwczAuNDY5IDEuMjI5IDAgMS42OTdsLTIuNzU4IDMuMTUyIDIuNzU4IDMuMTVjMC40NjkgMC40NjkgMC40NjkgMS4yMjkgMCAxLjY5OHpcIiAvPlxuICA8L1N2Zz5cbik7XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IGFueSkgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIEluZGljYXRvclByb3BzID0gQ29tbW9uUHJvcHMgJiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuOiBOb2RlLFxuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn07XG5cbmNvbnN0IGJhc2VDU1MgPSAoe1xuICBpc0ZvY3VzZWQsXG4gIHRoZW1lOiB7XG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIGNvbG9ycyxcbiAgfSxcbn06IEluZGljYXRvclByb3BzKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG5cbiAgJzpob3Zlcic6IHtcbiAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnY2xlYXJJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudHlwZSBTZXBhcmF0b3JTdGF0ZSA9IHsgaXNEaXNhYmxlZDogYm9vbGVhbiB9O1xuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gKHtcbiAgaXNEaXNhYmxlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogQ29tbW9uUHJvcHMgJiBTZXBhcmF0b3JTdGF0ZSkgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgd2lkdGg6IDEsXG59KTtcblxuZXhwb3J0IGNvbnN0IEluZGljYXRvclNlcGFyYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdpbmRpY2F0b3JTZXBhcmF0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KHsgJ2luZGljYXRvci1zZXBhcmF0b3InOiB0cnVlIH0sIGNsYXNzTmFtZSl9XG4gICAgLz5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTG9hZGluZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGxvYWRpbmdEb3RBbmltYXRpb25zID0ga2V5ZnJhbWVzYFxuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICA0MCUgeyBvcGFjaXR5OiAxOyB9XG5gO1xuXG5leHBvcnQgY29uc3QgbG9hZGluZ0luZGljYXRvckNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgc2l6ZSxcbiAgdGhlbWU6IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICB9LFxufToge1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXG4gIHNpemU6IG51bWJlcixcbiAgdGhlbWU6IFRoZW1lLFxufSkgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgZm9udFNpemU6IHNpemUsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG1hcmdpblJpZ2h0OiBzaXplLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbn0pO1xuXG50eXBlIERvdFByb3BzID0geyBkZWxheTogbnVtYmVyLCBvZmZzZXQ6IGJvb2xlYW4gfTtcbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IERvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiBudWxsLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgdHlwZSBMb2FkaW5nSWNvblByb3BzID0ge1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn0gJiBDb21tb25Qcm9wcyAmIHtcbiAgICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgICBzaXplOiBudW1iZXIsXG4gIH07XG5leHBvcnQgY29uc3QgTG9hZGluZ0luZGljYXRvciA9IChwcm9wczogTG9hZGluZ0ljb25Qcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcywgaXNSdGwgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2xvYWRpbmdJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHsgc2l6ZTogNCB9O1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size = _ref3.size, props = _objectWithoutProperties(_ref3, ["size"]);
  return jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return {
    label: "indicatorContainer",
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    display: "flex",
    padding: baseUnit2 * 2,
    transition: "color 150ms",
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  };
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("dropdownIndicator", props),
    className: cx({
      indicator: true,
      "dropdown-indicator": true
    }, className)
  }, innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("clearIndicator", props),
    className: cx({
      indicator: true,
      "clear-indicator": true
    }, className)
  }, innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return {
    label: "indicatorSeparator",
    alignSelf: "stretch",
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2,
    width: 1
  };
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, {
    css: getStyles3("indicatorSeparator", props),
    className: cx({
      "indicator-separator": true
    }, className)
  }));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5) {
  var isFocused = _ref5.isFocused, size = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return {
    label: "loadingIndicator",
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    display: "flex",
    padding: baseUnit2 * 2,
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: "center",
    verticalAlign: "middle"
  };
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css3({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : null,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, true ? "" : ";label:LoadingDot;", true ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0xJIiwiZmlsZSI6ImluZGljYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyB0eXBlIE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBDb21tb25Qcm9wcywgVGhlbWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRHJvcGRvd24gJiBDbGVhciBJY29uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IFN2ZyA9ICh7IHNpemUsIC4uLnByb3BzIH06IHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogYW55KSA9PiAoXG4gIDxTdmcgc2l6ZT17MjB9IHsuLi5wcm9wc30+XG4gICAgPHBhdGggZD1cIk0xNC4zNDggMTQuODQ5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwbC0yLjY1MS0zLjAzMC0yLjY1MSAzLjAyOWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMC0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOSAwLTEuNjk3bDIuNzU4LTMuMTUtMi43NTktMy4xNTJjLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI4IDAtMS42OTdzMS4yMjgtMC40NjkgMS42OTcgMGwyLjY1MiAzLjAzMSAyLjY1MS0zLjAzMWMwLjQ2OS0wLjQ2OSAxLjIyOC0wLjQ2OSAxLjY5NyAwczAuNDY5IDEuMjI5IDAgMS42OTdsLTIuNzU4IDMuMTUyIDIuNzU4IDMuMTVjMC40NjkgMC40NjkgMC40NjkgMS4yMjkgMCAxLjY5OHpcIiAvPlxuICA8L1N2Zz5cbik7XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IGFueSkgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIEluZGljYXRvclByb3BzID0gQ29tbW9uUHJvcHMgJiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuOiBOb2RlLFxuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn07XG5cbmNvbnN0IGJhc2VDU1MgPSAoe1xuICBpc0ZvY3VzZWQsXG4gIHRoZW1lOiB7XG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIGNvbG9ycyxcbiAgfSxcbn06IEluZGljYXRvclByb3BzKSA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG5cbiAgJzpob3Zlcic6IHtcbiAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnZHJvcGRvd25JbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBjeCwgZ2V0U3R5bGVzLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjc3M9e2dldFN0eWxlcygnY2xlYXJJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWVcbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudHlwZSBTZXBhcmF0b3JTdGF0ZSA9IHsgaXNEaXNhYmxlZDogYm9vbGVhbiB9O1xuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gKHtcbiAgaXNEaXNhYmxlZCxcbiAgdGhlbWU6IHtcbiAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgY29sb3JzLFxuICB9LFxufTogQ29tbW9uUHJvcHMgJiBTZXBhcmF0b3JTdGF0ZSkgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgd2lkdGg6IDEsXG59KTtcblxuZXhwb3J0IGNvbnN0IEluZGljYXRvclNlcGFyYXRvciA9IChwcm9wczogSW5kaWNhdG9yUHJvcHMpID0+IHtcbiAgY29uc3QgeyBjbGFzc05hbWUsIGN4LCBnZXRTdHlsZXMsIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIGNzcz17Z2V0U3R5bGVzKCdpbmRpY2F0b3JTZXBhcmF0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KHsgJ2luZGljYXRvci1zZXBhcmF0b3InOiB0cnVlIH0sIGNsYXNzTmFtZSl9XG4gICAgLz5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTG9hZGluZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IGxvYWRpbmdEb3RBbmltYXRpb25zID0ga2V5ZnJhbWVzYFxuICAwJSwgODAlLCAxMDAlIHsgb3BhY2l0eTogMDsgfVxuICA0MCUgeyBvcGFjaXR5OiAxOyB9XG5gO1xuXG5leHBvcnQgY29uc3QgbG9hZGluZ0luZGljYXRvckNTUyA9ICh7XG4gIGlzRm9jdXNlZCxcbiAgc2l6ZSxcbiAgdGhlbWU6IHtcbiAgICBjb2xvcnMsXG4gICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICB9LFxufToge1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW4sXG4gIHNpemU6IG51bWJlcixcbiAgdGhlbWU6IFRoZW1lLFxufSkgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgZm9udFNpemU6IHNpemUsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG1hcmdpblJpZ2h0OiBzaXplLFxuICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbn0pO1xuXG50eXBlIERvdFByb3BzID0geyBkZWxheTogbnVtYmVyLCBvZmZzZXQ6IGJvb2xlYW4gfTtcbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IERvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiBudWxsLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgdHlwZSBMb2FkaW5nSWNvblByb3BzID0ge1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IGFueSxcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbixcbiAgLyoqIFdoZXRoZXIgdGhlIHRleHQgaXMgcmlnaHQgdG8gbGVmdCAqL1xuICBpc1J0bDogYm9vbGVhbixcbn0gJiBDb21tb25Qcm9wcyAmIHtcbiAgICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgICBzaXplOiBudW1iZXIsXG4gIH07XG5leHBvcnQgY29uc3QgTG9hZGluZ0luZGljYXRvciA9IChwcm9wczogTG9hZGluZ0ljb25Qcm9wcykgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZSwgY3gsIGdldFN0eWxlcywgaW5uZXJQcm9wcywgaXNSdGwgfSA9IHByb3BzO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY3NzPXtnZXRTdHlsZXMoJ2xvYWRpbmdJbmRpY2F0b3InLCBwcm9wcyl9XG4gICAgICBjbGFzc05hbWU9e2N4KFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5Mb2FkaW5nSW5kaWNhdG9yLmRlZmF1bHRQcm9wcyA9IHsgc2l6ZTogNCB9O1xuIl19 */")
  });
};
var LoadingIndicator = function LoadingIndicator2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps, isRtl = props.isRtl;
  return jsx("div", _extends({
    css: getStyles3("loadingIndicator", props),
    className: cx({
      indicator: true,
      "loading-indicator": true
    }, className)
  }, innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};
var css4 = function css5(_ref3) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return {
    label: "control",
    alignItems: "center",
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : null,
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms",
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  };
};
var Control = function Control2(props) {
  var children = props.children, cx = props.cx, getStyles3 = props.getStyles, className = props.className, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef,
    css: getStyles3("control", props),
    className: cx({
      control: true,
      "control--is-disabled": isDisabled,
      "control--is-focused": isFocused,
      "control--menu-is-open": menuIsOpen
    }, className)
  }, innerProps), children);
};
var groupCSS = function groupCSS2(_ref3) {
  var spacing2 = _ref3.theme.spacing;
  return {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group2 = function Group3(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({
    css: getStyles3("group", props),
    className: cx({
      group: true
    }, className)
  }, innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles: getStyles3,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23) {
  var spacing2 = _ref23.theme.spacing;
  return {
    label: "group",
    color: "#999",
    cursor: "default",
    display: "block",
    fontSize: "75%",
    fontWeight: "500",
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  };
};
var GroupHeading = function GroupHeading2(props) {
  var getStyles3 = props.getStyles, cx = props.cx, className = props.className;
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, ["data"]);
  return jsx("div", _extends({
    css: getStyles3("groupHeading", props),
    className: cx({
      "group-heading": true
    }, className)
  }, innerProps));
};
var inputCSS = function inputCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    visibility: isDisabled ? "hidden" : "visible",
    color: colors2.neutral80
  };
};
var inputStyle = function inputStyle2(isHidden) {
  return {
    label: "input",
    background: 0,
    border: 0,
    fontSize: "inherit",
    opacity: isHidden ? 0 : 1,
    outline: 0,
    padding: 0,
    color: "inherit"
  };
};
var Input = function Input2(props) {
  var className = props.className, cx = props.cx, getStyles3 = props.getStyles;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, innerProps = _objectWithoutProperties(_cleanCommonProps, ["innerRef", "isDisabled", "isHidden"]);
  return jsx("div", {
    css: getStyles3("input", props)
  }, jsx(import_react_input_autosize.default, _extends({
    className: cx({
      input: true
    }, className),
    inputRef: innerRef,
    inputStyle: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var multiValueCSS = function multiValueCSS2(_ref3) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return {
    label: "multiValue",
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    display: "flex",
    margin: spacing2.baseUnit / 2,
    minWidth: 0
  };
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    overflow: "hidden",
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis ? "ellipsis" : null,
    whiteSpace: "nowrap"
  };
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return {
    alignItems: "center",
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused && colors2.dangerLight,
    display: "flex",
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  };
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", innerProps, children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, className = props.className, components2 = props.components, cx = props.cx, data2 = props.data, getStyles3 = props.getStyles, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label = components2.Label, Remove = components2.Remove;
  return jsx(ClassNames, null, function(_ref6) {
    var css7 = _ref6.css, emotionCx = _ref6.cx;
    return jsx(Container, {
      data: data2,
      innerProps: _objectSpread2({
        className: emotionCx(css7(getStyles3("multiValue", props)), cx({
          "multi-value": true,
          "multi-value--is-disabled": isDisabled
        }, className))
      }, innerProps),
      selectProps
    }, jsx(Label, {
      data: data2,
      innerProps: {
        className: emotionCx(css7(getStyles3("multiValueLabel", props)), cx({
          "multi-value__label": true
        }, className))
      },
      selectProps
    }, children), jsx(Remove, {
      data: data2,
      innerProps: _objectSpread2({
        className: emotionCx(css7(getStyles3("multiValueRemove", props)), cx({
          "multi-value__remove": true
        }, className))
      }, removeProps),
      selectProps
    }));
  });
};
MultiValue.defaultProps = {
  cropWithEllipsis: true
};
var optionCSS = function optionCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "option",
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)",
    ":active": {
      backgroundColor: !isDisabled && (isSelected ? colors2.primary : colors2.primary50)
    }
  };
};
var Option = function Option2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("option", props),
    className: cx({
      option: true,
      "option--is-disabled": isDisabled,
      "option--is-focused": isFocused,
      "option--is-selected": isSelected
    }, className),
    ref: innerRef
  }, innerProps), children);
};
var placeholderCSS = function placeholderCSS2(_ref3) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "placeholder",
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2,
    position: "absolute",
    top: "50%",
    transform: "translateY(-50%)"
  };
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("placeholder", props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};
var css$1 = function css6(_ref3) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return {
    label: "singleValue",
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2,
    maxWidth: "calc(100% - ".concat(spacing2.baseUnit * 2, "px)"),
    overflow: "hidden",
    position: "absolute",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    top: "50%",
    transform: "translateY(-50%)"
  };
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, className = props.className, cx = props.cx, getStyles3 = props.getStyles, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({
    css: getStyles3("singleValue", props),
    className: cx({
      "single-value": true,
      "single-value--is-disabled": isDisabled
    }, className)
  }, innerProps), children);
};
var components = {
  ClearIndicator,
  Control,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group2,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input,
  LoadingIndicator,
  Menu,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option,
  Placeholder,
  SelectContainer,
  SingleValue,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/react-select/dist/Select-dbb12e54.esm.js
var import_react14 = __toModule(require("react"));

// node_modules/memoize-one/dist/memoize-one.esm.js
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (newInputs[i2] !== lastInputs[i2]) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual) {
  if (isEqual === void 0) {
    isEqual = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/react-select/dist/Select-dbb12e54.esm.js
var _ref = true ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFJIiwiZmlsZSI6IkExMXlUZXh0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgdHlwZSBFbGVtZW50Q29uZmlnIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuXG4vLyBBc3Npc3RpdmUgdGV4dCB0byBkZXNjcmliZSB2aXN1YWwgZWxlbWVudHMuIEhpZGRlbiBmb3Igc2lnaHRlZCB1c2Vycy5cbmNvbnN0IEExMXlUZXh0ID0gKHByb3BzOiBFbGVtZW50Q29uZmlnPCdzcGFuJz4pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, _props$focused = props.focused, focused = _props$focused === void 0 ? {} : _props$focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = (0, import_react14.useMemo)(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = (0, import_react14.useMemo)(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, removedValue = ariaSelection.removedValue, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var onChangeProps = _objectSpread2({
        isDisabled: selected && isOptionDisabled3(selected),
        label: selected ? getOptionLabel4(selected) : ""
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, isOptionDisabled3, getOptionLabel4, messages]);
  var ariaFocused = (0, import_react14.useMemo)(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused),
        isSelected,
        options: options2,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, options2, selectValue]);
  var ariaResults = (0, import_react14.useMemo)(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = (0, import_react14.useMemo)(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  return jsx(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && jsx(import_react14.default.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext)));
};
var diacritics = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i2 = 0; i2 < diacritics.length; i2++) {
  diacritic = diacritics[i2];
  for (j2 = 0; j2 < diacritic.letters.length; j2++) {
    diacriticToBase[diacritic.letters[j2]] = diacritic.base;
  }
}
var diacritic;
var j2;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoize_one_esm_default(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
function DummyInput(_ref3) {
  _ref3.in;
  _ref3.out;
  _ref3.onExited;
  _ref3.appear;
  _ref3.enter;
  _ref3.exit;
  var innerRef = _ref3.innerRef;
  _ref3.emotion;
  var props = _objectWithoutProperties(_ref3, ["in", "out", "onExited", "appear", "enter", "exit", "innerRef", "emotion"]);
  return jsx("input", _extends({
    ref: innerRef
  }, props, {
    css: /* @__PURE__ */ css3({
      label: "dummyInput",
      background: 0,
      border: 0,
      fontSize: "inherit",
      outline: 0,
      padding: 0,
      width: 1,
      color: "transparent",
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(0)"
    }, true ? "" : ";label:DummyInput;", true ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBbUJNIiwiZmlsZSI6IkR1bW15SW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbjogaW5Qcm9wLFxuICBvdXQsXG4gIG9uRXhpdGVkLFxuICBhcHBlYXIsXG4gIGVudGVyLFxuICBleGl0LFxuICBpbm5lclJlZixcbiAgZW1vdGlvbixcbiAgLi4ucHJvcHNcbn06IGFueSkge1xuICByZXR1cm4gKFxuICAgIDxpbnB1dFxuICAgICAgcmVmPXtpbm5lclJlZn1cbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = (0, import_react14.useRef)(false);
  var isTop = (0, import_react14.useRef)(false);
  var touchStart = (0, import_react14.useRef)(0);
  var scrollTarget = (0, import_react14.useRef)(null);
  var handleEventDelta = (0, import_react14.useCallback)(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, []);
  var onWheel = (0, import_react14.useCallback)(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0, import_react14.useCallback)(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0, import_react14.useCallback)(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0, import_react14.useCallback)(function(el2) {
    if (!el2)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("wheel", onWheel, notPassive);
    }
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("touchstart", onTouchStart, notPassive);
    }
    if (typeof el2.addEventListener === "function") {
      el2.addEventListener("touchmove", onTouchMove, notPassive);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0, import_react14.useCallback)(function(el2) {
    if (!el2)
      return;
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("wheel", onWheel, false);
    }
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("touchstart", onTouchStart, false);
    }
    if (typeof el2.removeEventListener === "function") {
      el2.removeEventListener("touchmove", onTouchMove, false);
    }
  }, [onTouchMove, onTouchStart, onWheel]);
  (0, import_react14.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  e2.preventDefault();
}
function allowTouchMove(e2) {
  e2.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0, import_react14.useRef)({});
  var scrollTarget = (0, import_react14.useRef)(null);
  var addScrollLock = (0, import_react14.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, []);
  var removeScrollLock = (0, import_react14.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, []);
  (0, import_react14.useEffect)(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref22 = true ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0RVIiwiZmlsZSI6IlNjcm9sbE1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgUmVhY3QsIHsgdHlwZSBFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNjcm9sbENhcHR1cmUgZnJvbSAnLi91c2VTY3JvbGxDYXB0dXJlJztcbmltcG9ydCB1c2VTY3JvbGxMb2NrIGZyb20gJy4vdXNlU2Nyb2xsTG9jayc7XG5cbnR5cGUgUmVmQ2FsbGJhY2s8VD4gPSAoVCB8IG51bGwpID0+IHZvaWQ7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNoaWxkcmVuOiAoUmVmQ2FsbGJhY2s8SFRNTEVsZW1lbnQ+KSA9PiBFbGVtZW50PCo+LFxuICBsb2NrRW5hYmxlZDogYm9vbGVhbixcbiAgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW4sXG4gIG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRWxlbWVudD4pID0+IHZvaWQsXG4gIG9uQm90dG9tTGVhdmU/OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxFbGVtZW50PikgPT4gdm9pZCxcbiAgb25Ub3BBcnJpdmU/OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxFbGVtZW50PikgPT4gdm9pZCxcbiAgb25Ub3BMZWF2ZT86IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTEVsZW1lbnQ+KSA9PiB2b2lkLFxufTtcblxuY29uc3QgYmx1clNlbGVjdElucHV0ID0gKCkgPT5cbiAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2Nyb2xsTWFuYWdlcih7XG4gIGNoaWxkcmVuLFxuICBsb2NrRW5hYmxlZCxcbiAgY2FwdHVyZUVuYWJsZWQgPSB0cnVlLFxuICBvbkJvdHRvbUFycml2ZSxcbiAgb25Cb3R0b21MZWF2ZSxcbiAgb25Ub3BBcnJpdmUsXG4gIG9uVG9wTGVhdmUsXG59OiBQcm9wcykge1xuICBjb25zdCBzZXRTY3JvbGxDYXB0dXJlVGFyZ2V0ID0gdXNlU2Nyb2xsQ2FwdHVyZSh7XG4gICAgaXNFbmFibGVkOiBjYXB0dXJlRW5hYmxlZCxcbiAgICBvbkJvdHRvbUFycml2ZSxcbiAgICBvbkJvdHRvbUxlYXZlLFxuICAgIG9uVG9wQXJyaXZlLFxuICAgIG9uVG9wTGVhdmUsXG4gIH0pO1xuICBjb25zdCBzZXRTY3JvbGxMb2NrVGFyZ2V0ID0gdXNlU2Nyb2xsTG9jayh7IGlzRW5hYmxlZDogbG9ja0VuYWJsZWQgfSk7XG5cbiAgY29uc3QgdGFyZ2V0UmVmID0gZWxlbWVudCA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(import_react14.default.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref22
  }), children(targetRef));
}
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel = function getOptionLabel2(option) {
  return option.label;
};
var getOptionValue = function getOptionValue2(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles2 = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css4,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css$1,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel,
  getOptionValue,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: "0",
  tabSelectsValue: true
};
function toCategorizedOption(props, option, selectValue, index4) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel$1(props, option);
  var value = getOptionValue$1(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index4
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if (groupOrOption.options) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(function(categorizedOption) {
    return !!categorizedOption;
  });
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data2 = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data: data2
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel$1 = function getOptionLabel3(props, data2) {
  return props.getOptionLabel(data2);
};
var getOptionValue$1 = function getOptionValue3(props, data2) {
  return props.getOptionValue(data2);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue$1(props, option);
  return selectValue.some(function(i2) {
    return getOptionValue$1(props, i2) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name2 = _this$props.name;
      actionMeta.name = name2;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue) {
      var action = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "set-value";
      var option = arguments.length > 2 ? arguments[2] : void 0;
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti;
      _this.onInputChange("", {
        action: "set-value"
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name2 = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(selectValue.filter(function(i2) {
          return _this.getOptionValue(i2) !== candidate;
        }), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue([].concat(_toConsumableArray(selectValue), [newValue]), "select-option", newValue);
        } else {
          _this.setValue(newValue, "select-option");
        }
      } else {
        _this.ariaOnChange(newValue, {
          action: "select-option",
          name: name2
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i2) {
        return _this.getOptionValue(i2) !== candidate;
      });
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(_this.props.isMulti ? [] : null, {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = isMulti ? newValueArray : newValueArray[0] || null;
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data2) {
      return getOptionLabel$1(_this.props, data2);
    };
    _this.getOptionValue = function(data2) {
      return getOptionValue$1(_this.props, data2);
    };
    _this.getStyles = function(key, props) {
      var base = defaultStyles2[key](props);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
      event.stopPropagation();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.stopPropagation();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change"
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur"
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close"
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (isFocused && !isDisabled && prevProps.isDisabled || isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close"
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: function getTheme() {
      if (!this.props.theme) {
        return defaultTheme;
      }
      if (typeof this.props.theme === "function") {
        return this.props.theme(defaultTheme);
      }
      return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles3 = this.getStyles, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles: getStyles3,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data2, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var inputValue = this.props.inputValue;
        var selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data2, {
          context,
          inputValue,
          selectValue
        });
      } else {
        return this.getOptionLabel(data2);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data2) {
      return this.props.formatGroupLabel(data2);
    }
  }, {
    key: "startListeningComposition",
    value: function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener("compositionstart", this.onCompositionStart, false);
        document.addEventListener("compositionend", this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener("touchstart", this.onTouchStart, false);
        document.addEventListener("touchmove", this.onTouchMove, false);
        document.addEventListener("touchend", this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: function renderInput() {
      var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form;
      var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
      var inputIsHidden = this.state.inputIsHidden;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId("input");
      var ariaAttributes = {
        "aria-autocomplete": "list",
        "aria-label": this.props["aria-label"],
        "aria-labelledby": this.props["aria-labelledby"]
      };
      if (!isSearchable) {
        return /* @__PURE__ */ import_react14.default.createElement(DummyInput, _extends({
          id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          readOnly: true,
          disabled: isDisabled,
          tabIndex,
          form,
          value: ""
        }, ariaAttributes));
      }
      return /* @__PURE__ */ import_react14.default.createElement(Input3, _extends({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id,
        innerRef: this.getInputRef,
        isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex,
        form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state4 = this.state, selectValue = _this$state4.selectValue, focusedValue = _this$state4.focusedValue, isFocused = _this$state4.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ import_react14.default.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused
        }), placeholder);
      }
      if (isMulti) {
        var selectValues = selectValue.map(function(opt, index4) {
          var isOptionFocused = opt === focusedValue;
          return /* @__PURE__ */ import_react14.default.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key: "".concat(_this3.getOptionValue(opt)).concat(index4),
            index: index4,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e2) {
                e2.preventDefault();
                e2.stopPropagation();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
        return selectValues;
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ import_react14.default.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ import_react14.default.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ import_react14.default.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group4 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal2 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render2 = function render3(props, id) {
        var type = props.type, data2 = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data2;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data2);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data2);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ import_react14.default.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data: data2,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var data2 = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ import_react14.default.createElement(Group4, _extends({}, commonProps, {
              key: groupId,
              data: data2,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render2(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render2(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = /* @__PURE__ */ import_react14.default.createElement(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ import_react14.default.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ import_react14.default.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ import_react14.default.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading,
          placement
        }), /* @__PURE__ */ import_react14.default.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ import_react14.default.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ import_react14.default.createElement(MenuPortal2, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name2 = _this$props13.name;
      var selectValue = this.state.selectValue;
      if (!name2 || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ import_react14.default.createElement("input", {
            name: name2,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i2) {
            return /* @__PURE__ */ import_react14.default.createElement("input", {
              key: "i-".concat(i2),
              name: name2,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ import_react14.default.createElement("input", {
            name: name2,
            type: "hidden"
          });
          return /* @__PURE__ */ import_react14.default.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ import_react14.default.createElement("input", {
          name: name2,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state5 = this.state, ariaSelection = _this$state5.ariaSelection, focusedOption = _this$state5.focusedOption, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused, selectValue = _this$state5.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ import_react14.default.createElement(LiveRegion, _extends({}, commonProps, {
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ import_react14.default.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ import_react14.default.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ import_react14.default.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ import_react14.default.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue;
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var selectValue = cleanValue(value);
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props
      });
    }
  }]);
  return Select2;
}(import_react14.Component);
Select.defaultProps = defaultProps;

// node_modules/react-select/dist/stateManager-845a3300.esm.js
var import_react16 = __toModule(require("react"));
var defaultProps2 = {
  defaultInputValue: "",
  defaultMenuIsOpen: false,
  defaultValue: null
};
var manageState = function manageState2(SelectComponent) {
  var _class, _temp;
  return _temp = _class = /* @__PURE__ */ function(_Component) {
    _inherits(StateManager, _Component);
    var _super = _createSuper(StateManager);
    function StateManager() {
      var _this;
      _classCallCheck(this, StateManager);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.select = void 0;
      _this.state = {
        inputValue: _this.props.inputValue !== void 0 ? _this.props.inputValue : _this.props.defaultInputValue,
        menuIsOpen: _this.props.menuIsOpen !== void 0 ? _this.props.menuIsOpen : _this.props.defaultMenuIsOpen,
        value: _this.props.value !== void 0 ? _this.props.value : _this.props.defaultValue
      };
      _this.onChange = function(value, actionMeta) {
        _this.callProp("onChange", value, actionMeta);
        _this.setState({
          value
        });
      };
      _this.onInputChange = function(value, actionMeta) {
        var newValue = _this.callProp("onInputChange", value, actionMeta);
        _this.setState({
          inputValue: newValue !== void 0 ? newValue : value
        });
      };
      _this.onMenuOpen = function() {
        _this.callProp("onMenuOpen");
        _this.setState({
          menuIsOpen: true
        });
      };
      _this.onMenuClose = function() {
        _this.callProp("onMenuClose");
        _this.setState({
          menuIsOpen: false
        });
      };
      return _this;
    }
    _createClass(StateManager, [{
      key: "focus",
      value: function focus() {
        this.select.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this.select.blur();
      }
    }, {
      key: "getProp",
      value: function getProp(key) {
        return this.props[key] !== void 0 ? this.props[key] : this.state[key];
      }
    }, {
      key: "callProp",
      value: function callProp(name2) {
        if (typeof this.props[name2] === "function") {
          var _this$props;
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return (_this$props = this.props)[name2].apply(_this$props, args);
        }
      }
    }, {
      key: "render",
      value: function render2() {
        var _this2 = this;
        var _this$props2 = this.props;
        _this$props2.defaultInputValue;
        _this$props2.defaultMenuIsOpen;
        _this$props2.defaultValue;
        var props = _objectWithoutProperties(_this$props2, ["defaultInputValue", "defaultMenuIsOpen", "defaultValue"]);
        return /* @__PURE__ */ import_react16.default.createElement(SelectComponent, _extends({}, props, {
          ref: function ref(_ref3) {
            _this2.select = _ref3;
          },
          inputValue: this.getProp("inputValue"),
          menuIsOpen: this.getProp("menuIsOpen"),
          onChange: this.onChange,
          onInputChange: this.onInputChange,
          onMenuClose: this.onMenuClose,
          onMenuOpen: this.onMenuOpen,
          value: this.getProp("value")
        }));
      }
    }]);
    return StateManager;
  }(import_react16.Component), _class.defaultProps = defaultProps2, _temp;
};

// node_modules/react-select/dist/react-select.esm.js
var import_react17 = __toModule(require("react"));
var import_react_input_autosize2 = __toModule(require_AutosizeInput());
var import_react_dom2 = __toModule(require("react-dom"));
var index3 = manageState(Select);
var react_select_esm_default = index3;

// node_modules/spacetime/builds/spacetime.mjs
var e = (e2, t2, a2) => {
  const [n2, r2] = e2.split("/"), [o2, i2] = r2.split(":");
  return Date.UTC(a2, n2 - 1, o2, i2) - 36e5 * t2;
};
var t = (t2, a2, n2, r2, o2) => {
  const i2 = new Date(t2).getUTCFullYear(), s2 = e(a2, o2, i2), u2 = e(n2, r2, i2);
  return t2 >= s2 && t2 < u2;
};
var a = (e2) => {
  let a2 = e2.timezones[e2.tz];
  if (a2 === void 0)
    return console.warn("Warning: couldn't find timezone " + e2.tz), 0;
  if (a2.dst === void 0)
    return a2.offset;
  let n2 = a2.offset, r2 = a2.offset + 1;
  a2.hem === "n" && (r2 = n2 - 1);
  let o2 = a2.dst.split("->");
  return t(e2.epoch, o2[0], o2[1], n2, r2) === true ? n2 : r2;
};
var n = ["africa", "america", "asia", "atlantic", "australia", "brazil", "canada", "chile", "europe", "indian", "mexico", "pacific", "antarctica", "etc"];
var r;
var o = (r = Object.freeze({__proto__: null, default: {"9|s": "2/dili,2/jayapura", "9|n": "2/chita,2/khandyga,2/pyongyang,2/seoul,2/tokyo,11/palau", "9.5|s|04/04:03->10/03:02": "4/adelaide,4/broken_hill,4/south,4/yancowinna", "9.5|s": "4/darwin,4/north", "8|s|03/08:01->10/04:00": "12/casey", "8|s": "2/kuala_lumpur,2/makassar,2/singapore,4/perth,2/ujung_pandang,4/west", "8|n": "2/brunei,2/choibalsan,2/hong_kong,2/irkutsk,2/kuching,2/macau,2/manila,2/shanghai,2/taipei,2/ulaanbaatar,2/chongqing,2/chungking,2/harbin,2/macao,2/ulan_bator", "8.75|s": "4/eucla", "7|s": "12/davis,2/jakarta,9/christmas", "7|n": "2/bangkok,2/barnaul,2/hovd,2/krasnoyarsk,2/novokuznetsk,2/novosibirsk,2/phnom_penh,2/pontianak,2/saigon,2/tomsk,2/vientiane,2/ho_chi_minh", "6|s": "12/vostok", "6|n": "2/almaty,2/bishkek,2/dhaka,2/omsk,2/qyzylorda,2/qostanay,2/thimphu,2/urumqi,9/chagos,2/dacca,2/kashgar,2/thimbu", "6.5|n": "2/rangoon,9/cocos,2/yangon", "5|s": "12/mawson,9/kerguelen", "5|n": "2/aqtau,2/aqtobe,2/ashgabat,2/atyrau,2/baku,2/dushanbe,2/karachi,2/oral,2/samarkand,2/tashkent,2/yekaterinburg,9/maldives,2/ashkhabad", "5.75|n": "2/katmandu,2/kathmandu", "5.5|n": "2/calcutta,2/colombo,2/kolkata", "4|s": "9/reunion", "4|n": "2/dubai,2/muscat,2/tbilisi,2/yerevan,8/astrakhan,8/samara,8/saratov,8/ulyanovsk,8/volgograd,2/volgograd,9/mahe,9/mauritius", "4.5|n|03/22:00->09/21:24": "2/tehran", "4.5|n": "2/kabul", "3|s": "12/syowa,9/antananarivo", "3|n|03/28:03->10/31:04": "2/famagusta,2/nicosia,8/athens,8/bucharest,8/helsinki,8/kiev,8/mariehamn,8/riga,8/sofia,8/tallinn,8/uzhgorod,8/vilnius,8/zaporozhye,8/nicosia", "3|n|03/28:02->10/31:03": "8/chisinau,8/tiraspol", "3|n|03/28:00->10/30:24": "2/beirut", "3|n|03/27:00->10/30:01": "2/gaza,2/hebron", "3|n|03/26:02->10/31:02": "2/jerusalem,2/tel_aviv", "3|n|03/26:00->10/29:01": "2/amman", "3|n|03/26:00->10/28:24": "2/damascus", "3|n": "0/addis_ababa,0/asmera,0/dar_es_salaam,0/djibouti,0/juba,0/kampala,0/mogadishu,0/nairobi,2/aden,2/baghdad,2/bahrain,2/kuwait,2/qatar,2/riyadh,8/istanbul,8/kirov,8/minsk,8/moscow,8/simferopol,9/comoro,9/mayotte,0/asmara,2/istanbul", "2|s|03/28:02->10/31:02": "12/troll", "2|s": "0/gaborone,0/harare,0/johannesburg,0/lubumbashi,0/lusaka,0/maputo,0/maseru,0/mbabane", "2|n|03/28:02->10/31:03": "0/ceuta,arctic/longyearbyen,8/amsterdam,8/andorra,8/belgrade,8/berlin,8/bratislava,8/brussels,8/budapest,8/busingen,8/copenhagen,8/gibraltar,8/ljubljana,8/luxembourg,8/madrid,8/malta,8/monaco,8/oslo,8/paris,8/podgorica,8/prague,8/rome,8/san_marino,8/sarajevo,8/skopje,8/stockholm,8/tirane,8/vaduz,8/vatican,8/vienna,8/warsaw,8/zagreb,8/zurich,3/jan_mayen", "2|n": "0/blantyre,0/bujumbura,0/cairo,0/khartoum,0/kigali,0/tripoli,8/kaliningrad", "1|s": "0/brazzaville,0/kinshasa,0/luanda,0/windhoek", "1|n|04/11:03->05/16:02": "0/casablanca,0/el_aaiun", "1|n|03/28:01->10/31:02": "3/canary,3/faeroe,3/madeira,8/dublin,8/guernsey,8/isle_of_man,8/jersey,8/lisbon,8/london,3/faroe,8/belfast", "1|n": "0/algiers,0/bangui,0/douala,0/lagos,0/libreville,0/malabo,0/ndjamena,0/niamey,0/porto-novo,0/tunis", "14|n": "11/kiritimati", "13|s|04/04:04->09/26:03": "11/apia", "13|s|01/15:02->11/05:03": "11/tongatapu", "13|n": "11/enderbury,11/fakaofo", "12|s|04/04:03->09/26:02": "12/mcmurdo,11/auckland,12/south_pole", "12|s|01/17:03->11/14:02": "11/fiji", "12|n": "2/anadyr,2/kamchatka,2/srednekolymsk,11/funafuti,11/kwajalein,11/majuro,11/nauru,11/tarawa,11/wake,11/wallis", "12.75|s|04/04:03->09/26:02": "11/chatham", "11|s|04/04:03->10/03:02": "12/macquarie", "11|s": "11/bougainville", "11|n": "2/magadan,2/sakhalin,11/efate,11/guadalcanal,11/kosrae,11/noumea,11/ponape,11/pohnpei", "11.5|n|04/04:03->10/03:02": "11/norfolk", "10|s|04/04:03->10/03:02": "4/currie,4/hobart,4/melbourne,4/sydney,4/act,4/canberra,4/nsw,4/tasmania,4/victoria", "10|s": "12/dumontdurville,4/brisbane,4/lindeman,11/port_moresby,4/queensland", "10|n": "2/ust-nera,2/vladivostok,2/yakutsk,11/guam,11/saipan,11/truk,11/chuuk,11/yap", "10.5|s|04/04:01->10/03:02": "4/lord_howe,4/lhi", "0|n|03/28:00->10/31:01": "1/scoresbysund,3/azores", "0|n": "0/abidjan,0/accra,0/bamako,0/banjul,0/bissau,0/conakry,0/dakar,0/freetown,0/lome,0/monrovia,0/nouakchott,0/ouagadougou,0/sao_tome,1/danmarkshavn,3/reykjavik,3/st_helena,13/gmt,13/utc,0/timbuktu,13/gmt-0,13/gmt+0,13/gmt0,13/greenwich,13/uct,13/universal,13/zulu", "-9|n|03/14:02->11/07:02": "1/adak,1/atka,us/aleutian", "-9|n": "11/gambier", "-9.5|n": "11/marquesas", "-8|n|03/14:02->11/07:02": "1/anchorage,1/juneau,1/metlakatla,1/nome,1/sitka,1/yakutat,us/alaska", "-8|n": "11/pitcairn", "-7|n|03/14:02->11/07:02": "1/los_angeles,1/santa_isabel,1/tijuana,1/vancouver,1/ensenada,6/pacific,10/bajanorte,us/pacific-new,us/pacific", "-7|n|03/08:02->11/01:01": "1/dawson,1/whitehorse,6/yukon", "-7|n": "1/creston,1/dawson_creek,1/fort_nelson,1/hermosillo,1/phoenix,us/arizona", "-6|s|04/03:22->09/04:22": "11/easter,7/easterisland", "-6|n|04/04:02->10/31:02": "1/chihuahua,1/mazatlan,10/bajasur", "-6|n|03/14:02->11/07:02": "1/boise,1/cambridge_bay,1/denver,1/edmonton,1/inuvik,1/ojinaga,1/yellowknife,1/shiprock,6/mountain,us/mountain", "-6|n": "1/belize,1/costa_rica,1/el_salvador,1/guatemala,1/managua,1/regina,1/swift_current,1/tegucigalpa,11/galapagos,6/east-saskatchewan,6/saskatchewan", "-5|s": "1/lima,1/rio_branco,1/porto_acre,5/acre", "-5|n|04/04:02->10/31:02": "1/bahia_banderas,1/merida,1/mexico_city,1/monterrey,10/general", "-5|n|03/14:02->11/07:02": "1/chicago,1/matamoros,1/menominee,1/rainy_river,1/rankin_inlet,1/resolute,1/winnipeg,1/indiana/knox,1/indiana/tell_city,1/north_dakota/beulah,1/north_dakota/center,1/north_dakota/new_salem,1/knox_in,6/central,us/central,us/indiana-starke", "-5|n|03/12:03->11/05:01": "1/north_dakota", "-5|n": "1/bogota,1/cancun,1/cayman,1/coral_harbour,1/eirunepe,1/guayaquil,1/jamaica,1/panama,1/atikokan", "-4|s|05/13:23->08/13:01": "12/palmer", "-4|s|04/03:24->09/05:00": "1/santiago,7/continental", "-4|s|03/27:24->10/03:00": "1/asuncion", "-4|s|02/16:24->11/03:00": "1/campo_grande,1/cuiaba", "-4|s": "1/la_paz,1/manaus,5/west", "-4|n|03/14:02->11/07:02": "1/detroit,1/grand_turk,1/indianapolis,1/iqaluit,1/louisville,1/montreal,1/nassau,1/new_york,1/nipigon,1/pangnirtung,1/port-au-prince,1/thunder_bay,1/toronto,1/indiana/marengo,1/indiana/petersburg,1/indiana/vevay,1/indiana/vincennes,1/indiana/winamac,1/kentucky/monticello,1/fort_wayne,1/indiana/indianapolis,1/kentucky/louisville,6/eastern,us/east-indiana,us/eastern,us/michigan", "-4|n|03/14:00->11/07:01": "1/havana", "-4|n|03/12:03->11/05:01": "1/indiana,1/kentucky", "-4|n": "1/anguilla,1/antigua,1/aruba,1/barbados,1/blanc-sablon,1/boa_vista,1/caracas,1/curacao,1/dominica,1/grenada,1/guadeloupe,1/guyana,1/kralendijk,1/lower_princes,1/marigot,1/martinique,1/montserrat,1/port_of_spain,1/porto_velho,1/puerto_rico,1/santo_domingo,1/st_barthelemy,1/st_kitts,1/st_lucia,1/st_thomas,1/st_vincent,1/tortola,1/virgin", "-3|s": "1/argentina,1/buenos_aires,1/catamarca,1/cordoba,1/fortaleza,1/jujuy,1/mendoza,1/montevideo,1/punta_arenas,1/sao_paulo,12/rothera,3/stanley,1/argentina/la_rioja,1/argentina/rio_gallegos,1/argentina/salta,1/argentina/san_juan,1/argentina/san_luis,1/argentina/tucuman,1/argentina/ushuaia,1/argentina/buenos_aires,1/argentina/catamarca,1/argentina/comodrivadavia,1/argentina/cordoba,1/argentina/jujuy,1/argentina/mendoza,1/rosario,5/east", "-3|n|03/14:02->11/07:02": "1/glace_bay,1/goose_bay,1/halifax,1/moncton,1/thule,3/bermuda,6/atlantic", "-3|n": "1/araguaina,1/bahia,1/belem,1/cayenne,1/maceio,1/paramaribo,1/recife,1/santarem", "-2|n|03/27:22->10/30:23": "1/godthab,1/nuuk", "-2|n|03/14:02->11/07:02": "1/miquelon", "-2|n": "1/noronha,3/south_georgia,5/denoronha", "-2.5|n|03/14:02->11/07:02": "1/st_johns,6/newfoundland", "-1|n": "3/cape_verde", "-11|n": "11/midway,11/niue,11/pago_pago,11/samoa,us/samoa", "-10|n": "11/honolulu,11/johnston,11/rarotonga,11/tahiti,us/hawaii"}})) && r.default || r;
var i = {};
Object.keys(o).forEach((e2) => {
  let t2 = e2.split("|"), a2 = {offset: Number(t2[0]), hem: t2[1]};
  t2[2] && (a2.dst = t2[2]), o[e2].split(",").forEach((e3) => {
    e3 = e3.replace(/(^[0-9]+)\//, (e4, t3) => (t3 = Number(t3), n[t3] + "/")), i[e3] = a2;
  });
}), i.utc = {offset: 0, hem: "n"};
for (let e2 = -14; e2 <= 14; e2 += 0.5) {
  let t2 = e2;
  t2 > 0 && (t2 = "+" + t2);
  let a2 = "etc/gmt" + t2;
  i[a2] = {offset: -1 * e2, hem: "n"}, a2 = "utc/gmt" + t2, i[a2] = {offset: -1 * e2, hem: "n"};
}
var s = i;
var u = /(\-?[0-9]+)h(rs)?/i;
var l = /(\-?[0-9]+)/;
var h = /utc([\-+]?[0-9]+)/i;
var c = /gmt([\-+]?[0-9]+)/i;
var d = function(e2) {
  return (e2 = Number(e2)) >= -13 && e2 <= 13 ? "etc/gmt" + (e2 = ((e2 *= -1) > 0 ? "+" : "") + e2) : null;
};
var m = function(e2) {
  let t2 = e2.match(u);
  if (t2 !== null)
    return d(t2[1]);
  if (t2 = e2.match(h), t2 !== null)
    return d(t2[1]);
  if (t2 = e2.match(c), t2 !== null) {
    let e3 = -1 * Number(t2[1]);
    return d(e3);
  }
  return t2 = e2.match(l), t2 !== null ? d(t2[1]) : null;
};
var p = (() => {
  let e2 = (() => {
    if (typeof Intl == "undefined" || Intl.DateTimeFormat === void 0)
      return null;
    let e3 = Intl.DateTimeFormat();
    if (e3 === void 0 || e3.resolvedOptions === void 0)
      return null;
    let t2 = e3.resolvedOptions().timeZone;
    return t2 ? t2.toLowerCase() : null;
  })();
  return e2 === null ? "utc" : e2;
})();
var f = Object.keys(s).reduce((e2, t2) => {
  let a2 = t2.split("/")[1] || "";
  return a2 = a2.replace(/_/g, " "), e2[a2] = t2, e2;
}, {});
var y;
var g = (e2, t2) => {
  if (!e2)
    return p;
  typeof e2 != "string" && console.error("Timezone must be a string - recieved: '", e2, "'\n");
  let a2 = e2.trim();
  if (a2 = a2.toLowerCase(), t2.hasOwnProperty(a2) === true)
    return a2;
  if (a2 = ((e3) => (e3 = (e3 = (e3 = (e3 = (e3 = e3.replace(/ time/g, "")).replace(/ (standard|daylight|summer)/g, "")).replace(/\b(east|west|north|south)ern/g, "$1")).replace(/\b(africa|america|australia)n/g, "$1")).replace(/\beuropean/g, "europe")).replace(/\islands/g, "island"))(a2), t2.hasOwnProperty(a2) === true)
    return a2;
  if (f.hasOwnProperty(a2) === true)
    return f[a2];
  if (/[0-9]/.test(a2) === true) {
    let e3 = m(a2);
    if (e3)
      return e3;
  }
  throw new Error("Spacetime: Cannot find timezone named: '" + e2 + "'. Please enter an IANA timezone id.");
};
var b = (function(e2, t2) {
  t2.isLeapYear = (e3) => e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0, t2.isDate = (e3) => Object.prototype.toString.call(e3) === "[object Date]" && !isNaN(e3.valueOf()), t2.isArray = (e3) => Object.prototype.toString.call(e3) === "[object Array]", t2.isObject = (e3) => Object.prototype.toString.call(e3) === "[object Object]", t2.isBoolean = (e3) => Object.prototype.toString.call(e3) === "[object Boolean]", t2.zeroPad = (e3, t3 = 2) => (e3 += "").length >= t3 ? e3 : new Array(t3 - e3.length + 1).join("0") + e3, t2.titleCase = (e3) => e3 ? e3[0].toUpperCase() + e3.substr(1) : "", t2.ordinal = (e3) => {
    let t3 = e3 % 10, a2 = e3 % 100;
    return t3 === 1 && a2 !== 11 ? e3 + "st" : t3 === 2 && a2 !== 12 ? e3 + "nd" : t3 === 3 && a2 !== 13 ? e3 + "rd" : e3 + "th";
  }, t2.toCardinal = (e3) => (e3 = (e3 = String(e3)).replace(/([0-9])(st|nd|rd|th)$/i, "$1"), parseInt(e3, 10)), t2.normalize = (e3 = "") => (e3 = (e3 = (e3 = (e3 = e3.toLowerCase().trim()).replace(/ies$/, "y")).replace(/s$/, "")).replace(/-/g, "")) === "day" || e3 === "days" ? "date" : e3 === "min" || e3 === "mins" ? "minute" : e3, t2.getEpoch = (e3) => typeof e3 == "number" ? e3 : t2.isDate(e3) ? e3.getTime() : e3.epoch ? e3.epoch : null, t2.beADate = (e3, a2) => t2.isObject(e3) === false ? a2.clone().set(e3) : e3, t2.formatTimezone = (e3, a2 = "") => {
    const n2 = e3 > 0 ? "+" : "-", r2 = Math.abs(e3);
    return `${n2}${t2.zeroPad(parseInt("" + r2, 10))}${a2}${t2.zeroPad(r2 % 1 * 60)}`;
  };
}(y = {exports: {}}, y.exports), y.exports);
b.isLeapYear, b.isDate, b.isArray, b.isObject, b.isBoolean, b.zeroPad, b.titleCase, b.ordinal, b.toCardinal, b.normalize, b.getEpoch, b.beADate, b.formatTimezone;
var k = {year: new Date().getFullYear(), month: 0, date: 1};
var w2 = {parseArray: (e2, t2, a2) => {
  if (t2.length === 0)
    return e2;
  let n2 = ["year", "month", "date", "hour", "minute", "second", "millisecond"];
  for (let r2 = 0; r2 < n2.length; r2++) {
    let o2 = t2[r2] || a2[n2[r2]] || k[n2[r2]] || 0;
    e2 = e2[n2[r2]](o2);
  }
  return e2;
}, parseObject: (e2, t2, a2) => {
  if (Object.keys(t2).length === 0)
    return e2;
  t2 = Object.assign({}, k, a2, t2);
  let n2 = Object.keys(t2);
  for (let r2 = 0; r2 < n2.length; r2++) {
    let o2 = n2[r2];
    if (e2[o2] === void 0 || typeof e2[o2] != "function")
      continue;
    if (t2[o2] === null || t2[o2] === void 0 || t2[o2] === "")
      continue;
    let i2 = t2[o2] || a2[o2] || k[o2] || 0;
    e2 = e2[o2](i2);
  }
  return e2;
}, parseNumber: function(e2, t2) {
  return t2 > 0 && t2 < 25e8 && e2.silent === false && (console.warn("  - Warning: You are setting the date to January 1970."), console.warn("       -   did input seconds instead of milliseconds?")), e2.epoch = t2, e2;
}};
var v = function(e2) {
  return e2.epoch = Date.now(), Object.keys(e2._today || {}).forEach((t2) => {
    typeof e2[t2] == "function" && (e2 = e2[t2](e2._today[t2]));
  }), e2;
};
var z = {now: (e2) => v(e2), today: (e2) => v(e2), tonight: (e2) => e2 = (e2 = v(e2)).hour(18), tomorrow: (e2) => e2 = (e2 = (e2 = v(e2)).add(1, "day")).startOf("day"), yesterday: (e2) => e2 = (e2 = (e2 = v(e2)).subtract(1, "day")).startOf("day"), christmas: (e2) => {
  let t2 = v(e2).year();
  return e2 = e2.set([t2, 11, 25, 18, 0, 0]);
}, "new years": (e2) => {
  let t2 = v(e2).year();
  return e2 = e2.set([t2, 11, 31, 18, 0, 0]);
}};
z["new years eve"] = z["new years"];
var _ = z;
var j = function(e2) {
  return e2 = (e2 = (e2 = (e2 = e2.replace(/\b(mon|tues?|wed|wednes|thur?s?|fri|sat|satur|sun)(day)?\b/i, "")).replace(/([0-9])(th|rd|st|nd)/, "$1")).replace(/,/g, "")).replace(/ +/g, " ").trim();
};
var O = {millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5};
O.date = O.day, O.month = 25488e5, O.week = 6048e5, O.year = 3154e7, Object.keys(O).forEach((e2) => {
  O[e2 + "s"] = O[e2];
});
var $ = O;
var D = (e2, t2, a2, n2, r2) => {
  let o2 = e2.d[a2]();
  if (o2 === t2)
    return;
  let i2 = r2 === null ? null : e2.d[r2](), s2 = e2.epoch, u2 = t2 - o2;
  e2.epoch += $[n2] * u2, n2 === "day" && Math.abs(u2) > 28 && t2 < 28 && (e2.epoch += $.hour), r2 !== null && i2 !== e2.d[r2]() && (e2.epoch = s2);
  const l2 = $[n2] / 2;
  for (; e2.d[a2]() < t2; )
    e2.epoch += l2;
  for (; e2.d[a2]() > t2; )
    e2.epoch -= l2;
  r2 !== null && i2 !== e2.d[r2]() && (e2.epoch = s2);
};
var M = {year: {valid: (e2) => e2 > -4e3 && e2 < 4e3, walkTo: (e2, t2) => D(e2, t2, "getFullYear", "year", null)}, month: {valid: (e2) => e2 >= 0 && e2 <= 11, walkTo: (e2, t2) => {
  let a2 = e2.d, n2 = a2.getMonth(), r2 = e2.epoch, o2 = a2.getFullYear();
  if (n2 === t2)
    return;
  let i2 = t2 - n2;
  for (e2.epoch += $.day * (28 * i2), o2 !== e2.d.getFullYear() && (e2.epoch = r2); e2.d.getMonth() < t2; )
    e2.epoch += $.day;
  for (; e2.d.getMonth() > t2; )
    e2.epoch -= $.day;
}}, date: {valid: (e2) => e2 > 0 && e2 <= 31, walkTo: (e2, t2) => D(e2, t2, "getDate", "day", "getMonth")}, hour: {valid: (e2) => e2 >= 0 && e2 < 24, walkTo: (e2, t2) => D(e2, t2, "getHours", "hour", "getDate")}, minute: {valid: (e2) => e2 >= 0 && e2 < 60, walkTo: (e2, t2) => D(e2, t2, "getMinutes", "minute", "getHours")}, second: {valid: (e2) => e2 >= 0 && e2 < 60, walkTo: (e2, t2) => {
  e2.epoch = e2.seconds(t2).epoch;
}}, millisecond: {valid: (e2) => e2 >= 0 && e2 < 1e3, walkTo: (e2, t2) => {
  e2.epoch = e2.milliseconds(t2).epoch;
}}};
var P = (e2, t2) => {
  let a2 = Object.keys(M), n2 = e2.clone();
  for (let r2 = 0; r2 < a2.length; r2++) {
    let o2 = a2[r2], i2 = t2[o2];
    if (i2 === void 0 && (i2 = n2[o2]()), typeof i2 == "string" && (i2 = parseInt(i2, 10)), !M[o2].valid(i2))
      return e2.epoch = null, void (e2.silent === false && console.warn("invalid " + o2 + ": " + i2));
    M[o2].walkTo(e2, i2);
  }
};
var q = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var S = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sept", "oct", "nov", "dec"];
var E = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
var T = () => S;
var N = () => E;
var C = () => function() {
  const e2 = {sep: 8};
  for (let t2 = 0; t2 < S.length; t2++)
    e2[S[t2]] = t2;
  for (let t2 = 0; t2 < E.length; t2++)
    e2[E[t2]] = t2;
  return e2;
}();
var I = (e2) => {
  S = e2.short || S, E = e2.long || E;
};
var A = (e2, t2) => {
  if (!t2)
    return e2;
  t2 !== "Z" && t2 !== "z" || (t2 = "+0000");
  let a2 = 0;
  /^[\+-]?[0-9]{2}:[0-9]{2}$/.test(t2) && (/:00/.test(t2) === true && (t2 = t2.replace(/:00/, "")), /:30/.test(t2) === true && (t2 = t2.replace(/:30/, ".5"))), /^[\+-]?[0-9]{4}$/.test(t2) && (t2 = t2.replace(/30$/, ".5")), a2 = parseFloat(t2), Math.abs(a2) > 100 && (a2 /= 100), a2 *= -1, a2 >= 0 && (a2 = "+" + a2);
  let n2 = "etc/gmt" + a2;
  return e2.timezones[n2] && (e2.tz = n2), e2;
};
var Y = (e2, t2 = "") => {
  let a2 = (t2 = t2.replace(/^\s+/, "").toLowerCase()).match(/([0-9]{1,2}):([0-9]{1,2}):?([0-9]{1,2})?[:\.]?([0-9]{1,4})?/);
  if (a2 !== null) {
    let n2 = Number(a2[1]);
    if (n2 < 0 || n2 > 24)
      return e2.startOf("day");
    let r2 = Number(a2[2]);
    if (a2[2].length < 2 || r2 < 0 || r2 > 59)
      return e2.startOf("day");
    a2[4] > 999 && (a2[4] = parseInt(("" + a2[4]).substring(0, 3), 10)), e2 = (e2 = (e2 = (e2 = e2.hour(n2)).minute(r2)).seconds(a2[3] || 0)).millisecond(a2[4] || 0);
    let o2 = t2.match(/[\b0-9](am|pm)\b/);
    return o2 !== null && o2[1] && (e2 = e2.ampm(o2[1])), e2;
  }
  if (a2 = t2.match(/([0-9]+) ?(am|pm)/), a2 !== null && a2[1]) {
    let t3 = Number(a2[1]);
    return t3 > 12 || t3 < 1 ? e2.startOf("day") : e2 = (e2 = (e2 = e2.hour(a2[1] || 0)).ampm(a2[2])).startOf("hour");
  }
  return e2 = e2.startOf("day");
};
var x = b.isLeapYear;
var L2 = C();
var F = {parseOffset: A, parseTime: Y, parseYear: (e2 = "", t2) => {
  if (e2 = e2.trim(), /^'[0-9][0-9]$/.test(e2) === true) {
    let t3 = Number(e2.replace(/'/, ""));
    return t3 > 50 ? 1900 + t3 : 2e3 + t3;
  }
  let a2 = parseInt(e2, 10);
  return !a2 && t2 && (a2 = t2.year), a2 = a2 || new Date().getFullYear(), a2;
}, parseMonth: function(e2) {
  return e2 = e2.toLowerCase().trim(), L2[e2];
}, validate: (e2) => {
  if (q.hasOwnProperty(e2.month) !== true)
    return false;
  if (e2.month === 1)
    return !!(x(e2.year) && e2.date <= 29) || e2.date <= 28;
  let t2 = q[e2.month] || 0;
  return e2.date <= t2;
}};
var {validate: B, parseTime: Z, parseYear: H, parseMonth: Q, parseOffset: G} = F;
var U = [{reg: /^(\-?0?0?[0-9]{3,4})-([0-9]{1,2})-([0-9]{1,2})[T| ]([0-9.:]+)(Z|[0-9\-\+:]+)?$/i, parse: (e2, t2) => {
  let a2 = {year: t2[1], month: parseInt(t2[2], 10) - 1, date: t2[3]};
  return B(a2) === false ? (e2.epoch = null, e2) : (G(e2, t2[5]), P(e2, a2), e2 = Z(e2, t2[4]));
}}, {reg: /^([0-9]{4})[\-\/\. ]([0-9]{1,2})[\-\/\. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse: (e2, t2) => {
  let a2 = {year: t2[1], month: parseInt(t2[2], 10) - 1, date: parseInt(t2[3], 10)};
  return a2.month >= 12 && (a2.date = parseInt(t2[2], 10), a2.month = parseInt(t2[3], 10) - 1), B(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = Z(e2, t2[4]));
}}, {reg: /^([0-9]{4})[\-\/\. ]([a-z]+)[\-\/\. ]([0-9]{1,2})( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse: (e2, t2) => {
  let a2 = {year: H(t2[1], e2._today), month: Q(t2[2]), date: b.toCardinal(t2[3] || "")};
  return B(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = Z(e2, t2[4]));
}}];
var {validate: V, parseTime: W, parseYear: J, parseMonth: K} = F;
var R = [{reg: /^([0-9]{1,2})[\-\/.]([0-9]{1,2})[\-\/.]?([0-9]{4})?( [0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i, parse: (e2, t2) => {
  let a2 = parseInt(t2[1], 10) - 1, n2 = parseInt(t2[2], 10);
  (e2.british || a2 >= 12) && (n2 = parseInt(t2[1], 10), a2 = parseInt(t2[2], 10) - 1);
  let r2 = {date: n2, month: a2, year: J(t2[3], e2._today) || new Date().getFullYear()};
  return V(r2) === false ? (e2.epoch = null, e2) : (P(e2, r2), e2 = W(e2, t2[4]));
}}, {reg: /^([a-z]+)[\-\/\. ]([0-9]{1,2})[\-\/\. ]?([0-9]{4}|'[0-9]{2})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse: (e2, t2) => {
  let a2 = {year: J(t2[3], e2._today), month: K(t2[1]), date: b.toCardinal(t2[2] || "")};
  return V(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = W(e2, t2[4]));
}}, {reg: /^([a-z]+) ([0-9]{1,2})( [0-9]{4})?( ([0-9:]+( ?am| ?pm| ?gmt)?))?$/i, parse: (e2, t2) => {
  let a2 = {year: J(t2[3], e2._today), month: K(t2[1]), date: b.toCardinal(t2[2] || "")};
  return V(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = W(e2, t2[4]));
}}, {reg: /^([a-z]+) ([0-9]{1,2})( [0-9:]+)?( \+[0-9]{4})?( [0-9]{4})?$/i, parse: (e2, t2) => {
  let a2 = {year: J(t2[5], e2._today), month: K(t2[1]), date: b.toCardinal(t2[2] || "")};
  return V(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = W(e2, t2[3]));
}}];
var {validate: X, parseTime: ee, parseYear: te, parseMonth: ae} = F;
var ne = [{reg: /^([0-9]{1,2})[\-\/]([a-z]+)[\-\/]?([0-9]{4})?$/i, parse: (e2, t2) => {
  let a2 = {year: te(t2[3], e2._today), month: ae(t2[2]), date: b.toCardinal(t2[1] || "")};
  return X(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = ee(e2, t2[4]));
}}, {reg: /^([0-9]{1,2})( [a-z]+)( [0-9]{4}| '[0-9]{2})? ?([0-9]{1,2}:[0-9]{2}:?[0-9]{0,2}? ?(am|pm|gmt))?$/i, parse: (e2, t2) => {
  let a2 = {year: te(t2[3], e2._today), month: ae(t2[2]), date: b.toCardinal(t2[1])};
  return a2.month && X(a2) !== false ? (P(e2, a2), e2 = ee(e2, t2[4])) : (e2.epoch = null, e2);
}}, {reg: /^([0-9]{1,2})[\. -/]([a-z]+)[\. -/]([0-9]{4})?( [0-9]{1,2}(:[0-9]{0,2})?(:[0-9]{0,3})? ?(am|pm)?)?$/i, parse: (e2, t2) => {
  let a2 = {date: Number(t2[1]), month: ae(t2[2]), year: Number(t2[3])};
  return X(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = e2.startOf("day"), e2 = ee(e2, t2[4]));
}}];
var {validate: re, parseTime: oe, parseYear: ie, parseMonth: se} = F;
var ue = [].concat(U, R, ne, [{reg: /^([0-9]{4})[\-\/]([0-9]{2})$/i, parse: (e2, t2) => {
  let a2 = {year: t2[1], month: parseInt(t2[2], 10) - 1, date: 1};
  return re(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = oe(e2, t2[4]));
}}, {reg: /^([a-z]+) ([0-9]{4})$/i, parse: (e2, t2) => {
  let a2 = {year: ie(t2[2], e2._today), month: se(t2[1]), date: e2._today.date || 1};
  return re(a2) === false ? (e2.epoch = null, e2) : (P(e2, a2), e2 = oe(e2, t2[4]));
}}, {reg: /^(q[0-9])( of)?( [0-9]{4})?/i, parse: (e2, t2) => {
  let a2 = t2[1] || "";
  e2 = e2.quarter(a2);
  let n2 = t2[3] || "";
  return n2 && (n2 = n2.trim(), e2 = e2.year(n2)), e2;
}}, {reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i, parse: (e2, t2) => {
  let a2 = t2[1] || "";
  e2 = e2.season(a2);
  let n2 = t2[3] || "";
  return n2 && (n2 = n2.trim(), e2 = e2.year(n2)), e2;
}}, {reg: /^[0-9,]+ ?b\.?c\.?$/i, parse: (e2, t2) => {
  let a2 = t2[0] || "";
  a2 = a2.replace(/^([0-9,]+) ?b\.?c\.?$/i, "-$1");
  let n2 = new Date(), r2 = {year: parseInt(a2.trim(), 10), month: n2.getMonth(), date: n2.getDate()};
  return re(r2) === false ? (e2.epoch = null, e2) : (P(e2, r2), e2 = oe(e2));
}}, {reg: /^[0-9,]+ ?(a\.?d\.?|c\.?e\.?)$/i, parse: (e2, t2) => {
  let a2 = t2[0] || "";
  a2 = a2.replace(/,/g, "");
  let n2 = new Date(), r2 = {year: parseInt(a2.trim(), 10), month: n2.getMonth(), date: n2.getDate()};
  return re(r2) === false ? (e2.epoch = null, e2) : (P(e2, r2), e2 = oe(e2));
}}, {reg: /^[0-9]{4}( ?a\.?d\.?)?$/i, parse: (e2, t2) => {
  let a2 = e2._today;
  a2.month && !a2.date && (a2.date = 1);
  let n2 = new Date(), r2 = {year: ie(t2[0], a2), month: a2.month || n2.getMonth(), date: a2.date || n2.getDate()};
  return re(r2) === false ? (e2.epoch = null, e2) : (P(e2, r2), e2 = oe(e2));
}}]);
var le = function(e2, t2, a2) {
  for (let n2 = 0; n2 < ue.length; n2++) {
    let r2 = t2.match(ue[n2].reg);
    if (r2) {
      let t3 = ue[n2].parse(e2, r2, a2);
      if (t3 !== null && t3.isValid())
        return t3;
    }
  }
  return e2.silent === false && console.warn("Warning: couldn't parse date-string: '" + t2 + "'"), e2.epoch = null, e2;
};
var {parseArray: he, parseObject: ce, parseNumber: de} = w2;
var me = {year: new Date().getFullYear(), month: 0, date: 1};
var pe = (e2, t2) => {
  let a2 = e2._today || me;
  if (typeof t2 == "number")
    return de(e2, t2);
  if (e2.epoch = Date.now(), e2._today && b.isObject(e2._today) && Object.keys(e2._today).length > 0) {
    let t3 = ce(e2, a2, me);
    t3.isValid() && (e2.epoch = t3.epoch);
  }
  return t2 == null || t2 === "" ? e2 : b.isDate(t2) === true ? (e2.epoch = t2.getTime(), e2) : b.isArray(t2) === true ? e2 = he(e2, t2, a2) : b.isObject(t2) === true ? t2.epoch ? (e2.epoch = t2.epoch, e2.tz = t2.tz, e2) : e2 = ce(e2, t2, a2) : typeof t2 != "string" ? e2 : (t2 = j(t2), _.hasOwnProperty(t2) === true ? e2 = _[t2](e2) : le(e2, t2));
};
var fe = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var ye = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var ge = {short: () => fe, long: () => ye, set: (e2) => {
  fe = e2.short || fe, ye = e2.long || ye;
}, aliases: {mo: 1, tu: 2, we: 3, th: 4, fr: 5, sa: 6, su: 7, tues: 2, weds: 3, wedn: 3, thur: 4, thurs: 4}};
var be = true;
var ke = () => be;
var we = (e2) => {
  be = e2;
};
var ve = (e2) => {
  let t2 = e2.timezone().current.offset;
  return t2 ? b.formatTimezone(t2, ":") : "Z";
};
var ze = (e2) => ke() ? b.titleCase(e2) : e2;
var _e = {day: (e2) => ze(e2.dayName()), "day-short": (e2) => ze(ge.short()[e2.day()]), "day-number": (e2) => e2.day(), "day-ordinal": (e2) => b.ordinal(e2.day()), "day-pad": (e2) => b.zeroPad(e2.day()), date: (e2) => e2.date(), "date-ordinal": (e2) => b.ordinal(e2.date()), "date-pad": (e2) => b.zeroPad(e2.date()), month: (e2) => ze(e2.monthName()), "month-short": (e2) => ze(T()[e2.month()]), "month-number": (e2) => e2.month(), "month-ordinal": (e2) => b.ordinal(e2.month()), "month-pad": (e2) => b.zeroPad(e2.month()), "iso-month": (e2) => b.zeroPad(e2.month() + 1), year: (e2) => {
  let t2 = e2.year();
  return t2 > 0 ? t2 : (t2 = Math.abs(t2), t2 + " BC");
}, "year-short": (e2) => {
  let t2 = e2.year();
  return t2 > 0 ? "'" + String(e2.year()).substr(2, 4) : (t2 = Math.abs(t2), t2 + " BC");
}, "iso-year": (e2) => {
  let t2 = e2.year(), a2 = t2 < 0, n2 = b.zeroPad(Math.abs(t2), 4);
  return a2 && (n2 = b.zeroPad(n2, 6), n2 = "-" + n2), n2;
}, time: (e2) => e2.time(), "time-24": (e2) => `${e2.hour24()}:${b.zeroPad(e2.minute())}`, hour: (e2) => e2.hour12(), "hour-pad": (e2) => b.zeroPad(e2.hour12()), "hour-24": (e2) => e2.hour24(), "hour-24-pad": (e2) => b.zeroPad(e2.hour24()), minute: (e2) => e2.minute(), "minute-pad": (e2) => b.zeroPad(e2.minute()), second: (e2) => e2.second(), "second-pad": (e2) => b.zeroPad(e2.second()), ampm: (e2) => e2.ampm(), quarter: (e2) => "Q" + e2.quarter(), season: (e2) => e2.season(), era: (e2) => e2.era(), json: (e2) => e2.json(), timezone: (e2) => e2.timezone().name, offset: (e2) => ve(e2), numeric: (e2) => `${e2.year()}/${b.zeroPad(e2.month() + 1)}/${b.zeroPad(e2.date())}`, "numeric-us": (e2) => `${b.zeroPad(e2.month() + 1)}/${b.zeroPad(e2.date())}/${e2.year()}`, "numeric-uk": (e2) => `${b.zeroPad(e2.date())}/${b.zeroPad(e2.month() + 1)}/${e2.year()}`, "mm/dd": (e2) => `${b.zeroPad(e2.month() + 1)}/${b.zeroPad(e2.date())}`, iso: (e2) => `${e2.format("iso-year")}-${b.zeroPad(e2.month() + 1)}-${b.zeroPad(e2.date())}T${b.zeroPad(e2.h24())}:${b.zeroPad(e2.minute())}:${b.zeroPad(e2.second())}.${b.zeroPad(e2.millisecond(), 3)}${ve(e2)}`, "iso-short": (e2) => {
  let t2 = b.zeroPad(e2.month() + 1), a2 = b.zeroPad(e2.date());
  return `${e2.year()}-${t2}-${a2}`;
}, "iso-utc": (e2) => new Date(e2.epoch).toISOString(), nice: (e2) => `${T()[e2.month()]} ${b.ordinal(e2.date())}, ${e2.time()}`, "nice-24": (e2) => `${T()[e2.month()]} ${b.ordinal(e2.date())}, ${e2.hour24()}:${b.zeroPad(e2.minute())}`, "nice-year": (e2) => `${T()[e2.month()]} ${b.ordinal(e2.date())}, ${e2.year()}`, "nice-day": (e2) => `${ge.short()[e2.day()]} ${ze(T()[e2.month()])} ${b.ordinal(e2.date())}`, "nice-full": (e2) => `${e2.dayName()} ${ze(e2.monthName())} ${b.ordinal(e2.date())}, ${e2.time()}`, "nice-full-24": (e2) => `${e2.dayName()} ${ze(e2.monthName())} ${b.ordinal(e2.date())}, ${e2.hour24()}:${b.zeroPad(e2.minute())}`};
var je = {"day-name": "day", "month-name": "month", "iso 8601": "iso", "time-h24": "time-24", "time-12": "time", "time-h12": "time", tz: "timezone", "day-num": "day-number", "month-num": "month-number", "month-iso": "iso-month", "year-iso": "iso-year", "nice-short": "nice", "nice-short-24": "nice-24", mdy: "numeric-us", dmy: "numeric-uk", ymd: "numeric", "yyyy/mm/dd": "numeric", "mm/dd/yyyy": "numeric-us", "dd/mm/yyyy": "numeric-us", "little-endian": "numeric-uk", "big-endian": "numeric", "day-nice": "nice-day"};
Object.keys(je).forEach((e2) => _e[e2] = _e[je[e2]]);
var Oe = (e2, t2 = "") => {
  if (e2.isValid() !== true)
    return "";
  if (_e.hasOwnProperty(t2)) {
    let a2 = _e[t2](e2) || "";
    return t2 !== "json" && (a2 = String(a2), t2 !== "ampm" && (a2 = ze(a2))), a2;
  }
  if (t2.indexOf("{") !== -1) {
    let a2 = /\{(.+?)\}/g;
    return t2 = t2.replace(a2, (t3, a3) => {
      if (a3 = a3.toLowerCase().trim(), _e.hasOwnProperty(a3)) {
        let t4 = String(_e[a3](e2));
        return a3 !== "ampm" ? ze(t4) : t4;
      }
      return "";
    });
  }
  return e2.format("iso-short");
};
var $e = b.zeroPad;
var De = b.formatTimezone;
var Me = {G: (e2) => e2.era(), GG: (e2) => e2.era(), GGG: (e2) => e2.era(), GGGG: (e2) => e2.era() === "AD" ? "Anno Domini" : "Before Christ", y: (e2) => e2.year(), yy: (e2) => parseInt(String(e2.year()).substr(2, 4), 10), yyy: (e2) => e2.year(), yyyy: (e2) => e2.year(), yyyyy: (e2) => "0" + e2.year(), Q: (e2) => e2.quarter(), QQ: (e2) => e2.quarter(), QQQ: (e2) => e2.quarter(), QQQQ: (e2) => e2.quarter(), M: (e2) => e2.month() + 1, MM: (e2) => $e(e2.month() + 1), MMM: (e2) => e2.format("month-short"), MMMM: (e2) => e2.format("month"), w: (e2) => e2.week(), ww: (e2) => $e(e2.week()), d: (e2) => e2.date(), dd: (e2) => $e(e2.date()), D: (e2) => e2.dayOfYear(), DD: (e2) => $e(e2.dayOfYear()), DDD: (e2) => $e(e2.dayOfYear(), 3), E: (e2) => e2.format("day-short"), EE: (e2) => e2.format("day-short"), EEE: (e2) => e2.format("day-short"), EEEE: (e2) => e2.format("day"), EEEEE: (e2) => e2.format("day")[0], e: (e2) => e2.day(), ee: (e2) => e2.day(), eee: (e2) => e2.format("day-short"), eeee: (e2) => e2.format("day"), eeeee: (e2) => e2.format("day")[0], a: (e2) => e2.ampm().toUpperCase(), aa: (e2) => e2.ampm().toUpperCase(), aaa: (e2) => e2.ampm().toUpperCase(), aaaa: (e2) => e2.ampm().toUpperCase(), h: (e2) => e2.h12(), hh: (e2) => $e(e2.h12()), H: (e2) => e2.hour(), HH: (e2) => $e(e2.hour()), m: (e2) => e2.minute(), mm: (e2) => $e(e2.minute()), s: (e2) => e2.second(), ss: (e2) => $e(e2.second()), A: (e2) => e2.epoch - e2.startOf("day").epoch, z: (e2) => e2.timezone().name, zz: (e2) => e2.timezone().name, zzz: (e2) => e2.timezone().name, zzzz: (e2) => e2.timezone().name, Z: (e2) => De(e2.timezone().current.offset), ZZ: (e2) => De(e2.timezone().current.offset), ZZZ: (e2) => De(e2.timezone().current.offset), ZZZZ: (e2) => De(e2.timezone().current.offset, ":")};
var Pe = (e2, t2, a2) => {
  let n2 = e2, r2 = t2;
  for (let o2 = 0; o2 < a2; o2 += 1)
    Me[n2] = Me[r2], n2 += e2, r2 += t2;
};
Pe("q", "Q", 4), Pe("L", "M", 4), Pe("Y", "y", 4), Pe("c", "e", 4), Pe("k", "H", 2), Pe("K", "h", 2), Pe("S", "s", 2), Pe("v", "z", 4), Pe("V", "Z", 4);
var qe = (e2, t2) => {
  let a2 = t2.split("");
  return a2 = function(e3) {
    for (let t3 = 0; t3 < e3.length; t3 += 1)
      if (e3[t3] === "'")
        for (let a3 = t3 + 1; a3 < e3.length; a3 += 1) {
          if (e3[a3] && (e3[t3] += e3[a3]), e3[a3] === "'") {
            e3[a3] = null;
            break;
          }
          e3[a3] = null;
        }
    return e3.filter((e4) => e4);
  }(a2), a2 = function(e3) {
    for (let t3 = 0; t3 < e3.length; t3 += 1) {
      let a3 = e3[t3];
      for (let n2 = t3 + 1; n2 < e3.length && e3[n2] === a3; n2 += 1)
        e3[t3] += e3[n2], e3[n2] = null;
    }
    return (e3 = e3.filter((e4) => e4)).map((e4) => (e4 === "''" && (e4 = "'"), e4));
  }(a2), a2.reduce((t3, a3) => (Me[a3] !== void 0 ? t3 += Me[a3](e2) || "" : (/^'.{1,}'$/.test(a3) && (a3 = a3.replace(/'/g, "")), t3 += a3), t3), "");
};
var Se = ["year", "season", "quarter", "month", "week", "day", "quarterHour", "hour", "minute"];
var Ee = function(e2, t2) {
  let a2 = e2.clone().startOf(t2), n2 = e2.clone().endOf(t2).epoch - a2.epoch, r2 = (e2.epoch - a2.epoch) / n2;
  return parseFloat(r2.toFixed(2));
};
var Te = (e2, t2) => {
  if (t2)
    return t2 = b.normalize(t2), Ee(e2, t2);
  let a2 = {};
  return Se.forEach((t3) => {
    a2[t3] = Ee(e2, t3);
  }), a2;
};
var Ne = (e2, t2) => {
  let a2 = e2.progress();
  return (t2 = b.normalize(t2)) === "quarterhour" && (t2 = "quarterHour"), a2[t2] !== void 0 ? (a2[t2] > 0.5 && (e2 = e2.add(1, t2)), e2 = e2.startOf(t2)) : e2.silent === false && console.warn("no known unit '" + t2 + "'"), e2;
};
var Ce = (e2, t2, a2) => {
  let n2 = 0;
  for (e2 = e2.clone(); e2.isBefore(t2); )
    e2 = e2.add(1, a2), n2 += 1;
  return e2.isAfter(t2, a2) && (n2 -= 1), n2;
};
var Ie = (e2, t2, a2) => e2.isBefore(t2) ? Ce(e2, t2, a2) : -1 * Ce(t2, e2, a2);
var Ae = function(e2, t2) {
  let a2 = t2.epoch - e2.epoch, n2 = {milliseconds: a2, seconds: parseInt(a2 / 1e3, 10)};
  n2.minutes = parseInt(n2.seconds / 60, 10), n2.hours = parseInt(n2.minutes / 60, 10);
  let r2 = e2.clone();
  return n2.years = ((e3, t3) => {
    let a3 = t3.year() - e3.year();
    return (e3 = e3.year(t3.year())).isAfter(t3) && (a3 -= 1), a3;
  })(r2, t2), r2 = e2.add(n2.years, "year"), n2.months = 12 * n2.years, r2 = e2.add(n2.months, "month"), n2.months += Ie(r2, t2, "month"), n2.weeks = 52 * n2.years, r2 = e2.add(n2.weeks, "week"), n2.weeks += Ie(r2, t2, "week"), n2.days = 7 * n2.weeks, r2 = e2.add(n2.days, "day"), n2.days += Ie(r2, t2, "day"), n2;
};
var Ye = function(e2, t2, a2) {
  t2 = b.beADate(t2, e2);
  let n2 = false;
  if (e2.isAfter(t2)) {
    let a3 = e2;
    e2 = t2, t2 = a3, n2 = true;
  }
  let r2 = Ae(e2, t2);
  return n2 && (r2 = function(e3) {
    return Object.keys(e3).forEach((t3) => {
      e3[t3] *= -1;
    }), e3;
  }(r2)), a2 ? (a2 = b.normalize(a2), /s$/.test(a2) !== true && (a2 += "s"), a2 === "dates" && (a2 = "days"), r2[a2]) : r2;
};
var xe = {months: {almost: 10, over: 4}, days: {almost: 25, over: 10}, hours: {almost: 20, over: 8}, minutes: {almost: 50, over: 20}, seconds: {almost: 50, over: 20}};
function Le(e2, t2) {
  return e2 === 1 && (t2 = t2.slice(0, -1)), e2 + " " + t2;
}
var Fe = (e2, t2) => {
  const a2 = function(e3, t3) {
    const a3 = e3.isBefore(t3), n3 = a3 ? t3 : e3;
    let r3 = a3 ? e3 : t3;
    r3 = r3.clone();
    const o3 = {years: 0, months: 0, days: 0, hours: 0, minutes: 0, seconds: 0};
    return Object.keys(o3).forEach((e4) => {
      if (r3.isSame(n3, e4))
        return;
      let t4 = r3.diff(n3, e4);
      r3 = r3.add(t4, e4), o3[e4] = t4;
    }), a3 && Object.keys(o3).forEach((e4) => {
      o3[e4] !== 0 && (o3[e4] *= -1);
    }), o3;
  }(e2, t2 = b.beADate(t2, e2));
  if (Object.keys(a2).every((e3) => !a2[e3]) === true)
    return {diff: a2, rounded: "now", qualified: "now", precise: "now"};
  let n2, r2, o2, i2 = [];
  return Object.keys(a2).forEach((e3, t3, o3) => {
    const s2 = Math.abs(a2[e3]);
    if (s2 === 0)
      return;
    const u2 = Le(s2, e3);
    if (i2.push(u2), !n2) {
      if (n2 = r2 = u2, t3 > 4)
        return;
      const i3 = o3[t3 + 1], l2 = Math.abs(a2[i3]);
      l2 > xe[i3].almost ? (n2 = Le(s2 + 1, e3), r2 = "almost " + n2) : l2 > xe[i3].over && (r2 = "over " + u2);
    }
  }), o2 = i2.splice(0, 2).join(", "), e2.isAfter(t2) === true ? (n2 += " ago", r2 += " ago", o2 += " ago") : (n2 = "in " + n2, r2 = "in " + r2, o2 = "in " + o2), {diff: a2, rounded: n2, qualified: r2, precise: o2};
};
var Be = {north: [["spring", 2, 1], ["summer", 5, 1], ["fall", 8, 1], ["autumn", 8, 1], ["winter", 11, 1]], south: [["fall", 2, 1], ["autumn", 2, 1], ["winter", 5, 1], ["spring", 8, 1], ["summer", 11, 1]]};
var Ze = [null, [0, 1], [3, 1], [6, 1], [9, 1]];
var He = {minute: (e2) => (P(e2, {second: 0, millisecond: 0}), e2), quarterhour: (e2) => {
  let t2 = e2.minutes();
  return e2 = t2 >= 45 ? e2.minutes(45) : t2 >= 30 ? e2.minutes(30) : t2 >= 15 ? e2.minutes(15) : e2.minutes(0), P(e2, {second: 0, millisecond: 0}), e2;
}, hour: (e2) => (P(e2, {minute: 0, second: 0, millisecond: 0}), e2), day: (e2) => (P(e2, {hour: 0, minute: 0, second: 0, millisecond: 0}), e2), week: (e2) => {
  let t2 = e2.clone();
  return (e2 = e2.day(e2._weekStart)).isAfter(t2) && (e2 = e2.subtract(1, "week")), P(e2, {hour: 0, minute: 0, second: 0, millisecond: 0}), e2;
}, month: (e2) => (P(e2, {date: 1, hour: 0, minute: 0, second: 0, millisecond: 0}), e2), quarter: (e2) => {
  let t2 = e2.quarter();
  return Ze[t2] && P(e2, {month: Ze[t2][0], date: Ze[t2][1], hour: 0, minute: 0, second: 0, millisecond: 0}), e2;
}, season: (e2) => {
  let t2 = e2.season(), a2 = "north";
  e2.hemisphere() === "South" && (a2 = "south");
  for (let n2 = 0; n2 < Be[a2].length; n2++)
    if (Be[a2][n2][0] === t2) {
      let r2 = e2.year();
      return t2 === "winter" && e2.month() < 3 && (r2 -= 1), P(e2, {year: r2, month: Be[a2][n2][1], date: Be[a2][n2][2], hour: 0, minute: 0, second: 0, millisecond: 0}), e2;
    }
  return e2;
}, year: (e2) => (P(e2, {month: 0, date: 1, hour: 0, minute: 0, second: 0, millisecond: 0}), e2), decade: (e2) => {
  let t2 = (e2 = e2.startOf("year")).year(), a2 = 10 * parseInt(t2 / 10, 10);
  return e2 = e2.year(a2);
}, century: (e2) => {
  let t2 = (e2 = e2.startOf("year")).year(), a2 = 100 * parseInt(t2 / 100, 10);
  return e2 = e2.year(a2);
}};
He.date = He.day;
var Qe = (e2, t2) => {
  let a2 = e2.clone();
  return t2 = b.normalize(t2), He[t2] ? He[t2](a2) : t2 === "summer" || t2 === "winter" ? (a2 = a2.season(t2), He.season(a2)) : a2;
};
var Ge = (e2, t2) => {
  let a2 = e2.clone();
  return t2 = b.normalize(t2), He[t2] ? (a2 = He[t2](a2), a2 = a2.add(1, t2), a2 = a2.subtract(1, "millisecond"), a2) : a2;
};
var Ue = function(e2, t2 = "", a2) {
  if (!t2 || !a2)
    return [];
  if (t2 = b.normalize(t2), a2 = e2.clone().set(a2), e2.isAfter(a2)) {
    let t3 = e2;
    e2 = a2, a2 = t3;
  }
  let n2 = e2.clone();
  !function(e3) {
    return !!ge.short().find((t3) => t3 === e3) || !!ge.long().find((t3) => t3 === e3);
  }(t2) ? n2 = n2.next(t2) : (n2 = n2.next(t2), t2 = "week");
  let r2 = [];
  for (; n2.isBefore(a2); )
    r2.push(n2), n2 = n2.add(1, t2);
  return r2;
};
var Ve = (e2) => {
  let a2 = e2.timezones, n2 = e2.tz;
  if (a2.hasOwnProperty(n2) === false && (n2 = g(e2.tz, a2)), n2 === null)
    return e2.silent === false && console.warn("Warn: could not find given or local timezone - '" + e2.tz + "'"), {current: {epochShift: 0}};
  let r2 = a2[n2], o2 = {name: (i2 = n2, i2 = (i2 = (i2 = i2[0].toUpperCase() + i2.substr(1)).replace(/\/gmt/, "/GMT")).replace(/[\/_]([a-z])/gi, (e3) => e3.toUpperCase())), hasDst: Boolean(r2.dst), default_offset: r2.offset, hemisphere: r2.hem === "s" ? "South" : "North", current: {}};
  var i2, s2;
  if (o2.hasDst) {
    let e3 = (s2 = r2.dst) ? s2.split("->") : [];
    o2.change = {start: e3[0], back: e3[1]};
  }
  let u2 = r2.offset, l2 = u2;
  return o2.hasDst === true && (l2 = o2.hemisphere === "North" ? u2 - 1 : r2.offset + 1), o2.hasDst === false ? (o2.current.offset = u2, o2.current.isDST = false) : t(e2.epoch, o2.change.start, o2.change.back, u2, l2) === true ? (o2.current.offset = u2, o2.current.isDST = o2.hemisphere === "North") : (o2.current.offset = l2, o2.current.isDST = o2.hemisphere === "South"), o2;
};
var We = ["century", "decade", "year", "month", "date", "day", "hour", "minute", "second", "millisecond"];
var Je = {set: function(e2, t2) {
  let a2 = this.clone();
  return a2 = pe(a2, e2), t2 && (this.tz = g(t2)), a2;
}, timezone: function() {
  return Ve(this);
}, isDST: function() {
  return Ve(this).current.isDST;
}, hasDST: function() {
  return Ve(this).hasDst;
}, offset: function() {
  return 60 * Ve(this).current.offset;
}, hemisphere: function() {
  return Ve(this).hemisphere;
}, format: function(e2) {
  return Oe(this, e2);
}, unixFmt: function(e2) {
  return qe(this, e2);
}, startOf: function(e2) {
  return Qe(this, e2);
}, endOf: function(e2) {
  return Ge(this, e2);
}, leapYear: function() {
  let e2 = this.year();
  return b.isLeapYear(e2);
}, progress: function(e2) {
  return Te(this, e2);
}, nearest: function(e2) {
  return Ne(this, e2);
}, diff: function(e2, t2) {
  return Ye(this, e2, t2);
}, since: function(e2) {
  return e2 || (e2 = this.clone().set()), Fe(this, e2);
}, next: function(e2) {
  return this.add(1, e2).startOf(e2);
}, last: function(e2) {
  return this.subtract(1, e2).startOf(e2);
}, isValid: function() {
  return !(!this.epoch && this.epoch !== 0) && !isNaN(this.d.getTime());
}, goto: function(e2) {
  let t2 = this.clone();
  return t2.tz = g(e2, t2.timezones), t2;
}, every: function(e2, t2) {
  if (typeof e2 == "object" && typeof t2 == "string") {
    let a2 = t2;
    t2 = e2, e2 = a2;
  }
  return Ue(this, e2, t2);
}, isAwake: function() {
  let e2 = this.hour();
  return !(e2 < 8 || e2 > 22);
}, isAsleep: function() {
  return !this.isAwake();
}, log: function() {
  return console.log(""), console.log(Oe(this, "nice-short")), this;
}, logYear: function() {
  return console.log(""), console.log(Oe(this, "full-short")), this;
}, json: function() {
  return We.reduce((e2, t2) => (e2[t2] = this[t2](), e2), {});
}, debug: function() {
  let e2 = this.timezone(), t2 = this.format("MM") + " " + this.format("date-ordinal") + " " + this.year();
  return t2 += "\n     - " + this.format("time"), console.log("\n\n", t2 + "\n     - " + e2.name + " (" + e2.current.offset + ")"), this;
}, from: function(e2) {
  return (e2 = this.clone().set(e2)).since(this);
}, fromNow: function() {
  return this.clone().set(Date.now()).since(this);
}, weekStart: function(e2) {
  if (typeof e2 == "number")
    return this._weekStart = e2, this;
  if (typeof e2 == "string") {
    e2 = e2.toLowerCase().trim();
    let t2 = ge.short().indexOf(e2);
    t2 === -1 && (t2 = ge.long().indexOf(e2)), t2 === -1 && (t2 = 1), this._weekStart = t2;
  } else
    console.warn("Spacetime Error: Cannot understand .weekStart() input:", e2);
  return this;
}};
Je.inDST = Je.isDST, Je.round = Je.nearest, Je.each = Je.every;
var Ke = Je;
var Re = b.isLeapYear;
var Xe = (e2) => (typeof e2 == "string" && (e2 = parseInt(e2, 10)), e2);
var et = ["year", "month", "date", "hour", "minute", "second", "millisecond"];
var tt = (e2, t2, a2) => {
  let n2 = et.indexOf(a2), r2 = et.slice(n2, et.length);
  for (let a3 = 0; a3 < r2.length; a3++) {
    let n3 = t2[r2[a3]]();
    e2[r2[a3]](n3);
  }
  return e2;
};
var at2 = function(e2, t2, a2, n2) {
  return a2 === true && e2.isBefore(t2) ? e2 = e2.add(1, n2) : a2 === false && e2.isAfter(t2) && (e2 = e2.minus(1, n2)), e2;
};
var nt = (e2, t2) => {
  t2 = Xe(t2);
  let a2 = e2.millisecond() - t2;
  return e2.epoch - a2;
};
var rt = (e2, t2, a2) => {
  t2 = Xe(t2);
  let n2 = e2.clone(), r2 = (e2.second() - t2) * $.second;
  return e2.epoch = e2.epoch - r2, (e2 = at2(e2, n2, a2, "minute")).epoch;
};
var ot = (e2, t2, a2) => {
  t2 = Xe(t2);
  let n2 = e2.clone(), r2 = (e2.minute() - t2) * $.minute;
  return e2.epoch -= r2, tt(e2, n2, "second"), (e2 = at2(e2, n2, a2, "hour")).epoch;
};
var it = (e2, t2, a2) => {
  (t2 = Xe(t2)) >= 24 ? t2 = 24 : t2 < 0 && (t2 = 0);
  let n2 = e2.clone(), r2 = e2.hour() - t2, o2 = r2 * $.hour;
  return e2.epoch -= o2, e2.date() !== n2.date() && (e2 = n2.clone(), r2 > 1 && (r2 -= 1), r2 < 1 && (r2 += 1), o2 = r2 * $.hour, e2.epoch -= o2), P(e2, {hour: t2}), tt(e2, n2, "minute"), (e2 = at2(e2, n2, a2, "day")).epoch;
};
var st = (e2, t2, a2) => {
  let n2 = t2.match(/([0-9]{1,2})[:h]([0-9]{1,2})(:[0-9]{1,2})? ?(am|pm)?/);
  if (!n2) {
    if (n2 = t2.match(/([0-9]{1,2}) ?(am|pm)/), !n2)
      return e2.epoch;
    n2.splice(2, 0, "0"), n2.splice(3, 0, "");
  }
  let r2 = false, o2 = parseInt(n2[1], 10), i2 = parseInt(n2[2], 10);
  i2 >= 60 && (i2 = 59), o2 > 12 && (r2 = true), r2 === false && (n2[4] === "am" && o2 === 12 && (o2 = 0), n2[4] === "pm" && o2 < 12 && (o2 += 12)), n2[3] = n2[3] || "", n2[3] = n2[3].replace(/:/, "");
  let s2 = parseInt(n2[3], 10) || 0, u2 = e2.clone();
  return e2 = (e2 = (e2 = (e2 = e2.hour(o2)).minute(i2)).second(s2)).millisecond(0), (e2 = at2(e2, u2, a2, "day")).epoch;
};
var ut = (e2, t2, a2) => {
  if ((t2 = Xe(t2)) > 28) {
    let a3 = e2.month(), n3 = q[a3];
    a3 === 1 && t2 === 29 && Re(e2.year()) && (n3 = 29), t2 > n3 && (t2 = n3);
  }
  t2 <= 0 && (t2 = 1);
  let n2 = e2.clone();
  return P(e2, {date: t2}), (e2 = at2(e2, n2, a2, "month")).epoch;
};
var lt = (e2, t2, a2) => {
  typeof t2 == "string" && (t2 = C()[t2.toLowerCase()]), (t2 = Xe(t2)) >= 12 && (t2 = 11), t2 <= 0 && (t2 = 0);
  let n2 = e2.date();
  n2 > q[t2] && (n2 = q[t2]);
  let r2 = e2.clone();
  return P(e2, {month: t2, date: n2}), (e2 = at2(e2, r2, a2, "year")).epoch;
};
var ht = (e2, t2) => (typeof t2 == "string" && /^'[0-9]{2}$/.test(t2) && (t2 = t2.replace(/'/, "").trim(), t2 = (t2 = Number(t2)) > 30 ? 1900 + t2 : 2e3 + t2), t2 = Xe(t2), P(e2, {year: t2}), e2.epoch);
var ct = (e2, t2, a2) => {
  let n2 = e2.clone();
  return t2 = Xe(t2), (e2 = (e2 = (e2 = e2.month(0)).date(1)).day("monday")).monthName() === "december" && e2.date() >= 28 && (e2 = e2.add(1, "week")), t2 -= 1, e2 = e2.add(t2, "weeks"), (e2 = at2(e2, n2, a2, "year")).epoch;
};
var dt = (e2, t2, a2) => {
  t2 = Xe(t2);
  let n2 = e2.clone();
  return (t2 -= 1) <= 0 ? t2 = 0 : t2 >= 365 && (t2 = 364), e2 = (e2 = e2.startOf("year")).add(t2, "day"), tt(e2, n2, "hour"), (e2 = at2(e2, n2, a2, "year")).epoch;
};
var mt = {millisecond: function(e2) {
  if (e2 !== void 0) {
    let t2 = this.clone();
    return t2.epoch = nt(t2, e2), t2;
  }
  return this.d.getMilliseconds();
}, second: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return a2.epoch = rt(a2, e2, t2), a2;
  }
  return this.d.getSeconds();
}, minute: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return a2.epoch = ot(a2, e2, t2), a2;
  }
  return this.d.getMinutes();
}, hour: function(e2, t2) {
  let a2 = this.d;
  if (e2 !== void 0) {
    let a3 = this.clone();
    return a3.epoch = it(a3, e2, t2), a3;
  }
  return a2.getHours();
}, hourFloat: function(e2, t2) {
  if (e2 !== void 0) {
    let a3 = this.clone(), n3 = e2 % 1;
    n3 *= 60;
    let r3 = parseInt(e2, 10);
    return a3.epoch = it(a3, r3, t2), a3.epoch = ot(a3, n3, t2), a3;
  }
  let a2 = this.d, n2 = a2.getHours(), r2 = a2.getMinutes();
  return r2 /= 60, n2 + r2;
}, hour12: function(e2, t2) {
  let a2 = this.d;
  if (e2 !== void 0) {
    let a3 = this.clone(), n3 = (e2 = "" + e2).match(/^([0-9]+)(am|pm)$/);
    if (n3) {
      let e3 = parseInt(n3[1], 10);
      n3[2] === "pm" && (e3 += 12), a3.epoch = it(a3, e3, t2);
    }
    return a3;
  }
  let n2 = a2.getHours();
  return n2 > 12 && (n2 -= 12), n2 === 0 && (n2 = 12), n2;
}, time: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return e2 = e2.toLowerCase().trim(), a2.epoch = st(a2, e2, t2), a2;
  }
  return `${this.h12()}:${b.zeroPad(this.minute())}${this.ampm()}`;
}, ampm: function(e2, t2) {
  let a2 = "am", n2 = this.hour();
  if (n2 >= 12 && (a2 = "pm"), typeof e2 != "string")
    return a2;
  let r2 = this.clone();
  return e2 = e2.toLowerCase().trim(), n2 >= 12 && e2 === "am" ? (n2 -= 12, r2.hour(n2, t2)) : n2 < 12 && e2 === "pm" ? (n2 += 12, r2.hour(n2, t2)) : r2;
}, dayTime: function(e2, t2) {
  if (e2 !== void 0) {
    const a3 = {morning: "7:00am", breakfast: "7:00am", noon: "12:00am", lunch: "12:00pm", afternoon: "2:00pm", evening: "6:00pm", dinner: "6:00pm", night: "11:00pm", midnight: "23:59pm"};
    let n2 = this.clone();
    return e2 = (e2 = e2 || "").toLowerCase(), a3.hasOwnProperty(e2) === true && (n2 = n2.time(a3[e2], t2)), n2;
  }
  let a2 = this.hour();
  return a2 < 6 ? "night" : a2 < 12 ? "morning" : a2 < 17 ? "afternoon" : a2 < 22 ? "evening" : "night";
}, iso: function(e2) {
  return e2 !== void 0 ? this.set(e2) : this.format("iso");
}};
var pt = {date: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return (e2 = parseInt(e2, 10)) && (a2.epoch = ut(a2, e2, t2)), a2;
  }
  return this.d.getDate();
}, day: function(e2, t2) {
  if (e2 === void 0)
    return this.d.getDay();
  let a2 = this.clone(), n2 = e2;
  typeof e2 == "string" && (e2 = e2.toLowerCase(), ge.aliases.hasOwnProperty(e2) ? n2 = ge.aliases[e2] : (n2 = ge.short().indexOf(e2), n2 === -1 && (n2 = ge.long().indexOf(e2))));
  let r2 = this.d.getDay() - n2;
  t2 === true && r2 > 0 && (r2 -= 7), t2 === false && r2 < 0 && (r2 += 7);
  let o2 = this.subtract(r2, "days");
  return P(o2, {hour: a2.hour(), minute: a2.minute(), second: a2.second()}), o2;
}, dayName: function(e2, t2) {
  if (e2 === void 0)
    return ge.long()[this.day()];
  let a2 = this.clone();
  return a2 = a2.day(e2, t2), a2;
}};
var ft = (e2) => e2 = (e2 = (e2 = e2.minute(0)).second(0)).millisecond(1);
var yt = {dayOfYear: function(e2, t2) {
  if (e2 !== void 0) {
    let a3 = this.clone();
    return a3.epoch = dt(a3, e2, t2), a3;
  }
  let a2, n2 = 0, r2 = this.d.getMonth();
  for (let e3 = 1; e3 <= r2; e3++)
    a2 = new Date(), a2.setDate(1), a2.setFullYear(this.d.getFullYear()), a2.setHours(1), a2.setMinutes(1), a2.setMonth(e3), a2.setHours(-2), n2 += a2.getDate();
  return n2 + this.d.getDate();
}, week: function(e2, t2) {
  if (e2 !== void 0) {
    let a3 = this.clone();
    return a3.epoch = ct(this, e2, t2), a3 = ft(a3), a3;
  }
  let a2 = this.clone();
  a2 = a2.month(0), a2 = a2.date(1), a2 = ft(a2), a2 = a2.day("monday"), a2.monthName() === "december" && a2.date() >= 28 && (a2 = a2.add(1, "week"));
  let n2 = 1;
  a2.date() === 1 && (n2 = 0), a2 = a2.minus(1, "second");
  const r2 = this.epoch;
  if (a2.epoch > r2)
    return 1;
  let o2 = 0, i2 = 4 * this.month();
  for (a2.epoch += $.week * i2, o2 += i2; o2 <= 52; o2++) {
    if (a2.epoch > r2)
      return o2 + n2;
    a2 = a2.add(1, "week");
  }
  return 52;
}, month: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return a2.epoch = lt(a2, e2, t2), a2;
  }
  return this.d.getMonth();
}, monthName: function(e2, t2) {
  if (e2 !== void 0) {
    let a2 = this.clone();
    return a2 = a2.month(e2, t2), a2;
  }
  return N()[this.month()];
}, quarter: function(e2, t2) {
  if (e2 !== void 0 && (typeof e2 == "string" && (e2 = e2.replace(/^q/i, ""), e2 = parseInt(e2, 10)), Ze[e2])) {
    let a3 = this.clone(), n2 = Ze[e2][0];
    return a3 = a3.month(n2, t2), a3 = a3.date(1, t2), a3 = a3.startOf("day"), a3;
  }
  let a2 = this.d.getMonth();
  for (let e3 = 1; e3 < Ze.length; e3++)
    if (a2 < Ze[e3][0])
      return e3 - 1;
  return 4;
}, season: function(e2, t2) {
  let a2 = "north";
  if (this.hemisphere() === "South" && (a2 = "south"), e2 !== void 0) {
    let n3 = this.clone();
    for (let r2 = 0; r2 < Be[a2].length; r2++)
      e2 === Be[a2][r2][0] && (n3 = n3.month(Be[a2][r2][1], t2), n3 = n3.date(1), n3 = n3.startOf("day"));
    return n3;
  }
  let n2 = this.d.getMonth();
  for (let e3 = 0; e3 < Be[a2].length - 1; e3++)
    if (n2 >= Be[a2][e3][1] && n2 < Be[a2][e3 + 1][1])
      return Be[a2][e3][0];
  return "winter";
}, year: function(e2) {
  if (e2 !== void 0) {
    let t2 = this.clone();
    return t2.epoch = ht(t2, e2), t2;
  }
  return this.d.getFullYear();
}, era: function(e2) {
  if (e2 !== void 0) {
    let t2 = this.clone();
    e2 = e2.toLowerCase();
    let a2 = t2.d.getFullYear();
    return e2 === "bc" && a2 > 0 && (t2.epoch = ht(t2, -1 * a2)), e2 === "ad" && a2 < 0 && (t2.epoch = ht(t2, -1 * a2)), t2;
  }
  return this.d.getFullYear() < 0 ? "BC" : "AD";
}, decade: function(e2) {
  if (e2 !== void 0) {
    if (!(e2 = (e2 = (e2 = String(e2)).replace(/([0-9])'?s$/, "$1")).replace(/([0-9])(th|rd|st|nd)/, "$1")))
      return console.warn("Spacetime: Invalid decade input"), this;
    e2.length === 2 && /[0-9][0-9]/.test(e2) && (e2 = "19" + e2);
    let t2 = Number(e2);
    return isNaN(t2) ? this : (t2 = 10 * Math.floor(t2 / 10), this.year(t2));
  }
  return this.startOf("decade").year();
}, century: function(e2) {
  if (e2 !== void 0) {
    typeof e2 == "string" && (e2 = (e2 = (e2 = e2.replace(/([0-9])(th|rd|st|nd)/, "$1")).replace(/([0-9]+) ?(b\.?c\.?|a\.?d\.?)/i, (e3, t4, a2) => (a2.match(/b\.?c\.?/i) && (t4 = "-" + t4), t4))).replace(/c$/, ""));
    let t3 = Number(e2);
    return isNaN(e2) ? (console.warn("Spacetime: Invalid century input"), this) : (t3 === 0 && (t3 = 1), t3 = t3 >= 0 ? 100 * (t3 - 1) : 100 * (t3 + 1), this.year(t3));
  }
  let t2 = this.startOf("century").year();
  return t2 = Math.floor(t2 / 100), t2 < 0 ? t2 - 1 : t2 + 1;
}, millenium: function(e2) {
  if (e2 !== void 0) {
    if (typeof e2 == "string" && (e2 = e2.replace(/([0-9])(th|rd|st|nd)/, "$1"), e2 = Number(e2), isNaN(e2)))
      return console.warn("Spacetime: Invalid millenium input"), this;
    e2 > 0 && (e2 -= 1);
    let t3 = 1e3 * e2;
    return t3 === 0 && (t3 = 1), this.year(t3);
  }
  let t2 = Math.floor(this.year() / 1e3);
  return t2 >= 0 && (t2 += 1), t2;
}};
var gt = Object.assign({}, mt, pt, yt);
gt.milliseconds = gt.millisecond, gt.seconds = gt.second, gt.minutes = gt.minute, gt.hours = gt.hour, gt.hour24 = gt.hour, gt.h12 = gt.hour12, gt.h24 = gt.hour24, gt.days = gt.day;
var bt = (e2) => {
  Object.keys(gt).forEach((t2) => {
    e2.prototype[t2] = gt[t2];
  });
};
var kt = b.isLeapYear;
var wt = function(e2, t2) {
  return e2 === 1 && kt(t2) ? 29 : q[e2];
};
var vt = (e2, t2) => {
  if (e2.month > 0) {
    let a2 = parseInt(e2.month / 12, 10);
    e2.year = t2.year() + a2, e2.month = e2.month % 12;
  } else if (e2.month < 0) {
    let a2 = Math.floor(Math.abs(e2.month) / 13, 10);
    a2 = Math.abs(a2) + 1, e2.year = t2.year() - a2, e2.month = e2.month % 12, e2.month = e2.month + 12, e2.month === 12 && (e2.month = 0);
  }
  return e2;
};
var zt = (e2, t2, a2) => {
  let n2 = t2.year(), r2 = t2.month(), o2 = wt(r2, n2);
  for (; a2 > o2; )
    a2 -= o2, r2 += 1, r2 >= 12 && (r2 -= 12, n2 += 1), o2 = wt(r2, n2);
  return e2.month = r2, e2.date = a2, e2;
};
var _t = (e2, t2, a2) => {
  e2.year = t2.year(), e2.month = t2.month();
  let n2 = t2.date();
  for (e2.date = n2 - Math.abs(a2); e2.date < 1; ) {
    e2.month -= 1, e2.month < 0 && (e2.month = 11, e2.year -= 1);
    let t3 = wt(e2.month, e2.year);
    e2.date += t3;
  }
  return e2;
};
var jt = ["millisecond", "second", "minute", "hour", "date", "month"];
var Ot = {second: jt.slice(0, 1), minute: jt.slice(0, 2), quarterhour: jt.slice(0, 2), hour: jt.slice(0, 3), date: jt.slice(0, 4), month: jt.slice(0, 4), quarter: jt.slice(0, 4), season: jt.slice(0, 4), year: jt, decade: jt, century: jt};
Ot.week = Ot.hour, Ot.season = Ot.date, Ot.quarter = Ot.date;
var $t = {year: true, quarter: true, season: true, month: true, week: true, day: true};
var Dt = {month: true, quarter: true, season: true, year: true};
var Mt = (e2) => {
  e2.prototype.add = function(e3, t2) {
    let a2 = this.clone();
    if (!t2 || e3 === 0)
      return a2;
    let n2 = this.clone();
    if ((t2 = b.normalize(t2)) === "millisecond")
      return a2.epoch += e3, a2;
    t2 === "fortnight" && (e3 *= 2, t2 = "week"), $[t2] ? a2.epoch += $[t2] * e3 : t2 === "week" || t2 === "weekend" ? a2.epoch += $.day * (7 * e3) : t2 === "quarter" || t2 === "season" ? a2.epoch += $.month * (3 * e3) : t2 === "quarterhour" && (a2.epoch += 15 * $.minute * e3);
    let r2 = {};
    if (Ot[t2] && Ot[t2].forEach((e4) => {
      r2[e4] = n2[e4]();
    }), $t[t2]) {
      const e4 = n2.timezone().current.offset - a2.timezone().current.offset;
      a2.epoch += 3600 * e4 * 1e3;
    }
    if (t2 === "month" && (r2.month = n2.month() + e3, r2 = vt(r2, n2)), t2 === "week") {
      let t3 = n2.date() + 7 * e3;
      t3 <= 28 && t3 > 1 && (r2.date = t3);
    }
    if (t2 === "weekend" && a2.dayName() !== "saturday")
      a2 = a2.day("saturday", true);
    else if (t2 === "date") {
      if (e3 < 0)
        r2 = _t(r2, n2, e3);
      else {
        let t3 = n2.date() + e3;
        r2 = zt(r2, n2, t3);
      }
      e3 !== 0 && n2.isSame(a2, "day") && (r2.date = n2.date() + e3);
    } else if (t2 === "quarter") {
      if (r2.month = n2.month() + 3 * e3, r2.year = n2.year(), r2.month < 0) {
        let e4 = Math.floor(r2.month / 12), t3 = r2.month + 12 * Math.abs(e4);
        r2.month = t3, r2.year += e4;
      } else if (r2.month >= 12) {
        let e4 = Math.floor(r2.month / 12);
        r2.month = r2.month % 12, r2.year += e4;
      }
      r2.date = n2.date();
    } else if (t2 === "year") {
      let t3 = n2.year() + e3, r3 = a2.year();
      (r3 < t3 || r3 > t3) && (a2.epoch += $.day);
    } else
      t2 === "decade" ? r2.year = a2.year() + 10 : t2 === "century" && (r2.year = a2.year() + 100);
    if (Dt[t2]) {
      let e4 = q[r2.month];
      r2.date = n2.date(), r2.date > e4 && (r2.date = e4);
    }
    return Object.keys(r2).length > 1 && P(a2, r2), a2;
  }, e2.prototype.subtract = function(e3, t2) {
    return this.clone().add(-1 * e3, t2);
  }, e2.prototype.minus = e2.prototype.subtract, e2.prototype.plus = e2.prototype.add;
};
var Pt = {millisecond: (e2) => e2.epoch, second: (e2) => [e2.year(), e2.month(), e2.date(), e2.hour(), e2.minute(), e2.second()].join("-"), minute: (e2) => [e2.year(), e2.month(), e2.date(), e2.hour(), e2.minute()].join("-"), hour: (e2) => [e2.year(), e2.month(), e2.date(), e2.hour()].join("-"), day: (e2) => [e2.year(), e2.month(), e2.date()].join("-"), week: (e2) => [e2.year(), e2.week()].join("-"), month: (e2) => [e2.year(), e2.month()].join("-"), quarter: (e2) => [e2.year(), e2.quarter()].join("-"), year: (e2) => e2.year()};
Pt.date = Pt.day;
var qt = (e2) => {
  e2.prototype.isSame = function(t2, a2, n2 = true) {
    let r2 = this;
    if (!a2)
      return null;
    if (typeof t2 == "string" && typeof a2 == "object") {
      let e3 = t2;
      t2 = a2, a2 = e3;
    }
    return typeof t2 != "string" && typeof t2 != "number" || (t2 = new e2(t2, this.timezone.name)), a2 = a2.replace(/s$/, ""), n2 === true && r2.tz !== t2.tz && ((t2 = t2.clone()).tz = r2.tz), Pt[a2] ? Pt[a2](r2) === Pt[a2](t2) : null;
  };
};
var St = (e2) => {
  const t2 = {isAfter: function(e3) {
    e3 = b.beADate(e3, this);
    let t3 = b.getEpoch(e3);
    return t3 === null ? null : this.epoch > t3;
  }, isBefore: function(e3) {
    e3 = b.beADate(e3, this);
    let t3 = b.getEpoch(e3);
    return t3 === null ? null : this.epoch < t3;
  }, isEqual: function(e3) {
    e3 = b.beADate(e3, this);
    let t3 = b.getEpoch(e3);
    return t3 === null ? null : this.epoch === t3;
  }, isBetween: function(e3, t3, a2 = false) {
    e3 = b.beADate(e3, this), t3 = b.beADate(t3, this);
    let n2 = b.getEpoch(e3);
    if (n2 === null)
      return null;
    let r2 = b.getEpoch(t3);
    return r2 === null ? null : a2 ? this.isBetween(e3, t3) || this.isEqual(e3) || this.isEqual(t3) : n2 < this.epoch && this.epoch < r2;
  }};
  Object.keys(t2).forEach((a2) => {
    e2.prototype[a2] = t2[a2];
  });
};
var Et = (e2) => {
  const t2 = {i18n: (e3) => {
    b.isObject(e3.days) && ge.set(e3.days), b.isObject(e3.months) && I(e3.months), b.isBoolean(e3.useTitleCase) && we(e3.useTitleCase);
  }};
  Object.keys(t2).forEach((a2) => {
    e2.prototype[a2] = t2[a2];
  });
};
var Tt = s;
var Nt = function(e2, t2, n2 = {}) {
  this.epoch = null, this.tz = g(t2, Tt), this.silent = n2.silent || true, this.british = n2.dmy || n2.british, this._weekStart = 1, n2.weekStart !== void 0 && (this._weekStart = n2.weekStart), this._today = {}, n2.today !== void 0 && (this._today = n2.today), Object.defineProperty(this, "d", {get: function() {
    let e3 = a(this), t3 = (new Date(this.epoch).getTimezoneOffset() || 0) + 60 * e3;
    t3 = 60 * t3 * 1e3;
    let n3 = this.epoch + t3;
    return new Date(n3);
  }}), Object.defineProperty(this, "timezones", {get: () => Tt, set: (e3) => (Tt = e3, e3)});
  let r2 = pe(this, e2);
  this.epoch = r2.epoch;
};
Object.keys(Ke).forEach((e2) => {
  Nt.prototype[e2] = Ke[e2];
}), Nt.prototype.clone = function() {
  return new Nt(this.epoch, this.tz, {silent: this.silent, weekStart: this._weekStart, today: this._today, parsers: this.parsers});
}, Nt.prototype.toLocalDate = function() {
  return new Date(this.epoch);
}, bt(Nt), Mt(Nt), qt(Nt), St(Nt), Et(Nt);
var Ct = Nt;
var It = (e2, t2) => {
  let a2 = new Ct(null), n2 = new Ct(null);
  a2 = a2.time(e2), n2 = t2 ? n2.time(t2) : a2.add(59, "minutes");
  let r2 = a2.hour(), o2 = n2.hour();
  return Object.keys(a2.timezones).filter((e3) => {
    if (e3.indexOf("/") === -1)
      return false;
    let t3 = new Ct(null, e3), i2 = t3.hour();
    return i2 >= r2 && i2 <= o2 && (!(i2 === r2 && t3.minute() < a2.minute()) && !(i2 === o2 && t3.minute() > n2.minute()));
  });
};
var At = (e2, t2, a2) => new Ct(e2, t2, a2);
var Yt = function(e2) {
  let t2 = e2._today || {};
  return Object.keys(t2).forEach((a2) => {
    e2 = e2[a2](t2[a2]);
  }), e2;
};
At.now = (e2, t2) => {
  let a2 = new Ct(new Date().getTime(), e2, t2);
  return a2 = Yt(a2), a2;
}, At.today = (e2, t2) => {
  let a2 = new Ct(new Date().getTime(), e2, t2);
  return a2 = Yt(a2), a2.startOf("day");
}, At.tomorrow = (e2, t2) => {
  let a2 = new Ct(new Date().getTime(), e2, t2);
  return a2 = Yt(a2), a2.add(1, "day").startOf("day");
}, At.yesterday = (e2, t2) => {
  let a2 = new Ct(new Date().getTime(), e2, t2);
  return a2 = Yt(a2), a2.subtract(1, "day").startOf("day");
}, At.extend = function(e2 = {}) {
  return Object.keys(e2).forEach((t2) => {
    Ct.prototype[t2] = e2[t2];
  }), this;
}, At.timezones = function() {
  return new Ct().timezones;
}, At.max = function(e2, t2) {
  let a2 = new Ct(null, e2, t2);
  return a2.epoch = 864e13, a2;
}, At.min = function(e2, t2) {
  let a2 = new Ct(null, e2, t2);
  return a2.epoch = -864e13, a2;
}, At.whereIts = It, At.version = "6.16.0", At.plugin = At.extend;
var xt = At;
var spacetime_default = xt;

// node_modules/spacetime-informal/builds/spacetime-informal.mjs
var iana = {
  Africa: ["Abidjan", "Accra", "Addis_Ababa", "Algiers", "Asmara", "Asmera", "Bamako", "Bangui", "Banjul", "Bissau", "Blantyre", "Brazzaville", "Bujumbura", "Cairo", "Casablanca", "Ceuta", "Conakry", "Dakar", "Dar_Es_Salaam", "Djibouti", "Douala", "El_Aaiun", "Freetown", "Gaborone", "Harare", "Johannesburg", "Juba", "Kampala", "Khartoum", "Kigali", "Kinshasa", "Lagos", "Libreville", "Lome", "Luanda", "Lubumbashi", "Lusaka", "Malabo", "Maputo", "Maseru", "Mbabane", "Mogadishu", "Monrovia", "Nairobi", "Ndjamena", "Niamey", "Nouakchott", "Ouagadougou", "Porto-novo", "Sao_Tome", "Timbuktu", "Tripoli", "Tunis", "Windhoek"],
  America: ["Adak", "Anchorage", "Anguilla", "Antigua", "Araguaina", "Argentina", "Aruba", "Asuncion", "Atikokan", "Atka", "Bahia", "Bahia_Banderas", "Barbados", "Belem", "Belize", "Blanc-sablon", "Boa_Vista", "Bogota", "Boise", "Buenos_Aires", "Cambridge_Bay", "Campo_Grande", "Cancun", "Caracas", "Catamarca", "Cayenne", "Cayman", "Chicago", "Chihuahua", "Coral_Harbour", "Cordoba", "Costa_Rica", "Creston", "Cuiaba", "Curacao", "Danmarkshavn", "Dawson", "Dawson_Creek", "Denver", "Detroit", "Dominica", "Edmonton", "Eirunepe", "El_Salvador", "Ensenada", "Fort_Wayne", "Fortaleza", "Glace_Bay", "Godthab", "Goose_Bay", "Grand_Turk", "Grenada", "Guadeloupe", "Guatemala", "Guayaquil", "Guyana", "Halifax", "Havana", "Hermosillo", "Indiana", "Indianapolis", "Inuvik", "Iqaluit", "Jamaica", "Jujuy", "Juneau", "Kentucky", "Knox_In", "Kralendijk", "La_Paz", "Lima", "Los_Angeles", "Louisville", "Lower_Princes", "Maceio", "Managua", "Manaus", "Marigot", "Martinique", "Matamoros", "Mazatlan", "Mendoza", "Menominee", "Merida", "Metlakatla", "Mexico_City", "Miquelon", "Moncton", "Monterrey", "Montevideo", "Montreal", "Montserrat", "Nassau", "New_York", "Nipigon", "Nome", "Noronha", "North_Dakota", "Ojinaga", "Panama", "Pangnirtung", "Paramaribo", "Phoenix", "Port-au-prince", "Port_Of_Spain", "Porto_Acre", "Porto_Velho", "Puerto_Rico", "Punta_Arenas", "Rainy_River", "Rankin_Inlet", "Recife", "Regina", "Resolute", "Rio_Branco", "Rosario", "Santa_Isabel", "Santarem", "Santiago", "Santo_Domingo", "Sao_Paulo", "Scoresbysund", "Shiprock", "Sitka", "St_Barthelemy", "St_Johns", "St_Kitts", "St_Lucia", "St_Thomas", "St_Vincent", "Swift_Current", "Tegucigalpa", "Thule", "Thunder_Bay", "Tijuana", "Toronto", "Tortola", "Vancouver", "Virgin", "Whitehorse", "Winnipeg", "Yakutat", "Yellowknife"],
  Antarctica: ["Casey", "Davis", "Dumontdurville", "Macquarie", "Mawson", "Mcmurdo", "Palmer", "Rothera", "South_Pole", "Syowa", "Troll", "Vostok"],
  Arctic: ["Longyearbyen"],
  Asia: ["Aden", "Almaty", "Amman", "Anadyr", "Aqtau", "Aqtobe", "Ashgabat", "Ashkhabad", "Atyrau", "Baghdad", "Bahrain", "Baku", "Bangkok", "Barnaul", "Beirut", "Bishkek", "Brunei", "Calcutta", "Chita", "Choibalsan", "Chongqing", "Chungking", "Colombo", "Dacca", "Damascus", "Dhaka", "Dili", "Dubai", "Dushanbe", "Gaza", "Harbin", "Hebron", "Ho_Chi_Minh", "Hong_Kong", "Hovd", "Irkutsk", "Istanbul", "Jakarta", "Jayapura", "Jerusalem", "Kabul", "Kamchatka", "Karachi", "Kashgar", "Kathmandu", "Katmandu", "Khandyga", "Kolkata", "Krasnoyarsk", "Kuala_Lumpur", "Kuching", "Kuwait", "Macao", "Macau", "Magadan", "Makassar", "Manila", "Muscat", "Nicosia", "Novokuznetsk", "Novosibirsk", "Omsk", "Oral", "Phnom_Penh", "Pontianak", "Pyongyang", "Qatar", "Qyzylorda", "Rangoon", "Riyadh", "Saigon", "Sakhalin", "Samarkand", "Seoul", "Shanghai", "Singapore", "Srednekolymsk", "Taipei", "Tashkent", "Tbilisi", "Tehran", "Tel_Aviv", "Thimbu", "Thimphu", "Tokyo", "Tomsk", "Ujung_Pandang", "Ulaanbaatar", "Ulan_Bator", "Urumqi", "Ust-nera", "Vientiane", "Vladivostok", "Yakutsk", "Yekaterinburg", "Yerevan", "Volgograd"],
  Atlantic: ["Azores", "Bermuda", "Canary", "Cape_Verde", "Faeroe", "Faroe", "Jan_Mayen", "Madeira", "Reykjavik", "South_Georgia", "St_Helena", "Stanley"],
  Australia: ["Act", "Adelaide", "Brisbane", "Broken_Hill", "Canberra", "Currie", "Darwin", "Eucla", "Hobart", "Lhi", "Lindeman", "Lord_Howe", "Melbourne", "Nsw", "North", "Perth", "Queensland", "South", "Sydney", "Tasmania", "Victoria", "West", "Yancowinna"],
  Brazil: ["Acre", "Denoronha", "East", "West"],
  Canada: ["Atlantic", "Central", "East-saskatchewan", "Eastern", "Mountain", "Newfoundland", "Pacific", "Saskatchewan", "Yukon"],
  Chile: ["Continental", "EasterIsland"],
  Europe: ["Amsterdam", "Andorra", "Astrakhan", "Athens", "Belfast", "Belgrade", "Berlin", "Bratislava", "Brussels", "Bucharest", "Budapest", "Busingen", "Chisinau", "Copenhagen", "Dublin", "Gibraltar", "Guernsey", "Helsinki", "Isle_Of_Man", "Istanbul", "Jersey", "Kaliningrad", "Kirov", "Kiev", "Lisbon", "Ljubljana", "London", "Luxembourg", "Madrid", "Malta", "Mariehamn", "Minsk", "Monaco", "Moscow", "Nicosia", "Oslo", "Paris", "Podgorica", "Prague", "Riga", "Rome", "Samara", "Saratov", "San_Marino", "Sarajevo", "Simferopol", "Skopje", "Sofia", "Stockholm", "Tallinn", "Tirane", "Tiraspol", "Ulyanovsk", "Uzhgorod", "Vaduz", "Vatican", "Vienna", "Vilnius", "Volgograd", "Warsaw", "Zagreb", "Zaporozhye", "Zurich"],
  Indian: ["Antananarivo", "Chagos", "Christmas", "Cocos", "Comoro", "Kerguelen", "Mahe", "Maldives", "Mauritius", "Mayotte", "Reunion"],
  Mexico: ["Bajanorte", "Bajasur", "General"],
  Pacific: ["Apia", "Auckland", "Bougainville", "Chatham", "Chuuk", "Easter", "Efate", "Enderbury", "Fakaofo", "Fiji", "Funafuti", "Galapagos", "Gambier", "Guadalcanal", "Guam", "Honolulu", "Johnston", "Kiritimati", "Kosrae", "Kwajalein", "Majuro", "Marquesas", "Midway", "Nauru", "Niue", "Norfolk", "Noumea", "Pago_Pago", "Palau", "Pitcairn", "Pohnpei", "Ponape", "Port_Moresby", "Rarotonga", "Saipan", "Samoa", "Tahiti", "Tarawa", "Tongatapu", "Truk", "Wake", "Wallis", "Yap"],
  ETC: ["GMT", "GMT+0", "GMT-0", "GMT0", "Greenwich", "UTC", "Universal", "Zulu"]
};
var ignore = {
  east: true,
  west: true
};
var zones = {};
Object.keys(iana).forEach(function(k2) {
  iana[k2].forEach(function(str) {
    var id = k2 + "/" + str;
    zones[id.toLowerCase()] = id;
    if (!ignore[str]) {
      str = str.toLowerCase();
      str = str.replace(/[_-]/g, " ");
      zones[str] = id;
    }
  });
});
var _01Iana = zones;
var _02ByCity = {
  "san fransisco": "America/Los_Angeles",
  ottawa: "America/Toronto",
  montreal: "America/Toronto",
  chongqing: "Asia/Shanghai",
  beijing: "Asia/Shanghai",
  chengdu: "Asia/Shanghai",
  guangzhou: "Asia/Shanghai",
  tianjin: "Asia/Shanghai",
  baoding: "Asia/Shanghai",
  wenzhou: "Asia/Shanghai",
  xian: "Asia/Shanghai",
  shenzhen: "Asia/Shanghai",
  suzhou: "Asia/Shanghai",
  nanjing: "Asia/Shanghai",
  dongguan: "Asia/Shanghai",
  quanzhou: "Asia/Shanghai",
  "hong kong": "Asia/Shanghai",
  mumbai: "Asia/Kolkata",
  bombay: "Asia/Kolkata",
  madras: "Asia/Kolkata",
  calcutta: "Asia/Kolkata",
  "port blair": "Asia/Kolkata",
  delhi: "Asia/Kolkata",
  chennai: "Asia/Kolkata",
  bangalore: "Asia/Kolkata",
  hyderabad: "Asia/Kolkata",
  lahore: "Asia/Karachi",
  islamabad: "Asia/Karachi",
  peshawar: "Asia/Karachi",
  multan: "Asia/Karachi"
};
var _04OldZones = {
  "africa/asmera": "Africa/Nairobi",
  "africa/timbuktu": "Africa/Abidjan",
  "america/argentina/comodrivadavia": "America/Argentina",
  "america/atka": "America/Adak",
  "america/buenos_aires": "America/Argentina",
  "america/argentina/buenos_aires": "America/Argentina",
  "america/catamarca": "America/Argentina",
  "america/argentina/catamarca": "America/Argentina",
  "america/coral_harbour": "America/Atikokan",
  "america/cordoba": "America/Argentina",
  "america/argentina/cordoba": "America/Argentina",
  "america/ensenada": "America/Tijuana",
  "america/fort_wayne": "America/Indiana",
  "america/indiana/indianapolis": "America/Indiana",
  "america/indianapolis": "America/Indiana",
  "america/jujuy": "America/Argentina",
  "america/knox_in": "America/Indiana",
  "america/louisville": "America/Kentucky",
  "america/kentucky/louisville": "America/Kentucky",
  "america/mendoza": "America/Argentina",
  "america/montreal": "America/Toronto",
  "america/porto_acre": "America/Rio_Branco",
  "america/rosario": "America/Argentina",
  "america/santa_isabel": "America/Tijuana",
  "america/shiprock": "America/Denver",
  "america/virgin": "America/Port_Of_Spain",
  "antarctica/south_pole": "Pacific/Auckland",
  "asia/ashkhabad": "Asia/Ashgabat",
  "asia/calcutta": "Asia/Kolkata",
  "asia/chongqing": "Asia/Shanghai",
  "asia/chungking": "Asia/Shanghai",
  "asia/dacca": "Asia/Dhaka",
  "asia/harbin": "Asia/Shanghai",
  "asia/kashgar": "Asia/Urumqi",
  "asia/katmandu": "Asia/Kathmandu",
  "asia/macao": "Asia/Macau",
  "asia/rangoon": "Asia/Yangon",
  "asia/saigon": "Asia/Ho_Chi_Minh",
  "asia/tel_aviv": "Asia/Jerusalem",
  "asia/thimbu": "Asia/Thimphu",
  "asia/ujung_pandang": "Asia/Makassar",
  "asia/ulan_bator": "Asia/Ulaanbaatar",
  "atlantic/faeroe": "atlantic/Faroe",
  "atlantic/jan_mayen": "Europe/Oslo",
  "australia/act": "Australia/Sydney",
  "australia/canberra": "Australia/Sydney",
  "australia/lhi": "Australia/Lord_Howe",
  "australia/nsw": "Australia/Sydney",
  "australia/north": "Australia/Darwin",
  "australia/queensland": "Australia/Brisbane",
  "australia/south": "Australia/Adelaide",
  "australia/tasmania": "Australia/Hobart",
  "australia/victoria": "Australia/Melbourne",
  "australia/west": "Australia/Perth",
  "australia/yancowinna": "Australia/Broken_Hill",
  "brazil/acre": "America/Rio_Branco",
  "brazil/denoronha": "America/Noronha",
  "brazil/east": "America/Sao_Paulo",
  "brazil/west": "America/Manaus",
  "canada/atlantic": "America/Halifax",
  "canada/central": "America/Winnipeg",
  "canada/east-saskatchewan": "America/Regina",
  "canada/eastern": "America/Toronto",
  "canada/mountain": "America/Edmonton",
  "canada/newfoundland": "America/St_Johns",
  "canada/pacific": "America/Vancouver",
  "canada/saskatchewan": "America/Regina",
  "canada/yukon": "America/Whitehorse",
  "chile/continental": "America/Santiago",
  "chile/easterisland": "Pacific/Easter",
  cuba: "America/Havana",
  egypt: "Africa/Cairo",
  eire: "Europe/Dublin",
  "europe/belfast": "Europe/London",
  "europe/tiraspol": "Europe/Chisinau",
  gb: "Europe/London",
  "gb-eire": "Europe/London",
  "gmt+0": "etc/Gmt",
  "gmt-0": "etc/Gmt",
  gmt0: "etc/Gmt",
  greenwich: "etc/Gmt",
  hongkong: "Asia/Hong_Kong",
  iceland: "atlantic/Reykjavik",
  iran: "Asia/Tehran",
  israel: "Asia/Jerusalem",
  jamaica: "America/Jamaica",
  japan: "Asia/Tokyo",
  kwajalein: "Pacific/Kwajalein",
  libya: "Africa/Tripoli",
  "mexico/bajanorte": "America/Tijuana",
  "mexico/bajasur": "America/Mazatlan",
  "mexico/general": "America/Mexico_City",
  nz: "Pacific/Auckland",
  "nz-chat": "Pacific/Chatham",
  navajo: "America/Denver",
  prc: "Asia/Shanghai",
  "pacific/johnston": "Pacific/Honolulu",
  "pacific/ponape": "Pacific/Pohnpei",
  "pacific/samoa": "Pacific/Pago_Pago",
  "pacific/truk": "Pacific/Chuuk",
  "pacific/yap": "Pacific/Chuuk",
  poland: "Europe/Warsaw",
  portugal: "Europe/Lisbon",
  roc: "Asia/Taipei",
  rok: "Asia/Seoul",
  "us/alaska": "America/Anchorage",
  "us/aleutian": "America/Adak",
  "us/arizona": "America/Phoenix",
  "us/central": "America/Chicago",
  "us/east-indiana": "America/Indiana",
  "us/eastern": "America/New_York",
  "us/hawaii": "Pacific/Honolulu",
  "us/indiana-starke": "America/Indiana",
  "america/indiana/knox": "America/Indiana",
  "us/michigan": "America/Detroit",
  "us/mountain": "America/Denver",
  "us/pacific": "America/Los_Angeles",
  "us/samoa": "Pacific/Pago_Pago",
  universal: "etc/Utc",
  "w-su": "Europe/Moscow",
  zulu: "Etc/Utc",
  z: "Etc/Utc",
  "america/argentina/jujuy": "America/Jujuy",
  "america/argentina/mendoza": "America/Mendoza",
  "america/atikokan": "America/Coral_Harbour",
  "europe/nicosia": "Asia/Nicosia",
  "africa/asmara": "Africa/Asmera",
  "pacific/pohnpei": "Pacific/Ponape",
  "pacific/chuuk": "Pacific/Truk",
  "atlantic/faroe": "atlantic/Faeroe",
  "asia/kolkata": "Asia/Calcutta",
  "asia/yangon": "Asia/Rangoon",
  "asia/kathmandu": "Asia/Katmandu",
  "asia/ho_chi_minh": "Asia/Saigon",
  "asia/istanbul": "Europe/Istanbul",
  "etc/gmt+0": "Etc/Gmt",
  "etc/gmt-0": "Etc/Gmt",
  "etc/gmt0": "Etc/Gmt",
  "etc/greenwich": "etc/Gmt",
  "etc/uct": "Etc/Utc",
  "etc/universal": "Etc/Utc",
  "etc/zulu": "Etc/Utc",
  gmt: "etc/Gmt",
  singapore: "Asia/Singapore",
  "easter island": "Chile/EasterIsland",
  "us/pacific-new": "America/Los_Angeles",
  uct: "Etc/Utc",
  utc: "Etc/Utc",
  est: "Etc/Gmt+5",
  mst: "Etc/Gmt+7",
  hst: "Etc/Gmt+10"
};
var _07Parentheses = {
  "west africa time": "Africa/Lagos",
  casey: "Antarctica/Casey",
  davis: "Antarctica/Davis",
  "dumont-d'urville": "Antarctica/DumontDUrville",
  mawson: "Antarctica/Mawson",
  palmer: "Antarctica/Palmer",
  rothera: "Antarctica/Rothera",
  syowa: "Antarctica/Syowa",
  troll: "Antarctica/Troll",
  vostok: "Antarctica/Vostok",
  "new zealand time": "Pacific/Auckland",
  "buenos aires (ba, cf)": "America/Argentina",
  "argentina (most areas: cb, cc, cn, er, fm, mn, se, sf)": "America/Argentina",
  "salta (sa, lp, nq, rn)": "America/Argentina",
  "jujuy (jy)": "America/Argentina",
  "tucum\xE1n (tm)": "America/Argentina",
  "catamarca (ct); chubut (ch)": "America/Argentina",
  "la rioja (lr)": "America/Argentina",
  "san juan (sj)": "America/Argentina",
  "mendoza (mz)": "America/Argentina",
  "san luis (sl)": "America/Argentina",
  "santa cruz (sc)": "America/Argentina",
  "tierra del fuego (tf)": "America/Argentina",
  "samoa, midway": "Pacific/Pago_Pago",
  "lord howe island": "Australia/Lord_Howe",
  "macquarie island": "Antarctica/Macquarie",
  "tasmania (most areas)": "Australia/Hobart",
  "tasmania (king island)": "Australia/Currie",
  victoria: "Australia/Melbourne",
  "new south wales (most areas)": "Australia/Sydney",
  "new south wales (yancowinna)": "Australia/Broken_Hill",
  "queensland (most areas)": "Australia/Brisbane",
  "queensland (whitsunday islands)": "Australia/Lindeman",
  "south australia": "Australia/Adelaide",
  "northern territory": "Australia/Darwin",
  "western australia (most areas)": "Australia/Perth",
  "western australia (eucla)": "Australia/Eucla",
  "central africa time": "Africa/Maputo",
  "atlantic islands": "America/Noronha",
  "par\xE1 (east); amap\xE1": "America/Belem",
  "brazil (northeast: ma, pi, ce, rn, pb)": "America/Fortaleza",
  pernambuco: "America/Recife",
  tocantins: "America/Araguaina",
  "alagoas, sergipe": "America/Maceio",
  bahia: "America/Bahia",
  "brazil (southeast: go, df, mg, es, rj, sp, pr, sc, rs)": "America/Sao_Paulo",
  "mato grosso do sul": "America/Campo_Grande",
  "mato grosso": "America/Cuiaba",
  "par\xE1 (west)": "America/Santarem",
  rond\u00F4nia: "America/Porto_Velho",
  roraima: "America/Boa_Vista",
  "amazonas (east)": "America/Manaus",
  "amazonas (west)": "America/Eirunepe",
  acre: "America/Rio_Branco",
  "newfoundland; labrador (southeast)": "America/St_Johns",
  "atlantic - ns (most areas); pe": "America/Halifax",
  "atlantic - ns (cape breton)": "America/Glace_Bay",
  "atlantic - new brunswick": "America/Moncton",
  "atlantic - labrador (most areas)": "America/Goose_Bay",
  "ast - qc (lower north shore)": "America/Blanc-Sablon",
  "eastern - on, qc (most areas)": "America/Toronto",
  "eastern - on, qc (no dst 1967-73)": "America/Nipigon",
  "eastern - on (thunder bay)": "America/Thunder_Bay",
  "eastern - nu (most east areas)": "America/Iqaluit",
  "eastern - nu (pangnirtung)": "America/Pangnirtung",
  "est - on (atikokan); nu (coral h)": "America/Atikokan",
  "central - on (west); manitoba": "America/Winnipeg",
  "central - on (rainy r, ft frances)": "America/Rainy_River",
  "central - nu (resolute)": "America/Resolute",
  "central - nu (central)": "America/Rankin_Inlet",
  "cst - sk (most areas)": "America/Regina",
  "cst - sk (midwest)": "America/Swift_Current",
  "mountain - ab; bc (e); sk (w)": "America/Edmonton",
  "mountain - nu (west)": "America/Cambridge_Bay",
  "mountain - nt (central)": "America/Yellowknife",
  "mountain - nt (west)": "America/Inuvik",
  "mst - bc (creston)": "America/Creston",
  "mst - bc (dawson cr, ft st john)": "America/Dawson_Creek",
  "mst - bc (ft nelson)": "America/Fort_Nelson",
  "pacific - bc (most areas)": "America/Vancouver",
  "pacific - yukon (south)": "America/Whitehorse",
  "pacific - yukon (north)": "America/Dawson",
  "swiss time": "Europe/Zurich",
  "chile (most areas)": "America/Santiago",
  "region of magallanes": "America/Punta_Arenas",
  "easter island": "Chile/EasterIsland",
  "beijing time": "Asia/Shanghai",
  "xinjiang time": "Asia/Urumqi",
  "cyprus (most areas)": "Asia/Nicosia",
  "northern cyprus": "Asia/Famagusta",
  "germany (most areas)": "Europe/Berlin",
  "ecuador (mainland)": "America/Guayaquil",
  "gal\xE1pagos islands": "Pacific/Galapagos",
  "spain (mainland)": "Europe/Madrid",
  "ceuta, melilla": "Africa/Ceuta",
  "canary islands": "Atlantic/Canary",
  "chuuk/truk, yap": "Pacific/Chuuk",
  "pohnpei/ponape": "Pacific/Pohnpei",
  kosrae: "Pacific/Kosrae",
  "greenland (most areas)": "America/Godthab",
  "national park (east coast)": "America/Danmarkshavn",
  "scoresbysund/ittoqqortoormiit": "America/Scoresbysund",
  "thule/pituffik": "America/Thule",
  "java, sumatra": "Asia/Jakarta",
  "borneo (west, central)": "Asia/Pontianak",
  "borneo (east, south); sulawesi/celebes, bali, nusa tengarra; timor (west)": "Asia/Makassar",
  "new guinea (west papua / irian jaya); malukus/moluccas": "Asia/Jayapura",
  "indochina (most areas)": "Asia/Bangkok",
  "gilbert islands": "Pacific/Tarawa",
  "phoenix islands": "Pacific/Enderbury",
  "line islands": "Pacific/Kiritimati",
  "kazakhstan (most areas)": "Asia/Almaty",
  "qyzylorda/kyzylorda/kzyl-orda": "Asia/Qyzylorda",
  "aqt\xF6be/aktobe": "Asia/Aqtobe",
  "mangghysta\u016B/mankistau": "Asia/Aqtau",
  "atyra\u016B/atirau/gur'yev": "Asia/Atyrau",
  "west kazakhstan": "Asia/Oral",
  "marshall islands (most areas)": "Pacific/Majuro",
  kwajalein: "Pacific/Kwajalein",
  "mongolia (most areas)": "Asia/Ulaanbaatar",
  "bayan-\xF6lgii, govi-altai, hovd, uvs, zavkhan": "Asia/Hovd",
  "dornod, s\xFCkhbaatar": "Asia/Choibalsan",
  "central time": "America/Mexico_City",
  "eastern standard time - quintana roo": "America/Cancun",
  "central time - campeche, yucat\xE1n": "America/Merida",
  "central time - durango; coahuila, nuevo le\xF3n, tamaulipas (most areas)": "America/Monterrey",
  "central time us - coahuila, nuevo le\xF3n, tamaulipas (us border)": "America/Matamoros",
  "mountain time - baja california sur, nayarit, sinaloa": "America/Mazatlan",
  "mountain time - chihuahua (most areas)": "America/Chihuahua",
  "mountain time us - chihuahua (us border)": "America/Ojinaga",
  "mountain standard time - sonora": "America/Hermosillo",
  "pacific time us - baja california": "America/Tijuana",
  "central time - bah\xEDa de banderas": "America/Bahia_Banderas",
  "malaysia (peninsula)": "Asia/Kuala_Lumpur",
  "sabah, sarawak": "Asia/Kuching",
  "chatham islands": "Pacific/Chatham",
  "society islands": "Pacific/Tahiti",
  "marquesas islands": "Pacific/Marquesas",
  "gambier islands": "Pacific/Gambier",
  "papua new guinea (most areas)": "Pacific/Port_Moresby",
  bougainville: "Pacific/Bougainville",
  "gaza strip": "Asia/Gaza",
  "west bank": "Asia/Hebron",
  "portugal (mainland)": "Europe/Lisbon",
  "madeira islands": "Atlantic/Madeira",
  azores: "Atlantic/Azores",
  "r\xE9union, crozet, scattered islands": "Indian/Reunion",
  "msk-01 - kaliningrad": "Europe/Kaliningrad",
  "msk+00 - moscow area": "Europe/Moscow",
  "msk+00 - crimea": "Europe/Simferopol",
  "msk+00 - volgograd": "Europe/Volgograd",
  "msk+00 - kirov": "Europe/Kirov",
  "msk+01 - astrakhan": "Europe/Astrakhan",
  "msk+01 - saratov": "Europe/Saratov",
  "msk+01 - ulyanovsk": "Europe/Ulyanovsk",
  "msk+01 - samara, udmurtia": "Europe/Samara",
  "msk+02 - urals": "Asia/Yekaterinburg",
  "msk+03 - omsk": "Asia/Omsk",
  "msk+04 - novosibirsk": "Asia/Novosibirsk",
  "msk+04 - altai": "Asia/Barnaul",
  "msk+04 - tomsk": "Asia/Tomsk",
  "msk+04 - kemerovo": "Asia/Novokuznetsk",
  "msk+04 - krasnoyarsk area": "Asia/Krasnoyarsk",
  "msk+05 - irkutsk, buryatia": "Asia/Irkutsk",
  "msk+06 - zabaykalsky": "Asia/Chita",
  "msk+06 - lena river": "Asia/Yakutsk",
  "msk+06 - tomponsky, ust-maysky": "Asia/Khandyga",
  "msk+07 - amur river": "Asia/Vladivostok",
  "msk+07 - oymyakonsky": "Asia/Ust-Nera",
  "msk+08 - magadan": "Asia/Magadan",
  "msk+08 - sakhalin island": "Asia/Sakhalin",
  "msk+08 - sakha (e); north kuril is": "Asia/Srednekolymsk",
  "msk+09 - kamchatka": "Asia/Kamchatka",
  "msk+09 - bering sea": "Asia/Anadyr",
  "kerguelen, st paul island, amsterdam island": "Indian/Kerguelen",
  "ukraine (most areas)": "Europe/Kiev",
  ruthenia: "Europe/Uzhgorod",
  "zaporozh'ye/zaporizhia; lugansk/luhansk (east)": "Europe/Zaporozhye",
  "wake island": "Pacific/Wake",
  "eastern (most areas)": "America/New_York",
  "eastern - mi (most areas)": "America/Detroit",
  "eastern - ky (louisville area)": "America/Kentucky",
  "eastern - ky (wayne)": "America/Kentucky",
  "eastern - in (most areas)": "America/Indiana",
  "eastern - in (da, du, k, mn)": "America/Indiana",
  "eastern - in (pulaski)": "America/Indiana",
  "eastern - in (crawford)": "America/Indiana",
  "eastern - in (pike)": "America/Indiana",
  "eastern - in (switzerland)": "America/Indiana",
  "central (most areas)": "America/Chicago",
  "central - in (perry)": "America/Indiana",
  "central - in (starke)": "America/Indiana",
  "central - mi (wisconsin border)": "America/Menominee",
  "central - nd (oliver)": "America/North_Dakota",
  "central - nd (morton rural)": "America/North_Dakota",
  "central - nd (mercer)": "America/North_Dakota",
  "mountain (most areas)": "America/Denver",
  "mountain - id (south); or (east)": "America/Boise",
  "mst - arizona (except navajo)": "America/Phoenix",
  "alaska (most areas)": "America/Anchorage",
  "alaska - juneau area": "America/Juneau",
  "alaska - sitka area": "America/Sitka",
  "alaska - annette island": "America/Metlakatla",
  "alaska - yakutat": "America/Yakutat",
  "alaska (west)": "America/Nome",
  "aleutian islands": "America/Adak",
  "uzbekistan (west)": "Asia/Samarkand",
  "uzbekistan (east)": "Asia/Tashkent",
  "vietnam (south)": "Asia/Ho_Chi_Minh"
};
var informal = {
  "America/Halifax": ["ast", "adt", "atlantic"],
  "America/New_York": ["est", "edt", "eastern"],
  "America/Chicago": ["cst", "cdt", "central"],
  "America/Denver": ["mst", "mdt", "mountain"],
  "America/Los_Angeles": ["pst", "pdt", "pacific"],
  "America/Anchorage": ["ahst", "ahdt", "akst", "akdt", "alaska"],
  "America/St_Johns": ["nst", "ndt", "nt", "newfoundland", "nddt"],
  "America/Caracas": ["vet", null, "venezuela"],
  "America/Bogota": ["cot", null, "colombia"],
  "America/Cayenne": ["gft", null, "french guiana"],
  "America/Paramaribo": ["srt", null, "suriname"],
  "America/Guyana": ["gyt"],
  "America/Buenos_Aires": ["art", null, "argentina"],
  "America/La_Paz": ["bot", null, "bolivia"],
  "America/Asuncion": ["pyt", "pyst", "paraguay"],
  "America/Santiago": ["clt", "clst", "chile"],
  "America/Lima": ["pet", null, "peru"],
  "America/Montevideo": ["uyt", null, "uruguay"],
  "Atlantic/Stanley": ["fkst", null, "falkland island"],
  "America/Manaus": ["amt"],
  "America/Sao_Paulo": ["brt", "brst"],
  "Brazil/Acre": ["act"],
  "Europe/London": ["gmt", "bst", "british"],
  "ETC/GMT": ["gmt", null, "greenwich"],
  "Europe/Lisbon": ["wet", "west", "west europe"],
  "Europe/Berlin": ["cet", "cest", "central europe", "middle european", "met", "mest"],
  "Europe/Riga": ["eet", "eest", "east europe", "kalt"],
  "Europe/Moscow": ["msk", null, "fet", "mdst", "msd"],
  "Europe/Samara": ["samt"],
  "Asia/Yekaterinburg": ["yekt"],
  "Asia/Omsk": ["omst"],
  "Asia/Krasnoyarsk": ["krat"],
  "Asia/Novosibirsk": ["novt"],
  "Asia/Irkutsk": ["irkt"],
  "Asia/Yakutsk": ["yakt"],
  "Asia/Cladivostok": ["vlat"],
  "Asia/Magadan": ["magt"],
  "Asia/Sakhalin": ["sakt"],
  "Asia/Srednekolymsk": ["sret"],
  "Asia/Anadyr": ["anat"],
  "Asia/Kamchatka": ["pett"],
  "Asia/Tashkent": ["uzt", "uzbekistan"],
  "Asia/Bishkek": ["kgt", "kyrgyzstan"],
  "Antarctica/Vostok": ["vost"],
  "Asia/Hovd": ["hovt"],
  "Asia/Ashgabat": ["tmt", null, "turkmenistan"],
  "Africa/Lagos": ["wat", "wast", "west africa"],
  "Africa/Khartoum": ["cat", null, "central africa"],
  "Africa/Nairobi": ["eat", null, "east africa"],
  "Atlantic/Cape_Verde": ["cvt"],
  "Indian/Mauritius": ["mut"],
  "Indian/Reunion": ["ret"],
  "Africa/Johannesburg": ["sast", null, "south africa"],
  "Atlantic/Azores": ["azot", "azost", "hmt"],
  "America/Godthab": ["wgt", "wgst", "west greenland"],
  "America/Scoresbysund": ["egt", "egst", "east greenland"],
  "Europe/Istanbul": ["trt", null, "turkey"],
  "Asia/Tbilisi": ["get", null, "georgia"],
  "Asia/Baku": ["azt", null, "azerbaijan"],
  "Asia/Jerusalem": [null, "idt", "israel", "jmt", "iddt"],
  "Asia/Tehran": ["irst", "irdt", "iran"],
  "Asia/Karachi": ["pkt", null, "pakistan"],
  "Asia/Kabul": ["aft", null, "afghanistan"],
  "Asia/Dushanbe": ["tjt", null, "tajikistan"],
  "Asia/Almaty": ["almt", null, "alma ata"],
  "Asia/Dubai": ["gst", null, "gulf"],
  "Asia/Kolkata": ["ist", null, "india", "slst"],
  "Asia/Thimbu": ["btt", null, "bhutan"],
  "Indian/Maldives": ["mvt"],
  "Asia/Kathmandu": ["npt", null, "nepal"],
  "Indian/Cocos": ["cct", null, "cocos island"],
  "Indian/Chagos": ["iot", null, "indian chagos"],
  "Indian/Kerguelen": ["tft", null, "french southern and antarctic"],
  "Asia/Shanghai": ["ct", null, "china", "hkt"],
  "Asia/Ulaanbaatar": ["ulat"],
  "Asia/Seoul": ["kst", null, "korea"],
  "Asia/Tokyo": ["jst", null, "japan"],
  "Asia/Phnom_Penh": ["ict", null],
  "Asia/Manila": ["pht", null, "philippines"],
  "Asia/Singapore": ["sgt"],
  "Australia/Brisbane": ["aest", "aedt", "australian east"],
  "Australia/Adelaide": ["acst", "acdt", "australian central"],
  "Australia/Eucla": ["acwst", null, "cwst", "australian central western"],
  "Australia/Perth": ["awst", "awdt", "australian west"],
  "Pacific/Auckland": ["nzst", "nzdt", "nzmt"],
  "Australia/Lord_Howe": ["lhst", "lhdt"],
  "Pacific/Guam": ["chst"],
  "Pacific/Chatham": ["chast", "chadt"],
  "Pacific/Honolulu": ["hst"],
  "Asia/Brunei": ["bnt", null, "bdt"],
  "Pacific/Midway": ["sst", null, "samoa", "sdt"],
  "Pacific/Niue": ["nut"],
  "Pacific/Fakaofo": ["tkt"],
  "Pacific/Rarotonga": ["ckt", null, "cook islands"],
  "Chile/EasterIsland": ["east", "easst", "easter island", "emt"],
  "Asia/Jayapura": ["wit", null, "east indonesia"],
  "Asia/Jakarta": ["wib", null, "west indonesia"],
  "Asia/Makassar": ["wita", null, "central indonesia"],
  "Pacific/Galapagos": ["galt"],
  "Pacific/Fiji": ["fjt", "fjst"],
  "Asia/Dili": ["tlt", null, "east timor"],
  "Indian/Christmas": ["cxt"]
};
var _06Abbreviations = informal;
var _05Metazones = [
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    daylight: {
      name: "British Summer Time",
      abbrev: "BST"
    },
    alias: ["british", "britain"],
    pick: "Europe/London",
    zones: ["Europe/Guernsey", "Europe/Isle_Of_Man", "Europe/Jersey", "Europe/London"]
  },
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    daylight: {
      name: "Irish Summer Time",
      abbrev: "IST"
    },
    alias: ["ireland"],
    zones: ["Europe/Dublin"]
  },
  {
    standard: {
      name: "Greenwich Standard Time",
      abbrev: "GMT"
    },
    pick: "Africa/Freetown",
    alias: ["etc", "utc"],
    zones: ["Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "America/Danmarkshavn", "Antarctica/Troll", "Atlantic/Reykjavik", "Atlantic/St_Helena", "ETC/GMT"]
  },
  {
    standard: {
      name: "Central Standard Time",
      abbrev: "CST"
    },
    daylight: {
      name: "Central Daylight Time",
      abbrev: "CDT"
    },
    pick: "America/Chicago",
    zones: ["America/Bahia_Banderas", "America/Belize", "America/Chicago", "America/Costa_Rica", "America/El_Salvador", "America/Guatemala", "America/Indiana", "America/Managua", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/Monterrey", "America/North_Dakota", "America/North_Dakota", "America/North_Dakota", "America/Rainy_River", "America/Rankin_Inlet", "America/Regina", "America/Resolute", "America/Swift_Current", "America/Tegucigalpa", "America/Winnipeg"]
  },
  {
    standard: {
      name: "Mountain Standard Time",
      abbrev: "MST"
    },
    daylight: {
      name: "Mountain Daylight Time",
      abbrev: "MDT"
    },
    pick: "America/Denver",
    zones: [
      "America/Boise",
      "America/Cambridge_Bay",
      "America/Creston",
      "America/Dawson_Creek",
      "America/Denver",
      "America/Edmonton",
      "America/Fort_Nelson",
      "America/Inuvik",
      "America/Ojinaga",
      "America/Phoenix",
      "America/Yellowknife",
      "America/Chihuahua",
      "America/Hermosillo",
      "America/Mazatlan"
    ]
  },
  {
    standard: {
      name: "Atlantic Standard Time",
      abbrev: "AST"
    },
    daylight: {
      name: "Atlantic Daylight Time",
      abbrev: "ADT"
    },
    pick: "America/Halifax",
    zones: ["America/Anguilla", "America/Antigua", "America/Aruba", "America/Barbados", "America/Blanc-sablon", "America/Curacao", "America/Dominica", "America/Glace_Bay", "America/Goose_Bay", "America/Grenada", "America/Guadeloupe", "America/Halifax", "America/Kralendijk", "America/Lower_Princes", "America/Marigot", "America/Martinique", "America/Moncton", "America/Montserrat", "America/Port_Of_Spain", "America/Puerto_Rico", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thule", "America/Tortola", "Atlantic/Bermuda"]
  },
  {
    standard: {
      name: "Eastern Standard Time",
      abbrev: "EST"
    },
    daylight: {
      name: "Eastern Daylight Time",
      abbrev: "EDT"
    },
    pick: "America/New_York",
    zones: ["America/Cancun", "America/Cayman", "America/Coral_Harbour", "America/Detroit", "America/Grand_Turk", "America/Indiana", "America/Indianapolis", "America/Iqaluit", "America/Jamaica", "America/Kentucky", "America/Louisville", "America/Nassau", "America/New_York", "America/Nipigon", "America/Panama", "America/Pangnirtung", "America/Port-au-prince", "America/Thunder_Bay", "America/Toronto", "America/Montreal"]
  },
  {
    standard: {
      name: "Pacific Standard Time",
      abbrev: "PST"
    },
    daylight: {
      name: "Pacific Daylight Time",
      abbrev: "PDT"
    },
    pick: "America/Los_Angeles",
    zones: ["America/Dawson", "America/Los_Angeles", "America/Tijuana", "America/Vancouver", "America/Whitehorse"]
  },
  {
    standard: {
      name: "Alaskan Standard Time",
      abbrev: "AHST"
    },
    daylight: {
      name: "Alaskan Daylight Time",
      abbrev: "AHDT"
    },
    pick: "America/Anchorage",
    zones: ["America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat"]
  },
  {
    standard: {
      name: "Hawaiian Standard Time",
      abbrev: "HST"
    },
    alias: ["aleutian", "hawaii"],
    pick: "Pacific/Honolulu",
    zones: ["America/Adak", "Pacific/Honolulu", "Pacific/Johnston"]
  },
  {
    standard: {
      name: "Newfoundland Standard Time",
      abbrev: "NST"
    },
    daylight: {
      name: "Newfoundland Daylight Time",
      abbrev: "NDT"
    },
    pick: "America/St_Johns",
    zones: ["America/St_Johns"]
  },
  {
    standard: {
      name: "Central European Time",
      abbrev: "CET"
    },
    daylight: {
      name: "Central European Summer Time",
      abbrev: "CEST"
    },
    alias: ["romance", "central europe"],
    pick: "Europe/Berlin",
    zones: ["Africa/Algiers", "Africa/Ceuta", "Africa/Tunis", "arctic/Longyearbyen", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich"]
  },
  {
    standard: {
      name: "Eastern European Time",
      abbrev: "EET"
    },
    daylight: {
      name: "Eastern European Summer Time",
      abbrev: "EEST"
    },
    alias: ["eastern europe"],
    pick: "Europe/Riga",
    zones: ["Africa/Cairo", "Africa/Tripoli", "Asia/Amman", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Nicosia", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Kaliningrad", "Europe/Kiev", "Europe/Mariehamn", "Europe/Riga", "Europe/Sofia", "Europe/Tallinn", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye"]
  },
  {
    standard: {
      name: "Western European Time",
      abbrev: "WET"
    },
    daylight: {
      name: "Western European Summer Time",
      abbrev: "WEST"
    },
    alias: ["western europe"],
    pick: "Europe/Lisbon",
    zones: ["Africa/Casablanca", "Africa/El_Aaiun", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Madeira", "Europe/Lisbon"]
  },
  {
    standard: {
      name: "Turkey Standard Time",
      abbrev: "TRT"
    },
    alias: ["turkish"],
    pick: "Europe/Istanbul",
    zones: ["Europe/Istanbul"]
  },
  {
    standard: {
      name: "East Africa Time",
      abbrev: "EAT"
    },
    alias: ["east african", "eastern africa"],
    pick: "Africa/Nairobi",
    zones: ["Africa/Addis_Ababa", "Africa/Asmera", "Africa/Dar_Es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte"]
  },
  {
    standard: {
      name: "Central Africa Time",
      abbrev: "CAT"
    },
    pick: "Africa/Khartoum",
    alias: ["central africa"],
    zones: ["Africa/Blantyre", "Africa/Bujumbura", "Africa/Gaborone", "Africa/Harare", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Windhoek"]
  },
  {
    standard: {
      name: "South Africa Standard Time",
      abbrev: "SAST"
    },
    alias: ["southern africa", "south african"],
    pick: "Africa/Johannesburg",
    zones: ["Africa/Johannesburg", "Africa/Maseru", "Africa/Mbabane"]
  },
  {
    standard: {
      name: "West Africa Standard Time",
      abbrev: "WAT"
    },
    alias: ["western africa", "west african"],
    pick: "Africa/Lagos",
    zones: ["Africa/Bangui", "Africa/Brazzaville", "Africa/Douala", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-novo"]
  },
  {
    standard: {
      name: "Australian Central Standard Time",
      abbrev: "ACST"
    },
    daylight: {
      name: "Australian Central Daylight Time",
      abbrev: "ACDT"
    },
    alias: ["australia central"],
    pick: "Australia/Adelaide",
    zones: ["Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin"]
  },
  {
    standard: {
      name: "Australian Eastern Standard Time",
      abbrev: "AEST"
    },
    daylight: {
      name: "Australian Eastern Daylight Time",
      abbrev: "AEDT"
    },
    alias: ["australia east"],
    pick: "Australia/Brisbane",
    zones: ["Australia/Brisbane", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/Sydney"]
  },
  {
    standard: {
      name: "Australian Western Standard Time",
      abbrev: "AWST"
    },
    daylight: {
      name: "Australian Western Daylight Time",
      abbrev: "AWDT"
    },
    alias: ["australia west"],
    pick: "Australia/Perth",
    zones: ["Antarctica/Casey", "Australia/Perth"]
  },
  {
    standard: {
      name: "Australian Central Western Standard Time",
      abbrev: "ACWST"
    },
    alias: ["australia central west"],
    pick: "Australia/Eucla",
    zones: ["Australia/Eucla"]
  },
  {
    standard: {
      name: "Lord Howe Standard Time",
      abbrev: "LHST"
    },
    daylight: {
      name: "Lord Howe Daylight Time",
      abbrev: "LHDT"
    },
    pick: "Australia/Lord_Howe",
    zones: ["Australia/Lord_Howe"]
  },
  {
    standard: {
      name: "New Zealand Standard Time",
      abbrev: "NZST"
    },
    daylight: {
      name: "New Zealand Daylight Time",
      abbrev: "NZDT"
    },
    pick: "Pacific/Auckland",
    zones: ["Antarctica/Mcmurdo", "Pacific/Auckland"]
  },
  {
    standard: {
      name: "Chatham Island Standard Time",
      abbrev: "CHAST"
    },
    daylight: {
      name: "Chatham Island Daylight Time",
      abbrev: "CHADT"
    },
    pick: "Pacific/Chatham",
    zones: ["Pacific/Chatham"]
  },
  {
    standard: {
      name: "Russian Standard Time",
      abbrev: "MSK"
    },
    alias: ["russian"],
    pick: "Europe/Moscow",
    zones: ["Europe/Astrakhan", "Europe/Minsk", "Europe/Moscow", "Europe/Simferopol", "Europe/Ulyanovsk", "Europe/Kirov"]
  },
  {
    standard: {
      name: "Volgograd Time",
      abbrev: "VOLT"
    },
    zones: ["Europe/Volgograd"]
  },
  {
    standard: {
      name: "Brazil Time",
      abbrev: "BRT"
    },
    alias: ["bras\xEDlia", "brasilia", "brazilian"],
    pick: "America/Sao_Paulo",
    zones: ["America/Araguaina", "America/Bahia", "America/Belem", "America/Fortaleza", "America/Maceio", "America/Recife", "America/Santarem", "America/Sao_Paulo"]
  },
  {
    standard: {
      name: "Argentina Time",
      abbrev: "ART"
    },
    alias: ["argentinian"],
    pick: "America/Buenos_Aires",
    zones: ["America/Argentina", "America/Buenos_Aires", "America/Catamarca", "America/Cordoba", "America/Jujuy", "America/Mendoza"]
  },
  {
    standard: {
      name: "Amazon Time",
      abbrev: "AMT"
    },
    alias: ["amazonian"],
    pick: "America/Manaus",
    zones: [
      "America/Boa_Vista",
      "America/Campo_Grande",
      "America/Cuiaba",
      "America/Manaus",
      "America/Porto_Velho"
    ]
  },
  {
    standard: {
      name: "Easter Island Standard Time",
      abbrev: "EAST"
    },
    daylight: {
      name: "Easter Island Summer Time",
      abbrev: "EASST"
    },
    zones: ["Chile/EasterIsland"]
  },
  {
    standard: {
      name: "Venezuelan Standard Time",
      abbrev: "VET"
    },
    alias: ["venezuela"],
    zones: ["America/Caracas"]
  },
  {
    standard: {
      name: "Paraguay Time",
      abbrev: "PYT"
    },
    daylight: {
      name: "Paraguay Summer Time",
      abbrev: "PYST"
    },
    zones: ["America/Asuncion"]
  },
  {
    standard: {
      name: "Cuba Standard Time",
      abbrev: "CST"
    },
    daylight: {
      name: "Cuba Daylight Time",
      abbrev: "CDT"
    },
    alias: ["cuban"],
    zones: ["America/Havana"]
  },
  {
    standard: {
      name: "Bolivia Time",
      abbrev: "BOT"
    },
    alias: ["bolivian"],
    zones: ["America/La_Paz"]
  },
  {
    standard: {
      name: "Colombia Time",
      abbrev: "COT"
    },
    alias: ["colombian"],
    zones: ["America/Bogota"]
  },
  {
    standard: {
      name: "Acre Time",
      abbrev: "ACT"
    },
    pick: null,
    zones: ["America/Eirunepe", "America/Rio_Branco"]
  },
  {
    standard: {
      name: "Peru Time",
      abbrev: "PET"
    },
    zones: ["America/Lima"]
  },
  {
    standard: {
      name: "Chile Standard Time",
      abbrev: "CLST"
    },
    daylight: {
      name: "Chile Summer Time",
      abbrev: "CLDT"
    },
    pick: null,
    zones: ["America/Punta_Arenas", "America/Santiago", "Antarctica/Palmer"]
  },
  {
    standard: {
      name: "Uruguay Time",
      abbrev: "UYT"
    },
    zones: ["America/Montevideo"]
  },
  {
    standard: {
      name: "Arabic Standard Time",
      abbrev: "AST"
    },
    pick: "Asia/Baghdad",
    alias: ["arabic", "arab"],
    zones: ["Asia/Aden", "Asia/Baghdad", "Asia/Bahrain", "Asia/Kuwait", "Asia/Qatar", "Asia/Riyadh"]
  },
  {
    standard: {
      name: "Iran Standard Time",
      abbrev: "IRST"
    },
    daylight: {
      name: "Iran Daylight Time",
      abbrev: "IRDT"
    },
    alias: ["iranian"],
    pick: "Asia/Tehran",
    zones: ["Asia/Tehran"]
  },
  {
    standard: {
      name: "Pakistan Standard Time",
      abbrev: "PKT"
    },
    pick: "Asia/Karachi",
    zones: ["Asia/Karachi"]
  },
  {
    standard: {
      name: "India Standard Time",
      abbrev: "IST"
    },
    alias: ["indian"],
    pick: "Asia/Kolkata",
    zones: ["Asia/Kolkata", "Asia/Colombo"]
  },
  {
    standard: {
      name: "Indochina Time",
      abbrev: "ICT"
    },
    alias: ["South East Asia"],
    pick: "Asia/Bangkok",
    zones: ["Asia/Bangkok", "Asia/Phnom_Penh", "Asia/Saigon", "Asia/Vientiane"]
  },
  {
    standard: {
      name: "China Standard Time",
      abbrev: "CT"
    },
    alias: ["chinese"],
    pick: "Asia/Shanghai",
    zones: ["Asia/Macau", "Asia/Shanghai", "Asia/Taipei"]
  },
  {
    standard: {
      name: "Alma-Ata Time",
      abbrev: "ALMT"
    },
    pick: "Asia/Almaty",
    zones: ["Asia/Almaty", "Asia/Qostanay"]
  },
  {
    standard: {
      name: "Oral Time",
      abbrev: "ORAT"
    },
    pick: "Asia/Oral",
    zones: ["Asia/Aqtau", "Asia/Aqtobe", "Asia/Atyrau", "Asia/Oral", "Asia/Qyzylorda"]
  },
  {
    standard: {
      name: "Yakutsk Time",
      abbrev: "YAKT"
    },
    pick: "Asia/Yakutsk",
    zones: ["Asia/Chita", "Asia/Khandyga", "Asia/Yakutsk"]
  },
  {
    standard: {
      name: "Gulf Standard Time",
      abbrev: "GST"
    },
    pick: "Asia/Dubai",
    alias: ["uae"],
    zones: ["Asia/Dubai", "Asia/Muscat"]
  },
  {
    standard: {
      name: "Hong Kong Time",
      abbrev: "HKT"
    },
    zones: ["Asia/Hong_Kong"]
  },
  {
    standard: {
      name: "Western Indonesian Time",
      abbrev: "WIB"
    },
    alias: ["indonesia"],
    zones: ["Asia/Jakarta", "Asia/Pontianak", "Asia/Jayapura"]
  },
  {
    standard: {
      name: "Central Indonesian Time",
      abbrev: "WITA"
    },
    zones: ["Asia/Makassar"]
  },
  {
    standard: {
      name: "Israel Daylight Time",
      abbrev: "IDT"
    },
    daylight: {
      name: "Israel Standard Time",
      abbrev: "IST"
    },
    alias: ["israeli"],
    zones: ["Asia/Jerusalem"]
  },
  {
    standard: {
      name: "Krasnoyarsk Time",
      abbrev: "KRAT"
    },
    zones: ["Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Barnaul"]
  },
  {
    standard: {
      name: "Malaysia Time",
      abbrev: "MYT"
    },
    zones: ["Asia/Kuala_Lumpur", "Asia/Kuching"]
  },
  {
    standard: {
      name: "Singapore Time",
      abbrev: "SGT"
    },
    zones: ["Asia/Singapore"]
  },
  {
    standard: {
      name: "Korea Standard Time",
      abbrev: "KST"
    },
    pick: "Asia/Seoul",
    alias: ["korean"],
    zones: ["Asia/Pyongyang", "Asia/Seoul"]
  },
  {
    standard: {
      name: "Uzbekistan Time",
      abbrev: "UZT"
    },
    zones: ["Asia/Samarkand", "Asia/Tashkent"]
  },
  {
    standard: {
      name: "Vladivostok Time",
      abbrev: "VLAT"
    },
    pick: "Asia/Vladivostok",
    zones: ["Asia/Ust-nera", "Asia/Vladivostok"]
  },
  {
    standard: {
      name: "Anadyr Time",
      abbrev: "ANAT"
    },
    zones: ["Asia/Anadyr"]
  },
  {
    standard: {
      name: "Turkmenistan Time",
      abbrev: "TMT"
    },
    zones: ["Asia/Ashgabat"]
  },
  {
    standard: {
      name: "Azerbaijan Time",
      abbrev: "AZT"
    },
    zones: ["Asia/Baku"]
  },
  {
    standard: {
      name: "Kyrgyzstan Time",
      abbrev: "KGT"
    },
    zones: ["Asia/Bishkek"]
  },
  {
    standard: {
      name: "Brunei Darussalam Time",
      abbrev: "BNT"
    },
    zones: ["Asia/Brunei"]
  },
  {
    standard: {
      name: "Afghanistan Time",
      abbrev: "AFT"
    },
    zones: ["Asia/Kabul"]
  },
  {
    standard: {
      name: "Kamchatka Time",
      abbrev: "PETT"
    },
    zones: ["Asia/Kamchatka"]
  },
  {
    standard: {
      name: "Nepal Time",
      abbrev: "NPT"
    },
    zones: ["Asia/Katmandu"]
  },
  {
    standard: {
      name: "Philippine Time",
      abbrev: "PHT"
    },
    zones: ["Asia/Manila"]
  },
  {
    standard: {
      name: "Myanmar Time",
      abbrev: "MMT"
    },
    zones: ["Asia/Rangoon"]
  },
  {
    standard: {
      name: "Georgia Standard Time",
      abbrev: "GET"
    },
    zones: ["Asia/Tbilisi"]
  },
  {
    standard: {
      name: "Japan Standard Time",
      abbrev: "JST"
    },
    zones: ["Asia/Tokyo"]
  },
  {
    standard: {
      name: "Ulaanbaatar Time",
      abbrev: "ULAT"
    },
    zones: ["Asia/Ulaanbaatar"]
  },
  {
    standard: {
      name: "Maldives Time",
      abbrev: "MVT"
    },
    zones: ["Indian/Maldives"]
  },
  {
    standard: {
      name: "Mauritius Time",
      abbrev: "MUT"
    },
    zones: ["Indian/Mauritius"]
  },
  {
    standard: {
      name: "Marshall Islands Time",
      abbrev: "MHT"
    },
    zones: ["Pacific/Kwajalein", "Pacific/Majuro"]
  },
  {
    standard: {
      name: "Samoa Standard Time",
      abbrev: "SST"
    },
    alias: ["somoan"],
    zones: ["Pacific/Midway", "Pacific/Pago_Pago"]
  },
  {
    standard: {
      name: "Chamorro Standard Time",
      abbrev: "CHST"
    },
    zones: ["Pacific/Guam", "Pacific/Saipan"]
  },
  {
    standard: {
      name: "Papua New Guinea Time",
      abbrev: "PGT"
    },
    zones: ["Pacific/Bougainville", "Pacific/Port_Moresby"]
  }
];
var _03ByCountry = {
  andorra: {
    code: "ad",
    choice: "Europe/Andorra"
  },
  oman: {
    code: "om",
    choice: "Asia/Dubai"
  },
  afghanistan: {
    code: "af",
    choice: "Asia/Kabul"
  },
  "virgin islands": {
    code: "vi",
    choice: "America/Port_Of_Spain"
  },
  albania: {
    code: "al",
    choice: "Europe/Tirane"
  },
  armenia: {
    code: "am",
    choice: "Asia/Yerevan"
  },
  nigeria: {
    code: "ng",
    choice: "Africa/Lagos"
  },
  austria: {
    code: "at",
    choice: "Europe/Vienna"
  },
  "st maarten": {
    code: "sx",
    choice: "America/Curacao"
  },
  finland: {
    code: "fi",
    choice: "Europe/Helsinki"
  },
  azerbaijan: {
    code: "az",
    choice: "Asia/Baku"
  },
  slovenia: {
    code: "si",
    choice: "Europe/Belgrade"
  },
  barbados: {
    code: "bb",
    choice: "America/Barbados"
  },
  bangladesh: {
    code: "bd",
    choice: "Asia/Dhaka"
  },
  belgium: {
    code: "be",
    choice: "Europe/Brussels"
  },
  togo: {
    code: "tg",
    choice: "Africa/Abidjan"
  },
  bulgaria: {
    code: "bg",
    choice: "Europe/Sofia"
  },
  qatar: {
    code: "qa",
    choice: "Asia/Qatar"
  },
  zimbabwe: {
    code: "zw",
    choice: "Africa/Maputo"
  },
  bermuda: {
    code: "bm",
    choice: "Atlantic/Bermuda"
  },
  brunei: {
    code: "bn",
    choice: "Asia/Brunei"
  },
  bolivia: {
    code: "bo",
    choice: "America/La_Paz"
  },
  bahamas: {
    code: "bs",
    choice: "America/Nassau"
  },
  bhutan: {
    code: "bt",
    choice: "Asia/Thimphu"
  },
  belarus: {
    code: "by",
    choice: "Europe/Minsk"
  },
  belize: {
    code: "bz",
    choice: "America/Belize"
  },
  "cocos islands": {
    code: "cc",
    choice: "Indian/Cocos"
  },
  liechtenstein: {
    code: "li",
    choice: "Europe/Zurich"
  },
  "cook islands": {
    code: "ck",
    choice: "Pacific/Rarotonga"
  },
  colombia: {
    code: "co",
    choice: "America/Bogota"
  },
  "costa rica": {
    code: "cr",
    choice: "America/Costa_Rica"
  },
  cuba: {
    code: "cu",
    choice: "America/Havana"
  },
  "cape verde": {
    code: "cv",
    choice: "Atlantic/Cape_Verde"
  },
  "christmas island": {
    code: "cx",
    choice: "Indian/Christmas"
  },
  slovakia: {
    code: "sk",
    choice: "Europe/Prague"
  },
  mayotte: {
    code: "yt",
    choice: "Africa/Nairobi"
  },
  denmark: {
    code: "dk",
    choice: "Europe/Copenhagen"
  },
  "dominican republic": {
    code: "do",
    choice: "America/Santo_Domingo"
  },
  algeria: {
    code: "dz",
    choice: "Africa/Algiers"
  },
  estonia: {
    code: "ee",
    choice: "Europe/Tallinn"
  },
  egypt: {
    code: "eg",
    choice: "Africa/Cairo"
  },
  "western sahara": {
    code: "eh",
    choice: "Africa/El_Aaiun"
  },
  fiji: {
    code: "fj",
    choice: "Pacific/Fiji"
  },
  "falkland islands": {
    code: "fk",
    choice: "Atlantic/Stanley"
  },
  "faroe islands": {
    code: "fo",
    choice: "Atlantic/Faroe"
  },
  france: {
    code: "fr",
    choice: "Europe/Paris"
  },
  jersey: {
    code: "je",
    choice: "Europe/London"
  },
  georgia: {
    code: "ge",
    choice: "Asia/Tbilisi"
  },
  "french guiana": {
    code: "gf",
    choice: "America/Cayenne"
  },
  ghana: {
    code: "gh",
    choice: "Africa/Accra"
  },
  gibraltar: {
    code: "gi",
    choice: "Europe/Gibraltar"
  },
  greece: {
    code: "gr",
    choice: "Europe/Athens"
  },
  "south georgia": {
    code: "gs",
    choice: "Atlantic/South_Georgia"
  },
  guatemala: {
    code: "gt",
    choice: "America/Guatemala"
  },
  "northern mariana islands": {
    code: "mp",
    choice: "Pacific/Guam"
  },
  "guinea bissau": {
    code: "gw",
    choice: "Africa/Bissau"
  },
  guyana: {
    code: "gy",
    choice: "America/Guyana"
  },
  "hong kong": {
    code: "hk",
    choice: "Asia/Hong_Kong"
  },
  honduras: {
    code: "hn",
    choice: "America/Tegucigalpa"
  },
  haiti: {
    code: "ht",
    choice: "America/Port-au-prince"
  },
  hungary: {
    code: "hu",
    choice: "Europe/Budapest"
  },
  ireland: {
    code: "ie",
    choice: "Europe/Dublin"
  },
  israel: {
    code: "il",
    choice: "Asia/Jerusalem"
  },
  india: {
    code: "in",
    choice: "Asia/Kolkata"
  },
  "british indian ocean territory": {
    code: "io",
    choice: "Indian/Chagos"
  },
  iraq: {
    code: "iq",
    choice: "Asia/Baghdad"
  },
  iran: {
    code: "ir",
    choice: "Asia/Tehran"
  },
  iceland: {
    code: "is",
    choice: "Atlantic/Reykjavik"
  },
  "vatican city": {
    code: "va",
    choice: "Europe/Rome"
  },
  jamaica: {
    code: "jm",
    choice: "America/Jamaica"
  },
  jordan: {
    code: "jo",
    choice: "Asia/Amman"
  },
  japan: {
    code: "jp",
    choice: "Asia/Tokyo"
  },
  kyrgyzstan: {
    code: "kg",
    choice: "Asia/Bishkek"
  },
  "north korea": {
    code: "kp",
    choice: "Asia/Pyongyang"
  },
  "south korea": {
    code: "kr",
    choice: "Asia/Seoul"
  },
  yemen: {
    code: "ye",
    choice: "Asia/Riyadh"
  },
  panama: {
    code: "pa",
    choice: "America/Panama"
  },
  lebanon: {
    code: "lb",
    choice: "Asia/Beirut"
  },
  "sri lanka": {
    code: "lk",
    choice: "Asia/Colombo"
  },
  liberia: {
    code: "lr",
    choice: "Africa/Monrovia"
  },
  "south africa": {
    code: "za",
    choice: "Africa/Johannesburg"
  },
  lithuania: {
    code: "lt",
    choice: "Europe/Vilnius"
  },
  luxembourg: {
    code: "lu",
    choice: "Europe/Luxembourg"
  },
  latvia: {
    code: "lv",
    choice: "Europe/Riga"
  },
  libya: {
    code: "ly",
    choice: "Africa/Tripoli"
  },
  morocco: {
    code: "ma",
    choice: "Africa/Casablanca"
  },
  monaco: {
    code: "mc",
    choice: "Europe/Monaco"
  },
  moldova: {
    code: "md",
    choice: "Europe/Chisinau"
  },
  myanmar: {
    code: "mm",
    choice: "Asia/Yangon"
  },
  burma: {
    code: "mm",
    choice: "Asia/Yangon"
  },
  macau: {
    code: "mo",
    choice: "Asia/Macau"
  },
  martinique: {
    code: "mq",
    choice: "America/Martinique"
  },
  malta: {
    code: "mt",
    choice: "Europe/Malta"
  },
  mauritius: {
    code: "mu",
    choice: "Indian/Mauritius"
  },
  maldives: {
    code: "mv",
    choice: "Indian/Maldives"
  },
  namibia: {
    code: "na",
    choice: "Africa/Windhoek"
  },
  "new caledonia": {
    code: "nc",
    choice: "Pacific/Noumea"
  },
  "norfolk island": {
    code: "nf",
    choice: "Pacific/Norfolk"
  },
  nicaragua: {
    code: "ni",
    choice: "America/Managua"
  },
  netherlands: {
    code: "nl",
    choice: "Europe/Amsterdam"
  },
  "svalbard and jan mayen": {
    code: "sj",
    choice: "Europe/Oslo"
  },
  nepal: {
    code: "np",
    choice: "Asia/Kathmandu"
  },
  nauru: {
    code: "nr",
    choice: "Pacific/Nauru"
  },
  niue: {
    code: "nu",
    choice: "Pacific/Niue"
  },
  peru: {
    code: "pe",
    choice: "America/Lima"
  },
  philippines: {
    code: "ph",
    choice: "Asia/Manila"
  },
  pakistan: {
    code: "pk",
    choice: "Asia/Karachi"
  },
  poland: {
    code: "pl",
    choice: "Europe/Warsaw"
  },
  "st pierre and miquelon": {
    code: "pm",
    choice: "America/Miquelon"
  },
  pitcairn: {
    code: "pn",
    choice: "Pacific/Pitcairn"
  },
  "puerto rico": {
    code: "pr",
    choice: "America/Puerto_Rico"
  },
  palau: {
    code: "pw",
    choice: "Pacific/Palau"
  },
  paraguay: {
    code: "py",
    choice: "America/Asuncion"
  },
  romania: {
    code: "ro",
    choice: "Europe/Bucharest"
  },
  "solomon islands": {
    code: "sb",
    choice: "Pacific/Guadalcanal"
  },
  seychelles: {
    code: "sc",
    choice: "Indian/Mahe"
  },
  sudan: {
    code: "sd",
    choice: "Africa/Khartoum"
  },
  sweden: {
    code: "se",
    choice: "Europe/Stockholm"
  },
  singapore: {
    code: "sg",
    choice: "Asia/Singapore"
  },
  suriname: {
    code: "sr",
    choice: "America/Paramaribo"
  },
  "south sudan": {
    code: "ss",
    choice: "Africa/Juba"
  },
  "sao tome": {
    code: "st",
    choice: "Africa/Sao_Tome"
  },
  "el salvador": {
    code: "sv",
    choice: "America/El_Salvador"
  },
  syria: {
    code: "sy",
    choice: "Asia/Damascus"
  },
  "turks and caicos": {
    code: "tc",
    choice: "America/Grand_Turk"
  },
  chad: {
    code: "td",
    choice: "Africa/Ndjamena"
  },
  tajikistan: {
    code: "tj",
    choice: "Asia/Dushanbe"
  },
  tokelau: {
    code: "tk",
    choice: "Pacific/Fakaofo"
  },
  "east timor": {
    code: "tl",
    choice: "Asia/Dili"
  },
  turkmenistan: {
    code: "tm",
    choice: "Asia/Ashgabat"
  },
  tunisia: {
    code: "tn",
    choice: "Africa/Tunis"
  },
  tonga: {
    code: "to",
    choice: "Pacific/Tongatapu"
  },
  turkey: {
    code: "tr",
    choice: "Europe/Istanbul"
  },
  tuvalu: {
    code: "tv",
    choice: "Pacific/Funafuti"
  },
  taiwan: {
    code: "tw",
    choice: "Asia/Taipei"
  },
  uruguay: {
    code: "uy",
    choice: "America/Montevideo"
  },
  venezuela: {
    code: "ve",
    choice: "America/Caracas"
  },
  vanuatu: {
    code: "vu",
    choice: "Pacific/Efate"
  },
  "wallis and futuna": {
    code: "wf",
    choice: "Pacific/Wallis"
  },
  "western samoa": {
    code: "ws",
    choice: "Pacific/Apia"
  },
  samoa: {
    code: "ws",
    choice: "Pacific/Apia"
  },
  antarctica: {
    code: "aq",
    choice: "Antarctica/Davis"
  },
  argentina: {
    code: "ar",
    choice: "America/Argentina"
  },
  australia: {
    code: "au",
    choice: "Australia/Sydney"
  },
  brazil: {
    code: "br",
    choice: "America/Sao_Paulo"
  },
  canada: {
    code: "ca",
    choice: "America/Toronto"
  },
  congo: {
    code: "cd",
    choice: "Africa/Kinshasa"
  },
  chile: {
    code: "cl",
    choice: "America/Santiago"
  },
  china: {
    code: "cn",
    choice: "Asia/Shanghai"
  },
  cyprus: {
    code: "cy",
    choice: "Asia/Nicosia"
  },
  germany: {
    code: "de",
    choice: "Europe/Berlin"
  },
  ecuador: {
    code: "ec",
    choice: "America/Guayaquil"
  },
  spain: {
    code: "es",
    choice: "Europe/Madrid"
  },
  micronesia: {
    code: "fm",
    choice: "Pacific/Pohnpei"
  },
  greenland: {
    code: "gl",
    choice: "America/Godthab"
  },
  indonesia: {
    code: "id",
    choice: "Asia/Jakarta"
  },
  kiribati: {
    code: "ki",
    choice: "Pacific/Kiritimati"
  },
  kazakhstan: {
    code: "kz",
    choice: "Asia/Almaty"
  },
  "marshall islands": {
    code: "mh",
    choice: "Pacific/Majuro"
  },
  mongolia: {
    code: "mn",
    choice: "Asia/Ulaanbaatar"
  },
  mexico: {
    code: "mx",
    choice: "America/Mexico_City"
  },
  malaysia: {
    code: "my",
    choice: "Asia/Kuala_Lumpur"
  },
  "new zealand": {
    code: "nz",
    choice: "Pacific/Auckland"
  },
  "french polynesia": {
    code: "pf",
    choice: "Pacific/Pohnpei"
  },
  "papua new guinea": {
    code: "pg",
    choice: "Pacific/Port_Moresby"
  },
  palestine: {
    code: "ps",
    choice: "Asia/Gaza"
  },
  portugal: {
    code: "pt",
    choice: "Europe/Lisbon"
  },
  russia: {
    code: "ru",
    choice: "Europe/Moscow"
  },
  "french southern and antarctic lands": {
    code: "tf",
    choice: "Indian/Kerguelen"
  },
  ukraine: {
    code: "ua",
    choice: "Europe/Kiev"
  },
  "us minor outlying islands": {
    code: "um",
    choice: "Pacific/Wake"
  },
  "united states": {
    code: "us",
    choice: "America/New_York"
  },
  uzbekistan: {
    code: "uz",
    choice: "Asia/Tashkent"
  },
  vietnam: {
    code: "vn",
    choice: "Asia/Ho_Chi_Minh"
  }
};
var all = Object.assign({}, _01Iana, _02ByCity, _04OldZones, _07Parentheses);
Object.keys(_03ByCountry).forEach(function(key) {
  all[key] = _03ByCountry[key].choice;
  all[_03ByCountry[key].code] = _03ByCountry[key].choice;
});
_05Metazones.forEach(function(obj) {
  var zone = obj.pick || obj.zones[0];
  all[obj.standard.name.toLowerCase()] = zone;
  if (obj.standard.abbrev) {
    all[obj.standard.abbrev.toLowerCase()] = zone;
  }
  if (obj.daylight) {
    if (obj.daylight.name) {
      all[obj.daylight.name.toLowerCase()] = zone;
    }
    if (obj.daylight.abbrev) {
      all[obj.daylight.abbrev.toLowerCase()] = zone;
    }
  }
  if (obj.alias) {
    obj.alias.forEach(function(str) {
      return all[str.toLowerCase()] = zone;
    });
  }
});
Object.keys(_06Abbreviations).forEach(function(k2) {
  var arr = (_06Abbreviations[k2] || []).filter(function(a2) {
    return a2;
  });
  arr.forEach(function(abbr) {
    if (all.hasOwnProperty(abbr) === false) {
      all[abbr] = k2;
    }
  });
});
var data = all;
var isOffset = /(\-?[0-9]+)h(rs)?/i;
var isNumber = /(\-?[0-9]+)/;
var utcOffset = /utc([\-+]?[0-9]+)/i;
var gmtOffset = /gmt([\-+]?[0-9]+)/i;
var toIana = function toIana2(num) {
  num = Number(num);
  if (num > -13 && num < 13) {
    num = num * -1;
    num = (num > 0 ? "+" : "") + num;
    return "Etc/GMT" + num;
  }
  return null;
};
var parseOffset = function parseOffset2(tz) {
  var m2 = tz.match(isOffset);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  m2 = tz.match(utcOffset);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  m2 = tz.match(gmtOffset);
  if (m2 !== null) {
    var num = Number(m2[1]) * -1;
    return toIana(num);
  }
  m2 = tz.match(isNumber);
  if (m2 !== null) {
    return toIana(m2[1]);
  }
  return null;
};
var parseOffset_1 = parseOffset;
var normalizeOne = function normalizeOne2(tz) {
  tz = tz.replace(/ time/g, "");
  tz = tz.replace(/ (standard|daylight|summer)/g, "");
  tz = tz.replace(/ - .*/g, "");
  tz = tz.replace(/, .*/g, "");
  return tz.trim();
};
var normalizeTwo = function normalizeTwo2(tz) {
  tz = tz.replace(/\b(east|west|north|south)ern/g, "$1");
  tz = tz.replace(/\b(africa|america|australia)n/g, "$1");
  tz = tz.replace(/\beuropean/g, "europe");
  tz = tz.replace(/\islands/g, "island");
  tz = tz.replace(/.*\//g, "");
  return tz.trim();
};
var normalizeThree = function normalizeThree2(tz) {
  tz = tz.replace(/\(.*\)/, "");
  return tz.trim();
};
var find = function find2(str) {
  if (!str) {
    return null;
  }
  str = str.toLowerCase().trim();
  if (data.hasOwnProperty(str)) {
    return data[str];
  }
  if (/[0-9]/.test(str)) {
    var etc = parseOffset_1(str);
    if (etc) {
      return etc;
    }
  }
  str = normalizeOne(str);
  if (data.hasOwnProperty(str)) {
    return data[str];
  }
  var tmp2 = str + " time";
  if (data.hasOwnProperty(tmp2)) {
    return data[tmp2];
  }
  tmp2 = str + " standard time";
  if (data.hasOwnProperty(tmp2)) {
    return data[tmp2];
  }
  str = normalizeTwo(str);
  if (data.hasOwnProperty(str)) {
    return data[str];
  }
  str = normalizeThree(str);
  if (data.hasOwnProperty(str)) {
    return data[str];
  }
  tmp2 = str + " time";
  if (data.hasOwnProperty(tmp2)) {
    return data[tmp2];
  }
  tmp2 = str + " standard time";
  if (data.hasOwnProperty(tmp2)) {
    return data[tmp2];
  }
  return null;
};
var find_1 = find;
var display = function display2(str) {
  var id = find_1(str);
  if (!id) {
    return null;
  }
  var meta = _05Metazones.find(function(obj) {
    return obj.zones.find(function(tz) {
      return tz === id;
    });
  });
  meta = meta || {};
  return {
    iana: id,
    standard: meta.standard,
    daylight: meta.daylight
  };
};
var display_1 = display;
var _version = "0.5.0";
var src = {
  find: find_1,
  display: display_1,
  version: _version
};
var src_1 = src.find;
var src_2 = src.display;
var src_3 = src.version;

// node_modules/react-timezone-select/dist/index.js
var i18nTimezones = {
  "Pacific/Midway": "Midway Island, Samoa",
  "Pacific/Honolulu": "Hawaii",
  "America/Juneau": "Alaska",
  "America/Boise": "Mountain Time",
  "America/Dawson": "Dawson, Yukon",
  "America/Chihuahua": "Chihuahua, La Paz, Mazatlan",
  "America/Phoenix": "Arizona",
  "America/Chicago": "Central Time",
  "America/Regina": "Saskatchewan",
  "America/Mexico_City": "Guadalajara, Mexico City, Monterrey",
  "America/Belize": "Central America",
  "America/Detroit": "Eastern Time",
  "America/Bogota": "Bogota, Lima, Quito",
  "America/Caracas": "Caracas, La Paz",
  "America/Santiago": "Santiago",
  "America/St_Johns": "Newfoundland and Labrador",
  "America/Sao_Paulo": "Brasilia",
  "America/Tijuana": "Tijuana, Pacific Time",
  "America/Argentina/Buenos_Aires": "Buenos Aires, Georgetown",
  "America/Godthab": "Greenland",
  "Atlantic/Azores": "Azores",
  "Atlantic/Cape_Verde": "Cape Verde Islands",
  GMT: "Dublin, Edinburgh, Lisbon, London",
  "Africa/Casablanca": "Casablanca, Monrovia",
  "Atlantic/Canary": "Canary Islands",
  "Europe/Belgrade": "Belgrade, Bratislava, Budapest, Ljubljana, Prague",
  "Europe/Sarajevo": "Sarajevo, Skopje, Warsaw, Zagreb",
  "Europe/Brussels": "Brussels, Copenhagen, Madrid, Paris",
  "Europe/Amsterdam": "Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
  "Africa/Algiers": "West Central Africa",
  "Europe/Bucharest": "Bucharest",
  "Africa/Cairo": "Cairo",
  "Europe/Helsinki": "Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius",
  "Europe/Athens": "Athens, Istanbul, Minsk",
  "Asia/Jerusalem": "Jerusalem",
  "Africa/Harare": "Harare, Pretoria",
  "Europe/Moscow": "Moscow, St. Petersburg, Volgograd",
  "Asia/Kuwait": "Kuwait, Riyadh",
  "Africa/Nairobi": "Nairobi",
  "Asia/Baghdad": "Baghdad",
  "Asia/Tehran": "Tehran",
  "Asia/Dubai": "Abu Dhabi, Muscat",
  "Asia/Baku": "Baku, Tbilisi, Yerevan",
  "Asia/Kabul": "Kabul",
  "Asia/Yekaterinburg": "Ekaterinburg",
  "Asia/Karachi": "Islamabad, Karachi, Tashkent",
  "Asia/Kolkata": "Chennai, Kolkata, Mumbai, New Delhi",
  "Asia/Kathmandu": "Kathmandu",
  "Asia/Dhaka": "Astana, Dhaka",
  "Asia/Colombo": "Sri Jayawardenepura",
  "Asia/Almaty": "Almaty, Novosibirsk",
  "Asia/Rangoon": "Yangon Rangoon",
  "Asia/Bangkok": "Bangkok, Hanoi, Jakarta",
  "Asia/Krasnoyarsk": "Krasnoyarsk",
  "Asia/Shanghai": "Beijing, Chongqing, Hong Kong SAR, Urumqi",
  "Asia/Kuala_Lumpur": "Kuala Lumpur, Singapore",
  "Asia/Taipei": "Taipei",
  "Australia/Perth": "Perth",
  "Asia/Irkutsk": "Irkutsk, Ulaanbaatar",
  "Asia/Seoul": "Seoul",
  "Asia/Tokyo": "Osaka, Sapporo, Tokyo",
  "Asia/Yakutsk": "Yakutsk",
  "Australia/Darwin": "Darwin",
  "Australia/Adelaide": "Adelaide",
  "Australia/Sydney": "Canberra, Melbourne, Sydney",
  "Australia/Brisbane": "Brisbane",
  "Australia/Hobart": "Hobart",
  "Asia/Vladivostok": "Vladivostok",
  "Pacific/Guam": "Guam, Port Moresby",
  "Asia/Magadan": "Magadan, Solomon Islands, New Caledonia",
  "Asia/Kamchatka": "Kamchatka, Marshall Islands",
  "Pacific/Fiji": "Fiji Islands",
  "Pacific/Auckland": "Auckland, Wellington",
  "Pacific/Tongatapu": "Nuku'alofa"
};
var TimezoneSelect = ({value, onBlur, onChange: onChange2, labelStyle = "original", timezones = i18nTimezones, ...props}) => {
  const getOptions = React11.useMemo(() => {
    const options2 = [];
    Object.entries(timezones).reduce((obj, entry) => {
      const a2 = spacetime_default.now().goto(entry[0]);
      const tz = a2.timezone();
      const tzDisplay = src_2(entry[0]);
      let abbrev = entry[0];
      let altName = entry[0];
      if (tzDisplay && tzDisplay.daylight && tzDisplay.standard) {
        abbrev = a2.isDST() ? tzDisplay.daylight.abbrev : tzDisplay.standard.abbrev;
        altName = a2.isDST() ? tzDisplay.daylight.name : tzDisplay.standard.name;
      }
      obj.push({
        name: entry[0],
        label: entry[1],
        offset: tz.current.offset,
        abbrev,
        altName
      });
      return obj;
    }, []).sort((a2, b2) => {
      return a2.offset - b2.offset;
    }).map((tz) => {
      if (tz.offset === void 0)
        return false;
      let label = "";
      const min = tz.offset * 60;
      const hr = `${min / 60 ^ 0}:` + (min % 60 === 0 ? "00" : Math.abs(min % 60));
      const prefix3 = `(GMT${hr.includes("-") ? hr : `+${hr}`}) ${tz.label}`;
      switch (labelStyle) {
        case "original":
          label = prefix3;
          break;
        case "altName":
          label = `${prefix3} ${!tz.altName.includes("/") ? `(${tz.altName})` : ""}`;
          break;
        case "abbrev":
          label = `${prefix3} 
            ${tz.abbrev.length < 5 ? `(${tz.abbrev})` : ""}`;
          break;
        default:
          label = `${prefix3}`;
      }
      options2.push({
        value: tz.name,
        label,
        abbrev: tz.abbrev,
        altName: tz.altName
      });
    });
    return options2;
  }, [labelStyle, timezones]);
  const handleChange = (tz) => {
    onChange2 && onChange2(tz);
  };
  const normalizeTz = (value2) => {
    let returnTz;
    if (typeof value2 === "string") {
      returnTz = getOptions.find((tz) => tz.value === value2);
    } else if (value2.value && !value2.label) {
      returnTz = getOptions.find((tz) => tz.value === value2.value);
    } else {
      returnTz = value2;
    }
    return returnTz;
  };
  return React11.createElement(react_select_esm_default, Object.assign({value: normalizeTz(value), onChange: handleChange, options: getOptions, onBlur}, props));
};
var dist_default = TimezoneSelect;

// src/clock/clock.tsx
var useStyles = createUseStyles({
  react_clock: {
    MozBoxSizing: "border-box",
    WebkitBoxSizing: "border-box",
    boxSizing: "border-box",
    "&:before": {
      MozBoxSizing: "border-box",
      WebkitBoxSizing: "border-box",
      boxSizing: "border-box"
    },
    "&:after": {
      MozBoxSizing: "border-box",
      WebkitBoxSizing: "border-box",
      boxSizing: "border-box"
    },
    "& .react-clock__face": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "0",
      right: "0",
      border: (props) => `1px solid ${props.borderColor}`,
      borderRadius: "50%"
    },
    "& .react-clock__hand": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "50%",
      right: "50%"
    },
    "& .react-clock__hand__body": {
      position: "absolute",
      backgroundColor: (props) => props.handColor,
      transform: "translateX(-50%)"
    },
    "& .react-clock__mark": {
      position: "absolute",
      top: "0",
      bottom: "0",
      left: "50%",
      right: "50%"
    },
    "& .react-clock__mark__body": {
      position: "absolute",
      backgroundColor: (props) => props.faceColor,
      transform: "translateX(-50%)"
    },
    "& .react-clock__mark__number": {
      position: "absolute",
      left: "-40px",
      width: "80px",
      textAlign: "center",
      color: (props) => props.numberColor
    }
  }
});
function ClockRenderer(props) {
  const [value, setValue] = (0, import_react18.useState)(new Date());
  const intervalRef = (0, import_react18.useRef)(null);
  const classes = useStyles(props);
  const {
    timezone,
    showNumbers,
    showMinuteMarks,
    showHourMarks,
    showSecondHand,
    showMinuteHand
  } = props;
  (0, import_react18.useEffect)(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    intervalRef.current = setInterval(() => {
      let newDate = new Date();
      if (timezone) {
        newDate = changeTimezone(newDate, timezone);
      }
      setValue(newDate);
    }, 1e3);
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [timezone]);
  return /* @__PURE__ */ import_react18.default.createElement("div", null, /* @__PURE__ */ import_react18.default.createElement(esm_default, {
    value,
    className: classes.react_clock,
    renderHourMarks: showHourMarks,
    renderMinuteMarks: showMinuteMarks,
    renderNumbers: showNumbers,
    renderSecondHand: showSecondHand,
    renderMinuteHand: showMinuteHand
  }));
}
function changeTimezone(date, ianatz) {
  let st2 = spacetime_default(date);
  st2 = st2.goto(ianatz);
  return new Date(st2.year(), st2.month(), st2.day(), st2.hour(), st2.minute(), st2.second(), st2.millisecond());
}
var ClockPrototype = {
  _proportionalSizing: true
};
var ClockDescription = {
  name: "Clock",
  title: "Clock",
  description: "The Clock Component ...",
  author: "Playful Software",
  renderer: ClockRenderer,
  extends: "Play Kit/View",
  prototype: ClockPrototype,
  properties: {
    width: {type: "number", title: "Width", default: 100},
    height: {type: "number", title: "Height", default: 100},
    handColor: {type: "string", title: "Hand Color", default: "white", editor: "Color"},
    faceColor: {type: "string", title: "Face Color", default: "white", editor: "Color"},
    numberColor: {type: "string", title: "Number Color", default: "white", editor: "Color"},
    borderColor: {type: "string", title: "Border Color", default: "white", editor: "Color"},
    showNumbers: {type: "boolean", title: "Show Numbers", default: false},
    showMinuteMarks: {type: "boolean", title: "Show Minute Marks", default: true},
    showHourMarks: {type: "boolean", title: "Show Hour Marks", default: true},
    showSecondHand: {type: "boolean", title: "Show Second Hand", default: true},
    showMinuteHand: {type: "boolean", title: "Show Minute Hand", default: true},
    timezone: {
      type: "string",
      title: "Time Zone",
      editor: {
        type: "String",
        component: ({value, onValueChange}) => {
          const handleChange = (timezone) => {
            onValueChange(timezone.value);
          };
          return /* @__PURE__ */ import_react18.default.createElement(dist_default, {
            value,
            onChange: handleChange,
            styles: {
              option: (provided) => ({
                ...provided,
                color: "black"
              })
            }
          });
        }
      }
    }
  }
};

// src/warpspeed/WarpSpeedComponent.tsx
var import_react19 = __toModule(require("react"));
var import_WarpSpeed = __toModule(require_WarpSpeed());
function WarpSpeedComponent(props) {
  const {
    component,
    speed,
    speedAdjustmentFactor,
    density,
    shape,
    warpEffect,
    warpEffectLength,
    depthFade,
    starSize,
    backgroundColor,
    color,
    pause,
    preset
  } = props;
  const [warpspeed, setWarpspeed] = (0, import_react19.useState)();
  const [canvas, setCanvas] = (0, import_react19.useState)();
  function createWarpSpeed(id) {
    if (warpspeed) {
      warpspeed.destroy();
    }
    const ws = new import_WarpSpeed.default(id, {
      speed,
      speedAdjFactor: speedAdjustmentFactor,
      density,
      shape,
      warpEffect,
      warpEffectLength,
      depthFade,
      starSize,
      backgroundColor,
      starColor: color
    });
    if (pause) {
      ws.pause();
    }
    setWarpspeed(ws);
  }
  const canvasCallback = (0, import_react19.useCallback)((canvas2) => setCanvas(canvas2), []);
  (0, import_react19.useEffect)(() => {
    if (canvas) {
      createWarpSpeed(component.id.toString());
    }
    return () => warpspeed == null ? void 0 : warpspeed.destroy();
  }, [canvas, density]);
  (0, import_react19.useEffect)(() => {
    if (warpspeed) {
      warpspeed.TARGET_SPEED = speed;
      warpspeed.USE_CIRCLES = shape === "circle";
      warpspeed.WARP_EFFECT = warpEffect;
      warpspeed.WARP_EFFECT_LENGTH = warpEffectLength;
      warpspeed.DEPTH_ALPHA = depthFade;
      warpspeed.STAR_SCALE = starSize;
      warpspeed.BACKGROUND_COLOR = backgroundColor;
      warpspeed.STAR_R = parseInt(color.slice(1, 3), 16);
      warpspeed.STAR_G = parseInt(color.slice(3, 5), 16);
      warpspeed.STAR_B = parseInt(color.slice(5, 7), 16);
    }
  }, [
    speed,
    speedAdjustmentFactor,
    density,
    shape,
    warpEffect,
    warpEffectLength,
    depthFade,
    starSize,
    backgroundColor,
    color
  ]);
  (0, import_react19.useEffect)(() => {
    if (!warpspeed) {
      return;
    }
    if (pause) {
      warpspeed.pause();
    } else {
      warpspeed.resume();
    }
  }, [pause]);
  return /* @__PURE__ */ import_react19.default.createElement("canvas", {
    style: {width: "100%", height: "100%"},
    id: component.id.toString(),
    ref: canvasCallback
  });
}
var WarpSpeedDescription = {
  name: "WarpSpeed",
  description: "The WarpSpeed Component ...",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  renderer: WarpSpeedComponent,
  extends: "Play Kit/View",
  properties: {
    speed: {
      type: "number",
      default: 0.7,
      editor: {type: "Number", min: 0, max: 50, step: 0.1},
      description: `The speed at which we're moving through the starfield.`
    },
    warpEffect: {
      type: "boolean",
      default: true,
      description: `Draws lines instead of just the stars. Slower.`
    },
    warpEffectLength: {
      type: "number",
      default: 5,
      editor: {type: "Number", min: 0, max: 30, step: 0.1},
      description: `How long the warp strikes are in depth units.`
    },
    density: {
      type: "number",
      default: 0.7,
      editor: {type: "Number", min: 0, max: 30, step: 0.01},
      description: `Star density. Number of stars = density * drawDistance.`
    },
    depthFade: {
      type: "boolean",
      default: true,
      description: `Stars that are further from the camera are less opaque. Slower.`
    },
    starSize: {
      type: "number",
      default: 3,
      editor: {type: "Number", min: 1, max: 20},
      description: `Size of stars.`
    },
    shape: {
      type: "string",
      default: "circle",
      editor: {type: "Option", options: ["circle", "square"]},
      description: `Drawing squares instead of circles is faster, but looks less pretty.`
    },
    speedAdjustmentFactor: {
      type: "number",
      default: 0.03,
      editor: {type: "Number", min: 0, max: 1, step: 0.01},
      description: `How fast the speed changes from the current speed to target speed. 0 = no change, 1 = instant change.`
    },
    backgroundColor: {
      type: "string",
      default: "hsl(263,45%,7%)",
      editor: "Color",
      description: `Background color. Alpha not recommended.`
    },
    color: {
      type: "string",
      title: "Star Color",
      default: "#ffffff",
      editor: "Color",
      description: `Star color. Alpha not recommended.`
    },
    pause: {type: "boolean", default: false},
    credits: {
      type: "string",
      default: `WarpSpeed.js by Federico Dossena (https://github.com/adolfintel/warpspeed)`,
      readonly: true
    },
    width: {type: "number", title: "Width", default: 400},
    height: {type: "number", title: "Height", default: 400}
  }
};

// src/leaflet.tsx
var import_leaflet = __toModule(require_leaflet_src());
var import_leaflet2 = __toModule(require("url!./leaflet.css"));
var link = document.createElement("link");
link.rel = "stylesheet";
link.href = import_leaflet2.default;
document.head.appendChild(link);
import_leaflet.default.Icon.Default.imagePath = "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/";
var tilesets = {
  custom: [void 0, void 0, 18],
  google_satellite: ["&copy; google", "http://mt0.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", 18],
  openstreetmap: [
    '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    18,
    47.61213,
    -122.33945,
    15
  ],
  opentopomap: [
    'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
    "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
    17,
    47.61213,
    -122.33945,
    8
  ],
  stamen_watercolor: [
    'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    "https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.jpg",
    16,
    47.61213,
    -122.33945,
    14
  ],
  moon: [
    "&copy; OpenPlanetary",
    "https://cartocdn-gusc.global.ssl.fastly.net/opmbuilder/api/v1/map/named/opm-moon-basemap-v0-1/all/{z}/{x}/{y}.png",
    10,
    29.7,
    11.77,
    5
  ],
  mars: [
    "&copy; OpenPlanetary",
    "http://s3-eu-west-1.amazonaws.com/whereonmars.cartodb.net/celestia_mars-shaded-16k_global/{z}/{x}/{-y}.png",
    5,
    13.56,
    -147.14,
    4
  ],
  mars_elevation_color: [
    "&copy; OpenPlanetary",
    "http://s3-eu-west-1.amazonaws.com/whereonmars.cartodb.net/mola-color/{z}/{x}/{-y}.png",
    6,
    13.56,
    -147.14,
    4
  ],
  game_of_thrones: [
    "",
    "https://cartocdn-gusc.global.ssl.fastly.net//ramirocartodb/api/v1/map/named/tpl_756aec63_3adb_48b6_9d14_331c6cbc47cf/all/{z}/{x}/{y}.png",
    10,
    15.19,
    22.5,
    5
  ]
};
var MapPrototype = {
  latitude: 0,
  longitude: 0,
  zoom: 0,
  tiles: "",
  tilesUrl: "",
  attribution: "",
  maxZoom: 0,
  marker: false,
  markerLatitude: 0,
  markerLongitude: 0,
  zoomControl: true,
  attributionLabel: true,
  $tilesUrl: "",
  $attribution: "",
  $maxZoom: 0,
  $latitude: 0,
  $longitude: 0,
  $zoom: 0,
  project: void 0,
  _element: void 0,
  _map: void 0,
  _tileLayer: void 0,
  _marker: void 0,
  mount(container, insertBefore2) {
    super.mount(container, insertBefore2);
    this._map = import_leaflet.default.map(this._element, {
      attributionControl: true,
      zoomControl: true,
      center: [this.latitude, this.longitude],
      zoom: this.zoom
    });
    if (!this.project.designMode) {
      this._map.on("move", (event) => {
        const {lat, lng} = this._map.getCenter();
        this.latitude = lat;
        this.longitude = lng;
      });
      this._map.on("zoom", (event) => {
        const zoom = this._map.getZoom();
        this.zoom = zoom;
      });
    }
    this._tileLayer = import_leaflet.default.tileLayer(this.tilesUrl, {
      attribution: this.attribution,
      maxZoom: this.maxZoom
    }).addTo(this._map);
  },
  unmount() {
    super.unmount();
    if (this._map) {
      this._map.remove();
    }
  },
  update(changed) {
    var _a, _b;
    super.update(changed);
    if (changed.latitude || changed.longitude || changed.zoom) {
      this._map.setView([this.latitude, this.longitude], this.zoom, {animate: false});
    }
    if (changed.width || changed.height) {
      this._map.invalidateSize({animate: false});
    }
    if (changed.tilesUrl) {
      this._tileLayer.setUrl(this.tilesUrl);
    }
    if (changed.maxZoom) {
      this._map.setMaxZoom(this.maxZoom);
    }
    if (changed.attributionLabel) {
    }
    if (changed.zoomControl) {
      if (this.zoomControl) {
        this._map.addControl(this._map.zoomControl);
      } else if (this._map.zoomControl) {
        this._map.removeControl(this._map.zoomControl);
      }
    }
    if (changed.attributionLabel) {
      if (this.attributionLabel) {
        this._map.addControl(this._map.attributionControl);
      } else if (this._map.attributionControl) {
        this._map.removeControl(this._map.attributionControl);
      }
    }
    if (changed.marker) {
      if (this.marker) {
        if (!this._marker) {
          this._marker = import_leaflet.default.marker([this.markerLatitude, this.markerLongitude]).addTo(this._map);
        }
      } else {
        (_a = this._marker) == null ? void 0 : _a.remove();
        this._marker = void 0;
      }
    }
    if ((changed.markerLatitude || changed.markerLongitude) && this._marker) {
      (_b = this._marker) == null ? void 0 : _b.setLatLng([this.markerLatitude, this.markerLongitude]);
    }
    if (changed.tiles && this.project.designMode) {
      const [attribution, tilesUrl, maxZoom, lat, long, zoom] = tilesets[this.tiles];
      this.$maxZoom = maxZoom;
      this.$zoom = Math.min(maxZoom, this.zoom);
      if (tilesUrl) {
        this.$tilesUrl = tilesUrl;
      }
      if (attribution !== void 0) {
        this.$attribution = attribution;
      }
      if (lat && long && zoom) {
        this.$latitude = lat;
        this.$longitude = long;
        this.$zoom = zoom;
      }
    }
  }
};
var MapDescription = {
  name: "Map",
  description: "The Map Component...",
  author: "Playful Software",
  icon: "...",
  preview: "...",
  collection: "React Test Kit",
  prototype: MapPrototype,
  extends: "Play Kit/View",
  properties: {
    latitude: {
      type: "number",
      default: 47.61213,
      editor: {type: "Number", min: -90, max: 90, step: 0.1}
    },
    longitude: {
      type: "number",
      default: -122.33945,
      editor: {type: "Number", min: -180, max: 180, step: 0.1}
    },
    zoom: {type: "number", default: 13, editor: {type: "Number", min: 0, max: 18, step: 1}},
    tiles: {
      type: "string",
      default: "openstreetmap",
      editor: {
        fullWidthEditor: true,
        type: "Option",
        options: [
          {title: "Custom", value: "custom"},
          {title: "OpenStreetMap", value: "openstreetmap"},
          {title: "OpenTopoMap", value: "opentopomap"},
          {title: "Google Satellite", value: "google_satellite"},
          {title: "Stamen Watercolor", value: "stamen_watercolor"},
          {title: "Moon", value: "moon"},
          {title: "Mars", value: "mars"},
          {title: "Mars Elevation Color", value: "mars_elevation_color"},
          {title: "Game Of Thrones", value: "game_of_thrones"}
        ]
      }
    },
    attribution: {type: "string", editor: {type: "MultilineString", fullWidthEditor: true}},
    tilesUrl: {type: "string", editor: {type: "MultilineString", fullWidthEditor: true}},
    marker: {type: "boolean", default: false},
    markerLatitude: {
      type: "number",
      default: 47.61213,
      editor: {type: "Number", min: -90, max: 90, step: 0.1}
    },
    markerLongitude: {
      type: "number",
      default: -122.33945,
      editor: {type: "Number", min: -180, max: 180, step: 0.1}
    },
    maxZoom: {type: "number", default: 18},
    zoomControl: {type: "boolean", default: true},
    attributionLabel: {type: "boolean", default: true},
    width: {type: "number", default: 400},
    height: {type: "number", default: 400}
  }
};

// src/index.ts
var kit = {
  title: "React Test Kit",
  description: "React Test Kit contains React components used to test Play.",
  author: "Playful Software",
  components: [
    ThreeDescription,
    XKCDDescription,
    import_chart_xkcd.LineChartDescription,
    import_chart_xkcd.BarChartDescription,
    import_chart_xkcd.PieChartDescription,
    import_chart_xkcd.XYChartDescription,
    import_chart_xkcd.StackedBarChartDescription,
    import_chart_xkcd.RadarChartDescription,
    ClockDescription,
    WarpSpeedDescription,
    MapDescription
  ]
};
//# sourceMappingURL=index.js.map
